---
title: 3장 - Azure RTOS NetX Duo의 기능 구성 요소
description: 이 장에서는 기능 관점에서 고성능 Azure RTOS NetX Duo TCP/IP 스택에 관해 설명합니다.
author: philmea
ms.author: philmea
ms.date: 05/19/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 31900c7b822c88079e4b9fe28a8a388d20f819aa
ms.sourcegitcommit: 60ad844b58639d88830f2660ab0c4ff86b92c10f
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/07/2021
ms.locfileid: "106549847"
---
# <a name="chapter-3---functional-components-of-azure-rtos-netx-duo"></a><span data-ttu-id="c7e83-103">3장 - Azure RTOS NetX Duo의 기능 구성 요소</span><span class="sxs-lookup"><span data-stu-id="c7e83-103">Chapter 3 - Functional Components of Azure RTOS NetX Duo</span></span>

<span data-ttu-id="c7e83-104">이 장에서는 기능 관점에서 고성능 Azure RTOS NetX Duo TCP/IP 스택에 관해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-104">This chapter contains a description of the high- performance Azure RTOS NetX Duo TCP/IP stack from a functional perspective.</span></span> 

## <a name="execution-overview"></a><span data-ttu-id="c7e83-105">실행 개요</span><span class="sxs-lookup"><span data-stu-id="c7e83-105">Execution Overview</span></span>

<span data-ttu-id="c7e83-106">NetX Duo 애플리케이션 내에서는 프로그램이 초기화, 애플리케이션 인터페이스 호출, 내부 IP 스레드, IP 주기적 타이머, 네트워크 드라이버 등의 5가지 방식으로 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-106">There are five types of program execution within a NetX Duo application: initialization, application interface calls, internal IP thread, IP periodic timers, and the network driver.</span></span>

> [!NOTE]
> <span data-ttu-id="c7e83-107">NetX Duo는 ThreadX가 있는 것으로 가정하며 스레드 실행, 일시 중단, 주기적 타이머, 상호 배제 기능에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-107">*NetX Duo assumes the existence of ThreadX and depends on its thread execution, suspension, periodic timers, and mutual exclusion facilities.*</span></span>

### <a name="initialization"></a><span data-ttu-id="c7e83-108">초기화</span><span class="sxs-lookup"><span data-stu-id="c7e83-108">Initialization</span></span>

<span data-ttu-id="c7e83-109">다른 NetX Duo 서비스를 호출하기 전에 \***nx_system_initialize** _ 서비스를 호출해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-109">The service \***nx_system_initialize** _ must be called before any other NetX Duo service is called.</span></span> <span data-ttu-id="c7e83-110">ThreadX _ *_tx_application_define_*\* 함수나 애플리케이션 스레드에서 시스템 초기화를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-110">System initialization can be called either from the ThreadX _ *_tx_application_define_*\* function or from application threads.</span></span>

<span data-ttu-id="c7e83-111">\***nx_system_initialize** _가 반환되면 시스템은 패킷 풀 및 IP 인스턴스를 만들 준비가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-111">After \***nx_system_initialize** _ returns, the system is ready to create packet pools and IP instances.</span></span> <span data-ttu-id="c7e83-112">IP 인스턴스를 만들려면 기본 패킷 풀이 필요하므로 IP 인스턴스를 만들기 전에 하나 이상의 NetX Duo 패킷 풀이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-112">Because creating an IP instance requires a default packet pool, at least one NetX Duo packet pool must exist prior to creating an IP instance.</span></span> <span data-ttu-id="c7e83-113">패킷 풀 및 IP 인스턴스는 ThreadX 초기화 함수인 _ *_tx_application_define_*\* 및 애플리케이션 스레드에서 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-113">Creating packet pools and IP instances are allowed from the ThreadX initialization function _ *_tx_application_define_*\* and from application threads.</span></span>

<span data-ttu-id="c7e83-114">내부적으로 IP 인스턴스를 만드는 작업은 두 부분으로 수행됩니다. 첫 번째 부분은 ***tx_application_define*** 또는 애플리케이션 스레드 컨텍스트의 호출자 컨텍스트 내에서 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-114">Internally, creating an IP instance is accomplished in two parts: The first part is done within the context of the caller, either from ***tx_application_define*** or from an application thread's context.</span></span> <span data-ttu-id="c7e83-115">여기에는 IP 데이터 구조를 설정하고 내부 IP 스레드를 비롯한 다양한 IP 리소스를 만드는 작업이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-115">This includes setting up the IP data structure and creating various IP resources, including the internal IP thread.</span></span> <span data-ttu-id="c7e83-116">두 번째 부분은 내부 IP 스레드에서 초기 실행 중에 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-116">The second part is performed during the initial execution from the internal IP thread.</span></span> <span data-ttu-id="c7e83-117">여기서 IP 만들기의 첫 번째 부분을 수행하는 동안 제공되는 네트워크 드라이버를 먼저 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-117">This is where the network driver, supplied during the first part of IP creation, is first called.</span></span> <span data-ttu-id="c7e83-118">내부 IP 스레드에서 네트워크 드라이버를 호출하면 드라이버가 초기화 처리 중에 I/O를 수행 및 일시 중단할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-118">Calling the network driver from the internal IP thread enables the driver to perform I/O and suspend during its initialization processing.</span></span>

<span data-ttu-id="c7e83-119">네트워크 드라이버가 초기화 처리에서 반환되면 IP 생성이 완료됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-119">When the network driver returns from its initialization processing, the IP creation is complete.</span></span>

<span data-ttu-id="c7e83-120">NetX Duo에서 IPv6를 초기화하려면 몇 가지 추가 NetX Duo 서비스가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-120">Initialization of IPv6 in NetX Duo requires a few additional NetX Duo services.</span></span> <span data-ttu-id="c7e83-121">해당 내용은 이 장의 뒷부분에 나오는 [NetX Duo의 IPv6](#ipv6-in-netx-duo) 섹션에 매우 자세히 설명되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-121">These are described in greater detail in the section [IPv6 in NetX Duo](#ipv6-in-netx-duo) later in this chapter.</span></span>

> [!NOTE]
> <span data-ttu-id="c7e83-122">NetX Duo 서비스 **nx_ip_status_check** 는 IP 인스턴스 및 해당 기본 인터페이스 상태에 대한 정보를 가져오는 데 사용할 수 있습니다. 이러한 상태 정보에는 링크 초기화, 활성화, IP 주소 확인 여부가 포함됩니다. 이 정보는 새로 만든 IP 인스턴스 사용이 필요한 애플리케이션 스레드를 동기화하는 데 사용됩니다. 멀티홈 시스템의 경우 [멀티홈 지원](#multihome-support)을 참조하세요. **nx_ip_interface_/status_check** 를 사용하여 지정된 인터페이스에 대한 정보를 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-122">*The NetX Duo service **nx_ip_status_check** is available to obtain information on the IP instance and its primary interface status. Such status information includes whether or not the link is initialized, enabled and IP address is resolved. This information is used to synchronize application threads needing to use a newly created IP instance. For multihome systems, see [Multihome Support](#multihome-support). **nx_ip_interface_status_check** is available to obtain 3information on the specified interface.*</span></span>

### <a name="application-interface-calls"></a><span data-ttu-id="c7e83-123">애플리케이션 인터페이스 호출</span><span class="sxs-lookup"><span data-stu-id="c7e83-123">Application Interface Calls</span></span>

<span data-ttu-id="c7e83-124">애플리케이션의 호출은 ThreadX RTOS에서 실행되는 애플리케이션 스레드에서 주로 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-124">Calls from the application are largely made from application threads running under the ThreadX RTOS.</span></span> <span data-ttu-id="c7e83-125">그러나 일부 초기화, 만들기, 사용 서비스는 ***tx_application_define*** 에서 호출될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-125">However, some initialization, create, and enable services may be called from ***tx_application_define***.</span></span> <span data-ttu-id="c7e83-126">[4장 - Azure RTOS NetX Duo 서비스 설명](chapter4.md)의 “허용되는 위치” 섹션에서는 각 NetX Duo 서비스를 호출할 수 있는 경우를 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-126">The "Allowed From" sections in [Chapter 4 - Description of Azure RTOS NetX Duo Services](chapter4.md) indicate from which each NetX Duo service can be called.</span></span>

<span data-ttu-id="c7e83-127">대부분의 경우, 체크섬 계산과 같은 집약적인 작업 처리는 IP 인스턴스에 대한 다른 스레드의 액세스를 차단하지 않고 호출 스레드의 컨텍스트 내에서 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-127">For the most part, processing intensive activities such as computing checksums is done within the calling thread's context—without blocking access of other threads to the IP instance.</span></span> <span data-ttu-id="c7e83-128">예를 들어 전송 시에는 기본 IP 전송 함수를 호출하기 전에 \***nx_udp_socket_send** _ 서비스 내에서 UDP 체크섬 계산이 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-128">For example, on transmission, the UDP checksum calculation is performed inside the \***nx_udp_socket_send** _ service, prior to calling the underlying IP send function.</span></span> <span data-ttu-id="c7e83-129">수신된 패킷에서 UDP 체크섬은 애플리케이션 스레드의 컨텍스트에서 실행되는 _ *_nx_udp_socket_receive_*\* 서비스에서 계산됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-129">On a received packet, the UDP checksum is calculated in the _ *_nx_udp_socket_receive_*\* service, executed in the  of the application thread.</span></span> <span data-ttu-id="c7e83-130">이렇게 하면 우선 순위가 낮은 스레드에서 집약적인 체크섬 계산을 처리하므로 더 높은 우선 순위 스레드의 네트워크 요청이 지연되는 것을 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-130">This helps prevent stalling network requests of higher-priority threads because of processing intensive checksum computation in lower-priority threads.</span></span>

<span data-ttu-id="c7e83-131">IP 주소 및 포트 번호와 같은 값은 호스트 바이트 순서로 API에 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-131">Values, such as IP addresses and port numbers, are passed to APIs in host byte order.</span></span> <span data-ttu-id="c7e83-132">내부적으로 이러한 값은 호스트 바이트 순서에도 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-132">Internally these values are stored in host byte order as well.</span></span> <span data-ttu-id="c7e83-133">이렇게 하면 개발자는 디버거를 통해 값을 쉽게 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-133">This allows developers to easily view the values via a debugger.</span></span> <span data-ttu-id="c7e83-134">이러한 값이 전송용 프레임으로 프로그래밍이 되면 네트워크 바이트 순서로 변환됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-134">When these values are programmed into a frame for transmission, they are converted to network byte order.</span></span>

### <a name="internal-ip-thread"></a><span data-ttu-id="c7e83-135">내부 IP 스레드</span><span class="sxs-lookup"><span data-stu-id="c7e83-135">Internal IP Thread</span></span>

<span data-ttu-id="c7e83-136">설명한 대로 NetX Duo의 각 IP 인스턴스는 고유한 스레드를 가지고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-136">As mentioned, each IP instance in NetX Duo has its own thread.</span></span> <span data-ttu-id="c7e83-137">내부 IP 스레드의 우선 순위 및 스택 크기는 ***nx_ip_create*** 서비스에 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-137">The priority and stack size of the internal IP thread is defined in the ***nx_ip_create*** service.</span></span> <span data-ttu-id="c7e83-138">내부 IP 스레드가 실행 준비 모드에서 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-138">The internal IP thread is created in a ready-to-execute mode.</span></span> <span data-ttu-id="c7e83-139">IP 스레드의 우선 순위가 호출 스레드보다 높으면 IP 만들기 호출 내에서 선점이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-139">If the IP thread has a higher priority than the calling thread, preemption may occur inside the IP create call.</span></span>

<span data-ttu-id="c7e83-140">내부 IP 스레드의 진입점은 내부 함수 _ ***nx_ip_thread_entry*** 에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-140">The entry point of the internal IP thread is at the internal function _ ***nx_ip_thread_entry***.</span></span> <span data-ttu-id="c7e83-141">시작할 때, 내부 IP 스레드는 먼저 애플리케이션별 네트워크 드라이버에 대한 세 번의 호출로 구성된 네트워크 드라이버 초기화를 완료합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-141">When started, the internal IP thread first completes network driver initialization, which consists of making three calls to the application-specific network driver.</span></span> <span data-ttu-id="c7e83-142">첫 번째 호출은 네트워크 드라이버를 IP 인스턴스에 연결한 후 초기화 호출을 통해 네트워크 드라이버가 초기화 프로세스를 수행하게 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-142">The first call is to attach the network driver to the IP instance, followed by an initialization call, which allows the network driver to go through the initialization process.</span></span> <span data-ttu-id="c7e83-143">네트워크 드라이버가 초기화에서 반환된 후(하드웨어가 제대로 설정되기를 기다리는 동안 일시 중단될 수 있음) 내부 IP 스레드가 네트워크 드라이버를 다시 호출하여 링크를 사용하도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-143">After the network driver returns from initialization (it may suspend while waiting for the hardware to be properly set up), the internal IP thread calls the network driver again to enable the link.</span></span> <span data-ttu-id="c7e83-144">네트워크 드라이버가 링크 사용 호출에서 반환된 후 내부 IP 스레드는 이 IP 인스턴스에 대한 처리가 필요한 다양한 이벤트를 확인하는 영구 루프 검사를 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-144">After the network driver returns from the link enable call, the internal IP thread enters a forever loop checking for various events that need processing for this IP instance.</span></span> <span data-ttu-id="c7e83-145">이 루프에서 처리되는 이벤트에는 지연된 IP 패킷 수신, IP 패킷 조각 어셈블리, ICMP ping 처리, IGMP 처리, TCP 패킷 큐 처리, TCP 주기적 처리, IP 조각 어셈블리 시간 제한, IGMP 주기적 처리가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-145">Events processed in this loop include deferred IP packet reception, IP packet fragment assembly, ICMP ping processing, IGMP processing, TCP packet queue processing, TCP periodic processing, IP fragment assembly timeouts, and IGMP periodic processing.</span></span> <span data-ttu-id="c7e83-146">또한 이벤트에는 주소 확인 작업, IPv4의 ARP 패킷 처리 및 ARP 주기적 처리, 중복 주소 검색, 라우터 요청, IPv6의 인접 노드 검색이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-146">Events also include address resolution activities; ARP packet processing and ARP periodic processing in IPv4, Duplicate Address Detection, Router Solicitation, and Neighbor Discovery in IPv6.</span></span>

> [!CAUTION]
> <span data-ttu-id="c7e83-147">수신 대기 및 연결 해제 콜백을 포함한 NetX Duo 콜백 함수는 원래 호출 스레드가 아닌 내부 IP 스레드에서 호출됩니다. 애플리케이션은 NetX Duo 콜백 함수 내에서 일시 중단되지 않도록 주의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-147">*The NetX Duo callback functions, including listen and disconnect callbacks, are called from the internal IP thread—not the original calling thread. The application must take care not to suspend inside any NetX Duo callback function.*</span></span>

### <a name="ip-periodic-timers"></a><span data-ttu-id="c7e83-148">IP 주기적 타이머</span><span class="sxs-lookup"><span data-stu-id="c7e83-148">IP Periodic Timers</span></span>

<span data-ttu-id="c7e83-149">각 IP 인스턴스에는 두 개의 ThreadX 주기적 타이머가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-149">There are two ThreadX periodic timers used for each IP instance.</span></span> <span data-ttu-id="c7e83-150">첫 번째 타이머는 ARP, IGMP, TCP 시간 제한에 대한 1초 타이머이며 또한 IP 조각 리어셈블 처리도 구동합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-150">The first one is a one-second timer for ARP, IGMP, TCP timeout, and it also drives IP fragment reassemble processing.</span></span> <span data-ttu-id="c7e83-151">두 번째 타이머는 TCP 재전송 시간 제한 및 IPv6 관련 작업을 구동하는 100ms 타이머입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-151">The second timer is a 100ms timer to drive the TCP retransmission timeout and IPv6-related operations.</span></span>

### <a name="network-driver"></a><span data-ttu-id="c7e83-152">네트워크 드라이버</span><span class="sxs-lookup"><span data-stu-id="c7e83-152">Network Driver</span></span>

<span data-ttu-id="c7e83-153">NetX Duo의 각 IP 인스턴스는 ***nx_ip_create*** 서비스에 지정된 디바이스 드라이버로 식별되는 기본 인터페이스를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-153">Each IP instance in NetX Duo has a primary interface, which is identified by its device driver specified in the ***nx_ip_create*** service.</span></span> <span data-ttu-id="c7e83-154">네트워크 드라이버는 패킷 전송, 패킷 수신, 상태 및 제어 요청을 포함한 다양한 NetX Duo 요청을 처리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-154">The network driver is responsible for handling various NetX Duo requests, including packet transmission, packet reception, and requests for status and control.</span></span> 

<span data-ttu-id="c7e83-155">멀티홈 시스템의 경우 IP 인스턴스는 각 해당 인터페이스에 대해 이러한 작업을 수행하는 연결된 네트워크 드라이버를 가진 여러 인터페이스를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-155">For a multi-home system, the IP instance has multiple interfaces, each with an associated network driver that performs these tasks for the respective interface.</span></span>

<span data-ttu-id="c7e83-156">또한 네트워크 드라이버는 미디어에서 발생하는 비동기 이벤트도 처리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-156">The network driver must also handle asynchronous events occurring on the media.</span></span> <span data-ttu-id="c7e83-157">미디어의 비동기 이벤트에는 패킷 수신, 패킷 전송 완료, 상태 변경이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-157">Asynchronous events from the media include packet reception, packet transmission completion, and status changes.</span></span> <span data-ttu-id="c7e83-158">NetX Duo는 다양한 이벤트 처리를 위한 여러 액세스 함수를 포함하는 네트워크 드라이버를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-158">NetX Duo provides the network driver with several access functions to handle various events.</span></span> <span data-ttu-id="c7e83-159">이러한 함수는 네트워크 드라이버의 인터럽트 서비스 루틴 부분에서 호출되도록 설계되었습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-159">These functions are designed to be called from the  interrupt service routine portion of the network driver.</span></span> <span data-ttu-id="c7e83-160">IPv4 네트워크의 경우 네트워크 드라이버가 수신한 모든 ARP 패킷을 ***_nx_arp_packet_deferred_receive*** 내부 함수로 전달해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-160">For IPv4 networks, the network driver should forward all ARP packets received to the ***_nx_arp_packet_deferred_receive*** internal function.</span></span> <span data-ttu-id="c7e83-161">모든 RARP 패킷은 \* **_nx_rarp_packet_deferred_receive** _ 내부 함수로 전달되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-161">All RARP packets should be forwarded to \***_nx_rarp_packet_deferred_receive** _ internal function.</span></span> <span data-ttu-id="c7e83-162">IP 패킷에는 두 가지 옵션이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-162">There are two options for IP packets.</span></span> <span data-ttu-id="c7e83-163">IP 패킷을 빠르게 디스패치해야 하는 경우 들어오는 IP 패킷을 _ *_ _nx_ip_packet_receive_* _로 전달하여 즉시 처리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-163">If fast dispatch of IP packets is required, incoming IP packets should be forwarded to _ *_ _nx_ip_packet_receive_* _ for immediate processing.</span></span> <span data-ttu-id="c7e83-164">이렇게 하면 NetX Duo의 IP 패킷 처리 성능이 크게 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-164">This greatly improves NetX Duo performance in handling IP packets.</span></span> <span data-ttu-id="c7e83-165">그러지 않으면 IP 패킷을 _ \*_ _nx_ip_packet_deferred_receive_\*\*로 전달해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-165">Otherwise, forwarding IP packets to _ *_ _nx_ip_packet_deferred_receive_*\* should be done.</span></span> <span data-ttu-id="c7e83-166">이 서비스는 IP 패킷을 지연된 처리 큐에 배치한 다음, 이 큐에서 내부 IP 스레드에 의해 처리되므로 ISR 처리 시간이 최소화됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-166">This service places the IP packet in the deferred processing queue where it is then handled by the internal IP thread, which results in the least amount of ISR processing time.</span></span>

<span data-ttu-id="c7e83-167">네트워크 드라이버는 IP 스레드의 컨텍스트에서 실행되기 위해 인터럽트 처리를 연기할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-167">The network driver can also defer interrupt processing to run out of the context of the IP thread.</span></span> <span data-ttu-id="c7e83-168">이 모드에서 ISR은 필요한 정보를 저장하고 내부 함수 ***_nx_ip_driver_deferred_processing*** 을 호출하여 인터럽트 컨트롤러를 승인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-168">In this mode, the ISR shall save the necessary information, call the internal function ***_nx_ip_driver_deferred_processing***, and acknowledge the interrupt controller.</span></span> <span data-ttu-id="c7e83-169">이 서비스는 디바이스 드라이버에 대한 콜백을 예약하여 인터럽트를 유발하는 이벤트 프로세스를 완료하도록 IP 스레드에 알립니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-169">This service notifies IP thread to schedule a callback to the device driver to complete the process of the event that causes the interrupt.</span></span>

<span data-ttu-id="c7e83-170">일부 네트워크 컨트롤러는 유용한 CPU 리소스를 차지하지 않고도 TCP/IP 헤더 체크섬 계산 및 하드웨어의 유효성 검사를 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-170">Some network controllers are capable of performing TCP/IP header checksum computation and validation in hardware, without taking up valuable CPU resources.</span></span> <span data-ttu-id="c7e83-171">하드웨어 기능을 활용하기 위해 NetX Duo는 컴파일 시 다양한 소프트웨어 체크섬 계산을 사용하거나 또는 사용하지 않도록 옵션을 제공하고, 디바이스 드라이버가 하드웨어 기능에 대해 IP 계층과 통신할 수 있는 경우 런타임에 체크섬 계산을 설정하거나 해제하는 옵션도 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-171">To take advantage of the hardware capability feature, NetX Duo provides options to enable or disable various software checksum computation at compilation time, as well as turning on or off checksum computation at run time, if the device driver is able to communicate with the IP layer about is hardware capabilities.</span></span> <span data-ttu-id="c7e83-172">NetX Duo 네트워크 드라이버 작성에 대한 자세한 내용은 [5장 - Azure RTOS NetX Duo 네트워크 드라이버](chapter5.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="c7e83-172">See [Chapter 5 - Azure RTOS NetX Duo Network Drivers](chapter5.md) for more detailed information on writing NetX Duo network drivers.</span></span>

### <a name="multihome-support"></a><span data-ttu-id="c7e83-173">멀티홈 지원</span><span class="sxs-lookup"><span data-stu-id="c7e83-173">Multihome Support</span></span>

<span data-ttu-id="c7e83-174">NetX Duo는 단일 IP 인스턴스를 사용하여 여러 실제 디바이스에 연결된 시스템을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-174">NetX Duo supports systems connected to multiple physical devices using a single IP instance.</span></span> <span data-ttu-id="c7e83-175">각 실제 인터페이스는 IP 인스턴스의 인터페이스 제어 블록에 할당됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-175">Each physical interface is assigned to an interface control block in the IP instance.</span></span> <span data-ttu-id="c7e83-176">멀티홈 시스템을 사용하려는 애플리케이션은 시스템에 연결된 실제 디바이스 수로 \***NX_MAX_PHSYCIAL_INTERFACES** _ 값을 정의하고 NetX Duo 라이브러리를 다시 빌드해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-176">Applications wishing to use a multihome system must define the value for \***NX_MAX_PHSYCIAL_INTERFACES** _ to the number of physical devices attached to the system, and rebuild NetX Duo library.</span></span> <span data-ttu-id="c7e83-177">기본적으로 _ \*_NX_MAX_PHYSICAL_INTERFACES_\*\*는 하나로 설정되고, IP 인스턴스에서 하나의 인터페이스 제어 블록을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-177">By default _ *_NX_MAX_PHYSICAL_INTERFACES_*\* is set to one, creating one interface control block in the IP instance.</span></span>

<span data-ttu-id="c7e83-178">NetX Duo 애플리케이션은 \***nx_ip_create** _ 서비스를 사용하여 기본 디바이스를 위한 단일 IP 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-178">The NetX Duo application creates a single IP instance for the primary device using the \***nx_ip_create** _ service.</span></span> <span data-ttu-id="c7e83-179">애플리케이션은 각 추가 네트워크 디바이스에 대해 _ *_nx_ip_interface_attach_*\* 서비스를 사용하여 IP 인스턴스에 디바이스를 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-179">For each additional network devices, the application attaches the device to the IP instance using the _ *_nx_ip_interface_attach_*\* service.</span></span>

<span data-ttu-id="c7e83-180">각 네트워크 인터페이스 구조에는 인터페이스 IPv4 주소, 서브넷 마스크, IP MTU 크기, MAC 계층 주소 정보를 포함하여 IP 제어 블록에 포함된 네트워크 인터페이스에 대한 네트워크 정보의 하위 집합이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-180">Each network interface structure contains a subset of network information about the network interface that is contained in the IP control block, including interface IPv4 address, subnet mask, IP MTU size, and MAC-layer address information.</span></span>

> [!NOTE]
> <span data-ttu-id="c7e83-181">멀티홈을 지원하는 NetX Duo는 이전 버전의 NetX Duo와 호환됩니다. 명시적 인터페이스 정보를 사용하지 않는 서비스는 기본 네트워크 디바이스로 기본 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-181">*NetX Duo with multihome support is backward compatible with earlier versions of NetX Duo. Services that do not take explicit interface information default to the primary network device.*</span></span>

<span data-ttu-id="c7e83-182">기본 인터페이스의 IP 인스턴스 목록에 인덱스 0이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-182">The primary interface has index zero in the IP instance list.</span></span> <span data-ttu-id="c7e83-183">IP 인스턴스에 연결된 각 후속 디바이스에는 다음 인덱스가 할당됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-183">Each subsequent device attached to the IP instance is assigned the next index.</span></span>

<span data-ttu-id="c7e83-184">TCP, UDP, ICMP, IGMP를 포함하여 IP 인스턴스를 사용하는 모든 상위 계층 프로토콜 서비스를 연결된 모든 디바이스에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-184">All upper layer protocol services for which the IP instance is enabled, including TCP, UDP, ICMP, and IGMP, are available to all the attached devices.</span></span>

<span data-ttu-id="c7e83-185">대부분의 경우 NetX Duo는 패킷을 전송할 때 사용할 가장 적합한 소스 주소를 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-185">In most cases, NetX Duo can determine the best source address to use when transmitting a packet.</span></span> <span data-ttu-id="c7e83-186">소스 주소 선택은 대상 주소를 기반으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-186">The source address selection is based on the destination address.</span></span> <span data-ttu-id="c7e83-187">대상 주소에서 최적의 주소를 결정할 수 없는 경우 애플리케이션에서 사용할 특정 소스 주소를 지정할 수 있도록 NetX Duo 서비스가 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-187">NetX Duo services are added to allow applications to specify a specific source address to use, in cases where the most suitable one cannot be determined by the destination address.</span></span> <span data-ttu-id="c7e83-188">예를 들어, 멀티홈 시스템에서 애플리케이션은 IPv4 브로드캐스트 또는 멀티캐스트 대상 주소로 패킷을 전송해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-188">An example would be in a multihome system, an application needs to send a packet to an IPv4 broadcast or multicast destination addresses.</span></span>

<span data-ttu-id="c7e83-189">멀티홈 애플리케이션 개발을 위한 서비스는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-189">Services specifically for developing multihome applications include the following:</span></span>

- <span data-ttu-id="c7e83-190">*nx_igmp_multicast_interface_join*</span><span class="sxs-lookup"><span data-stu-id="c7e83-190">*nx_igmp_multicast_interface_join*</span></span>
- <span data-ttu-id="c7e83-191">*nx_igmp_multicast_interface_leave*</span><span class="sxs-lookup"><span data-stu-id="c7e83-191">*nx_igmp_multicast_interface_leave*</span></span>
- <span data-ttu-id="c7e83-192">*nx_ip_driver_interface_direct_command*</span><span class="sxs-lookup"><span data-stu-id="c7e83-192">*nx_ip_driver_interface_direct_command*</span></span>
- <span data-ttu-id="c7e83-193">*nx_ip_interface_address_get*</span><span class="sxs-lookup"><span data-stu-id="c7e83-193">*nx_ip_interface_address_get*</span></span>
- <span data-ttu-id="c7e83-194">*nx_ip_interface_address_mapping_configure*</span><span class="sxs-lookup"><span data-stu-id="c7e83-194">*nx_ip_interface_address_mapping_configure*</span></span>
- <span data-ttu-id="c7e83-195">*nx_ip_interface_address_set*</span><span class="sxs-lookup"><span data-stu-id="c7e83-195">*nx_ip_interface_address_set*</span></span>  
- <span data-ttu-id="c7e83-196">*nx_ip_interface_attach*</span><span class="sxs-lookup"><span data-stu-id="c7e83-196">*nx_ip_interface_attach*</span></span>
- <span data-ttu-id="c7e83-197">*nx_ip_interface_capability_get*</span><span class="sxs-lookup"><span data-stu-id="c7e83-197">*nx_ip_interface_capability_get*</span></span> 
- <span data-ttu-id="c7e83-198">*nx_ip_interface_capability_set*</span><span class="sxs-lookup"><span data-stu-id="c7e83-198">*nx_ip_interface_capability_set*</span></span>
- <span data-ttu-id="c7e83-199">*nx_ip_interface_detach*</span><span class="sxs-lookup"><span data-stu-id="c7e83-199">*nx_ip_interface_detach*</span></span>
- <span data-ttu-id="c7e83-200">*nx_ip_interface_info_get*</span><span class="sxs-lookup"><span data-stu-id="c7e83-200">*nx_ip_interface_info_get*</span></span>
- <span data-ttu-id="c7e83-201">*nx_ip_interface_mtu_set*</span><span class="sxs-lookup"><span data-stu-id="c7e83-201">*nx_ip_interface_mtu_set*</span></span>
- <span data-ttu-id="c7e83-202">*nx_ip_interface_physical_address_get*</span><span class="sxs-lookup"><span data-stu-id="c7e83-202">*nx_ip_interface_physical_address_get*</span></span>
- <span data-ttu-id="c7e83-203">*nx_ip_interface_physical_address_set*</span><span class="sxs-lookup"><span data-stu-id="c7e83-203">*nx_ip_interface_physical_address_set*</span></span>
- <span data-ttu-id="c7e83-204">*nx_ip_interface_status_check*</span><span class="sxs-lookup"><span data-stu-id="c7e83-204">*nx_ip_interface_status_check*</span></span>
- <span data-ttu-id="c7e83-205">*nx_ip_raw_packet_source_send*</span><span class="sxs-lookup"><span data-stu-id="c7e83-205">*nx_ip_raw_packet_source_send*</span></span>
- <span data-ttu-id="c7e83-206">*nx_ipv4_multicast_interface_join*</span><span class="sxs-lookup"><span data-stu-id="c7e83-206">*nx_ipv4_multicast_interface_join*</span></span>
- <span data-ttu-id="c7e83-207">*nx_ipv4_multicast_interface_leave*</span><span class="sxs-lookup"><span data-stu-id="c7e83-207">*nx_ipv4_multicast_interface_leave*</span></span>
- <span data-ttu-id="c7e83-208">*nx_udp_socket_source_send*</span><span class="sxs-lookup"><span data-stu-id="c7e83-208">*nx_udp_socket_source_send*</span></span>
- <span data-ttu-id="c7e83-209">*nxd_ipv6_multicast_interface_join*</span><span class="sxs-lookup"><span data-stu-id="c7e83-209">*nxd_ipv6_multicast_interface_join*</span></span>
- <span data-ttu-id="c7e83-210">*nxd_ipv6_multicast_interface_leave*</span><span class="sxs-lookup"><span data-stu-id="c7e83-210">*nxd_ipv6_multicast_interface_leave*</span></span> 
- <span data-ttu-id="c7e83-211">*nxd_udp_socket_source_send*</span><span class="sxs-lookup"><span data-stu-id="c7e83-211">*nxd_udp_socket_source_send*</span></span>
- <span data-ttu-id="c7e83-212">*nxd_icmp_source_ping*</span><span class="sxs-lookup"><span data-stu-id="c7e83-212">*nxd_icmp_source_ping*</span></span>
- <span data-ttu-id="c7e83-213">*nxd_ip_raw_packet_source_send*</span><span class="sxs-lookup"><span data-stu-id="c7e83-213">*nxd_ip_raw_packet_source_send*</span></span>
- <span data-ttu-id="c7e83-214">*nxd_udp_socket_source_send*</span><span class="sxs-lookup"><span data-stu-id="c7e83-214">*nxd_udp_socket_source_send*</span></span>

<span data-ttu-id="c7e83-215">이러한 서비스는 [NetX Duo 서비스 설명](chapter4.md)에 자세히 설명되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-215">These services are explained in greater detail in [Description of NetX Duo Services](chapter4.md).</span></span>

### <a name="loopback-interface"></a><span data-ttu-id="c7e83-216">루프백 인터페이스</span><span class="sxs-lookup"><span data-stu-id="c7e83-216">Loopback Interface</span></span>

<span data-ttu-id="c7e83-217">루프백 인터페이스는 실제 링크가 연결되어 있지 않은 특수한 네트워크 인터페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-217">The loopback interface is a special network interface without an physical link attached to.</span></span> <span data-ttu-id="c7e83-218">루프백 인터페이스를 통해 애플리케이션은 IPv4 루프백 주소 127.0.0.1을 사용하여 통신할 수 있습니다. 논리적 루프백 인터페이스를 활용하려면 구성 가능한 옵션 ***NX_DISABLE_LOOPBACK_INTERFACE*** 가 설정되어 있지 않았는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-218">The loopback interface allows applications to communicate using the IPv4 loopback address 127.0.0.1 To utilize a logical loopback interface, ensure the configurable option ***NX_DISABLE_LOOPBACK_INTERFACE*** is not set.</span></span>

### <a name="interface-control-blocks"></a><span data-ttu-id="c7e83-219">인터페이스 제어 블록</span><span class="sxs-lookup"><span data-stu-id="c7e83-219">Interface Control Blocks</span></span>

<span data-ttu-id="c7e83-220">IP 인스턴스의 인터페이스 제어 블록 수는 실제 인터페이스(\***NX_MAX_PHYSICAL_INTERFACES** _로 정의됨)의 수와 루프백 인터페이스(사용 가능한 경우) 수를 더한 값과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-220">The number of interface control blocks in the IP instance is the number of physical interfaces (defined by \***NX_MAX_PHYSICAL_INTERFACES** _) plus the loopback interface if it is enabled.</span></span> <span data-ttu-id="c7e83-221">총 인터페이스 수는 _\*_NX_MAX_IP_INTERFACES_\*\*에 정의되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-221">The total number of interfaces is defined in _\*_NX_MAX_IP_INTERFACES_\*\*.</span></span>

## <a name="protocol-layering"></a><span data-ttu-id="c7e83-222">프로토콜 계층화</span><span class="sxs-lookup"><span data-stu-id="c7e83-222">Protocol Layering</span></span>

<span data-ttu-id="c7e83-223">NetX Duo에 의해 구현된 TCP/IP는 계층화된 프로토콜로, 더 복잡한 프로토콜이 더 단순한 기본 프로토콜을 기반으로 하여 빌드됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-223">The TCP/IP implemented by NetX Duo is a layered protocol, which means more complex protocols are built on top of simpler underlying protocols.</span></span> <span data-ttu-id="c7e83-224">TCP/IP에서 가장 낮은 계층 프로토콜은 ‘링크 수준’에 있으며 네트워크 드라이버에서 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-224">In TCP/IP, the lowest layer protocol is at the *link level* and is handled by the network driver.</span></span> <span data-ttu-id="c7e83-225">이 수준은 일반적으로 이더넷을 대상으로 하지만 파이버, 시리얼 또는 거의 모든 실제 미디어를 대상으로 할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-225">This level is typically targeted towards Ethernet, but it could also be fiber, serial, or virtually any physical media.</span></span>

<span data-ttu-id="c7e83-226">링크 계층의 맨 위에는 ‘네트워크 계층’이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-226">On top of the link layer is the *network layer*.</span></span> <span data-ttu-id="c7e83-227">TCP/IP에서 이것은 기본적으로 네트워크를 통해 간단한 패킷을 최선의 방법으로 주고받는 것을 담당하는 IP입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-227">In TCP/IP, this is the IP, which is basically responsible for sending and receiving simple packets—in a best-effort manner—across the network.</span></span> <span data-ttu-id="c7e83-228">ICMP 및 IGMP와 같은 관리 형식 프로토콜은 일반적으로 IP를 주고받는 경우에도 네트워크 계층으로 분류됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-228">Management-type protocols like ICMP and IGMP are typically also categorized as network layers, even though they rely on IP for sending and receiving.</span></span>

<span data-ttu-id="c7e83-229">‘전송 계층’은 네트워크 계층의 맨 위에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-229">The *transport layer* rests on top of the network layer.</span></span> <span data-ttu-id="c7e83-230">이 계층은 네트워크의 호스트 간 데이터 흐름을 관리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-230">This layer is responsible for managing the flow of data between hosts on the network.</span></span> <span data-ttu-id="c7e83-231">NetX Duo에서 지원하는 전송 서비스에는 UDP 및 TCP의 두 가지 형식이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-231">There are two types of transport services supported by NetX Duo: UDP and TCP.</span></span> <span data-ttu-id="c7e83-232">UDP 서비스는 연결하지 않고 두 호스트 간에 데이터를 주고받는 최선의 방법을 제공하는 반면, TCP는 두 호스트 엔터티 간에 안정적인 연결 지향 서비스를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-232">UDP services provide best-effort sending and receiving of data between two hosts in a connectionless manner, while TCP provides reliable connection-oriented service between two host entities.</span></span>

<span data-ttu-id="c7e83-233">이 계층은 실제 네트워크 데이터 패킷에 반영됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-233">This layering is reflected in the actual network data packets.</span></span> <span data-ttu-id="c7e83-234">TCP/IP의 각 계층에는 헤더라는 정보 블록이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-234">Each layer in TCP/IP contains a block of information called a header.</span></span> <span data-ttu-id="c7e83-235">헤더를 사용하여 데이터(및 프로토콜 정보)를 둘러싸는 이 기술을 일반적으로 데이터 캡슐화라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-235">This technique of surrounding data (and possibly protocol information) with a header is typically called data encapsulation.</span></span> <span data-ttu-id="c7e83-236">그림 1은 NetX Duo 계층화의 예를 보여주고 그림 2는 전송 중인 UDP 데이터에 대한 데이터 캡슐화 결과의 예를 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-236">Figure 1 shows an example of NetX Duo layering and Figure 2 shows the resulting data encapsulation for UDP data being sent.</span></span>

![프로토콜 계층화](./media/user-guide/image12.jpg)

<span data-ttu-id="c7e83-238">**그림 1. 프로토콜 계층화**</span><span class="sxs-lookup"><span data-stu-id="c7e83-238">**FIGURE 1. Protocol Layering**</span></span>

## <a name="packet-pools"></a><span data-ttu-id="c7e83-239">패킷 풀</span><span class="sxs-lookup"><span data-stu-id="c7e83-239">Packet Pools</span></span>

<span data-ttu-id="c7e83-240">실시간 네트워킹 애플리케이션에서 신속하고 결정적인 방식으로 패킷을 할당하는 것은 항상 어려운 과제입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-240">Allocating packets in a fast and deterministic manner is always a challenge in real-time networking applications.</span></span> <span data-ttu-id="c7e83-241">이를 염두에 둔 NetX Duo는 고정 크기 네트워크 패킷의 여러 풀을 만들고 관리할 수 있는 기능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-241">With this in mind, NetX Duo provides the ability to create and manage multiple pools of fixed-size network packets.</span></span>

<span data-ttu-id="c7e83-242">NetX Duo 패킷 풀은 고정 크기의 메모리 블록으로 구성되므로 내부 조각화 문제가 발생하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-242">Because NetX Duo packet pools consist of fixed-size memory blocks, there are never any internal fragmentation problems.</span></span> <span data-ttu-id="c7e83-243">물론 조각화는 본질적으로 비결정적인 동작을 야기합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-243">Of course, fragmentation causes behavior that is inherently nondeterministic.</span></span> <span data-ttu-id="c7e83-244">더불어, NetX Duo 패킷을 할당하고 해제하는 데 필요한 시간은 간단한 연결된 목록 조작에 해당합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-244">In addition, the time required to allocate and free a NetX Duo packet amounts to simple linked-list manipulation.</span></span> <span data-ttu-id="c7e83-245">또한 패킷 할당 및 할당 해제는 사용 가능한 목록의 맨 위에서 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-245">Furthermore, packet allocation and deallocation is done at the head of the available list.</span></span> <span data-ttu-id="c7e83-246">이렇게 하면 가장 빠른 연결된 목록 처리를 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-246">This provides the fastest possible linked list processing.</span></span>

![UDP 데이터 캡슐화](./media/user-guide/image13.png)

<span data-ttu-id="c7e83-248">**그림 2. UDP 데이터 캡슐화**</span><span class="sxs-lookup"><span data-stu-id="c7e83-248">**FIGURE 2. UDP Data Encapsulation**</span></span>

<span data-ttu-id="c7e83-249">일반적으로 유연성 부족은 고정 크기 패킷 풀의 주요 단점입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-249">Lack of flexibility is typically the main drawback of fixed-size packet pools.</span></span> <span data-ttu-id="c7e83-250">최악의 경우 들어오는 패킷을 처리하는 최적의 패킷 페이로드 크기를 결정하는 것은 어려운 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-250">Determining the optimal packet payload size that also handles the worst-case incoming packet is a difficult task.</span></span> <span data-ttu-id="c7e83-251">NetX Duo 패킷은 패킷 연결이라는 옵션 기능을 사용하여 이 문제를 해결합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-251">NetX Duo packets address this problem with an optional feature called packet chaining.</span></span> <span data-ttu-id="c7e83-252">실제 네트워크 패킷은 함께 연결된 두 개 이상의 NetX Duo 패킷으로 구성될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-252">An actual network packet can be made of one or more NetX Duo packets linked together.</span></span> <span data-ttu-id="c7e83-253">또한 패킷 헤더는 패킷의 맨 위에 대한 포인터를 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-253">In addition, the packet header maintains a pointer to the top of the packet.</span></span> <span data-ttu-id="c7e83-254">추가 프로토콜이 추가되면 이 포인터는 단순히 뒤로 이동하고 새 헤더는 데이터 바로 앞에 작성됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-254">As additional protocols are added, this pointer is simply moved backwards and the new header is written directly in front of the data.</span></span> <span data-ttu-id="c7e83-255">유연한 패킷 기술이 없으면 스택은 처리 집약적인 새 헤더를 사용하여 다른 버퍼를 할당하고 데이터를 새 버퍼에 복사해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-255">Without the flexible packet technology, the stack would have to allocate another buffer and copy the data into a new buffer with the new header, which is processing intensive.</span></span>

<span data-ttu-id="c7e83-256">각 패킷 페이로드 크기는 지정된 패킷 풀에 대해 고정되므로 페이로드 크기보다 큰 애플리케이션 데이터에는 여러 패킷이 함께 연결되어 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-256">Since each packet payload size is fixed for a given packet pool, application data larger than the payload size would require multiple packets chained together.</span></span> <span data-ttu-id="c7e83-257">사용자 데이터를 사용하여 패킷을 채울 때 애플리케이션은 ***nx_packet_data_append*** 서비스를 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-257">When filling a packet with user data, the application shall use the service ***nx_packet_data_append***.</span></span> <span data-ttu-id="c7e83-258">이 서비스는 애플리케이션 데이터를 패킷으로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-258">This service moves application data into a packet.</span></span> <span data-ttu-id="c7e83-259">패킷이 사용자 데이터를 저장하기에 충분하지 않은 경우 사용자 데이터를 저장하기 위한 추가 패킷이 할당됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-259">In situations where a packet is not enough to hold user data, additional packets are allocated to store user data.</span></span> <span data-ttu-id="c7e83-260">패킷 연결을 사용하려면 드라이버에서 연결된 패킷으로 수신하거나 전송할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-260">To use packet chaining, the driver must be able to receive into or transmit from chained packets.</span></span>

<span data-ttu-id="c7e83-261">패킷 연결 기능을 사용할 필요가 없는 포함된 시스템의 경우 \***NX_DISABLE_PACKET_CHAIN** _으로 NetX Duo 라이브러리를 빌드하여 패킷 연결 논리를 제거할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-261">For embedded systems that do not need to use the packet chaining feature, the NetX Duo library can be built with \***NX_DISABLE_PACKET_CHAIN** _ to remove the packet chaining logic.</span></span> <span data-ttu-id="c7e83-262">IP 조각화 및 리어셈블리 기능은 연결된 패킷 기능을 활용해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-262">Note that the IP fragmentation and reassembly feature may need to utilize the chained packet feature.</span></span> <span data-ttu-id="c7e83-263">따라서 _*_NX_DISABLE_PACKET_CHAIN_*_ 을 정의하려면 _ \*_NX_DISABLE_FRAGMENTATION_\*\*도 정의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-263">Therefore defining _*_NX_DISABLE_PACKET_CHAIN_*_ requires _ *_NX_DISABLE_FRAGMENTATION_*\* also be defined.</span></span> 

<span data-ttu-id="c7e83-264">각 NetX Duo 패킷 메모리 풀은 퍼블릭 리소스입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-264">Each NetX Duo packet memory pool is a public resource.</span></span> <span data-ttu-id="c7e83-265">NetX Duo는 패킷 풀의 사용 방법에 제약 조건을 두지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-265">NetX Duo places no constraints on how packet pools are used.</span></span> 

### <a name="packet-pool-memory-area"></a><span data-ttu-id="c7e83-266">패킷 풀 메모리 영역</span><span class="sxs-lookup"><span data-stu-id="c7e83-266">Packet Pool Memory Area</span></span>

<span data-ttu-id="c7e83-267">패킷 풀의 메모리 영역은 만드는 동안 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-267">The memory area for the packet pool is specified during creation.</span></span> <span data-ttu-id="c7e83-268">ThreadX 및 NetX Duo 개체의 다른 메모리 영역과 마찬가지로 대상의 주소 공간 어디에서나 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-268">Like other memory areas for ThreadX and NetX Duo objects, it can be located anywhere in the target's address space.</span></span> 

<span data-ttu-id="c7e83-269">이는 애플리케이션에 상당한 유연성을 제공하기 때문에 중요한 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-269">This is an important feature because of the considerable flexibility it gives the application.</span></span> <span data-ttu-id="c7e83-270">예를 들어 통신 제품에 네트워크 버퍼를 위한 고속 메모리 영역이 있다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-270">For example, suppose that a communication product has a high-speed memory area for network buffers.</span></span> <span data-ttu-id="c7e83-271">이 메모리 영역은 NetX Duo 패킷 메모리 풀로 만들어 쉽게 활용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-271">This memory area is easily utilized by making it into a NetX Duo packet memory pool.</span></span>

### <a name="creating-packet-pools"></a><span data-ttu-id="c7e83-272">패킷 풀 만들기</span><span class="sxs-lookup"><span data-stu-id="c7e83-272">Creating Packet Pools</span></span>

<span data-ttu-id="c7e83-273">패킷 풀은 초기화 중에 또는 애플리케이션 스레드에서 런타임 중에 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-273">Packet pools are created either during initialization or during runtime by  application threads.</span></span> <span data-ttu-id="c7e83-274">NetX Duo 애플리케이션의 패킷 메모리 풀 수에는 제한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-274">There are no limits on the number of packet memory pools in a NetX Duo application.</span></span>

### <a name="dual-packet-pool"></a><span data-ttu-id="c7e83-275">이중 패킷 풀</span><span class="sxs-lookup"><span data-stu-id="c7e83-275">Dual Packet Pool</span></span>

<span data-ttu-id="c7e83-276">일반적으로 기본 IP 패킷 풀의 페이로드 크기는 네트워크 인터페이스 MTU까지 프레임 크기를 수용할 수 있을 만큼 충분히 큽니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-276">Typically the payload size of the default IP packet pool is large enough to accommodate frame size up to the network interface MTU.</span></span> <span data-ttu-id="c7e83-277">정상적인 작업 중에 IP 스레드는 ARP, TCP 제어 메시지, IGMP 메시지, ICMPv6 메시지 등의 메시지를 보내야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-277">During normal operation, the IP thread needs to send messages such as ARP, TCP control messages, IGMP messages, ICMPv6 messages.</span></span> <span data-ttu-id="c7e83-278">이러한 메시지는 IP 인스턴스의 기본 패킷 풀에서 할당된 패킷을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-278">These messages use the packets allocated from the default packet pool in the IP instance.</span></span> <span data-ttu-id="c7e83-279">패킷 풀에 사용할 수 있는 메모리양이 제한된 메모리 제약 시스템에서는 MTU 크기에 맞게 큰 페이로드 크기를 가진 단일 패킷 풀을 사용하는 것이 최적의 솔루션이 아닐 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-279">On a memory-constrained system where the amount of memory available for packet pool is limited, using a single packet pool (with the large payload size to match MTU size) may not be an optimal solution.</span></span> <span data-ttu-id="c7e83-280">NetX Duo를 사용하면 애플리케이션은 페이로드 크기가 더 작은 보조 패킷 풀을 설치할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-280">NetX Duo allows application to install an auxiliary packet pool, where the payload size is smaller.</span></span> <span data-ttu-id="c7e83-281">보조 패킷 풀이 설치되면 IP 도우미 스레드는 전송하는 메시지 크기에 따라 기본 패킷 풀이나 보조 풀에서 패킷을 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-281">Once the auxiliary packet pool is installed, the IP helper thread would allocate packets from either the default packet pool or the auxiliary pool, depending on the size of the message it transmits.</span></span> <span data-ttu-id="c7e83-282">보조 패킷 풀의 경우 IP 도우미 스레드가 전송하는 대부분의 메시지에서 200바이트의 페이로드 크기가 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-282">For an auxiliary packet pool, a payload size of 200 bytes would work with most of the messages the IP helper thread transmits.</span></span>

<span data-ttu-id="c7e83-283">기본적으로 NetX Duo 라이브러리는 이중 패킷 풀을 사용하지 않고 빌드됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-283">By default NetX Duo library is built without enabling dual packet pool.</span></span> <span data-ttu-id="c7e83-284">기능을 사용하도록 설정하려면 \***NX_DUAL_PACKET_POOL_ENABLE** _이 정의된 라이브러리를 빌드합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-284">To enable the feature, build the library with \***NX_DUAL_PACKET_POOL_ENABLE** _ defined.</span></span> <span data-ttu-id="c7e83-285">그런 다음 _\*_nx_ip_auxiliary_packet_pool_set_\*\*을 호출하여 보조 패킷 풀을 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-285">Then the auxiliary packet pool can be set by calling _\*_nx_ip_auxiliary_packet_pool_set_\*\*.</span></span>

<span data-ttu-id="c7e83-286">또한 두 개 이상의 패킷 풀을 만드는 옵션도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-286">There is also the option of creating more than one packet pool.</span></span> <span data-ttu-id="c7e83-287">예를 들어 전송 패킷 풀은 예상 메시지 크기에 대한 최적의 페이로드 크기로 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-287">For example a transmit packet pool is created with optimal payload size for expected message sizes.</span></span> <span data-ttu-id="c7e83-288">수신된 패킷의 크기를 예측할 수 없기 때문에 드라이버 MTU로 설정된 페이로드 크기의 드라이버에 수신 패킷 풀이 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-288">A receive packet pool is created in the driver with a payload size set to the driver MTU, since one cannot predict the size of received packets.</span></span>

### <a name="packet-header-nx_packet"></a><span data-ttu-id="c7e83-289">패킷 헤더 NX_PACKET</span><span class="sxs-lookup"><span data-stu-id="c7e83-289">Packet Header NX_PACKET</span></span>   
<span data-ttu-id="c7e83-290">기본적으로 NetX Duo는 패킷 페이로드 영역 바로 앞에 패킷 헤더를 배치합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-290">By default, NetX Duo places the packet header immediately before the packet payload area.</span></span> <span data-ttu-id="c7e83-291">패킷 메모리 풀은 기본적으로 일련의 패킷이며 헤더 바로 뒤에 패킷 페이로드가 배치됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-291">The packet memory pool is basically a series of packets— headers followed immediately by the packet payload.</span></span> <span data-ttu-id="c7e83-292">패킷 헤더(***NX_PACKET***)와 패킷 풀의 레이아웃은 그림 3에 나와 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-292">The packet header (***NX_PACKET***) and the layout of the packet pool are pictured in Figure 3.</span></span>

<span data-ttu-id="c7e83-293">무복사 작업을 수행할 수 있는 네트워크 디바이스 드라이버의 경우 일반적으로 패킷 페이로드 영역의 시작 주소가 DMA 논리로 프로그래밍이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-293">For network devices driver that are able to perform zero copy operations, typically the starting address of the packet payload area is programmed into the DMA logic.</span></span> <span data-ttu-id="c7e83-294">특정 DMA 엔진은 페이로드 영역에 맞춤 요구 사항이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-294">Certain DMA engines have alignment requirement on the payload area.</span></span> <span data-ttu-id="c7e83-295">페이로드 영역의 시작 주소를 DMA 엔진 또는 캐시 작업에 올바르게 맞추려면 사용자는 기호 ***NX_PACKET_ALIGNMENT*** 를 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-295">To make the starting address of the payload area align properly for the DMA engine, or the cache operation, the user can define the symbol ***NX_PACKET_ALIGNMENT***.</span></span>

> [!WARNING]
> <span data-ttu-id="c7e83-296">패킷 전송이 완료되면 네트워크 드라이버에서 **nx_packet_transmit_release** 함수를 사용하는 것이 중요합니다. 이 함수는 실제로 사용 가능한 풀에 다시 배치되기 전에 패킷이 TCP 출력 큐의 일부가 아닌지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-296">*It is important for the network driver to use the **nx_packet_transmit_release** function when transmission of a packet is complete. This function checks to make sure the packet is not part of a TCP output queue before it is actually placed back in the available pool.*</span></span>

![패킷 헤더 및 패킷 풀 레이아웃](./media/user-guide/image14.jpg)

<span data-ttu-id="c7e83-298">**그림 3. 패킷 헤더 및 패킷 풀 레이아웃**</span><span class="sxs-lookup"><span data-stu-id="c7e83-298">**FIGURE 3. Packet Header and Packet Pool Layout**</span></span>

<span data-ttu-id="c7e83-299">패킷 헤더의 필드는 다음과 같이 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-299">The fields of the packet header are defined as follows.</span></span> <span data-ttu-id="c7e83-300">이 표는 *NX_PACKET* 구조에 있는 모든 멤버의 포괄적인 목록은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-300">Note that this table is not a comprehensive list of all the members in the *NX_PACKET* structure.</span></span>

|<span data-ttu-id="c7e83-301">패킷 헤더</span><span class="sxs-lookup"><span data-stu-id="c7e83-301">Packet header</span></span> | <span data-ttu-id="c7e83-302">목적</span><span class="sxs-lookup"><span data-stu-id="c7e83-302">Purpose</span></span> |
|---|---|
|<span data-ttu-id="c7e83-303">***nx_packet_pool_owner***</span><span class="sxs-lookup"><span data-stu-id="c7e83-303">***nx_packet_pool_owner***</span></span>|<span data-ttu-id="c7e83-304">이 필드는 이 특정 패킷을 소유한 패킷 풀을 가리킵니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-304">This field points to the packet pool that owns this particular packet.</span></span> <span data-ttu-id="c7e83-305">패킷이 해제되면 이 특정 풀로 해제됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-305">When the packet is released, it is released to this particular pool.</span></span> <span data-ttu-id="c7e83-306">각 패킷 내부의 풀 소유권을 통해 데이터그램이 여러 패킷 풀에서 여러 패킷을 소유할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-306">With the pool ownership inside each packet, it is possible for a datagram to span multiple packets from multiple packet pools.</span></span>|
|<span data-ttu-id="c7e83-307">\***nx_packet_next** _</span><span class="sxs-lookup"><span data-stu-id="c7e83-307">\***nx_packet_next** _</span></span>|<span data-ttu-id="c7e83-308">이 필드는 동일한 프레임 내의 다음 패킷을 가리킵니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-308">This field points to the next packet within the same frame.</span></span> <span data-ttu-id="c7e83-309">NULL인 경우 프레임의 일부인 추가 패킷이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-309">If NULL, there are no additional packets that are part of the frame.</span></span> <span data-ttu-id="c7e83-310">이 필드는 전체 패킷을 다시 어셈블할 수 있을 때까지 조각난 패킷을 보관하는 데도 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-310">This field is also used to hold fragmented packets until the entire packet can be re-assembled.</span></span> <span data-ttu-id="c7e83-311">_\*_NX_DISABLE_PACKET_CHAIN_\*\*이 정의되면 제거됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-311">it is removed if _\*_NX_DISABLE_PACKET_CHAIN_\*\*is defined.</span></span>|
|<span data-ttu-id="c7e83-312">\***nx_packet_last** _</span><span class="sxs-lookup"><span data-stu-id="c7e83-312">\***nx_packet_last** _</span></span>|<span data-ttu-id="c7e83-313">이 필드는 동일한 네트워크 패킷 내의 마지막 패킷을 가리킵니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-313">This field points to the last packet within the same network packet.</span></span> <span data-ttu-id="c7e83-314">NULL인 경우 이 패킷은 전체 네트워크 패킷을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-314">If NULL, this packet represents the entire network packet.</span></span> <span data-ttu-id="c7e83-315">_\*_NX_DISABLE_PACKET_CHAIN_\*\*이 정의되면 이 필드는 제거됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-315">This field is removed if _\*_NX_DISABLE_PACKET_CHAIN_\*\*is defined.</span></span>|
|<span data-ttu-id="c7e83-316">\***nx_packet_length** _</span><span class="sxs-lookup"><span data-stu-id="c7e83-316">\***nx_packet_length** _</span></span>| <span data-ttu-id="c7e83-317">이 필드는 _nx_packet_next\* 멤버에 의해 함께 연결된 모든 패킷의 모든 바이트 수를 포함하여 전체 네트워크 패킷의 총 바이트 수를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-317">This field contains the total number of bytes in the entire network packet, including the total of all bytes in all packets chained together by the _nx_packet_next\*member.</span></span>|
|<span data-ttu-id="c7e83-318">***nx_packet_ip_interface***</span><span class="sxs-lookup"><span data-stu-id="c7e83-318">***nx_packet_ip_interface***</span></span>| <span data-ttu-id="c7e83-319">이 필드는 인터페이스 드라이버에 의해 수신될 때 패킷에 할당되고, NetX Duo에 의해 나가는 패킷에 할당되는 인터페이스 제어 블록입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-319">This field is the interface control block which is assigned to the packet when it is received by the interface driver, and by NetX Duo for outgoing packets.</span></span> <span data-ttu-id="c7e83-320">인터페이스 제어 블록은 네트워크 주소, MAC 주소, IP 주소 등의 인터페이스 및 링크 사용이나 실제 매핑 필요와 같은 인터페이스 상태를 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-320">An interface control block describes the interface e.g. network address, MAC address, IP address and interface status such as link enabled and physical mapping required.</span></span>|
|<span data-ttu-id="c7e83-321">\***nx_packet_data_start** _</span><span class="sxs-lookup"><span data-stu-id="c7e83-321">\***nx_packet_data_start** _</span></span>| <span data-ttu-id="c7e83-322">이 필드는 이 패킷의 실제 페이로드 영역의 시작을 가리킵니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-322">This field points to the start of the physical payload area of this packet.</span></span> <span data-ttu-id="c7e83-323">NX_PACKET 헤더 바로 뒤에 있을 필요는 없지만 _ *_nx_packet_pool_create_* 서비스에 대한 기본값입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-323">It does not have to be immediately following the NX_PACKET header, but that is the default for the _ *_nx_packet_pool_create_*\* service.</span></span>|
|<span data-ttu-id="c7e83-324">\***nx_packet_data_end** _</span><span class="sxs-lookup"><span data-stu-id="c7e83-324">\***nx_packet_data_end** _</span></span>|<span data-ttu-id="c7e83-325">이 필드는 이 패킷의 실제 페이로드 영역의 끝을 가리킵니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-325">This field points to the end of the physical payload area of this packet.</span></span> <span data-ttu-id="c7e83-326">이 필드와 _nx_packet_data_start\* 필드 간의 차이는 페이로드 크기를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-326">The difference between this field and the _nx_packet_data_start\* field represents the payload size.</span></span>|
|<span data-ttu-id="c7e83-327">\***nx_packet_prepend_ptr** _</span><span class="sxs-lookup"><span data-stu-id="c7e83-327">\***nx_packet_prepend_ptr** _</span></span>|<span data-ttu-id="c7e83-328">이 필드는 패킷 페이로드 영역의 기존 패킷 데이터(있는 경우) 앞에 프로토콜 헤더나 실제 데이터와 같은 패킷 데이터가 추가되는 위치를 가리킵니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-328">This field points to the location of where packet data, either protocol header or actual data, is added in front of the existing packet data (if any) in the packet payload area.</span></span> <span data-ttu-id="c7e83-329">_nx_packet_data_start\* 포인터 위치보다 크거나 같아야 하며 *nx_packet_append_ptr* 포인터보다 작거나 같아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-329">It must be greater than or equal to the _nx_packet_data_start\* pointer location and less than or equal to the *nx_packet_append_ptr* pointer.</span></span>|
> [!CAUTION]
> <span data-ttu-id="c7e83-330">성능상의 이유로, 전송을 위해 패킷이 NetX Duo 서비스에 전달될 때 NetX Duo는 앞에 추가 포인터가 긴 단어 맞춤 주소를 가리키는 것으로 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-330">*For performance reasons, NetX Duo assumes that when the packet is passed into NetX Duo services for transmission, the prepend pointer points to long word aligned address.*</span></span>

| <span data-ttu-id="c7e83-331">패킷 헤더</span><span class="sxs-lookup"><span data-stu-id="c7e83-331">Packet header</span></span> | <span data-ttu-id="c7e83-332">목적</span><span class="sxs-lookup"><span data-stu-id="c7e83-332">Purpose</span></span> |
|---|---|
|<span data-ttu-id="c7e83-333">\***nx_packet_append_ptr** _</span><span class="sxs-lookup"><span data-stu-id="c7e83-333">\***nx_packet_append_ptr** _</span></span>|<span data-ttu-id="c7e83-334">이 필드는 현재 패킷 페이로드 영역에 있는 데이터의 끝을 가리킵니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-334">This field points to the end of the data currently in the packet payload area.</span></span> <span data-ttu-id="c7e83-335">_nx_packet_prepend_ptr\* 및 *nx_packet_data_end.* 가 가리키는 메모리 위치 사이에 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-335">It must be in between the memory location pointed to by _nx_packet_prepend_ptr\* and *nx_packet_data_end.*</span></span> <span data-ttu-id="c7e83-336">이 필드와 *nx_packet_prepend_ptr* 필드 간의 차이는 이 패킷의 데이터양을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-336">The difference between this field and the *nx_packet_prepend_ptr* field represents the amount of data in this packet.</span></span>|
|<span data-ttu-id="c7e83-337">\***nx_packet_packet_pad** _</span><span class="sxs-lookup"><span data-stu-id="c7e83-337">\***nx_packet_packet_pad** _</span></span>|<span data-ttu-id="c7e83-338">이 필드는 원하는 맞춤 요구 사항을 달성하기 위해 4바이트 단어로 된 패딩의 길이를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-338">This fields defines the length of padding in 4-byte words to achieve the desired alignment requirement.</span></span> <span data-ttu-id="c7e83-339">_*_NX_PACKET_HEADER_PAD_*_ 가 정의되지 않은 경우 이 필드는 제거됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-339">This field is removed if _*_NX_PACKET_HEADER_PAD_*_ is not defined.</span></span> <span data-ttu-id="c7e83-340">또는 _nx_packet_header_pad를 정의하는 대신 _*_NX_PACKET_ALIGNMENT_*_ 를 사용할 수 있습니다.\*</span><span class="sxs-lookup"><span data-stu-id="c7e83-340">Alternatively _*_NX_PACKET_ALIGNMENT_*_ can be used instead of defining _nx_packet_header_pad.\*</span></span>|

### <a name="packet-header-offsets"></a><span data-ttu-id="c7e83-341">패킷 헤더 오프셋</span><span class="sxs-lookup"><span data-stu-id="c7e83-341">Packet Header Offsets</span></span>

<span data-ttu-id="c7e83-342">패킷 헤더 크기는 헤더 크기를 수용할 수 있는 충분한 공간을 허용하도록 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-342">Packet header size is defined to allow enough room  to accommodate the size of the header.</span></span> <span data-ttu-id="c7e83-343">***nx_packet_allocate*** 서비스는 패킷을 할당하고 지정된 패킷 형식에 따라 패킷의 앞에 추가 포인터를 조정하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-343">The ***nx_packet_allocate*** service is used to allocate a packet and adjusts the prepend pointer in the packet according to the type of packet specified.</span></span> <span data-ttu-id="c7e83-344">패킷 형식은 프로토콜 헤더(예: UDP, TCP, ICMP)를 프로토콜 데이터 앞에 삽입하는 데 필요한 오프셋을 NetX Duo에게 알려줍니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-344">The packet type tells NetX Duo the offset required for inserting the protocol header (such as UDP, TCP, or ICMP) in front of the protocol data.</span></span>

<span data-ttu-id="c7e83-345">다음 형식은 패킷의 IP 헤더와 실제 계층(이더넷) 헤더를 고려하도록 NetX Duo에서 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-345">The following types are defined in NetX Duo to take into account the IP header and physical layer (Ethernet) header in the packet.</span></span> <span data-ttu-id="c7e83-346">후자의 경우, 필요한 4바이트 맞춤을 고려하여 16바이트로 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-346">In the latter case, it is assumed to be 16 bytes taking the required 4-byte alignment into consideration.</span></span> <span data-ttu-id="c7e83-347">IPv4 패킷은 IPv4 네트워크의 패킷을 할당하는 애플리케이션에 대해 NetX Duo에서 계속 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-347">IPv4 packets are still defined in NetX Duo for applications to allocate packets for IPv4 networks.</span></span> <span data-ttu-id="c7e83-348">NetX Duo 라이브러리가 IPv6를 사용하도록 설정하여 빌드된 경우 일반 패킷 형식(예: NX_IP_PACKET)은 IPv6 버전에 매핑됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-348">Note that if the NetX Duo library is built with IPv6 enabled, the generic packet types (such as NX_IP_PACKET) are mapped to the IPv6 version.</span></span> <span data-ttu-id="c7e83-349">IPv6를 사용하도록 설정하지 않고 NetX Duo 라이브러리를 빌드하면 이러한 일반 패킷 형식은 IPv4 버전에 매핑됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-349">If the NetX Duo Library is built without IPv6 enabled, these generic packet types are mapped to the IPv4 version.</span></span>

<span data-ttu-id="c7e83-350">다음 표에서는 IPv6를 사용하도록 설정하여 정의된 기호를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-350">The following table shows symbols defined with IPv6 enabled:</span></span>

|<span data-ttu-id="c7e83-351">**패킷 형식**</span><span class="sxs-lookup"><span data-stu-id="c7e83-351">**Packet Type**</span></span> |<span data-ttu-id="c7e83-352">**값**</span><span class="sxs-lookup"><span data-stu-id="c7e83-352">**Value**</span></span> |
|---|---|
|<span data-ttu-id="c7e83-353">NX_IPv6_PACKET(NX_IP_PACKET)</span><span class="sxs-lookup"><span data-stu-id="c7e83-353">NX_IPv6_PACKET (NX_IP_PACKET)</span></span> | <span data-ttu-id="c7e83-354">0x38</span><span class="sxs-lookup"><span data-stu-id="c7e83-354">0x38</span></span> |
|<span data-ttu-id="c7e83-355">NX_UDPv6_PACKET(NX_UDP_PACKET)</span><span class="sxs-lookup"><span data-stu-id="c7e83-355">NX_UDPv6_PACKET (NX_UDP_PACKET)</span></span> |<span data-ttu-id="c7e83-356">0x40</span><span class="sxs-lookup"><span data-stu-id="c7e83-356">0x40</span></span> |
|<span data-ttu-id="c7e83-357">NX_TCPv6_PACKET(NX_TCP_PACKET)</span><span class="sxs-lookup"><span data-stu-id="c7e83-357">NX_TCPv6_PACKET (NX_TCP_PACKET)</span></span> |<span data-ttu-id="c7e83-358">0x4c</span><span class="sxs-lookup"><span data-stu-id="c7e83-358">0x4c</span></span> |
|<span data-ttu-id="c7e83-359">NX_IPv4_PACKET</span><span class="sxs-lookup"><span data-stu-id="c7e83-359">NX_IPv4_PACKET</span></span> |<span data-ttu-id="c7e83-360">0x24</span><span class="sxs-lookup"><span data-stu-id="c7e83-360">0x24</span></span> |
|<span data-ttu-id="c7e83-361">NX_IPv4_UDP_PACKET</span><span class="sxs-lookup"><span data-stu-id="c7e83-361">NX_IPv4_UDP_PACKET</span></span> |<span data-ttu-id="c7e83-362">0x2c</span><span class="sxs-lookup"><span data-stu-id="c7e83-362">0x2c</span></span> |
|<span data-ttu-id="c7e83-363">NX_IPv4_TCP_PACKET</span><span class="sxs-lookup"><span data-stu-id="c7e83-363">NX_IPv4_TCP_PACKET</span></span> |<span data-ttu-id="c7e83-364">0x38</span><span class="sxs-lookup"><span data-stu-id="c7e83-364">0x38</span></span> |

<span data-ttu-id="c7e83-365">다음 표에서는 IPv6를 사용하지 않도록 설정하여 정의된 기호를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-365">The following table shows symbols defined with IPv6 disabled:</span></span>

|<span data-ttu-id="c7e83-366">**패킷 형식**</span><span class="sxs-lookup"><span data-stu-id="c7e83-366">**Packet Type**</span></span> |<span data-ttu-id="c7e83-367">**값**</span><span class="sxs-lookup"><span data-stu-id="c7e83-367">**Value**</span></span> |
|---|---|
|<span data-ttu-id="c7e83-368">NX_IPv4_PACKET(NX_IP_PACKET)</span><span class="sxs-lookup"><span data-stu-id="c7e83-368">NX_IPv4_PACKET (NX_IP_PACKET)</span></span> |<span data-ttu-id="c7e83-369">0x24</span><span class="sxs-lookup"><span data-stu-id="c7e83-369">0x24</span></span> |
|<span data-ttu-id="c7e83-370">NX_IPv4_UDP_PACKET(NX_UDP_PACKET)</span><span class="sxs-lookup"><span data-stu-id="c7e83-370">NX_IPv4_UDP_PACKET (NX_UDP_PACKET)</span></span> |<span data-ttu-id="c7e83-371">0x2c</span><span class="sxs-lookup"><span data-stu-id="c7e83-371">0x2c</span></span> |
|<span data-ttu-id="c7e83-372">NX_IPv4_TCP_PACKET(NX_TCP_PACKET)</span><span class="sxs-lookup"><span data-stu-id="c7e83-372">NX_IPv4_TCP_PACKET (NX_TCP_PACKET)</span></span> |<span data-ttu-id="c7e83-373">0x38</span><span class="sxs-lookup"><span data-stu-id="c7e83-373">0x38</span></span> |

<span data-ttu-id="c7e83-374">*NX_IPSEC_ENABLE* 이 정의된 경우 이러한 값은 변경됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-374">Note that these values will change if *NX_IPSEC_ENABLE* is defined.</span></span> <span data-ttu-id="c7e83-375">IPsec을 사용하는 애플리케이션에 대한 자세한 정보는 NetX Duo IPsec 사용자 가이드를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="c7e83-375">For application using IPsec, refer to NetX Duo IPsec User Guide for more information.</span></span>

### <a name="pool-capacity"></a><span data-ttu-id="c7e83-376">풀 용량</span><span class="sxs-lookup"><span data-stu-id="c7e83-376">Pool Capacity</span></span>

<span data-ttu-id="c7e83-377">패킷 풀의 패킷 수는 페이로드 크기와 패킷 풀 만들기 서비스에 제공된 메모리 영역의 총 바이트 수의 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-377">The number of packets in a packet pool is a function of the payload size and the total number of bytes in the memory area supplied to the packet pool create service.</span></span> <span data-ttu-id="c7e83-378">풀의 용량은 패킷 크기(NX_PACKET 헤더의 크기, 페이로드 크기, 올바른 맞춤 포함)를 제공된 메모리 영역의 총 바이트 수로 나누어 계산합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-378">The capacity of the pool is calculated by dividing the packet size (including the size of the NX_PACKET header, the payload size, and proper alignment) into the total number of bytes in the supplied memory area.</span></span>

### <a name="payload-area-alignment"></a><span data-ttu-id="c7e83-379">페이로드 영역 맞춤</span><span class="sxs-lookup"><span data-stu-id="c7e83-379">Payload Area Alignment</span></span>

<span data-ttu-id="c7e83-380">NetX Duo의 패킷 풀 디자인은 무복사를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-380">Packet pool design in NetX Duo supports zero-copy.</span></span> <span data-ttu-id="c7e83-381">디바이스 드라이버 수준에서 드라이버는 데이터 수신에 대해 페이로드 영역을 버퍼 설명자에 직접 할당할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-381">At the device driver level, the driver is able to assign the payload area directly into buffer descriptors for data reception.</span></span> <span data-ttu-id="c7e83-382">경우에 따라 DMA 엔진 또는 캐시 동기화 메커니즘은 특정한 맞춤 요구 사항을 충족하기 위해 페이로드 영역의 시작 주소가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-382">Sometimes the DMA engine or the cache synchronization mechanism requires the starting address of the payload area to have a certain alignment requirement.</span></span> <span data-ttu-id="c7e83-383">이는 ***NX_PACKET_ALIGNMENT*** 에서 원하는 맞춤 요구 사항(바이트)을 정의하여 달성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-383">This can be achieved by defining the desired alignment requirement (in bytes) in ***NX_PACKET_ALIGNMENT***.</span></span> <span data-ttu-id="c7e83-384">패킷 풀을 만들 때 페이로드 영역의 시작 주소가 이 값에 맞춰집니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-384">When creating a packet pool, the starting address of the payload area will aligned to this value.</span></span> <span data-ttu-id="c7e83-385">기본적으로 시작 주소는 4바이트 맞춤입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-385">By default, starting address is 4-byte aligned.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="c7e83-386">스레드 일시 중단</span><span class="sxs-lookup"><span data-stu-id="c7e83-386">Thread Suspension</span></span>

<span data-ttu-id="c7e83-387">빈 풀에서 패킷을 기다리는 동안 애플리케이션 스레드가 일시 중단될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-387">Application threads can suspend while waiting for a packet from an empty pool.</span></span> <span data-ttu-id="c7e83-388">패킷이 풀로 반환되면 일시 중단된 스레드에 이 패킷이 제공되고 다시 시작됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-388">When a packet is returned to the pool, the suspended thread is given this packet and resumed.</span></span>

<span data-ttu-id="c7e83-389">여러 스레드가 동일한 패킷 풀에서 일시 중단되면 일시 중단된 순서대로(FIFO) 다시 시작됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-389">If multiple threads are suspended on the same packet pool, they  resumed in the order they were suspended (FIFO).</span></span>

### <a name="pool-statistics-and-errors"></a><span data-ttu-id="c7e83-390">풀 통계 및 오류</span><span class="sxs-lookup"><span data-stu-id="c7e83-390">Pool Statistics and Errors</span></span>

<span data-ttu-id="c7e83-391">사용하도록 설정된 경우 NetX Duo 패킷 관리 소프트웨어는 애플리케이션에 유용할 수 있는 몇 가지 통계 및 오류를 추적합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-391">If enabled, the NetX Duo packet management software keeps track of several statistics and errors that may be useful to the application.</span></span> <span data-ttu-id="c7e83-392">패킷 풀에 대해 다음 통계 및 오류 보고서가 유지 관리됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-392">The following statistics and error reports are maintained for packet pools:</span></span>

- <span data-ttu-id="c7e83-393">풀의 총 패킷</span><span class="sxs-lookup"><span data-stu-id="c7e83-393">Total Packets in Pool</span></span>
- <span data-ttu-id="c7e83-394">풀의 사용 가능한 패킷</span><span class="sxs-lookup"><span data-stu-id="c7e83-394">Free Packets in Pool</span></span>
- <span data-ttu-id="c7e83-395">총 패킷 할당</span><span class="sxs-lookup"><span data-stu-id="c7e83-395">Total Packet Allocations</span></span>
- <span data-ttu-id="c7e83-396">풀 빈 할당 요청</span><span class="sxs-lookup"><span data-stu-id="c7e83-396">Pool Empty Allocation Requests</span></span>
- <span data-ttu-id="c7e83-397">풀 빈 할당 일시 중단</span><span class="sxs-lookup"><span data-stu-id="c7e83-397">Pool Empty Allocation Suspensions</span></span>
- <span data-ttu-id="c7e83-398">잘못된 패킷 릴리스</span><span class="sxs-lookup"><span data-stu-id="c7e83-398">Invalid Packet Releases</span></span>

<span data-ttu-id="c7e83-399">\***NX_DISABLE_PACKET_INFO** _가 정의되어 있지 않은 경우 풀의 총 패킷 수와 사용 가능한 패킷 수를 제외한 모든 통계 및 오류 보고서는 NetX Duo 라이브러리에 내장되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-399">All of these statistics and error reports, except for total and free packet count in pool, are built into NetX Duo library unless \***NX_DISABLE_PACKET_INFO** _ is defined.</span></span> <span data-ttu-id="c7e83-400">이 데이터는 애플리케이션이 _ *_nx_packet_pool_info_get_*\* 서비스를 통해 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-400">This data is available to the application with the _ *_nx_packet_pool_info_get_*\* service.</span></span>

### <a name="packet-pool-control-block-nx_packet_pool"></a><span data-ttu-id="c7e83-401">패킷 풀 제어 블록 NX_PACKET_POOL</span><span class="sxs-lookup"><span data-stu-id="c7e83-401">Packet Pool Control Block NX_PACKET_POOL</span></span>

<span data-ttu-id="c7e83-402">각 패킷 메모리 풀의 특성은 해당 제어 블록에서 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-402">The characteristics of each packet memory pool are found in its control block.</span></span> <span data-ttu-id="c7e83-403">이 풀에는 사용 가능한 패킷의 연결된 목록, 사용 가능한 패킷 수, 이 풀의 패킷에 대한 페이로드 크기와 같은 유용한 정보가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-403">It contains useful information such as the linked list of free packets, the number of free packets, and the payload size for packets in this pool.</span></span> <span data-ttu-id="c7e83-404">이 구조는 nx_api.h 파일에서 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-404">This structure is defined in the ***nx_api.h*** file.</span></span>

<span data-ttu-id="c7e83-405">패킷 풀 제어 블록은 메모리 내 어디에나 위치할 수 있지만, 제어 블록을 모든 함수의 범위 밖에 정의하여 전역 구조로 만드는 것이 가장 일반적입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-405">Packet pool control blocks can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

## <a name="ipv4-protocol"></a><span data-ttu-id="c7e83-406">IPv4 프로토콜</span><span class="sxs-lookup"><span data-stu-id="c7e83-406">IPv4 Protocol</span></span>

<span data-ttu-id="c7e83-407">NetX Duo의 IP(인터넷 프로토콜) 구성 요소는 인터넷에서 IPv4 패킷을 주고받는 역할을 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-407">The Internet Protocol (IP) component of NetX Duo is responsible for sending and receiving IPv4 packets on the Internet.</span></span> <span data-ttu-id="c7e83-408">NetX Duo에서 기본 네트워크 드라이버를 활용하여 TCP, UDP, ICMP, IGMP 메시지를 최종적으로 주고받는 구성 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-408">In NetX Duo, it is the component ultimately responsible for sending and receiving TCP, UDP, ICMP, and IGMP messages, utilizing the underlying network driver.</span></span>

<span data-ttu-id="c7e83-409">NetX Duo는 IPv4 프로토콜(RFC 791) 및 IPv6 프로토콜(RFC 2460)을 모두 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-409">NetX Duo supports both IPv4 protocol (RFC 791) and IPv6 protocol (RFC 2460).</span></span> <span data-ttu-id="c7e83-410">이 섹션에서는 IPv4에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-410">This section discusses IPv4.</span></span> <span data-ttu-id="c7e83-411">IPv6는 다음 섹션에서 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-411">IPv6 is discussed in the next section.</span></span>

### <a name="ipv4-addresses"></a><span data-ttu-id="c7e83-412">IPv4 주소</span><span class="sxs-lookup"><span data-stu-id="c7e83-412">IPv4 Addresses</span></span>

<span data-ttu-id="c7e83-413">인터넷의 각 호스트에는 IP 주소라는 고유한 32비트 식별자가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-413">Each host on the Internet has a unique 32-bit identifier called an IP address.</span></span> <span data-ttu-id="c7e83-414">그림 4에 설명된 대로 IPv4 주소에는 5개의 클래스가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-414">There are five classes of IPv4 addresses as described in Figure 4.</span></span> <span data-ttu-id="c7e83-415">5개의 IPv4 주소 클래스의 범위는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-415">The ranges of the five IPv4 address classes are as follows:</span></span>

|<span data-ttu-id="c7e83-416">클래스</span><span class="sxs-lookup"><span data-stu-id="c7e83-416">Class</span></span>|<span data-ttu-id="c7e83-417">범위</span><span class="sxs-lookup"><span data-stu-id="c7e83-417">Range</span></span>|
|---|---|
|<span data-ttu-id="c7e83-418">A</span><span class="sxs-lookup"><span data-stu-id="c7e83-418">A</span></span> |<span data-ttu-id="c7e83-419">0.0.0.0~127.255.255.255</span><span class="sxs-lookup"><span data-stu-id="c7e83-419">0.0.0.0 to 127.255.255.255</span></span>|
|<span data-ttu-id="c7e83-420">b</span><span class="sxs-lookup"><span data-stu-id="c7e83-420">B</span></span> |<span data-ttu-id="c7e83-421">128.0.0.0~191.255.255.255</span><span class="sxs-lookup"><span data-stu-id="c7e83-421">128.0.0.0 to 191.255.255.255</span></span>|
|<span data-ttu-id="c7e83-422">C</span><span class="sxs-lookup"><span data-stu-id="c7e83-422">C</span></span> |<span data-ttu-id="c7e83-423">192.0.0.0~223.255.255.255</span><span class="sxs-lookup"><span data-stu-id="c7e83-423">192.0.0.0 to 223.255.255.255</span></span>|
|<span data-ttu-id="c7e83-424">D</span><span class="sxs-lookup"><span data-stu-id="c7e83-424">D</span></span> |<span data-ttu-id="c7e83-425">224.0.0.0~239.255.255.255</span><span class="sxs-lookup"><span data-stu-id="c7e83-425">224.0.0.0 to 239.255.255.255</span></span>|
|<span data-ttu-id="c7e83-426">E</span><span class="sxs-lookup"><span data-stu-id="c7e83-426">E</span></span> |<span data-ttu-id="c7e83-427">240.0.0.0~247.255.255.255</span><span class="sxs-lookup"><span data-stu-id="c7e83-427">240.0.0.0 to 247.255.255.255</span></span>|

![IPv4 주소 구조의 다이어그램입니다.](./media/user-guide/ipv4-address-structure.png)

### <a name="figure-4-ipv4-address-structure"></a><span data-ttu-id="c7e83-429">그림 4.</span><span class="sxs-lookup"><span data-stu-id="c7e83-429">FIGURE 4.</span></span> <span data-ttu-id="c7e83-430">IPv4 주소 구조</span><span class="sxs-lookup"><span data-stu-id="c7e83-430">IPv4 Address Structure</span></span>

<span data-ttu-id="c7e83-431">또한 주소 사양에는 ‘유니캐스트’, ‘브로드캐스트’, ‘멀티캐스트’의 세 가지 형식이 있습니다.  </span><span class="sxs-lookup"><span data-stu-id="c7e83-431">There are also three types of address specifications: *unicast*, *broadcast*, and *multicast*.</span></span> <span data-ttu-id="c7e83-432">유니캐스트 주소는 인터넷에서 특정 호스트를 식별하는 IPv4 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-432">Unicast addresses are those IPv4 addresses that identify a specific host on the Internet.</span></span> <span data-ttu-id="c7e83-433">유니캐스트 주소는 소스 또는 대상 IPv4 주소일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-433">Unicast addresses can be either a source or a destination IPv4 address.</span></span> <span data-ttu-id="c7e83-434">브로드캐스트 주소는 특정 네트워크 또는 하위 네트워크의 모든 호스트를 식별하고 대상 주소로만 사용될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-434">A broadcast address identifies all hosts on a specific network or sub-network and can only be used as destination addresses.</span></span> <span data-ttu-id="c7e83-435">브로드캐스트 주소는 주소의 호스트 ID 부분을 하나로 설정하여 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-435">Broadcast addresses are specified by having the host ID portion of the address set to ones.</span></span> <span data-ttu-id="c7e83-436">멀티캐스트 주소(클래스 D)는 인터넷에서 동적 호스트 그룹을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-436">Multicast addresses (Class D) specify a dynamic group of hosts on the Internet.</span></span> <span data-ttu-id="c7e83-437">멀티캐스트 그룹의 멤버는 언제든지 가입하고 탈퇴할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-437">Members of the multicast group may join and leave whenever they wish.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="c7e83-438">IPv4를 통한 UDP와 같은 연결 없는 프로토콜만이 브로드캐스트와 멀티캐스트 그룹의 제한된 브로드캐스트 기능을 이용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-438">*Only connectionless protocols like UDP over IPv4 can utilize broadcast and the limited broadcast capability of the multicast group.*</span></span>

> [!IMPORTANT]
> <span data-ttu-id="c7e83-439">\*매크로 *IP_ADDRESS* 는 \***nx_api.h** _에 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-439">\*The macro *IP_ADDRESS* is defined in \***nx_api.h** _.</span></span> <span data-ttu-id="c7e83-440">마침표 대신 쉼표를 사용하여 IPv4 주소를 쉽게 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-440">It allows easy specification of IPv4 addresses using commas instead of a periods.</span></span> <span data-ttu-id="c7e83-441">예를 들어 _IP_ADDRESS(128,0,0,0)*는 그림 4에 표시된 첫 번째 클래스 B 주소를 지정합니다.*</span><span class="sxs-lookup"><span data-stu-id="c7e83-441">For example, _IP_ADDRESS(128,0,0,0)\* specifies the first class B address shown in Figure 4.\*</span></span>

### <a name="ipv4-gateway-address"></a><span data-ttu-id="c7e83-442">IPv4 게이트웨이 주소</span><span class="sxs-lookup"><span data-stu-id="c7e83-442">IPv4 Gateway Address</span></span>

<span data-ttu-id="c7e83-443">네트워크 게이트웨이는 네트워크의 호스트가 로컬 도메인 외부의 대상으로 향하는 패킷을 릴레이하도록 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-443">Network gateways assist hosts on their networks to relay packets destined to destinations outside the local domain.</span></span> <span data-ttu-id="c7e83-444">각 노드는 인접 노드 중 하나 또는 미리 프로그래밍이 된 고정 라우팅 테이블을 통해 다음 홉을 전송할 대상에 대한 약간의 정보를 가지고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-444">Each node has some knowledge of which next hop to send to, either the destination one of its neighbors, or through a pre-programmed static routing table.</span></span> <span data-ttu-id="c7e83-445">그러나 이러한 접근 방식이 실패할 경우 노드는 패킷을 대상으로 라우팅하는 방법에 대한 더 나은 정보를 가진 기본 게이트웨이로 패킷을 전달해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-445">However if these approaches fail, the node should forward the packet to its default gateway which has better knowledge on how to route the packet to its destination.</span></span> <span data-ttu-id="c7e83-446">기본 게이트웨이는 IP 인스턴스에 연결된 실제 인터페이스 중 하나를 통해 직접 액세스할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-446">Note that the default gateway must be directly accessible through one of the physical interfaces attached to the IP instance.</span></span> <span data-ttu-id="c7e83-447">애플리케이션은 IPv4 기본 게이트웨이 주소를 구성하기 위해 \***nx_ip_gateway_address_set** _을 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-447">The application calls \***nx_ip_gateway_address_set** _ to configure IPv4 default gateway address.</span></span> <span data-ttu-id="c7e83-448">_*_nx_ip_gateway_address_get_*_ 서비스를 사용하여 현재 IPv4 게이트웨이 설정을 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-448">Use the service _*_nx_ip_gateway_address_get_*_ to retrieve the current IPv4 gateway settings.</span></span> <span data-ttu-id="c7e83-449">애플리케이션은 _ *_nx_ip_gateway_address_clear_*\* 서비스를 사용하여 게이트웨이 설정을 지워야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-449">Application shall use the service _ *_nx_ip_gateway_address_clear_*\* to clear the gateway setting.</span></span>

### <a name="ipv4-header"></a><span data-ttu-id="c7e83-450">IPv4 헤더</span><span class="sxs-lookup"><span data-stu-id="c7e83-450">IPv4 Header</span></span>

<span data-ttu-id="c7e83-451">인터넷에서 IPv4 패킷을 전송하려면 IPv4 헤더가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-451">For any IPv4 packet to be sent on the Internet, it must have an IPv4 header.</span></span> <span data-ttu-id="c7e83-452">상위 수준의 프로토콜(UDP, TCP, ICMP, IGMP)이 패킷을 전송하기 위해 IP 구성 요소를 호출할 때 IPv4 전송 모듈은 데이터 앞에 IPv4 헤더를 배치합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-452">When higher-level protocols (UDP, TCP, ICMP, or IGMP) call the IP component to send a packet, the IPv4 transmit module places an IPv4 header in front of the data.</span></span> <span data-ttu-id="c7e83-453">반대로, IP 패킷이 네트워크에서 수신되면, IP 구성 요소는 상위 수준의 프로토콜로 전송되기 전에 패킷에서 IPv4 헤더를 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-453">Conversely, when IP packets are received from the network, the IP component removes the IPv4 header from the packet before delivery to the higher-level protocols.</span></span> <span data-ttu-id="c7e83-454">그림 5는 IP 헤더의 형식을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-454">Figure 5 shows the format of the IP header.</span></span>

![IPv4 헤더 형식](./media/user-guide/ipv4-header-format.png)

### <a name="figure-5-ipv4-header-format"></a><span data-ttu-id="c7e83-456">그림 5.</span><span class="sxs-lookup"><span data-stu-id="c7e83-456">FIGURE 5.</span></span> <span data-ttu-id="c7e83-457">IPv4 헤더 형식</span><span class="sxs-lookup"><span data-stu-id="c7e83-457">IPv4 Header Format</span></span>

> [!IMPORTANT]
> <span data-ttu-id="c7e83-458">TCP/IP 구현의 모든 헤더는 **big endian** 형식이어야 합니다. 이 형식에서 단어의 가장 중요한 바이트는 가장 낮은 바이트 주소에 있습니다. 예를 들어 IP 헤더의 4비트 버전과 4비트 헤더 길이는 헤더의 첫 번째 바이트에 위치해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-458">*All headers in the TCP/IP implementation are expected to be in **big endian** format. In this format, the most significant byte of the word resides at the lowest byte address. For example, the 4-bit version and the 4-bit header length of the IP header must be located on the first byte of the header.*</span></span>

<span data-ttu-id="c7e83-459">IPv4 헤더의 필드는 다음과 같이 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-459">The fields of the IPv4 header are defined as follows:</span></span>

|<span data-ttu-id="c7e83-460">IPv4&nbsp;헤더&nbsp;필드</span><span class="sxs-lookup"><span data-stu-id="c7e83-460">IPv4&nbsp;Header&nbsp;Field</span></span> |<span data-ttu-id="c7e83-461">목적</span><span class="sxs-lookup"><span data-stu-id="c7e83-461">Purpose</span></span> |
|---|---|
|<span data-ttu-id="c7e83-462">***4비트 버전***</span><span class="sxs-lookup"><span data-stu-id="c7e83-462">***4-bit version***</span></span> |<span data-ttu-id="c7e83-463">이 필드에는 이 헤더가 나타내는 IP 버전이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-463">This field contains the version of IP this header represents.</span></span> <span data-ttu-id="c7e83-464">NetX Duo에서 지원하는 IP 버전 4의 경우 이 필드의 값은 4입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-464">For IP version 4, which is what NetX Duo supports, the value of this field is 4.</span></span> |
|<span data-ttu-id="c7e83-465">***4비트 헤더 길이***</span><span class="sxs-lookup"><span data-stu-id="c7e83-465">***4-bit header length***</span></span> |<span data-ttu-id="c7e83-466">이 필드는 IP 헤더에 있는 32비트 단어 수를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-466">This field specifies the number of 32-bit words in the IP header.</span></span> <span data-ttu-id="c7e83-467">옵션 단어가 없을 경우 이 필드의 값은 5입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-467">If no option words are present, the value for this field is 5.</span></span> |
|<span data-ttu-id="c7e83-468">***8비트 TOS(서비스 형식)***</span><span class="sxs-lookup"><span data-stu-id="c7e83-468">***8-bit type of service (TOS)***</span></span> |<span data-ttu-id="c7e83-469">이 필드는 이 IP 패킷에 대해 요청된 서비스 형식을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-469">This field specifies the type of service requested for this IP packet.</span></span> <span data-ttu-id="c7e83-470">유효한 요청은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-470">Valid requests are as follows:</span></span><br /><span data-ttu-id="c7e83-471">- 보통: 0x00</span><span class="sxs-lookup"><span data-stu-id="c7e83-471">- Normal: 0x00</span></span> <br /><span data-ttu-id="c7e83-472">- 최소 지연: 0x00</span><span class="sxs-lookup"><span data-stu-id="c7e83-472">- Minimum Delay: 0x00</span></span><br /><span data-ttu-id="c7e83-473">- 최대 데이터: 0x08</span><span class="sxs-lookup"><span data-stu-id="c7e83-473">- Maximum Data: 0x08</span></span><br /><span data-ttu-id="c7e83-474">- 최대 안정성: 0x04</span><span class="sxs-lookup"><span data-stu-id="c7e83-474">- Maximum Reliability: 0x04</span></span><br /><span data-ttu-id="c7e83-475">- 최소 비용: 0x02</span><span class="sxs-lookup"><span data-stu-id="c7e83-475">- Minimum Cost: 0x02</span></span> |
|<span data-ttu-id="c7e83-476">***16비트 총 길이***</span><span class="sxs-lookup"><span data-stu-id="c7e83-476">***16-bit total length***</span></span> |<span data-ttu-id="c7e83-477">이 필드는 IP 헤더를 포함하여 IP 데이터그램의 총 길이(바이트)를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-477">This field contains the total length of the IP datagram in bytes, including the IP header.</span></span> <span data-ttu-id="c7e83-478">IP 데이터그램은 TCP/IP 인터넷에 있는 기본 정보 단위입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-478">An IP datagram is the basic unit of information found on a TCP/IP Internet.</span></span> <span data-ttu-id="c7e83-479">데이터 외에도 대상 및 소스 주소가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-479">It contains a destination and source address in addition to data.</span></span> <span data-ttu-id="c7e83-480">16비트 필드이기 때문에 IP 데이터그램의 최대 크기는 65,535바이트입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-480">Because it is a 16-bit field, the maximum size of an IP datagram is 65,535 bytes.</span></span>|
|<span data-ttu-id="c7e83-481">***16비트 식별***</span><span class="sxs-lookup"><span data-stu-id="c7e83-481">***16-bit identification***</span></span> |<span data-ttu-id="c7e83-482">필드는 호스트에서 전송된 각 IP 데이터그램을 고유하게 식별하는 데 사용되는 숫자입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-482">The field is a number used to uniquely identify each IP datagram sent from a host.</span></span> <span data-ttu-id="c7e83-483">이 숫자는 일반적으로 IP 데이터그램이 전송된 후에 증가합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-483">This number is typically incremented after an IP datagram is sent.</span></span> <span data-ttu-id="c7e83-484">특히 수신된 IP 패킷 조각을 어셈블하는 데 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-484">It is especially useful in assembling received IP packet fragments.</span></span>|
|<span data-ttu-id="c7e83-485">***3비트 플래그***</span><span class="sxs-lookup"><span data-stu-id="c7e83-485">***3-bit flags***</span></span> |<span data-ttu-id="c7e83-486">이 필드는 IP 조각화 정보를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-486">This field contains IP fragmentation information.</span></span> <span data-ttu-id="c7e83-487">비트 14는 “Don’t Fragment” 비트입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-487">Bit 14 is the "don't fragment" bit.</span></span> <span data-ttu-id="c7e83-488">이 비트가 설정되면 나가는 IP 데이터그램이 조각나지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-488">If this bit is set, the outgoing IP datagram will not be fragmented.</span></span> <span data-ttu-id="c7e83-489">비트 13은 “More Fragments” 비트입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-489">Bit 13 is the "more fragments" bit.</span></span> <span data-ttu-id="c7e83-490">이 비트가 설정되면 더 많은 조각이 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-490">If this bit is set, there are more fragments.</span></span> <span data-ttu-id="c7e83-491">이 비트가 0이면 이는 IP 패킷의 마지막 조각입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-491">If this bit is clear, this is the last fragment of the IP packet.</span></span>|
|<span data-ttu-id="c7e83-492">***13비트 조각 오프셋***</span><span class="sxs-lookup"><span data-stu-id="c7e83-492">***13-bit fragment offset***</span></span> |<span data-ttu-id="c7e83-493">이 필드에는 조각 오프셋의 상위 13비트가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-493">This field contains the upper 13-bits of the fragment offset.</span></span> <span data-ttu-id="c7e83-494">따라서 조각 오프셋은 8바이트 경계에서만 허용됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-494">Because of this, fragment offsets are only allowed on 8-byte boundaries.</span></span> <span data-ttu-id="c7e83-495">조각화된 IP 데이터그램의 첫 번째 조각은 “More Fragments” 비트 집합을 포함하고 오프셋은 0입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-495">The first fragment of a fragmented IP datagram will have the "more fragments" bit set and have an offset of 0.</span></span>|
|<span data-ttu-id="c7e83-496">***8비트 TTL(Time to Live)***</span><span class="sxs-lookup"><span data-stu-id="c7e83-496">***8-bit time to live (TTL)***</span></span> |<span data-ttu-id="c7e83-497">이 필드는 데이터그램이 전달할 수 있는 라우터 수를 포함하며, 기본적으로 데이터그램의 수명을 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-497">This field contains the number of routers this datagram can pass, which basically limits the lifetime of the datagram.</span></span>|
|<span data-ttu-id="c7e83-498">***8비트 프로토콜***</span><span class="sxs-lookup"><span data-stu-id="c7e83-498">***8-bit protocol***</span></span>|<span data-ttu-id="c7e83-499">이 필드는 IP 데이터그램을 사용하는 프로토콜을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-499">This field specifies which protocol is using the IP datagram.</span></span> <span data-ttu-id="c7e83-500">다음은 유효한 프로토콜과 프로토콜 값의 목록입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-500">The following is a list of valid protocols and their values:</span></span><br /><span data-ttu-id="c7e83-501">- ICMP: 0x01</span><span class="sxs-lookup"><span data-stu-id="c7e83-501">- ICMP: 0x01</span></span> <br /><span data-ttu-id="c7e83-502">- IGMP: 0x02</span><span class="sxs-lookup"><span data-stu-id="c7e83-502">- IGMP: 0x02</span></span><br /><span data-ttu-id="c7e83-503">- TCP: 0x06</span><span class="sxs-lookup"><span data-stu-id="c7e83-503">- TCP: 0X06</span></span><br /><span data-ttu-id="c7e83-504">- UDP: 0x11</span><span class="sxs-lookup"><span data-stu-id="c7e83-504">- UDP: 0X11</span></span> |
|<span data-ttu-id="c7e83-505">***16비트 체크섬***</span><span class="sxs-lookup"><span data-stu-id="c7e83-505">***16-bit checksum***</span></span> |<span data-ttu-id="c7e83-506">이 필드에는 IP 헤더만 포함하는 16비트 체크섬이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-506">This field contains the 16-bit checksum that covers the IP header only.</span></span> <span data-ttu-id="c7e83-507">IP 페이로드를 포함하는 상위 수준 프로토콜에는 추가 체크섬이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-507">There are additional checksums in the higher level protocols that cover the IP payload.</span></span> |
|<span data-ttu-id="c7e83-508">***32비트 소스 IP 주소***</span><span class="sxs-lookup"><span data-stu-id="c7e83-508">***32-bit source IP address***</span></span> |<span data-ttu-id="c7e83-509">이 필드는 항상 호스트 주소이고 보낸 사람의 IP 주소를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-509">This field contains the IP address of the sender and is always a host address.</span></span> |
|<span data-ttu-id="c7e83-510">***32비트 대상 IP 주소***</span><span class="sxs-lookup"><span data-stu-id="c7e83-510">***32-bit destination IP address***</span></span> |<span data-ttu-id="c7e83-511">이 필드는 주소가 브로드캐스트 또는 멀티캐스트 주소인 경우 받는 사람 또는 받는 사람의 IP 주소를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-511">This field contains the IP address of the receiver or receivers if the address is a broadcast or multicast address.</span></span> |

### <a name="creating-ip-instances"></a><span data-ttu-id="c7e83-512">IP 인스턴스 만들기</span><span class="sxs-lookup"><span data-stu-id="c7e83-512">Creating IP Instances</span></span>

<span data-ttu-id="c7e83-513">IP 인스턴스는 초기화 중에 또는 애플리케이션 스레드에서 런타임 중에 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-513">IP instances are created either during initialization or during runtime by application threads.</span></span> <span data-ttu-id="c7e83-514">애플리케이션이 IPv6 네트워크만 사용하려는 경우에도, 내부 IP 스레드의 초기 IPv4 주소, 네트워크 마스크, 기본 패킷 풀, 미디어 드라이버, 메모리 및 우선 순위는 ***nx_ip_create*** 서비스에 의해 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-514">The initial IPv4 address, network mask, default packet pool, media driver, and memory and priority of the internal IP thread are defined by the ***nx_ip_create*** service even if the application intends to use IPv6 networks only.</span></span> <span data-ttu-id="c7e83-515">애플리케이션에서 IPv4 주소를 잘못된 주소(0.0.0.0)로 설정한 IP 인스턴스를 초기화하는 경우 인터페이스 주소는 나중에 RARP를 통한 수동 구성이나 DHCP 또는 유사한 프로토콜을 통해 해결하는 것으로 간주합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-515">If the application initializes the IP instance with its IPv4 address set to an invalid address(0.0.0.0), it is assumed that the interface address is going to resolved by manual configuration later, via RARP, or through DHCP or similar protocols.</span></span>

<span data-ttu-id="c7e83-516">여러 네트워크 인터페이스가 있는 시스템의 경우 기본 인터페이스는 \***nx_ip_create** _를 호출할 때 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-516">For systems with multiple network interfaces, the primary interface is designated when calling \***nx_ip_create** _.</span></span> <span data-ttu-id="c7e83-517">각 추가 인터페이스는 _\*_nx_ip_interface_attach_\*\*를 호출하여 동일한 IP 인스턴스에 연결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-517">Each additional interface can be attached to the same IP instance by calling _\*_nx_ip_interface_attach_\*\*.</span></span> <span data-ttu-id="c7e83-518">이 서비스는 네트워크 인터페이스(예: IP 주소, 네트워크 마스크)에 대한 정보를 인터페이스 제어 블록에 저장하고 드라이버 인스턴스를 IP 인스턴스의 인터페이스 제어 블록과 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-518">This service stores information about the network interface (such as IP address, network mask) in the interface control block, and associates the driver instance with the interface control block in the IP instance.</span></span> <span data-ttu-id="c7e83-519">드라이버는 데이터 패킷을 수신할 때 인터페이스 정보를 IP 수신 논리로 전달하기 전에 NX_PACKET 구조에 저장해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-519">As the driver receives a data packet, it needs to store the interface information in the NX_PACKET structure before forwarding it to the IP receive logic.</span></span> <span data-ttu-id="c7e83-520">인터페이스를 연결하기 전에 IP 인스턴스를 이미 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-520">Note an IP instance must already be created before attaching any interfaces.</span></span>

<span data-ttu-id="c7e83-521">\***nx_ip_create** _를 호출한 후에는 IPv6 서비스가 시작되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-521">IPv6 services are not started after calling \***nx_ip_create** _.</span></span> <span data-ttu-id="c7e83-522">IPv6 서비스를 사용하려는 애플리케이션은 _ *_nx_ipv6_enable_*\* 서비스를 호출하여 IPv6를 시작해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-522">Applications wishing to use IPv6 services must call the service _ *_nx_ipv6_enable_*\* to start IPv6.</span></span>

<span data-ttu-id="c7e83-523">IPv6 네트워크에서는 IP 인스턴스의 각 인터페이스에 여러 IPv6 글로벌 주소가 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-523">On the IPv6 network, each interface in an IP instance may have multiple IPv6 global addresses.</span></span> <span data-ttu-id="c7e83-524">디바이스는 IPv6 주소 할당에 DHCPv6를 사용하는 것 외에도 상태 비저장 주소 자동 구성을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-524">In addition to using DHCPv6 for IPv6 address assignment, a device may also use Stateless Address Autoconfiguration.</span></span> <span data-ttu-id="c7e83-525">자세한 내용은 이 장의 뒷부분에 나오는 “IP 제어 블록” 및 “IPv6 주소 확인” 섹션에서 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-525">More information is available in the "IP Control Block" and "IPv6 Address Resolution" sections later in this chapter.</span></span>

### <a name="ip-send"></a><span data-ttu-id="c7e83-526">IP 전송</span><span class="sxs-lookup"><span data-stu-id="c7e83-526">IP Send</span></span>

<span data-ttu-id="c7e83-527">NetX Duo의 IP 전송 처리는 매우 간소화되었습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-527">The IP send processing in NetX Duo is very streamlined.</span></span> <span data-ttu-id="c7e83-528">패킷의 앞에 추가 포인터는 IP 헤더에 맞게 뒤로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-528">The prepend pointer in the packet is moved backwards to accommodate the IP header.</span></span> <span data-ttu-id="c7e83-529">IP 헤더가 완료되고(호출 프로토콜 계층에서 지정한 모든 옵션 포함), IP 체크섬이 인라인으로 계산되며(IPv4 패킷 전용), 패킷이 연결된 네트워크 드라이버로 디스패치됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-529">The IP header is completed (with all the options specified by the calling protocol layer), the IP checksum is computed in-line (for IPv4 packets only), and the packet is dispatched to the associated network driver.</span></span> <span data-ttu-id="c7e83-530">또한 나가는 조각화도 IP 전송 처리 내에서 조정됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-530">In addition, outgoing fragmentation is also coordinated from within the IP send processing.</span></span>

<span data-ttu-id="c7e83-531">IPv4의 경우 NetX Duo는 대상 IP 주소에 대한 실제 매핑이 필요한 경우 ARP 요청을 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-531">For IPv4, NetX Duo initiates ARP requests if physical mapping is needed for the destination IP address.</span></span> <span data-ttu-id="c7e83-532">IPv6는 IPv6-address-to-physical-address 매핑에 대한 인접 노드 검색을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-532">IPv6 uses Neighbor Discovery for IPv6-address-tophysical-address mapping.</span></span>

> [!NOTE]
> <span data-ttu-id="c7e83-533">IPv4 연결의 경우 큐에 있는 패킷 수가 ARP 큐 깊이(**NX_ARP_MAX_QUEUE_DEPTH** 기호에서 정의됨)를 초과할 때까지 IP 주소 확인(실제 매핑)이 필요한 패킷을 ARP 큐에 넣습니다. 큐 깊이에 도달하면 NetX Duo가 큐에서 가장 오래된 패킷을 제거하고 큐에 넣은 나머지 패킷의 주소 확인을 계속 기다립니다. 반면 ARP 항목이 확인되지 않으면 ARP 항목에서 보류 중인 패킷은 ARP 항목 시간 초과 시 해제됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-533">*For IPv4 connectivity, packets that require IP address resolution (i.e., physical mapping) are enqueued on the ARP queue until the number of packets queued exceeds the ARP queue depth (defined by the symbol **NX_ARP_MAX_QUEUE_DEPTH**). If the queue depth is reached, NetX Duo will remove the oldest packet on the queue and continue waiting for address resolution for the remaining packets enqueued. On the other hand, if an ARP entry is not resolved, the pending packets on the ARP entry are released upon ARP entry timeout.*</span></span>

<span data-ttu-id="c7e83-534">여러 네트워크 인터페이스를 포함하는 시스템의 경우 NetX Duo는 대상 IP 주소를 기반으로 인터페이스를 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-534">For systems with multiple network interfaces, NetX Duo chooses an interface based on the destination IP address.</span></span> <span data-ttu-id="c7e83-535">선택 프로세스에 적용되는 프로시저는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-535">The following procedure applies to the selection process:</span></span>

1. <span data-ttu-id="c7e83-536">보낸 사람이 나가는 인터페이스를 지정하고 인터페이스가 유효한 경우 해당 인터페이스를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-536">If the sender specifies an outgoing interface and the interface is valid, use that interface.</span></span>
2. <span data-ttu-id="c7e83-537">대상 주소가 IPv4 브로드캐스트 또는 멀티캐스트인 경우 첫 번째 사용 가능한 실제 인터페이스가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-537">If a destination address is IPv4 broadcast or multicast, the first enabled physical interface is used.</span></span>
3. <span data-ttu-id="c7e83-538">대상 주소가 고정 라우팅 테이블에 있는 경우 게이트웨이와 연결된 인터페이스가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-538">If the destination address is found in the static routing table, the interface associated with the gateway is used.</span></span>
4. <span data-ttu-id="c7e83-539">대상이 온-링크인 경우 온-링크 인터페이스가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-539">If the destination is on-link, the on-link interface is used.</span></span>
5. <span data-ttu-id="c7e83-540">대상 주소가 링크-로컬 주소(169.254.0.0/16)이면 첫 번째 유효한 인터페이스가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-540">If the destination address is a link-local address (169.254.0.0/16), the first valid interface is used.</span></span>
6. <span data-ttu-id="c7e83-541">기본 게이트웨이가 구성된 경우 기본 게이트웨이와 연결된 인터페이스를 사용하여 패킷을 전송합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-541">If the default gateway is configured, use the interface associated with the default gateway to transmit the packet.</span></span>
7. <span data-ttu-id="c7e83-542">마지막으로, 유효한 인터페이스 IP 주소 중 하나가 링크-로컬 주소(169.254.0.0/16)인 경우 이 인터페이스는 전송을 위한 소스 주소로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-542">Finally, if one of the valid interface IP address is link-local address (169.254.0.0/16), this interface is used as source address for the transmission.</span></span>
8. <span data-ttu-id="c7e83-543">위의 모든 작업이 실패하면 출력 패킷이 삭제됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-543">The output packet is dropped if all above fails.</span></span>

### <a name="ip-receive"></a><span data-ttu-id="c7e83-544">IP 수신</span><span class="sxs-lookup"><span data-stu-id="c7e83-544">IP Receive</span></span>

<span data-ttu-id="c7e83-545">IP 수신 처리는 지연된 수신 패킷 큐에서 패킷을 처리하기 위해 네트워크 드라이버 또는 내부 IP 스레드에서 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-545">The IP receive processing is either called from the network driver or the internal IP thread (for processing packets on the deferred received packet queue).</span></span> <span data-ttu-id="c7e83-546">IP 수신 처리는 프로토콜 필드를 검사하고 올바른 프로토콜 구성 요소에 대한 패킷의 디스패치를 시도합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-546">The IP receive processing examines the protocol field and attempts to dispatch the packet to the proper protocol component.</span></span> <span data-ttu-id="c7e83-547">패킷이 실제로 디스패치되기 전에 IP 헤더를 지나서 앞에 추가 포인터를 이동하면 IP 헤더가 제거됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-547">Before the packet is actually dispatched, the IP header is removed by advancing the prepend pointer past the IP header.</span></span>

<span data-ttu-id="c7e83-548">또한 IP 수신 처리는 조각난 IP 패킷을 검색하고, 조각화를 사용하는 경우 조각난 패킷 리어셈블에 필요한 단계를 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-548">IP receive processing also detects fragmented IP packets and performs the necessary steps to reassemble them if fragmentation is enabled.</span></span> <span data-ttu-id="c7e83-549">조각화가 필요하지만 사용하도록 설정되지 않은 경우 패킷이 삭제됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-549">If fragmentation is needed but not enabled, the packet is dropped.</span></span>

<span data-ttu-id="c7e83-550">NetX Duo는 패킷에 지정된 인터페이스에 따라 적절한 네트워크 인터페이스를 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-550">NetX Duo determines the appropriate network interface based on the interface specified in the packet.</span></span> <span data-ttu-id="c7e83-551">패킷 인터페이스가 NULL이면 NetX Duo는 기본 인터페이스로 기본 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-551">If the packet interface is NULL, NetX Duo defaults to the primary interface.</span></span> <span data-ttu-id="c7e83-552">이는 레거시 NetX Duo 이더넷 드라이버와의 호환성을 보장하기 위해 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-552">This is done to guarantee compatibility with legacy NetX Duo Ethernet drivers.</span></span>

### <a name="raw-ip-send"></a><span data-ttu-id="c7e83-553">원시 IP 전송</span><span class="sxs-lookup"><span data-stu-id="c7e83-553">Raw IP Send</span></span>

<span data-ttu-id="c7e83-554">원시 IP 패킷은 NetX Duo에서 직접 지원하고 처리하지 않는 상위 계층 프로토콜 페이로드를 포함하는 IP 프레임입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-554">A raw IP packet is an IP frame that contains upper layer protocol payload not directly supported (and processed) by NetX Duo.</span></span> <span data-ttu-id="c7e83-555">원시 패킷을 통해 개발자는 자신의 IP 기반 애플리케이션을 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-555">A raw packet allows developers to define their own IP-based applications.</span></span> <span data-ttu-id="c7e83-556">_*_nx_ip_raw_packet_enabled_*_ 서비스에서 원시 IP 패킷 처리를 사용하도록 설정한 경우 애플리케이션은 \***nxd_ip_raw_packet_send** _ 서비스를 사용하여 원시 IP 패킷을 직접 전송할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-556">An application may send raw IP packets directly using the ***nxd_ip_raw_packet_send** _ service if raw IP packet processing has been enabled with the _*_nx_ip_raw_packet_enabled_\*_ service.</span></span> <span data-ttu-id="c7e83-557">IPv6 네트워크에서 유니캐스트 패킷을 전송하는 경우 NetX Duo는 대상 주소를 기반으로 패킷을 전송하기 위해 사용할 최적의 소스 IPv6 주소를 자동으로 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-557">When transmitting a unicast packet on an IPv6 network, NetX Duo automatically determines the best source IPv6 address to use to send the packets out on, based on the destination address.</span></span> <span data-ttu-id="c7e83-558">그러나 대상 주소가 멀티캐스트(또는 IPv4의 경우 브로드캐스트) 주소인 경우 NetX Duo는 첫 번째 기본 인터페이스로 기본 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-558">If the destination address is a multicast (or broadcast for IPv4) address, however, NetX Duo will default to the first (primary) interface.</span></span> <span data-ttu-id="c7e83-559">따라서 보조 인터페이스에서 이러한 패킷을 전송하려면 애플리케이션이 _ *_nx_ip_raw_packet_source_send_*\* 서비스를 사용하여 나가는 패킷에 사용할 소스 주소를 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-559">Therefore, to send such packets out on secondary interfaces, the application must use the _ *_nx_ip_raw_packet_source_send_*\* service to specify the source address to use for the outgoing packet.</span></span>

### <a name="raw-ip-receive"></a><span data-ttu-id="c7e83-560">원시 IP 수신</span><span class="sxs-lookup"><span data-stu-id="c7e83-560">Raw IP Receive</span></span>

<span data-ttu-id="c7e83-561">원시 IP 패킷 처리를 사용하는 경우 애플리케이션은 \***nx_ip_raw_packet_receive** _ 서비스를 통해 원시 IP 패킷을 받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-561">If raw IP packet processing is enabled, the application may receive raw IP packets through the \***nx_ip_raw_packet_receive** _ service.</span></span> <span data-ttu-id="c7e83-562">들어오는 모든 패킷은 IP 헤더에 지정된 프로토콜에 따라 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-562">All incoming packets are processed according to the protocol specified in the IP header.</span></span> <span data-ttu-id="c7e83-563">프로토콜이 UDP, TCP, IGMP, ICMP를 지정하는 경우 NetX Duo는 패킷 프로토콜 형식에 적합한 처리기를 사용하여 패킷을 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-563">If the protocol specifies UDP, TCP, IGMP or ICMP, NetX Duo will process the packet using the appropriate handler for the packet protocol type.</span></span> <span data-ttu-id="c7e83-564">프로토콜이 이러한 프로토콜 중 하나가 아니며 원시 IP 수신을 사용하도록 설정한 경우 들어오는 패킷은 _*_nx_ip_raw_packet_receive_*\* 서비스를 통해 애플리케이션이 수신되기를 대기하는 원시 패킷 큐에 배치됩니다. 또한 애플리케이션 스레드는 원시 IP 패킷을 기다리는 동안 선택적 시간 제한으로 일시 중단될 수 있습니다. 원시 패킷 큐에서 큐에 대기할 수 있는 패킷 수는 제한되어 있습니다. 최댓값은 \***NX_IP_RAW_MAX_QUEUE_DEPTH**_ 에 정의되고 기본값은 20입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-564">If the protocol is not one of these protocols, and raw IP receive is enabled, the incoming packet will be put into the raw packet queue waiting for the application to receive it via the _*_nx_ip_raw_packet_receive_*\* service. In addition, application threads may suspend with an optional timeout while waiting for a raw IP packet. The number of packets that can be queued on the raw packet queue is limited. The maximum value is defined in \***NX_IP_RAW_MAX_QUEUE_DEPTH**_, whose default value is 20.</span></span> <span data-ttu-id="c7e83-565">애플리케이션은 _ *_nx_ip_raw_receive_queue_max_set_*\* 서비스를 호출하여 최댓값을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-565">An application may change the maximum value by calling the _ *_nx_ip_raw_receive_queue_max_set_*\* service.</span></span>

<span data-ttu-id="c7e83-566">또는 \***NX_ENABLE_IP_RAW_PACKET_FILTER\*.** 를 사용하여 NetX Duo 라이브러리를 빌드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-566">Alternatively, the NetX Duo library may be built with \***NX_ENABLE_IP_RAW_PACKET_FILTER\*.**</span></span> <span data-ttu-id="c7e83-567">이 작업 모드에서 애플리케이션은 처리되지 않은 프로토콜 형식의 패킷을 수신할 때마다 호출되는 콜백 함수를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-567">In this mode of operation, the application provides a callback function that is invoked every time a packet with an unhandled protocol type is received.</span></span> <span data-ttu-id="c7e83-568">IP 수신 논리는 패킷을 사용자 정의 원시 패킷 수신 필터 루틴으로 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-568">The IP receive logic forwards the packet to the user-defined raw packet receive filter routine.</span></span> <span data-ttu-id="c7e83-569">필터 루틴은 이후 프로세스를 위해 원시 패킷을 유지할지 여부를 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-569">The filter routine decides whether or not to keep the raw packet for future process.</span></span> <span data-ttu-id="c7e83-570">콜백 루틴의 반환 값은 패킷이 원시 패킷 수신 필터에 의해 처리되었는지 여부를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-570">The return value from the callback routine indicates whether the packet has been processed by the raw packet receive filter.</span></span> <span data-ttu-id="c7e83-571">패킷이 콜백 함수에 의해 처리되는 경우 애플리케이션이 패킷을 사용한 후에 패킷을 해제해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-571">If the packet is processed by the callback function, the packet should be released after the application is done with the packet.</span></span> <span data-ttu-id="c7e83-572">그러지 않으면 NetX Duo가 패킷을 릴리스합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-572">Otherwise, NetX Duo is responsible for releasing the packet.</span></span> <span data-ttu-id="c7e83-573">원시 패킷 필터 함수를 사용하는 방법에 대한 자세한 내용은 **_nx_ip_raw_packet_filter_set_** 을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="c7e83-573">Refer to the **_nx_ip_raw_packet_filter_set_** for more information on how to use the raw packet filter function.</span></span>

> [!NOTE]
> <span data-ttu-id="c7e83-574">\*NetX Duo의 BSD 래퍼 기능은 원시 패킷 필터 함수를 사용하여 BSD 원시 소켓을 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-574">\*The BSD wrapper function for NetX Duo relies on the raw packet filter function to handle BSD raw sockets.</span></span> <span data-ttu-id="c7e83-575">따라서 BSD 래퍼의 원시 소켓을 지원하려면 ***NX_ENABLE_IP_RAW_PACKET_FILTER** _ 정의를 사용하여 NetX Duo 라이브러리를 빌드해야 하며 애플리케이션은 _*_nx_ip_raw_packet_filter_set_\*_ 을 사용하여 자체 원시 패킷 필터 함수를 설치하지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-575">Therefore, to support raw socket in the BSD wrapper, the NetX Duo library must be built with ***NX_ENABLE_IP_RAW_PACKET_FILTER** _ defined, and the application should not use the _*_nx_ip_raw_packet_filter_set_\*_ to install its own raw packet filter functions._</span></span>

### <a name="default-packet-pool"></a><span data-ttu-id="c7e83-576">기본 패킷 풀</span><span class="sxs-lookup"><span data-stu-id="c7e83-576">Default Packet Pool</span></span>

<span data-ttu-id="c7e83-577">각 IP 인스턴스에는 만드는 동안 기본 패킷 풀이 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-577">Each IP instance is given a default packet pool during creation.</span></span> <span data-ttu-id="c7e83-578">이 패킷 풀은 ARP, RARP, ICMP, IGMP, 다양한 TCP 제어 패킷(SYN, ACK 등), 인접 노드 검색, 라우터 검색, 중복 주소 검색에 대한 패킷을 할당하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-578">This packet pool is used to allocate packets for ARP, RARP, ICMP, IGMP, various TCP control packets (SYN, ACK, and so on), Neighbor Discovery, Router Discovery, and Duplicate Address Detection.</span></span> <span data-ttu-id="c7e83-579">NetX Duo에서 패킷을 할당해야 할 때 기본 패킷 풀이 비어 있으면 NetX Duo가 특정 작업을 중단해야 할 수 있으며 가능한 경우 오류 메시지를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-579">If the default packet pool is empty when NetX Duo needs to allocate a packet, NetX Duo may have to abort the particular operation, and will return an error message if possible.</span></span>

### <a name="ip-helper-thread"></a><span data-ttu-id="c7e83-580">IP 도우미 스레드</span><span class="sxs-lookup"><span data-stu-id="c7e83-580">IP Helper Thread</span></span>

<span data-ttu-id="c7e83-581">각 IP 인스턴스에는 도우미 스레드가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-581">Each IP instance has a helper thread.</span></span> <span data-ttu-id="c7e83-582">이 스레드는 모든 지연된 패킷 처리 및 모든 주기적 처리를 담당합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-582">This thread is responsible for handling all deferred packet processing and all periodic processing.</span></span> <span data-ttu-id="c7e83-583">IP 도우미 스레드는 ***nx_ip_create*** 에서 만들어집니다. 여기서 스레드의 스택 및 우선 순위를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-583">The IP helper thread is created in ***nx_ip_create.*** This is where the thread is given its stack and priority.</span></span> <span data-ttu-id="c7e83-584">IP 도우미 스레드의 첫 번째 처리 작업은 IP 만들기 서비스와 연결된 네트워크 드라이버 초기화를 완료하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-584">Note that the first processing in the IP helper thread is to finish the network driver initialization associated with the IP create service.</span></span> <span data-ttu-id="c7e83-585">네트워크 드라이버 초기화가 완료되면 도우미 스레드는 패킷 및 주기적 요청을 처리하기 위해 무한 루프를 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-585">After the network driver initialization is complete, the helper thread starts an endless loop to process packet and periodic requests.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="c7e83-586">IP 도우미 스레드에서 설명할 수 없는 동작이 나타나는 경우, IP 만들기 서비스 중에 스택 크기를 늘리는 것이 첫 번째 디버깅 단계입니다. 스택이 너무 작으면 IP 도우미 스레드가 메모리를 덮어쓸 수 있으며 이로 인해 비정상적인 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-586">*If unexplained behavior is seen within the IP helper thread, increasing its stack size during the IP create service is the first debugging step. If the stack is too small, the IP helper thread could possibly be overwriting memory, which may cause unusual problems.*</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="c7e83-587">스레드 일시 중단</span><span class="sxs-lookup"><span data-stu-id="c7e83-587">Thread Suspension</span></span>

<span data-ttu-id="c7e83-588">애플리케이션 스레드는 원시 IP 패킷을 수신하는 동안 일시 중단될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-588">Application threads can suspend while attempting to receive raw IP packets.</span></span> <span data-ttu-id="c7e83-589">원시 패킷이 수신되면 새 패킷이 일시 중단된 첫 번째 스레드에 제공되고 해당 스레드가 다시 시작됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-589">After a raw packet is received, the new packet is given to the first thread suspended and that thread is resumed.</span></span> <span data-ttu-id="c7e83-590">패킷을 수신하는 NetX Duo 서비스에는 모두 선택적 일시 중단 시간 제한이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-590">NetX Duo services for receiving packets all have an optional suspension timeout.</span></span> <span data-ttu-id="c7e83-591">패킷을 수신하거나 시간 제한이 만료되면 애플리케이션 스레드가 적절한 완료 상태로 다시 시작됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-591">When a packet is received or the timeout expires, the application thread is resumed with the appropriate completion status.</span></span>

### <a name="ip-statistics-and-errors"></a><span data-ttu-id="c7e83-592">IP 통계 및 오류</span><span class="sxs-lookup"><span data-stu-id="c7e83-592">IP Statistics and Errors</span></span>

<span data-ttu-id="c7e83-593">사용하도록 설정된 경우 NetX Duo는 애플리케이션에 유용할 수 있는 몇 가지 통계 및 오류를 추적합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-593">If enabled, the NetX Duo keeps track of several statistics and errors that may be useful to the application.</span></span> <span data-ttu-id="c7e83-594">각 IP 인스턴스에 대해 다음 통계 및 오류 보고서가 유지 관리됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-594">The following statistics and error reports are maintained for each IP instance:</span></span>

- <span data-ttu-id="c7e83-595">전송된 총 IP 패킷</span><span class="sxs-lookup"><span data-stu-id="c7e83-595">Total IP Packets Sent</span></span>
- <span data-ttu-id="c7e83-596">전송된 총 IP 바이트</span><span class="sxs-lookup"><span data-stu-id="c7e83-596">Total IP Bytes Sent</span></span>
- <span data-ttu-id="c7e83-597">수신된 총 IP 패킷</span><span class="sxs-lookup"><span data-stu-id="c7e83-597">Total IP Packets Received</span></span>
- <span data-ttu-id="c7e83-598">수신된 총 IP 바이트</span><span class="sxs-lookup"><span data-stu-id="c7e83-598">Total IP Bytes Received</span></span>
- <span data-ttu-id="c7e83-599">총 IP 잘못된 패킷</span><span class="sxs-lookup"><span data-stu-id="c7e83-599">Total IP Invalid Packets</span></span>
- <span data-ttu-id="c7e83-600">삭제된 총 IP 수신 패킷</span><span class="sxs-lookup"><span data-stu-id="c7e83-600">Total IP Receive Packets Dropped</span></span>
- <span data-ttu-id="c7e83-601">총 IP 수신 체크섬 오류</span><span class="sxs-lookup"><span data-stu-id="c7e83-601">Total IP Receive Checksum Errors</span></span>
- <span data-ttu-id="c7e83-602">삭제된 총 IP 전송 패킷</span><span class="sxs-lookup"><span data-stu-id="c7e83-602">Total IP Send Packets Dropped</span></span>
- <span data-ttu-id="c7e83-603">전송된 총 IP 조각</span><span class="sxs-lookup"><span data-stu-id="c7e83-603">Total IP Fragments Sent</span></span>
- <span data-ttu-id="c7e83-604">수신된 총 IP 조각</span><span class="sxs-lookup"><span data-stu-id="c7e83-604">Total IP Fragments Received</span></span>

<span data-ttu-id="c7e83-605">이러한 모든 통계 및 오류 보고서는 ***nx_ip_info_get*** 서비스를 사용하여 애플리케이션에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-605">All of these statistics and error reports are available to the application with the ***nx_ip_info_get*** service.</span></span>

### <a name="ip-control-block-nx_ip"></a><span data-ttu-id="c7e83-606">IP 제어 블록 NX_IP</span><span class="sxs-lookup"><span data-stu-id="c7e83-606">IP Control Block NX_IP</span></span>

<span data-ttu-id="c7e83-607">각 IP 인스턴스의 특성은 해당 제어 블록에서 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-607">The characteristics of each IP instance are found in its control block.</span></span> <span data-ttu-id="c7e83-608">각 네트워크 디바이스의 IP 주소 및 네트워크 마스크, 인접 IP 및 실제 하드웨어 주소 매핑 테이블과 같은 유용한 정보를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-608">It contains useful information such as the IP addresses and network masks of each network device, and a table of neighbor IP and physical hardware address mapping.</span></span> <span data-ttu-id="c7e83-609">이 구조는 \***nx_api.h** 파일에 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-609">This structure is defined in the \***nx_api.h** _file.</span></span> <span data-ttu-id="c7e83-610">IPv6를 사용하도록 설정한 경우 사용자가 구성할 수 있는 옵션 _\*_NX_MAX_IPV6_ADDRESSES_\*\*로 지정된 수의 IPv6 주소 배열을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-610">If IPv6 is enabled, it also contains an array of IPv6 address, the number of which is specified by the user configurable option _\*_NX_MAX_IPV6_ADDRESSES_\*\*.</span></span> <span data-ttu-id="c7e83-611">기본값을 사용하면 각 실제 네트워크 인터페이스에 세 개의 IPv6 주소를 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-611">The default value allows each physical network interface to have three IPv6 addresses.</span></span>

<span data-ttu-id="c7e83-612">IP 인스턴스 제어 블록은 메모리의 어디에나 위치할 수 있지만 제어 블록을 모든 함수의 범위 밖에 정의하여 전역 구조로 만드는 것이 가장 일반적입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-612">IP instance control blocks can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="static-ipv4-routing"></a><span data-ttu-id="c7e83-613">고정 IPv4 라우팅</span><span class="sxs-lookup"><span data-stu-id="c7e83-613">Static IPv4 Routing</span></span>

<span data-ttu-id="c7e83-614">고정 라우팅 기능을 사용하면 애플리케이션에서 특정 네트워크 외부 대상 IP 주소에 대해 IPv4 네트워크 및 다음 홉 주소를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-614">The static routing feature allows an application to specify an IPv4 network and next hop address for specific out of network destination IP addresses.</span></span> <span data-ttu-id="c7e83-615">고정 라우팅을 사용하도록 설정한 경우 NetX Duo는 고정 라우팅 테이블을 통해 전송할 패킷의 대상 주소와 일치하는 항목을 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-615">If static routing is enabled, NetX Duo searches through the static routing table for an entry matching the destination address of the packet to send.</span></span> <span data-ttu-id="c7e83-616">일치하는 항목이 없으면 NetX Duo는 실제 인터페이스 목록을 검색하여 대상 IP 주소와 네트워크 마스크를 기반으로 소스 IP 주소와 다음 홉 주소를 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-616">If no match is found, NetX Duo searches through the list of physical interfaces and chooses a source IP address and next hop address based on the destination IP address and the network mask.</span></span> <span data-ttu-id="c7e83-617">대상이 IP 인스턴스에 연결된 네트워크 드라이버의 IP 주소와 일치하지 않으면 NetX Duo는 기본 게이트웨이에 직접 연결된 인터페이스를 선택하고 인터페이스의 IP 주소를 소스 주소로 사용하고 기본 게이트웨이를 다음 홉으로 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-617">If the destination does not match any of the IP addresses of the network drivers attached to the IP instance, NetX Duo chooses an interface that is directly connected to the default gateway, and uses the IP address of the interface as source address, and the default gateway as the next hop.</span></span>

<span data-ttu-id="c7e83-618">각각 ***nx_ip_static_route_add** _ 및 _ *_nx_ip_static_route_delete_** 서비스를 사용하여 고정 라우팅 테이블에서 항목을 추가하고 제거할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-618">Entries can be added and removed from the static routing table using the ***nx_ip_static_route_add** _ and _ *_nx_ip_static_route_delete_** services, respectively.</span></span> <span data-ttu-id="c7e83-619">고정 라우팅을 사용하려면 호스트 애플리케이션이 ***NX_ENABLE_IP_STATIC_ROUTING*** 을 정의하여 이 기능을 사용하도록 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-619">To use static routing, the host application must enable this feature by defining ***NX_ENABLE_IP_STATIC_ROUTING.***</span></span>

> [!NOTE]
> <span data-ttu-id="c7e83-620">고정 라우팅 테이블에 항목을 추가하는 경우 NetX Duo는 테이블에 이미 있는 지정된 대상 주소와 일치하는 항목을 확인합니다. 항목이 있는 경우 네트워크 마스크에서 더 작은 네트워크(더 긴 접두사)가 있는 항목을 선호합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-620">*When adding an entry to the static routing table, NetX Duo checks for a matching entry for the specified destination address already in the table. If one exists, it gives preference to the entry with the smaller network (longer prefix) in the network mask.*</span></span>

### <a name="ipv4-forwarding"></a><span data-ttu-id="c7e83-621">IPv4 전달</span><span class="sxs-lookup"><span data-stu-id="c7e83-621">IPv4 Forwarding</span></span>

<span data-ttu-id="c7e83-622">들어오는 IPv4 패킷이 이 노드에 적합하지 않고 IPv4 전달 기능이 사용되도록 설정된 경우 NetX Duo는 다른 인터페이스를 통해 패킷을 전달하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-622">If the incoming IPv4 packet is not destined for this node and IPv4 forwarding feature is enabled, NetX Duo attempts to forward the packet out via the other interfaces.</span></span>  

### <a name="ip-fragmentation"></a><span data-ttu-id="c7e83-623">IP 조각화</span><span class="sxs-lookup"><span data-stu-id="c7e83-623">IP Fragmentation</span></span>

<span data-ttu-id="c7e83-624">네트워크 디바이스에는 나가는 패킷의 크기가 제한될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-624">The network device may have limits on the size of outgoing packets.</span></span> <span data-ttu-id="c7e83-625">이 제한을 MTU(최대 전송 단위)라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-625">This limit is called the maximum transmission unit (MTU).</span></span> <span data-ttu-id="c7e83-626">IP MTU는 링크 계층 드라이버가 IP 패킷을 조각화하지 않고 전송할 수 있는 가장 큰 IP 프레임 크기입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-626">IP MTU is the largest IP frame size a link layer driver is able to transmit without fragmenting the IP packet.</span></span> <span data-ttu-id="c7e83-627">디바이스 드라이버 초기화 단계에서 드라이버 모듈은 ***nx_ip_interface_mtu_set*** 서비스를 통해 IP MTU 크기를 구성해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-627">During a device driver initialization phase, the driver module must configure its IP MTU size via the service ***nx_ip_interface_mtu_set.***</span></span>

<span data-ttu-id="c7e83-628">권장하지는 않지만 애플리케이션은 디바이스에서 지원되는 기본 IP MTU보다 큰 데이터그램을 생성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-628">Although not recommended, the application may generate datagrams larger than the underlying IP MTU supported by the device.</span></span> <span data-ttu-id="c7e83-629">이와 같은 IP 데이터그램을 전송하기 전에 IP 계층은 이러한 패킷을 분할해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-629">Before transmitting such IP datagram, the IP layer must fragment these packets.</span></span> <span data-ttu-id="c7e83-630">조각난 IP 프레임을 수신하는 경우, 수신 끝은 조각난 모든 IP 프레임을 동일한 조각화 ID로 저장하고 순서대로 리어셈블해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-630">On receiving fragmented IP frames, the receiving end must store all fragmented IP frames with the same fragmentation ID, and reassemble them in order.</span></span> <span data-ttu-id="c7e83-631">IP 수신 논리가 모든 조각을 수집하여 원래 IP 프레임을 제때 복원할 수 없는 경우 모든 조각이 해제됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-631">If the IP receive logic is unable to collect all the fragments to restore the original IP frame in time, all the fragments are released.</span></span> <span data-ttu-id="c7e83-632">이러한 패킷 손실을 탐지하고 그로부터 복구하는 것은 상위 계층 프로토콜의 역할입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-632">It is up to the upper layer protocol to detect such packet loss and recover from it.</span></span>

<span data-ttu-id="c7e83-633">IP 조각화는 IPv4와 IPv6 패킷 모두에 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-633">The IP fragmentation applies to both IPv4 and IPv6 packets.</span></span>

<span data-ttu-id="c7e83-634">IP 조각화 및 리어셈블리 작업을 지원하기 위해 시스템 디자이너는 ***nx_ip_fragment_enable*** 서비스를 사용하여 NetX Duo에서 IP 조각화 기능을 사용하도록 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-634">In order to support IP fragmentation and reassembly operation, the system designer must enable the IP fragmentation feature in NetX Duo using the ***nx_ip_fragment_enable*** service.</span></span> <span data-ttu-id="c7e83-635">이 기능을 사용하도록 설정하지 않으면 네트워크 드라이버의 MTU를 초과하는 패킷뿐만 아니라 들어오는 조각난 IP 패킷도 삭제됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-635">If this feature is not enabled, incoming fragmented IP packets are discarded, as well as packets that exceed the network driver's MTU.</span></span>

> [!NOTE]
> <span data-ttu-id="c7e83-636">NetX Duo 라이브러리를 빌드할 때 \***NX_DISABLE_FRAGMENTATION** _을 정의하여 IP 조각화 논리를 완전히 제거할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-636">\*The IP Fragmentation logic can be removed completely by defining \***NX_DISABLE_FRAGMENTATION** _ when building the NetX Duo library.</span></span> <span data-ttu-id="c7e83-637">이렇게 하면 NetX Duo의 코드 크기를 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-637">Doing so helps reduce the code size of NetX Duo.</span></span> <span data-ttu-id="c7e83-638">이 경우 IPv4 및 IPv6 조각화/리어셈블리 함수는 모두 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-638">Note that in this situation, both the IPv4 and IPv6 fragmentation/reassembly functions are disabled._</span></span>

> [!NOTE]
> <span data-ttu-id="c7e83-639">**NX_DISABLE_CHAINED_PACKET** 이 정의된 경우 IP 조각화를 사용하지 않도록 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-639">*If **NX_DISABLE_CHAINED_PACKET** is defined, IP fragmentation must be disabled.*</span></span>

> [!NOTE]
> <span data-ttu-id="c7e83-640">IPv6 네트워크에서 라우터는 데이터그램의 크기가 최소 MTU 크기를 초과할 경우 데이터그램을 조각내지 않습니다. 따라서 소스와 대상 간의 최소 MTU를 결정하고 IP 데이터그램 크기가 경로 MTU를 초과하지 않도록 하는 것은 전송 디바이스의 역할입니다. NetX Duo에서 정의된 **NX_ENABLE_IPV6_PATH_MTU_DISCOVERY** 기호가 있는 NetX Duo 라이브러리를 빌드하여 IPv6 PATH MTU 검색을 사용하도록 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-640">*In an IPv6 network, routers do not fragment a datagram if the size of the datagram exceeds its minimum MTU size. Therefore, it is up to the sending device to determine the minimum MTU between the source and the destination, and to ensure the IP datagram size does not exceed the path MTU. In NetX Duo, IPv6 PATH MTU discovery can be enabled by building NetX Duo library with the symbol **NX_ENABLE_IPV6_PATH_MTU_DISCOVERY** defined.*</span></span>

## <a name="address-resolution-protocol-arp-in-ipv4"></a><span data-ttu-id="c7e83-641">IPv4의 ARP(주소 확인 프로토콜)</span><span class="sxs-lookup"><span data-stu-id="c7e83-641">Address Resolution Protocol (ARP) in IPv4</span></span>

<span data-ttu-id="c7e83-642">ARP(주소 확인 프로토콜)는 32비트 IPv4 주소를 기본 실제 미디어(RFC 826)의 주소에 동적으로 매핑하는 역할을 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-642">The Address Resolution Protocol (ARP) is responsible for dynamically mapping 32-bit IPv4 addresses to those of the underlying physical media (RFC 826).</span></span> <span data-ttu-id="c7e83-643">이더넷은 가장 일반적인 실제 미디어이며 48비트 주소를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-643">Ethernet is the most typical physical media, and it supports 48-bit addresses.</span></span> <span data-ttu-id="c7e83-644">ARP의 필요성은 \***nx_ip_create** _ 서비스에 제공된 네트워크 드라이버에 의해 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-644">The need for ARP is determined by the network driver supplied to the \***nx_ip_create** _ service.</span></span> <span data-ttu-id="c7e83-645">실제 매핑이 필요한 경우 네트워크 드라이버에서 _ *_nx_interface_address_mapping_needed_*\* 서비스를 사용하여 드라이버 인터페이스를 올바르게 구성해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-645">If physical mapping is required, the network driver must use the _ *_nx_interface_address_mapping_needed_*\* service to configure the driver interface properly.</span></span>

### <a name="arp-enable"></a><span data-ttu-id="c7e83-646">ARP 사용</span><span class="sxs-lookup"><span data-stu-id="c7e83-646">ARP Enable</span></span>

<span data-ttu-id="c7e83-647">ARP가 제대로 작동하려면 먼저 애플리케이션이 ***nx_arp_enable*** 서비스를 사용하도록 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-647">For ARP to function properly, it must first be enabled by the application with the ***nx_arp_enable*** service.</span></span> <span data-ttu-id="c7e83-648">이 서비스는 ARP 사용 서비스에 제공된 메모리에서 ARP 캐시 영역을 만드는 등 ARP 처리를 위한 다양한 데이터 구조를 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-648">This service sets up various data structures for ARP processing, including the creation of an ARP cache area from the memory supplied to the ARP enable service.</span></span>

### <a name="arp-cache"></a><span data-ttu-id="c7e83-649">ARP 캐시</span><span class="sxs-lookup"><span data-stu-id="c7e83-649">ARP Cache</span></span>

<span data-ttu-id="c7e83-650">ARP 캐시는 내부 ARP 매핑 데이터 구조의 배열로 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-650">The ARP cache can be viewed as an array of internal ARP mapping data structures.</span></span> <span data-ttu-id="c7e83-651">각 내부 구조는 IP 주소와 실제 하드웨어 주소 사이의 관계를 유지 관리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-651">Each internal structure is capable of maintaining the relationship between an IP address and a physical hardware address.</span></span> <span data-ttu-id="c7e83-652">또한 각 데이터 구조에는 링크 포인터가 있어 여러 연결된 목록에 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-652">In addition, each data structure has link pointers so it can be part of multiple linked lists.</span></span>

<span data-ttu-id="c7e83-653">매핑이 ARP 테이블에 있는 경우 애플리케이션은 \***nx_arp_ip_address_find** _ 서비스를 사용하여 하드웨어 MAC 주소를 제공하는 방법으로 ARP 캐시에서 IP 주소를 조회할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-653">Application can look up an IP address from the ARP cache by supplying hardware MAC address using the service \***nx_arp_ip_address_find** _ if the mapping exists in the ARP table.</span></span> <span data-ttu-id="c7e83-654">마찬가지로 _ _nx_arp_hardware_address_find_\* 서비스는 지정된 IP 주소에 대한 MAC 주소를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-654">Similarly, the service _ *_nx_arp_hardware_address_find_*\* returns the MAC address for a given IP address.</span></span>

### <a name="arp-dynamic-entries"></a><span data-ttu-id="c7e83-655">ARP 동적 항목</span><span class="sxs-lookup"><span data-stu-id="c7e83-655">ARP Dynamic Entries</span></span>

<span data-ttu-id="c7e83-656">기본적으로 ARP 사용 서비스는 ARP 캐시의 모든 항목을 사용 가능한 동적 ARP 항목 목록에 배치합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-656">By default, the ARP enable service places all entries in the ARP cache on the list of available dynamic ARP entries.</span></span> <span data-ttu-id="c7e83-657">매핑되지 않은 IP 주소에 대한 전송 요청이 검색되면 이 목록에서 NetX Duo가 동적 ARP 항목을 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-657">A dynamic ARP entry is allocated from this list by NetX Duo when a send request to an unmapped IP address is detected.</span></span> <span data-ttu-id="c7e83-658">할당 후 ARP 항목이 설정되고 실제 미디어로 ARP 요청이 전송됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-658">After allocation, the ARP entry is set up and an ARP request is sent to the physical media.</span></span>

<span data-ttu-id="c7e83-659">***nx_arp_dynamic_entry_set*** 서비스에서 동적 항목을 만들 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-659">A dynamic entry can also be created by the service ***nx_arp_dynamic_entry_set***.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="c7e83-660">모든 동적 ARP 항목이 사용 중인 경우 오래전에 사용한 ARP 항목이 새 매핑으로 바뀝니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-660">*If all dynamic ARP entries are in use, the least recently used ARP entry is replaced with a new mapping.*</span></span>

### <a name="arp-static-entries"></a><span data-ttu-id="c7e83-661">ARP 고정 항목</span><span class="sxs-lookup"><span data-stu-id="c7e83-661">ARP Static Entries</span></span>

<span data-ttu-id="c7e83-662">또한 애플리케이션은 \***nx_arp_static_entry_create** _ 서비스를 사용하여 고정 ARP 매핑을 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-662">The application can also set up static ARP mapping by using the \***nx_arp_static_entry_create** _service.</span></span> <span data-ttu-id="c7e83-663">이 서비스는 동적 ARP 항목 목록에서 ARP 항목을 할당하고 애플리케이션에서 제공하는 매핑 정보와 함께 고정 목록에 배치합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-663">This service allocates an ARP entry from the dynamic ARP entry list and places it on the static list with the mapping information supplied by the application.</span></span> <span data-ttu-id="c7e83-664">고정 ARP 항목에는 재사용 또는 에이징이 적용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-664">Static ARP entries are not subject to reuse or aging.</span></span> <span data-ttu-id="c7e83-665">애플리케이션은 서비스 _*_nx_arp_static_entry_delete_*_ 를 사용하여 고정 항목을 삭제할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-665">The application can delete a static entry by using the service _*_nx_arp_static_entry_delete_*_.</span></span> <span data-ttu-id="c7e83-666">ARP 테이블의 모든 고정 항목을 제거하기 위해 애플리케이션은 _*_nx_arp_static_entries_delete_*\* 서비스를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-666">To remove all static entries in the ARP table, the application may use the service _\*_nx_arp_static_entries_delete_\*\*.</span></span>

### <a name="automatic-arp-entry"></a><span data-ttu-id="c7e83-667">자동 ARP 항목</span><span class="sxs-lookup"><span data-stu-id="c7e83-667">Automatic ARP Entry</span></span>

<span data-ttu-id="c7e83-668">NetX Duo는 ARP 요청에 대한 피어 응답 후 피어의 IP/MAC 매핑을 기록합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-668">NetX Duo records the peer's IP/MAC mapping after the peer responses to the ARP request.</span></span> <span data-ttu-id="c7e83-669">NetX Duo는 또한 네트워크에서 요청되지 않은 ARP 요청을 기반으로 피어 IP/MAC 주소 매핑을 기록하는 자동 ARP 항목 기능을 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-669">NetX Duo also implements the automatic ARP entry feature where it records peer IP/MAC address mapping based on unsolicited ARP requests from the network.</span></span> <span data-ttu-id="c7e83-670">이 기능을 사용하면 ARP 테이블을 피어 정보로 채울 수 있으므로 ARP 요청/응답 주기를 통과하는 데 필요한 지연을 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-670">This feature allows the ARP table to be populated with peer information, reducing the delay needed to go through the ARP request/response cycle.</span></span> <span data-ttu-id="c7e83-671">그러나 자동 ARP를 사용하는 경우의 단점은 ARP 테이블이 로컬 링크에 많은 노드가 있는 사용량이 많은 네트워크에서 빠르게 채워지는 경향이 있고, 결국 이로 인해 ARP 항목을 대체하게 된다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-671">However the downside with enabling automatic ARP is that the ARP table tend to fill up quickly on a busy network with many nodes on the local link, which would eventually lead to ARP entry replacement.</span></span>

<span data-ttu-id="c7e83-672">이 기능은 기본적으로 사용하도록 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-672">This feature is enabled by default.</span></span> <span data-ttu-id="c7e83-673">이 기능을 사용하지 않으려면 정의된 ***NX_DISABLE_ARP_AUTO_ENTRY*** 기호를 사용하여 NetX Duo 라이브러리를 컴파일해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-673">To disable it, the NetX Duo library must be compiled with the symbol ***NX_DISABLE_ARP_AUTO_ENTRY*** defined.</span></span></p>

### <a name="arp-messages"></a><span data-ttu-id="c7e83-674">ARP 메시지</span><span class="sxs-lookup"><span data-stu-id="c7e83-674">ARP Messages</span></span>

<span data-ttu-id="c7e83-675">앞에서 언급한 대로 IP 작업에서 IP 주소에 대한 매핑이 필요하다는 것을 감지하면 ARP 요청 메시지가 전송됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-675">As mentioned previously, an ARP request message is sent when the IP task detects that mapping is needed for an IP address.</span></span> <span data-ttu-id="c7e83-676">ARP 요청은 해당 ARP 응답이 수신될 때까지 주기적으로(매 \***NX_ARP_UPDATE_RATE** _초마다) 전송됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-676">ARP requests are sent periodically (every \***NX_ARP_UPDATE_RATE** _ seconds) until a corresponding ARP response is received.</span></span> <span data-ttu-id="c7e83-677">ARP 시도가 중단되기 전에 총 _ *_NX_ARP_MAXIMUM_RETRIES_*\* ARP 요청이 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-677">A total of _ *_NX_ARP_MAXIMUM_RETRIES_*\* ARP requests are made before the ARP attempt is abandoned.</span></span> <span data-ttu-id="c7e83-678">ARP 응답이 수신되면 관련된 물리적 주소 정보는 캐시에 있는 ARP 항목에 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-678">When an ARP response is received, the associated physical address information is stored in the ARP entry that is in the cache.</span></span>

<span data-ttu-id="c7e83-679">멀티홈 시스템의 경우 NetX Duo는 지정된 대상 주소에 따라 ARP 요청 및 응답을 보낼 인터페이스를 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-679">For multihome systems, NetX Duo determines which interface to send the ARP requests and responses based on destination address specified.</span></span>

> [!NOTE]
> <span data-ttu-id="c7e83-680">NetX Duo가 ARP 응답을 대기하는 동안 나가는 IP 패킷은 큐에 대기합니다. 큐에 있는 나가는 IP 패킷 수는 상수 **NX_ARP_MAX_QUEUE_DEPTH** 에 의해 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-680">*Outgoing IP packets are queued while NetX Duo waits for the ARP response. The number of outgoing IP packets queued is defined by the constant **NX_ARP_MAX_QUEUE_DEPTH**.*</span></span>

<span data-ttu-id="c7e83-681">NetX Duo는 로컬 IPv4 네트워크에 있는 다른 노드의 ARP 요청에도 응답합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-681">NetX Duo also responds to ARP requests from other nodes on the local IPv4 network.</span></span> <span data-ttu-id="c7e83-682">ARP 요청을 수신하는 인터페이스의 현재 IP 주소와 일치하는 외부 ARP 요청이 이루어지면 NetX Duo는 현재 물리적 주소를 포함하는 ARP 응답 메시지를 작성합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-682">When an external ARP request is made that matches the current IP address of the interface that receives the ARP request, NetX Duo builds an ARP response message that contains the current physical address.</span></span>

<span data-ttu-id="c7e83-683">이더넷 ARP 요청 및 응답의 형식은 그림 6에 나타나 있으며 아래에 설명되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-683">The formats of Ethernet ARP requests and responses are shown in Figure 6 and are described below.</span></span>

| <span data-ttu-id="c7e83-684">**요청/응답&nbsp;필드**</span><span class="sxs-lookup"><span data-stu-id="c7e83-684">**Request/Response&nbsp;Field**</span></span>         | <span data-ttu-id="c7e83-685">**용도**</span><span class="sxs-lookup"><span data-stu-id="c7e83-685">**Purpose**</span></span>            |
| ---------------------------------- | ---------------------- |
| <span data-ttu-id="c7e83-686">***이더넷 대상 주소***</span><span class="sxs-lookup"><span data-stu-id="c7e83-686">***Ethernet Destination Address***</span></span> | <span data-ttu-id="c7e83-687">이 6바이트 필드는 ARP 응답의 대상 주소를 포함하며 ARP 요청을 위한 브로드캐스트(모두 포함)입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-687">This 6-byte field contains the destination address for the ARP response and is a broadcast (all ones) for ARP requests.</span></span> <span data-ttu-id="c7e83-688">이 필드는 네트워크 드라이버에 의해 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-688">This field is setup by the network driver.</span></span> 
| <span data-ttu-id="c7e83-689">***이더넷 소스 주소***</span><span class="sxs-lookup"><span data-stu-id="c7e83-689">***Ethernet Source Address***</span></span>      | <span data-ttu-id="c7e83-690">이 6바이트 필드는 ARP 요청 또는 응답의 보낸 사람 주소를 포함하고 네트워크 드라이버에 의해 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-690">This 6-byte field contains the address of the sender of the ARP request or response and is set up by the network driver.</span></span> |
| <span data-ttu-id="c7e83-691">***프레임 형식***</span><span class="sxs-lookup"><span data-stu-id="c7e83-691">***Frame Type***</span></span> | <span data-ttu-id="c7e83-692">이 2바이트 필드는 표시되는 이더넷 프레임 형식을 포함하며, ARP 요청 및 응답의 경우 이는 0x0806과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-692">This 2-byte field contains the type of Ethernet frame present and, for ARP requests and responses, this is equal to 0x0806.</span></span> <span data-ttu-id="c7e83-693">네트워크 드라이버가 설정할 마지막 필드입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-693">This is the last field the network driver is responsible for setting up.</span></span> |
| <span data-ttu-id="c7e83-694">***하드웨어 종류***</span><span class="sxs-lookup"><span data-stu-id="c7e83-694">***Hardware Type***</span></span> | <span data-ttu-id="c7e83-695">이 2바이트 필드에는 이더넷에 대해 0x0001인 하드웨어 종류가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-695">This 2-byte field contains the hardware type, which is 0x0001 for Ethernet.</span></span> |
| <span data-ttu-id="c7e83-696">***프로토콜 형식***</span><span class="sxs-lookup"><span data-stu-id="c7e83-696">***Protocol Type***</span></span> | <span data-ttu-id="c7e83-697">이 2바이트 필드에는 IP 주소에 대해 0x0800인 프로토콜 형식이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-697">This 2-byte field contains the protocol type, which is 0x0800 for IP addresses.</span></span> |
| <span data-ttu-id="c7e83-698">***하드웨어 크기***</span><span class="sxs-lookup"><span data-stu-id="c7e83-698">***Hardware Size***</span></span> | <span data-ttu-id="c7e83-699">이 1바이트 필드에는 이더넷 주소에 대해 6인 하드웨어 주소 크기가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-699">This 1-byte field contains the hardware address size, which is 6 for Ethernet addresses.</span></span> |

![ARP 패킷 형식의 다이어그램입니다.](./media/user-guide/arp-packet-format.png)

<span data-ttu-id="c7e83-701">**그림 6. ARP 패킷 형식**</span><span class="sxs-lookup"><span data-stu-id="c7e83-701">**FIGURE 6. ARP Packet Format**</span></span>

| <span data-ttu-id="c7e83-702">요청/응답&nbsp;필드</span><span class="sxs-lookup"><span data-stu-id="c7e83-702">Request/Response&nbsp;Field</span></span> | <span data-ttu-id="c7e83-703">목적</span><span class="sxs-lookup"><span data-stu-id="c7e83-703">Purpose</span></span> |
|---|---|
| <span data-ttu-id="c7e83-704">***프로토콜 크기***</span><span class="sxs-lookup"><span data-stu-id="c7e83-704">***Protocol Size***</span></span> | <span data-ttu-id="c7e83-705">이 1바이트 필드에는 IP 주소에 대해 4인 IP 주소 크기가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-705">This 1-byte field contains the IP address size, which is 4 for IP addresses.</span></span> |
| <span data-ttu-id="c7e83-706">***작업 코드***</span><span class="sxs-lookup"><span data-stu-id="c7e83-706">***Operation Code***</span></span> | <span data-ttu-id="c7e83-707">이 2바이트 필드에는 이 ARP 패킷에 대한 작업이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-707">This 2-byte field contains the operation for this ARP packet.</span></span> <span data-ttu-id="c7e83-708">ARP 요청은 0x0001 값으로 지정되고, ARP 응답은 0x0002 값으로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-708">An ARP request is specified with the value of 0x0001, while an ARP response is represented by a value of 0x0002.</span></span> |
| <span data-ttu-id="c7e83-709">***보낸 사람 이더넷 주소***</span><span class="sxs-lookup"><span data-stu-id="c7e83-709">***Sender Ethernet Address***</span></span> | <span data-ttu-id="c7e83-710">이 6바이트 필드에는 보낸 사람의 이더넷 주소가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-710">This 6-byte field contains the sender's Ethernet address.</span></span> |
| <span data-ttu-id="c7e83-711">***보낸 사람 IP 주소***</span><span class="sxs-lookup"><span data-stu-id="c7e83-711">***Sender IP Address***</span></span> | <span data-ttu-id="c7e83-712">이 4바이트 필드에는 보낸 사람의 IP 주소가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-712">This 4-byte field contains the sender's IP address.</span></span> |
| <span data-ttu-id="c7e83-713">***대상 이더넷 주소***</span><span class="sxs-lookup"><span data-stu-id="c7e83-713">***Target Ethernet Address***</span></span> | <span data-ttu-id="c7e83-714">이 6바이트 필드에는 대상의 이더넷 주소가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-714">This 6-byte field contains the target's Ethernet address.</span></span> |
| <span data-ttu-id="c7e83-715">***대상 IP 주소***</span><span class="sxs-lookup"><span data-stu-id="c7e83-715">***Target IP Address***</span></span> | <span data-ttu-id="c7e83-716">이 4바이트 필드에는 대상의 IP 주소가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-716">This 4-byte field contains the target's IP address.</span></span> |

> [!NOTE]
> <span data-ttu-id="c7e83-717">ARP 요청 및 응답은 이더넷 수준 패킷입니다. 다른 모든 TCP/IP 패킷은 IP 패킷 헤더에서 캡슐화됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-717">*ARP requests and responses are Ethernet-level packets. All other TCP/IP packets are encapsulated by an IP packet header.*</span></span>

> [!NOTE]
> <span data-ttu-id="c7e83-718">TCP/IP 구현의 모든 ARP 메시지는 **big endian** 형식이어야 합니다. 이 형식에서 단어의 가장 중요한 바이트는 가장 낮은 바이트 주소에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-718">*All ARP messages in the TCP/IP implementation are expected to be in **big endian** format. In this format, the most significant byte of the word resides at the lowest byte address.*</span></span>

### <a name="arp-aging"></a><span data-ttu-id="c7e83-719">ARP 에이징</span><span class="sxs-lookup"><span data-stu-id="c7e83-719">ARP Aging</span></span>

<span data-ttu-id="c7e83-720">NetX는 자동 동적 ARP 항목 무효화를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-720">NetX supports automatic dynamic ARP entry invalidation.</span></span><span data-ttu-id="c7e83-721">\ ***NX_ARP_EXPIRATION_RATE** _는 실제 매핑에 대해 설정된 IP 주소가 유효한 상태로 유지되는 시간(초)을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-721">\ ***NX_ARP_EXPIRATION_RATE** _ specifies the number of seconds an established IP address to physical mapping stays valid.</span></span> <span data-ttu-id="c7e83-722">만료 후 ARP 항목은 ARP 캐시에서 제거됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-722">After expiration, the ARP entry is removed from the ARP cache.</span></span> <span data-ttu-id="c7e83-723">다음번에 해당 IP 주소로 전송하려고 하면 새 ARP 요청이 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-723">The next attempt to send to the corresponding IP address will result in a new ARP request.</span></span> <span data-ttu-id="c7e83-724">_ \*_NX_ARP_EXPIRATION_RATE_\*\*를 0으로 설정하면 기본 구성인 ARP 에이징을 사용하지 않게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-724">Setting _ *_NX_ARP_EXPIRATION_RATE_*\* to zero disables ARP aging, which is the default configuration.</span></span>

### <a name="arp-defend"></a><span data-ttu-id="c7e83-725">ARP 방어</span><span class="sxs-lookup"><span data-stu-id="c7e83-725">ARP Defend</span></span>

<span data-ttu-id="c7e83-726">ARP 요청 또는 ARP 응답 패킷이 수신되고 보낸 사람이 이 노드의 IP 주소와 충돌하는 동일한 IP 주소를 가질 때 NetX Duo는 해당 주소에 대한 ARP 요청을 방어 수단으로 전송합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-726">When an ARP request or ARP response packet is received and the sender has the same IP address, which conflicts with the IP address of this node, NetX Duo sends an ARP request for that address as a defense.</span></span> <span data-ttu-id="c7e83-727">충돌 ARP 패킷이 10초 이내에 두 번 이상 수신되면 NetX Duo는 더 이상 방어 패킷을 전송하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-727">If the conflict ARP packet is received more than once in 10 seconds, NetX Duo does not send more defend packets.</span></span> <span data-ttu-id="c7e83-728">기본 간격 10초는 \***NX_ARP_DEFEND_INTERVAL** _로 다시 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-728">The default interval 10 seconds can be redefined by \***NX_ARP_DEFEND_INTERVAL** _.</span></span> <span data-ttu-id="c7e83-729">이 동작은 RFC5227의 2.4(c)에 지정된 정책을 따릅니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-729">This behavior follows the policy specified in 2.4(c) of RFC5227.</span></span> <span data-ttu-id="c7e83-730">Windows XP에서는 ARP 프로브를 위한 응답으로 ARP 알림을 무시하기 때문에 사용자가 _ \*_NX_ARP_DEFEND_BY_REPLY_\*\*를 정의하여 ARP 응답을 추가 방어 수단으로 전송할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-730">Since Windows XP ignores ARP announcement as a response for its ARP probe, user can define _ *_NX_ARP_DEFEND_BY_REPLY_*\* to send ARP response as additional defence.</span></span>

### <a name="arp-statistics-and-errors"></a><span data-ttu-id="c7e83-731">ARP 통계 및 오류</span><span class="sxs-lookup"><span data-stu-id="c7e83-731">ARP Statistics and Errors</span></span>

<span data-ttu-id="c7e83-732">사용하도록 설정된 경우 NetX Duo ARP 소프트웨어는 애플리케이션에 유용할 수 있는 몇 가지 통계 및 오류를 추적합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-732">If enabled, the NetX Duo ARP software keeps track of several statistics and errors that may be useful to the application.</span></span> <span data-ttu-id="c7e83-733">각 IP의 ARP 처리에 대해 다음 통계 및 오류 보고서가 유지 관리됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-733">The following statistics and error reports are maintained for each IP's ARP processing:</span></span>

- <span data-ttu-id="c7e83-734">전송된 총 ARP 요청</span><span class="sxs-lookup"><span data-stu-id="c7e83-734">Total ARP Requests Sent</span></span>
- <span data-ttu-id="c7e83-735">수신된 총 ARP 요청</span><span class="sxs-lookup"><span data-stu-id="c7e83-735">Total ARP Requests Received</span></span>
- <span data-ttu-id="c7e83-736">전송된 총 ARP 응답</span><span class="sxs-lookup"><span data-stu-id="c7e83-736">Total ARP Responses Sent</span></span> 
- <span data-ttu-id="c7e83-737">수신된 총 ARP 응답</span><span class="sxs-lookup"><span data-stu-id="c7e83-737">Total ARP Responses Received</span></span> 
- <span data-ttu-id="c7e83-738">총 ARP 동적 항목</span><span class="sxs-lookup"><span data-stu-id="c7e83-738">Total ARP Dynamic Entries</span></span> 
- <span data-ttu-id="c7e83-739">총 ARP 고정 항목</span><span class="sxs-lookup"><span data-stu-id="c7e83-739">Total ARP Static Entries</span></span> 
- <span data-ttu-id="c7e83-740">총 ARP 오래된 항목</span><span class="sxs-lookup"><span data-stu-id="c7e83-740">Total ARP Aged Entries</span></span> 
- <span data-ttu-id="c7e83-741">총 ARP 잘못된 메시지</span><span class="sxs-lookup"><span data-stu-id="c7e83-741">Total ARP Invalid Messages</span></span> 

<span data-ttu-id="c7e83-742">이러한 모든 통계 및 오류 보고서는 애플리케이션이 ***nx_arp_info_get*** 서비스를 사용하여 이용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-742">All these statistics and error reports are available to the application with the ***nx_arp_info_get*** service.</span></span>

## <a name="reverse-address-resolution-protocol-rarp-in-ipv4"></a><span data-ttu-id="c7e83-743">IPv4의 RARP(역주소 확인 프로토콜)</span><span class="sxs-lookup"><span data-stu-id="c7e83-743">Reverse Address Resolution Protocol (RARP) in IPv4</span></span>

<span data-ttu-id="c7e83-744">RARP(역주소 확인 프로토콜)는 호스트의 32비트 IP 주소(RFC 903)에 대한 네트워크 할당을 요청하는 프로토콜입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-744">The Reverse Address Resolution Protocol (RARP) is the protocol for requesting network assignment of the host's 32-bit IP addresses (RFC 903).</span></span> <span data-ttu-id="c7e83-745">이 작업은 RARP 요청을 통해 수행되며 네트워크 멤버가 RARP 응답에서 호스트 네트워크 인터페이스에 IP 주소를 할당할 때까지 주기적으로 계속됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-745">This is done through an RARP request and continues periodically until a network member assigns an IP address to the host network interface in an RARP response.</span></span> <span data-ttu-id="c7e83-746">애플리케이션은 IP 주소가 0인 ***nx_ip_create*** 서비스에서 IP 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-746">The application creates an IP instance by the service ***nx_ip_create*** with a zero IP address.</span></span> <span data-ttu-id="c7e83-747">애플리케이션에서 RARP를 사용하는 경우 RARP 프로토콜을 사용하여 IP 주소가 0인 인터페이스를 통해 액세스할 수 있는 네트워크 서버에서 IP 주소를 요청할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-747">If RARP is enabled by the application, it can use the RARP protocol to request an IP address from the network server accessible through the interface that has a zero IP address.</span></span>

### <a name="rarp-enable"></a><span data-ttu-id="c7e83-748">RARP 사용</span><span class="sxs-lookup"><span data-stu-id="c7e83-748">RARP Enable</span></span>

<span data-ttu-id="c7e83-749">RARP를 사용하려면 애플리케이션에서 IP 주소가 0인 IP 인스턴스를 만든 다음, ***nx_rarp_enable*** 서비스를 사용하여 RARP를 사용하도록 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-749">To use RARP, the application must create the IP instance with an IP address of zero, then enable RARP using the service ***nx_rarp_enable***.</span></span> <span data-ttu-id="c7e83-750">멀티홈 시스템의 경우 IP 인스턴스와 연결된 하나 이상의 네트워크 디바이스에 0인 IP 주소가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-750">For multihome systems, at least one network device associated with the IP instance must have an IP address of zero.</span></span> <span data-ttu-id="c7e83-751">RARP 처리는 네트워크 지정 IP 주소를 사용하는 유효한 RARP 응답이 수신될 때까지 IP 주소가 필요한 NetX Duo 시스템에 대한 RARP 요청 메시지를 주기적으로 전송합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-751">The RARP processing periodically sends RARP request messages for the NetX Duo system requiring an IP address until a valid RARP reply with the network designated IP address is received.</span></span> <span data-ttu-id="c7e83-752">이때 RARP 처리가 완료됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-752">At this point, RARP processing is complete.</span></span>

<span data-ttu-id="c7e83-753">RARP를 사용하도록 설정한 후에는 모든 인터페이스 주소가 확인되면 자동으로 사용할 수 없게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-753">After RARP has been enabled, it is disabled automatically after all interface addresses are resolved.</span></span> <span data-ttu-id="c7e83-754">애플리케이션이 ***nx_rarp_disable*** 서비스를 사용하여 강제로 RARP를 종료할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-754">The application may force RARP to terminate by using the service ***nx_rarp_disable***.</span></span>

### <a name="rarp-request"></a><span data-ttu-id="c7e83-755">RARP 요청</span><span class="sxs-lookup"><span data-stu-id="c7e83-755">RARP Request</span></span>

<span data-ttu-id="c7e83-756">RARP 요청 패킷의 형식은 [그림 6](#arp-messages)에 표시된 ARP 패킷과 거의 동일합니다. 유일한 차이점은 프레임 유형 필드는 0x8035이고 ‘작업 코드’ 필드는 3이며 RARP 요청을 지정한다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-756">The format of an RARP request packet is almost identical to the ARP packet shown in [Figure 6](#arp-messages).The only difference is the frame type field is 0x8035 and the *Operation Code* field is 3, designating an RARP request.</span></span> <span data-ttu-id="c7e83-757">앞에서 언급한 대로 RARP 요청은 네트워크에서 할당된 IP 주소를 가진 RARP 회신이 수신될 때까지 주기적으로(매 ***NX_RARP_UPDATE_RATE*** 초마다) 전송됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-757">As mentioned previously, RARP requests will be sent periodically (every ***NX_RARP_UPDATE_RATE*** seconds) until a RARP reply with the network assigned IP address is received.</span></span>

> [!NOTE]
> <span data-ttu-id="c7e83-758">TCP/IP 구현의 모든 RARP 메시지는 **big endian** 형식이어야 합니다. 이 형식에서 단어의 가장 중요한 바이트는 가장 낮은 바이트 주소에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-758">*All RARP messages in the TCP/IP implementation are expected to be in **big endian** format. In this format, the most significant byte of the word resides at the lowest byte address.*</span></span>

### <a name="rarp-reply"></a><span data-ttu-id="c7e83-759">RARP 응답</span><span class="sxs-lookup"><span data-stu-id="c7e83-759">RARP Reply</span></span>

<span data-ttu-id="c7e83-760">RARP 응답 메시지는 네트워크에서 수신되고 이 호스트에 할당된 네트워크 IP 주소를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-760">RARP reply messages are received from the network and contain the network assigned IP address for this host.</span></span> <span data-ttu-id="c7e83-761">RARP 응답 패킷의 형식은 그림 6에 표시된 ARP 패킷과 거의 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-761">The format of an RARP reply packet is almost identical to the ARP packet shown in Figure 6.</span></span> <span data-ttu-id="c7e83-762">유일한 차이점은 프레임 유형 필드는 0x8035이고 ‘작업 코드’ 필드는 4이며 RARP 응답을 지정하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-762">The only difference is the frame type field is 0x8035 and the *Operation Code* field is 4, which designates an RARP reply.</span></span> <span data-ttu-id="c7e83-763">수신 후 IP 주소는 IP 인스턴스에서 설정되고 주기적 RARP 요청은 사용할 수 없으며 IP 인스턴스는 정상적인 네트워크 작업을 수행할 준비가 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-763">After received, the IP address is setup in the IP instance, the periodic RARP request is disabled, and the IP instance is now ready for normal network operation.</span></span>

<span data-ttu-id="c7e83-764">멀티홈 호스트의 경우 IP 주소가 요청 네트워크 인터페이스에 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-764">For multihome hosts, the IP address is applied to the requesting network interface.</span></span> <span data-ttu-id="c7e83-765">여전히 IP 주소 할당을 요청하는 다른 네트워크 인터페이스가 있는 경우 모든 인터페이스 IP 주소 요청이 해결될 때까지 주기적인 RARP 서비스는 계속됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-765">If there are other network interfaces still requesting an IP address assignment, the periodic RARP service continues until all interface IP address requests are resolved.</span></span>

> [!NOTE]
> <span data-ttu-id="c7e83-766">애플리케이션은 RARP 처리가 완료될 때까지 IP 인스턴스를 사용하면 안 됩니다. **nx_ip_status_check** 를 사용하여 애플리케이션에서 RARP 완료를 기다릴 수 있습니다. 멀티홈 시스템의 경우 애플리케이션은 해당 인터페이스에서 RARP 처리가 완료될 때까지 요청 인터페이스를 사용하지 않아야 합니다. **nx_ip_interface_status_check** 서비스를 사용하여 보조 디바이스의 IP 주소 상태를 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-766">*The application should not use the IP instance until the RARP processing is complete. The **nx_ip_status_check** may be used by applications to wait for the RARP completion. For multihome systems, the application should not use the requesting interface until the RARP processing is complete on that interface. Status of the IP address on the secondary device can be checked with the **nx_ip_interface_status_check** service.*</span></span>

### <a name="rarp-statistics-and-errors"></a><span data-ttu-id="c7e83-767">RARP 통계 및 오류</span><span class="sxs-lookup"><span data-stu-id="c7e83-767">RARP Statistics and Errors</span></span>

<span data-ttu-id="c7e83-768">사용하도록 설정된 경우 NetX Duo RARP 소프트웨어는 애플리케이션에 유용할 수 있는 몇 가지 통계 및 오류를 추적합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-768">If enabled, the NetX Duo RARP software keeps track of several statistics and errors that may be useful to the application.</span></span> <span data-ttu-id="c7e83-769">각 IP의 RARP 처리에 대해 다음 통계 및 오류 보고서가 유지 관리됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-769">The following statistics and error reports are maintained for each IP's RARP processing:</span></span>

- <span data-ttu-id="c7e83-770">전송된 총 RARP 요청</span><span class="sxs-lookup"><span data-stu-id="c7e83-770">Total RARP Requests Sent</span></span>
- <span data-ttu-id="c7e83-771">수신된 총 RARP 응답</span><span class="sxs-lookup"><span data-stu-id="c7e83-771">Total RARP Responses Received</span></span>
- <span data-ttu-id="c7e83-772">총 RARP 잘못된 메시지</span><span class="sxs-lookup"><span data-stu-id="c7e83-772">Total RARP Invalid Messages</span></span>

<span data-ttu-id="c7e83-773">이러한 모든 통계 및 오류 보고서는 애플리케이션에서 ***nx_rarp_info_get*** 서비스를 통해 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-773">All these statistics and error reports are available to the application with the ***nx_rarp_info_get*** service.</span></span>

## <a name="internet-control-message-protocol-icmp"></a><span data-ttu-id="c7e83-774">ICMP(Internet Control Message Protocol)</span><span class="sxs-lookup"><span data-stu-id="c7e83-774">Internet Control Message Protocol (ICMP)</span></span>

<span data-ttu-id="c7e83-775">IPv4용 ICMP(Internet Control Message Protocol)는 IP 네트워크 멤버 사이에서 오류 및 제어 정보를 전달만 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-775">Internet Control Message Protocol for IPv4 (ICMP) is limited to passing error and control information between IP network members.</span></span> <span data-ttu-id="c7e83-776">ICMPv6(IPv6용 Internet Control Message Protocol)도 오류 및 제어 정보를 처리하며 DAD(중복 주소 검색) 및 상태 비저장 주소 자동 구성과 같은 주소 확인 프로토콜에 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-776">Internet Control Message Protocol for IPv6 (ICMPv6) also handles error and control information and is required for address resolution protocols such as Duplicate Address Detection (DAD) and stateless address autoconfiguration.</span></span>

<span data-ttu-id="c7e83-777">대부분의 다른 애플리케이션 계층(예: TCP/IP) 메시지와 마찬가지로 ICMP 및 ICMPv6 메시지는 ICMP(또는 ICMPv6) 프로토콜이 지정된 IP 헤더에 의해 캡슐화됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-777">Like most other application layer (e.g., TCP/IP) messages, ICMP and ICMPv6 messages are encapsulated by an IP header with the ICMP (or ICMPv6) protocol designation.</span></span>

### <a name="icmp-statistics-and-errors"></a><span data-ttu-id="c7e83-778">ICMP 통계 및 오류</span><span class="sxs-lookup"><span data-stu-id="c7e83-778">ICMP Statistics and Errors</span></span>

<span data-ttu-id="c7e83-779">사용하도록 설정된 경우 NetX Duo는 애플리케이션에 유용할 수 있는 몇 가지 ICMP 통계 및 오류를 추적합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-779">If enabled, NetX Duo keeps track of several ICMP statistics and errors that may be useful to the application.</span></span> <span data-ttu-id="c7e83-780">각 IP의 ICMP 처리에 대해 다음 통계 및 오류 보고서가 유지 관리됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-780">The following statistics and error reports are maintained for each IP's ICMP processing:</span></span> 

- <span data-ttu-id="c7e83-781">전송된 총 ICMP Ping</span><span class="sxs-lookup"><span data-stu-id="c7e83-781">Total ICMP Pings Sent</span></span>  
- <span data-ttu-id="c7e83-782">총 ICMP Ping 시간 제한</span><span class="sxs-lookup"><span data-stu-id="c7e83-782">Total ICMP Ping Timeouts</span></span> 
- <span data-ttu-id="c7e83-783">일시 중단된 총 ICMP Ping 스레드</span><span class="sxs-lookup"><span data-stu-id="c7e83-783">Total ICMP Ping Threads Suspended</span></span> 
- <span data-ttu-id="c7e83-784">수신된 총 ICMP Ping 응답</span><span class="sxs-lookup"><span data-stu-id="c7e83-784">Total ICMP Ping Responses Received</span></span> 
- <span data-ttu-id="c7e83-785">총 ICMP 체크섬 오류</span><span class="sxs-lookup"><span data-stu-id="c7e83-785">Total ICMP Checksum Errors</span></span> 
- <span data-ttu-id="c7e83-786">총 ICMP 처리되지 않은 메시지</span><span class="sxs-lookup"><span data-stu-id="c7e83-786">Total ICMP Unhandled Messages</span></span> 

<span data-ttu-id="c7e83-787">이러한 모든 통계 및 오류 보고서는 애플리케이션이 ***nx_icmp_info_get*** 서비스를 사용하여 이용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-787">All these statistics and error reports are available to the application with the ***nx_icmp_info_get*** service.</span></span>

## <a name="icmpv4-services-in-netx-duo"></a><span data-ttu-id="c7e83-788">NetX Duo의 ICMPv4 서비스</span><span class="sxs-lookup"><span data-stu-id="c7e83-788">ICMPv4 Services in NetX Duo</span></span>

### <a name="icmpv4-enable"></a><span data-ttu-id="c7e83-789">ICMPv4 사용</span><span class="sxs-lookup"><span data-stu-id="c7e83-789">ICMPv4 Enable</span></span>

<span data-ttu-id="c7e83-790">NetX Duo에서 ICMPv4 메시지를 처리하려면 먼저 애플리케이션이 ***nx_icmp_enable*** 서비스를 호출하여 ICMPv4를 처리하도록 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-790">Before ICMPv4 messages can be processed by NetX Duo, the application must call the ***nx_icmp_enable*** service to enable ICMPv4 processing.</span></span> <span data-ttu-id="c7e83-791">이 작업이 완료되면 애플리케이션에서 Ping 요청을 실행하고 들어오는 Ping 패킷을 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-791">After this is done, the application can issue ping requests and field incoming ping packets.</span></span>  

### <a name="icmpv4-echo-request"></a><span data-ttu-id="c7e83-792">ICMPv4 에코 요청</span><span class="sxs-lookup"><span data-stu-id="c7e83-792">ICMPv4 Echo Request</span></span>

<span data-ttu-id="c7e83-793">에코 요청은 호스트 IP 주소로 식별되는 네트워크에 특정 노드가 있는지 확인하는 데 일반적으로 사용되는 ICMPv4 메시지의 한 유형입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-793">An echo request is one type of ICMPv4 message that is typically used to check for the existence of a specific node on the network, as identified by its host IP address.</span></span> <span data-ttu-id="c7e83-794">인기 있는 ping 명령은 ICMP 에코 요청/에코 응답 메시지를 사용하여 구현됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-794">The popular ping command is implemented using ICMP echo request/echo reply messages.</span></span> <span data-ttu-id="c7e83-795">특정 호스트가 있는 경우 해당 네트워크 스택은 Ping 요청 및 응답을 ping 응답으로 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-795">If the specific host is present, its network stack processes the ping request and responses with a ping response.</span></span> <span data-ttu-id="c7e83-796">그림 7에서는 ICMPv4 Ping 메시지 형식에 대해 자세히 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-796">Figure 7 details the ICMPv4 ping message format.</span></span>

![ICMPv4 Ping 메시지](./media/user-guide/icmpv4-ping-message.png)  

<span data-ttu-id="c7e83-798">**그림 7. ICMPv4 Ping 메시지**</span><span class="sxs-lookup"><span data-stu-id="c7e83-798">**FIGURE 7. ICMPv4 Ping Message**</span></span>

> [!NOTE]
> <span data-ttu-id="c7e83-799">TCP/IP 구현의 모든 ICMPv4 메시지는 **Big Endian** 형식이어야 합니다. 이 형식에서 단어의 가장 중요한 바이트는 가장 낮은 바이트 주소에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-799">*All ICMPv4 messages in the TCP/IP implementation are expected to be in **big endian** format. In this format, the most significant byte of the word resides at the lowest byte address.*</span></span>

<span data-ttu-id="c7e83-800">다음은 ICMPv4 헤더 형식에 대한 설명입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-800">The following describes the ICMPv4 header format:</span></span>

|<span data-ttu-id="c7e83-801">헤더 필드</span><span class="sxs-lookup"><span data-stu-id="c7e83-801">Header Field</span></span> |<span data-ttu-id="c7e83-802">목적</span><span class="sxs-lookup"><span data-stu-id="c7e83-802">Purpose</span></span> |
|---|---|
|<span data-ttu-id="c7e83-803">**형식**</span><span class="sxs-lookup"><span data-stu-id="c7e83-803">**Type**</span></span> |<span data-ttu-id="c7e83-804">이 필드에서는 ICMPv4 메시지(31-24비트)를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-804">This field specifies the ICMPv4 message (bits 31-24).</span></span> <span data-ttu-id="c7e83-805">가장 일반적인 메시지:</span><span class="sxs-lookup"><span data-stu-id="c7e83-805">The most common are:</span></span><br /><span data-ttu-id="c7e83-806">- 0: 에코 응답</span><span class="sxs-lookup"><span data-stu-id="c7e83-806">-  0: Echo Reply</span></span><br /><span data-ttu-id="c7e83-807">- 3: 대상에 연결할 수 없음</span><span class="sxs-lookup"><span data-stu-id="c7e83-807">- 3: Destination Unreachable</span></span><br /><span data-ttu-id="c7e83-808">- 8: 에코 요청</span><span class="sxs-lookup"><span data-stu-id="c7e83-808">- 8: Echo Request</span></span><br /><span data-ttu-id="c7e83-809">- 11: 시간 초과</span><span class="sxs-lookup"><span data-stu-id="c7e83-809">- 11: Time Exceeded</span></span><br /><span data-ttu-id="c7e83-810">- 12: 매개 변수 문제</span><span class="sxs-lookup"><span data-stu-id="c7e83-810">- 12: Parameter Problem</span></span> |
|<span data-ttu-id="c7e83-811">**코드**</span><span class="sxs-lookup"><span data-stu-id="c7e83-811">**Code**</span></span> |<span data-ttu-id="c7e83-812">이 필드는 형식 필드의 컨텍스트에 따라 값이 달라집니다(23-16비트).</span><span class="sxs-lookup"><span data-stu-id="c7e83-812">This field is context specific on the type field (bits 23-16).</span></span> <span data-ttu-id="c7e83-813">에코 요청 또는 응답의 경우 코드는 0으로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-813">For an echo request or reply the code is set to zero.</span></span>|
|<span data-ttu-id="c7e83-814">**Checksum**</span><span class="sxs-lookup"><span data-stu-id="c7e83-814">**Checksum**</span></span> |<span data-ttu-id="c7e83-815">이 필드는 형식 필드에서 시작하는 ICMPv4 헤더 전체를 포함하여 ICMPv4 메시지의 1의 보수 합계에 대한 16비트 체크섬을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-815">This field contains the 16-bit checksum of the one's complement sum of the ICMPv4 message including the entire the ICMPv4 header starting with the Type field.</span></span> <span data-ttu-id="c7e83-816">체크섬을 생성하기 전에 체크섬 필드가 지워집니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-816">Before generating the checksum, the checksum field is cleared.</span></span>|
|<span data-ttu-id="c7e83-817">**ID**</span><span class="sxs-lookup"><span data-stu-id="c7e83-817">**Identification**</span></span> | <span data-ttu-id="c7e83-818">이 필드는 호스트를 식별하는 ID 값을 포함합니다. 호스트는 에코 응답의 에코 요청에서 추출된 ID를 사용해야 합니다(31-16비트).</span><span class="sxs-lookup"><span data-stu-id="c7e83-818">This field contains an ID value identifying the host; a host should use the ID extracted from an ECHO request in the ECHO REPLY (bits 31-16).</span></span>|
|<span data-ttu-id="c7e83-819">**시퀀스 번호**</span><span class="sxs-lookup"><span data-stu-id="c7e83-819">**Sequence number**</span></span> |<span data-ttu-id="c7e83-820">이 필드는 ID 값을 포함합니다. 호스트는 에코 응답의 에코 요청에서 추출된 ID를 사용해야 합니다(31-16비트).</span><span class="sxs-lookup"><span data-stu-id="c7e83-820">This field contains an ID value; a host should use the ID extracted from an ECHO request in the ECHO REPLY (bits 31-16).</span></span> <span data-ttu-id="c7e83-821">ID 필드와 달리 이 값은 동일한 호스트의 후속 에코 요청에서 변경됩니다(15-0비트).</span><span class="sxs-lookup"><span data-stu-id="c7e83-821">Unlike the identifier field, this value will change in a subsequent Echo request from the same host (bits 15-0).</span></span>|

### <a name="icmpv4-echo-response"></a><span data-ttu-id="c7e83-822">ICMPv4 에코 응답</span><span class="sxs-lookup"><span data-stu-id="c7e83-822">ICMPv4 Echo Response</span></span>    
<span data-ttu-id="c7e83-823">ping 응답은 외부 ping 요청에 대한 응답으로 ICMP 구성 요소에 의해 내부적으로 생성되는 또 다른 형식의 ICMP 메시지입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-823">A ping response is another type of ICMP message that is generated internally by the ICMP component in response to an external ping request.</span></span> <span data-ttu-id="c7e83-824">ping 응답에는 승인 외에, ping 요청에 제공된 사용자 데이터 복사본도 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-824">In addition to acknowledgement, the ping response also contains a copy of the user data supplied in the ping request.</span></span>

### <a name="icmpv4-error-messages"></a><span data-ttu-id="c7e83-825">ICMPv4 오류 메시지</span><span class="sxs-lookup"><span data-stu-id="c7e83-825">ICMPv4 Error Messages</span></span>   
<span data-ttu-id="c7e83-826">다음 ICMPv4 오류 메시지는 NetX Duo에서 지원됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-826">The following ICMPv4 error messages are supported in NetX Duo:</span></span> 
- <span data-ttu-id="c7e83-827">대상에 연결할 수 없음</span><span class="sxs-lookup"><span data-stu-id="c7e83-827">Destination Unreachable</span></span> 
- <span data-ttu-id="c7e83-828">시간 초과</span><span class="sxs-lookup"><span data-stu-id="c7e83-828">Time Exceed</span></span> 
- <span data-ttu-id="c7e83-829">매개 변수 문제</span><span class="sxs-lookup"><span data-stu-id="c7e83-829">Parameter Problem</span></span>

## <a name="internet-group-management-protocol-igmp"></a><span data-ttu-id="c7e83-830">IGMP(Internet Group Management Protocol)</span><span class="sxs-lookup"><span data-stu-id="c7e83-830">Internet Group Management Protocol (IGMP)</span></span>

<span data-ttu-id="c7e83-831">IGMP(Internet Group Management Protocol)는 IPv4 멀티캐스트 그룹(RFC 1112와 RFC 2236)을 수신하거나 가입하려는 인접 노드 및 라우터와 통신할 수 있는 디바이스를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-831">The Internet Group Management Protocol (IGMP) provides a device to communicate with its neighbors and its routers that it intends to receive, or join, an IPv4 multicast group (RFC 1112 and RFC 2236).</span></span> <span data-ttu-id="c7e83-832">멀티캐스트 그룹은 기본적으로 네트워크 멤버의 동적 집합이며 클래스 D IP 주소로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-832">A multicast group is basically a dynamic collection of network members and is represented by a Class D IP address.</span></span> <span data-ttu-id="c7e83-833">멀티캐스트 그룹의 멤버는 언제든지 탈퇴할 수 있고, 새로운 멤버는 언제든지 가입할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-833">Members of the multicast group may leave at any time, and new members may join at any time.</span></span> <span data-ttu-id="c7e83-834">그룹에 가입하고 탈퇴하는 것과 관련된 조정은 IGMP에서 수행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-834">The coordination involved in joining and leaving the group is the responsibility of IGMP.</span></span>

> [!NOTE]
> <span data-ttu-id="c7e83-835">IGMP는 IPv4 멀티캐스트 그룹만을 위해 설계되었습니다. IPv6 네트워크에서는 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-835">*IGMP is designed only for IPv4 multicast groups. It cannot be used on the IPv6 network.*</span></span>

### <a name="igmp-enable"></a><span data-ttu-id="c7e83-836">IGMP 사용</span><span class="sxs-lookup"><span data-stu-id="c7e83-836">IGMP Enable</span></span>     
<span data-ttu-id="c7e83-837">NetX Duo에서 멀티캐스팅 작업을 수행하려면 먼저 애플리케이션이 ***nx_igmp_enable*** 서비스를 호출해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-837">Before any multicasting activity can take place in NetX Duo, the application must call the ***nx_igmp_enable*** service.</span></span> <span data-ttu-id="c7e83-838">이 서비스는 멀티캐스트 요청에 준비하기 위해 기본적인 IGMP 초기화를 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-838">This service performs basic IGMP initialization in preparation for multicast requests.</span></span>

### <a name="multicast-ipv4-addressing"></a><span data-ttu-id="c7e83-839">멀티캐스트 IPv4 주소 지정</span><span class="sxs-lookup"><span data-stu-id="c7e83-839">Multicast IPv4 Addressing</span></span>  
<span data-ttu-id="c7e83-840">앞에서 설명한 대로 멀티캐스트 주소는 실제 [그림 4](#ipv4-addresses)에 나와 있는 것처럼 클래스 D IP 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-840">As mentioned previously, multicast addresses are actually Class D IP addresses as shown in [Figure 4](#ipv4-addresses).</span></span> <span data-ttu-id="c7e83-841">클래스 D 주소의 하위 28비트는 멀티캐스트 그룹 ID에 해당합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-841">The lower 28-bits of the Class D address correspond to the multicast group ID.</span></span> <span data-ttu-id="c7e83-842">미리 정의된 일련의 멀티캐스트 주소가 있습니다. 그러나 ‘모든 호스트 주소’(244.0.0.1)는 IGMP 처리에 특히 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-842">There are a series of pre-defined multicast addresses; however, the *all hosts address* (244.0.0.1) is particularly important to IGMP processing.</span></span> <span data-ttu-id="c7e83-843">‘모든 호스트 주소’는 라우터가 모든 멀티캐스트 멤버를 쿼리하여 자신이 속한 멀티캐스트 그룹을 보고하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-843">The *all hosts address* is used by routers to query all multicast members to report on which multicast groups they belong to.</span></span>  

### <a name="physical-address-mapping-in-ipv4"></a><span data-ttu-id="c7e83-844">IPv4의 물리적 주소 매핑</span><span class="sxs-lookup"><span data-stu-id="c7e83-844">Physical Address Mapping in IPv4</span></span>
<span data-ttu-id="c7e83-845">클래스 D 멀티캐스트 주소는 01.00.5e.00.00.00에서 01.00.5e.7f.ff.ff까지 범위의 실제 이더넷 주소로 직접 매핑됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-845">Class D multicast addresses map directly to physical Ethernet addresses ranging from 01.00.5e.00.00.00 through 01.00.5e.7f.ff.ff.</span></span> <span data-ttu-id="c7e83-846">IP 멀티캐스트 주소의 하단 23비트는 이더넷 주소의 하위 23비트에 직접 매핑됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-846">The lower 23 bits of the IP multicast address map directly to the lower 23 bits of the Ethernet address.</span></span>

### <a name="multicast-group-join"></a><span data-ttu-id="c7e83-847">멀티캐스트 그룹 가입</span><span class="sxs-lookup"><span data-stu-id="c7e83-847">Multicast Group Join</span></span>
<span data-ttu-id="c7e83-848">특정 멀티캐스트 그룹에 가입해야 하는 애플리케이션은 ***nx_igmp_multicast_join*** 서비스를 호출하여 이 작업을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-848">Applications that need to join a particular multicast group may do so by calling the ***nx_igmp_multicast_join*** service.</span></span> <span data-ttu-id="c7e83-849">이 서비스는 이 멀티캐스트 그룹에 가입하려는 요청 수를 추적합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-849">This service keeps track of the number of requests to join this multicast group.</span></span> <span data-ttu-id="c7e83-850">멀티캐스트 그룹에 가입하려는 첫 번째 애플리케이션 요청이라면 IGMP 보고서는 그룹에 가입하려는 이 호스트의 의도를 나타내는 기본 네트워크에 전송됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-850">If this is the first application requestto join the multicast group, an IGMP report is sent out on the primary network indicating this host's intention to join the group.</span></span> <span data-ttu-id="c7e83-851">그런 다음 네트워크 드라이버를 호출하여 이 멀티캐스트 그룹에 대한 이더넷 주소로 패킷을 수신 대기하도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-851">Next, the network driver is called to set up for listening for packets with the Ethernet address for this multicast group.</span></span>

<span data-ttu-id="c7e83-852">멀티홈 시스템에서, 멀티캐스트 그룹이 특정 인터페이스를 통해 접근할 수 있다면, 애플리케이션은 기본 네트워크의 멀티캐스트 그룹으로 제한된 _*_nx_igmp_multicast_join_*\* 대신 \***nx_igmp_multicast_interface_join** _ 서비스를 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-852">In a multihome system, if the multicast group is accessible via a specific interface, application shall use the service ***nx_igmp_multicast_interface_join** _ instead of _*_nx_igmp_multicast_join_\*\*, which is limited to multicast groups on the primary network.</span></span>

### <a name="multicast-group-leave"></a><span data-ttu-id="c7e83-853">멀티캐스트 그룹 탈퇴</span><span class="sxs-lookup"><span data-stu-id="c7e83-853">Multicast Group Leave</span></span>   
<span data-ttu-id="c7e83-854">이전에 가입된 멀티캐스트 그룹을 탈퇴해야 하는 애플리케이션은 ***nx_igmp_multicast_leave*** 서비스를 호출하여 탈퇴할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-854">Applications that need to leave a previously joined multicast group may do so by calling the ***nx_igmp_multicast_leave*** service.</span></span> <span data-ttu-id="c7e83-855">이 서비스는 그룹이 가입된 횟수와 관련된 내부 횟수를 줄입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-855">This service reduces the internal count associated with how many times the group was joined.</span></span> <span data-ttu-id="c7e83-856">그룹에 처리 중인 가입 요청이 없는 경우 네트워크 드라이버를 호출하여 이 멀티캐스트 그룹의 이더넷 주소로 패킷을 수신 대기하지 않도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-856">If there are no outstanding join requests for a group, the network driver is called to disable listening for packets with this multicast group's Ethernet address.</span></span>

### <a name="multicast-loopback"></a><span data-ttu-id="c7e83-857">멀티캐스트 루프백</span><span class="sxs-lookup"><span data-stu-id="c7e83-857">Multicast Loopback</span></span>    
<span data-ttu-id="c7e83-858">애플리케이션은 동일한 노드의 소스 중 하나에서 시작된 멀티캐스트 트래픽을 수신하려고 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-858">An application may wish to receive multicast traffic originated from one of the sources on the same node.</span></span> <span data-ttu-id="c7e83-859">이렇게 하려면 ***nx_igmp_loopback_enable*** 서비스를 사용하여 IP 멀티캐스트 구성 요소가 루프백을 사용하도록 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-859">This requires the IP multicast component to have loopback enabled by using the service ***nx_igmp_loopback_enable***.</span></span>

### <a name="igmp-report-message"></a><span data-ttu-id="c7e83-860">IGMP 보고서 메시지</span><span class="sxs-lookup"><span data-stu-id="c7e83-860">IGMP Report Message</span></span>      
<span data-ttu-id="c7e83-861">애플리케이션이 멀티캐스트 그룹에 가입할 때 IGMP 보고서 메시지는 네트워크를 통해 전송되어 특정 멀티캐스트 그룹에 가입하려는 호스트의 의도를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-861">When the application joins a multicast group, an IGMP report message is sent via the network to indicate the host's intention to join a particular multicast group.</span></span> <span data-ttu-id="c7e83-862">IGMP 보고서 메시지의 형식은 그림 8에서 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-862">The format of the IGMP report message is shown in Figure 8.</span></span> <span data-ttu-id="c7e83-863">멀티캐스트 그룹 주소는 IGMP 보고서 메시지의 그룹 메시지와 대상 IP 주소에 모두 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-863">The multicast group address is used for both the group message in the IGMP report message and the destination IP address.</span></span>

<span data-ttu-id="c7e83-864">위의 그림 8에서 IGMP 헤더에는 버전/유형 필드, 최대 응답이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-864">In the figure above (Figure 8), the IGMP header contains a version/type field, maximum response</span></span>

![IGMP 보고서 메시지의 다이어그램입니다.](./media/user-guide/image17.jpg)

<span data-ttu-id="c7e83-866">**그림 8. IGMP 보고서 메시지**</span><span class="sxs-lookup"><span data-stu-id="c7e83-866">**FIGURE 8. IGMP Report Message**</span></span>

<span data-ttu-id="c7e83-867">시간, 체크섬 필드, 멀티캐스트 그룹 주소 필드가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-867">time, a checksum field, and a multicast group address field.</span></span> <span data-ttu-id="c7e83-868">IGMPv1 메시지의 경우 최대 응답 시간 필드는 IGMPv1 프로토콜의 일부가 아니므로 항상 0으로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-868">For IGMPv1 messages, the Maximum Response Time field is always set to zero, as this is not part of the IGMPv1 protocol.</span></span> <span data-ttu-id="c7e83-869">최대 응답 시간 필드는 호스트가 쿼리 형식 IGMP 메시지를 수신할 때 설정되고 호스트가 IGMPv2 프로토콜로 정의된 다른 호스트의 보고서 형식 메시지를 수신할 때 삭제됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-869">The Maximum Response Time field is set when the host receives a Query type IGMP message and cleared when a host receives another host's Report type message as defined by the IGMPv2 protocol.</span></span>

<span data-ttu-id="c7e83-870">다음은 IGMP 헤더 형식에 대한 설명입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-870">The following describes the IGMP header format:</span></span>

|<span data-ttu-id="c7e83-871">헤더 필드</span><span class="sxs-lookup"><span data-stu-id="c7e83-871">Header Field</span></span>|<span data-ttu-id="c7e83-872">목적</span><span class="sxs-lookup"><span data-stu-id="c7e83-872">Purpose</span></span>|
|---|---|
|<span data-ttu-id="c7e83-873">**버전**</span><span class="sxs-lookup"><span data-stu-id="c7e83-873">**Version**</span></span> |<span data-ttu-id="c7e83-874">이 필드는 IGMP 버전을 지정합니다(31-28비트).</span><span class="sxs-lookup"><span data-stu-id="c7e83-874">This field specifies the IGMP version (bits 31- 28).</span></span>|
|<span data-ttu-id="c7e83-875">**형식**</span><span class="sxs-lookup"><span data-stu-id="c7e83-875">**Type**</span></span> |<span data-ttu-id="c7e83-876">이 필드는 IGMP 메시지 유형을 지정합니다(27-24비트).</span><span class="sxs-lookup"><span data-stu-id="c7e83-876">This field specifies the type of IGMP message (bits 27 -24).</span></span>|
|<span data-ttu-id="c7e83-877">**최대 응답 시간**</span><span class="sxs-lookup"><span data-stu-id="c7e83-877">**Maximum Response Time**</span></span> |<span data-ttu-id="c7e83-878">IGMP 버전 1에서 사용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-878">Not used in IGMP v1.</span></span> <span data-ttu-id="c7e83-879">IGMP 버전 2에서 이 필드는 최대 응답 시간으로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-879">In IGMP v2 this field serves as the maximum response time.</span></span>|
|<span data-ttu-id="c7e83-880">**Checksum**</span><span class="sxs-lookup"><span data-stu-id="c7e83-880">**Checksum**</span></span> |<span data-ttu-id="c7e83-881">이 필드에는 IGMP 버전으로 시작하는 IGMP 메시지의 1의 보수 합계에 대한 16비트 체크섬이 포함됩니다(0-15비트).</span><span class="sxs-lookup"><span data-stu-id="c7e83-881">This field contains the 16-bit checksum of the one's complement sum of the IGMP message starting with the IGMP version (bits 0-15)</span></span>|
|<span data-ttu-id="c7e83-882">**그룹 주소**</span><span class="sxs-lookup"><span data-stu-id="c7e83-882">**Group Address**</span></span> |<span data-ttu-id="c7e83-883">32비트 클래스 D 그룹 IP 주소</span><span class="sxs-lookup"><span data-stu-id="c7e83-883">32-bit class D group IP address</span></span>|

<span data-ttu-id="c7e83-884">또한 IGMP 보고서 메시지는 멀티캐스트 라우터에 의해 전송된 IGMP 쿼리 메시지에 응답하여 전송됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-884">IGMP report messages are also sent in response to IGMP query messages sent by a multicast router.</span></span> <span data-ttu-id="c7e83-885">멀티캐스트 라우터는 그룹 멤버 자격이 여전히 필요한 호스트를 확인하기 위해 주기적으로 쿼리 메시지를 전송합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-885">Multicast routers periodically send query messages out to see which hosts still require group membership.</span></span> <span data-ttu-id="c7e83-886">쿼리 메시지는 그림 8에 표시된 IGMP 보고서 메시지와 동일한 형식을 갖습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-886">Query messages have the same format as the IGMP Report message shown in Figure 8.</span></span> <span data-ttu-id="c7e83-887">유일한 차이점은 IGMP 형식이 1과 같고 그룹 주소 필드는 0으로 설정된다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-887">The only differences are the IGMP type is equal to 1 and the group address field is set to 0.</span></span> <span data-ttu-id="c7e83-888">IGMP 쿼리 메시지는 멀티캐스트 라우터에 의해 ‘모든 호스트’ IP 주소로 전송됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-888">IGMP Query messages are sent to the *all hosts* IP address by the multicast router.</span></span> <span data-ttu-id="c7e83-889">그룹 멤버 자격을 유지 관리하려는 호스트가 다른 IGMP 보고서 메시지를 전송하여 응답합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-889">A host that still wishes to maintain group membership responds by sending another IGMP Report message.</span></span>

> [!NOTE]
> <span data-ttu-id="c7e83-890">TCP/IP 구현의 모든 메시지는 **big endian** 형식이어야 합니다. 이 형식에서 단어의 가장 중요한 바이트는 가장 낮은 바이트 주소에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-890">*All messages in the TCP/IP implementation are expected to be in **big endian** format. In this format, the most significant byte of the word resides at the lowest byte address.*</span></span>

### <a name="igmp-statistics-and-errors"></a><span data-ttu-id="c7e83-891">IGMP 통계 및 오류</span><span class="sxs-lookup"><span data-stu-id="c7e83-891">IGMP Statistics and Errors</span></span>    
<th><p><span data-ttu-id="c7e83-892">사용하도록 설정된 경우 NetX Duo IGMP 소프트웨어는 애플리케이션에 유용할 수 있는 몇 가지 통계 및 오류를 추적합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-892">If enabled, the NetX Duo IGMP software keeps track of several statistics and errors that may be useful to the application.</span></span> <span data-ttu-id="c7e83-893">각 IP의 IGMP 처리에 대해 다음 통계 및 오류 보고서가 유지 관리됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-893">The following statistics and error reports are maintained for each IP's IGMP processing:</span></span> 

- <span data-ttu-id="c7e83-894">전송된 총 IGMP 보고서</span><span class="sxs-lookup"><span data-stu-id="c7e83-894">Total IGMP Reports Sent</span></span> 
- <span data-ttu-id="c7e83-895">수신된 총 IGMP 쿼리</span><span class="sxs-lookup"><span data-stu-id="c7e83-895">Total IGMP Queries Received</span></span> 
- <span data-ttu-id="c7e83-896">총 IGMP 체크섬 오류</span><span class="sxs-lookup"><span data-stu-id="c7e83-896">Total IGMP Checksum Errors</span></span> 
- <span data-ttu-id="c7e83-897">가입된 총 IGMP 현재 그룹</span><span class="sxs-lookup"><span data-stu-id="c7e83-897">Total IGMP Current Groups Joined</span></span> 

<span data-ttu-id="c7e83-898">이러한 모든 통계 및 오류 보고서는 애플리케이션이 ***nx_igmp_info_get*** 서비스를 사용하여 이용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-898">All these statistics and error reports are available to the application with the ***nx_igmp_info_get*** service.</span></span> 

### <a name="multicast-without-igmp"></a><span data-ttu-id="c7e83-899">IGMP를 사용하지 않은 멀티캐스트</span><span class="sxs-lookup"><span data-stu-id="c7e83-899">Multicast without IGMP</span></span>  
<span data-ttu-id="c7e83-900">IPv4 멀티캐스트 트래픽이 예상되는 애플리케이션은 ***nx_ipv4_multicast_interface_join*** 서비스를 사용하여 IGMP 메시지를 호출하지 않고 멀티캐스트 그룹 주소에 가입할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-900">Application expecting IPv4 multicast traffic can join a multicast group address without invoking IGMP messages by using the service ***nx_ipv4_multicast_interface_join***.</span></span> <span data-ttu-id="c7e83-901">이 서비스는 지정된 IPv4 멀티캐스트 주소의 패킷을 허용하도록 IPv4 계층 및 기본 인터페이스 드라이버에 지시합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-901">This service instructs the IPv4 layer and the underlying interface driver to accept packets from the designated IPv4 multicast address.</span></span> <span data-ttu-id="c7e83-902">그러나 이 그룹에 대해 전송하거나 처리 중인 IGMP 그룹 관리 메시지는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-902">However there is no IGMP group management messages being sent or processed for this group.</span></span>

<span data-ttu-id="c7e83-903">애플리케이션은 ***nx_ipv4_multicast_interface_leave*** 서비스를 사용할 수 있는 그룹으로부터 더 이상 트래픽을 수신하지 않으려 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-903">Application no longer wish to receive traffic from the group can use the service ***nx_ipv4_multicast_interface_leave.***</span></span>

## <a name="ipv6-in-netx-duo"></a><span data-ttu-id="c7e83-904">NetX Duo의 IPv6</span><span class="sxs-lookup"><span data-stu-id="c7e83-904">IPv6 in NetX Duo</span></span>

### <a name="ipv6-addresses"></a><span data-ttu-id="c7e83-905">IPv6 주소</span><span class="sxs-lookup"><span data-stu-id="c7e83-905">IPv6 Addresses</span></span>   
<span data-ttu-id="c7e83-906">IPv6 주소는 128비트입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-906">IPv6 addresses are 128 bits.</span></span> <span data-ttu-id="c7e83-907">IPv6 주소의 아키텍처는 RFC 4291에 설명되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-907">The architecture of IPv6 address is described in RFC 4291.</span></span> <span data-ttu-id="c7e83-908">주소는 가장 중요한 비트를 포함하는 접두사와 낮은 비트를 포함하는 호스트 주소로 구분됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-908">The address is divided into a prefix containing the most significant bits and a host address containing the lower bits.</span></span> <span data-ttu-id="c7e83-909">접두사는 주소 형식을 나타내며 IPv4 네트워크의 네트워크 주소와 거의 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-909">The prefix indicates the type of address and is roughly the equivalent of the network address in IPv4 network.</span></span>

<span data-ttu-id="c7e83-910">IPv6에는 유니캐스트, 애니캐스트(NetX Duo에서 지원되지 않음), 멀티캐스트의 세 가지 형식의 주소 사양이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-910">IPv6 has three types of address specifications: unicast, anycast (not supported in NetX Duo), and multicast.</span></span> <span data-ttu-id="c7e83-911">유니캐스트 주소는 인터넷에서 특정 호스트를 식별하는 IP 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-911">Unicast addresses are those IP addresses that identify a specific host on the Internet.</span></span> <span data-ttu-id="c7e83-912">유니캐스트 주소는 소스 또는 대상 IP 주소일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-912">Unicast addresses can be either a source or a destination IP address.</span></span> <span data-ttu-id="c7e83-913">멀티캐스트 주소는 인터넷에 있는 동적 호스트 그룹을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-913">Multicast addresses specify a dynamic group of hosts on the Internet.</span></span> <span data-ttu-id="c7e83-914">멀티캐스트 그룹의 멤버는 언제든지 가입하고 탈퇴할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-914">Members of the multicast group may join and leave whenever they wish.</span></span>

<span data-ttu-id="c7e83-915">IPv6에는 IPv4 브로드캐스트 메커니즘과 동등한 기능이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-915">IPv6 does not have the equivalent of the IPv4 broadcast mechanism.</span></span> <span data-ttu-id="c7e83-916">모든 호스트에 패킷을 보내는 기능은 링크-로컬 모든 호스트 멀티캐스트 그룹에 패킷을 전송함으로써 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-916">The ability to send a packet to all hosts can be achieved by sending a packet to the link-local all hosts multicast group.</span></span>

<span data-ttu-id="c7e83-917">IPv6는 멀티캐스트 주소를 활용하여 인접 노드 검색, 라우터 검색 및 상태 비저장 주소 자동 구성 프로시저를 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-917">IPv6 utilizes multicast addresses to perform Neighbor Discovery, Router Discovery, and Stateless Address Auto Configuration procedures.</span></span>

<span data-ttu-id="c7e83-918">IPv6 유니캐스트 주소에는 두 가지 형식이 있습니다. 일반적으로 잘 알려진 링크 로컬 접두사와 인터페이스 MAC 주소를 결합하여 구성된 링크 로컬 주소 형식과 접두사 부분과 호스트 ID 부분을 포함하는 글로벌 IP 주소 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-918">There are two types of IPv6 unicast addresses: link local addresses, typically constructed by combining the well-known link local prefix with the interface MAC address, and global IP addresses, which also has the prefix portion and the host ID portion.</span></span> <span data-ttu-id="c7e83-919">글로벌 주소는 수동으로 구성하거나 상태 비저장 주소 자동 구성 또는 DHCPv6를 통해 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-919">A global address may be configured manually, or through the Stateless Address Autoconfiguration or DHCPv6.</span></span> <span data-ttu-id="c7e83-920">NetX Duo는 링크 로컬 주소와 글로벌 주소를 모두 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-920">NetX Duo supports both link local address and global address.</span></span>

<span data-ttu-id="c7e83-921">IPv4 및 IPv6 형식을 모두 수용하기 위해 NetX Duo는 IPv4 및 IPv6 주소를 유지하기 위한 새로운 데이터 형식 NXD_ADDRESS를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-921">To accommodate both IPv4 and IPv6 formats, NetX Duo provides a new data type, NXD_ADDRESS, for holding IPv4 and IPv6 addresses.</span></span> <span data-ttu-id="c7e83-922">이 구조에 대한 설명은 아래에 나와 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-922">The definition of this structure is shown below.</span></span> <span data-ttu-id="c7e83-923">주소 필드는 IPv4 및 IPv6 주소 공용입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-923">The address field is a union of IPv4 and IPv6 addresses.</span></span>

```c
typedef struct NXD_ADDRESS_STRUCT
{
    ULONG nxd_ip_version;
    union
    {
        ULONG v4;
        ULONG v6[4];
    } nxd_ip_address;
} NXD_ADDRESS;
```

<span data-ttu-id="c7e83-924">NXD_ADDRESS 구조에서 첫 번째 요소인 *nxd_ip_version* 은 IPv4 또는 IPv6 버전을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-924">In the NXD_ADDRESS structure, the first element, *nxd_ip_version*, indicates IPv4 or IPv6 version.</span></span> <span data-ttu-id="c7e83-925">지원되는 값은 NX_IP_VERSION_V4 또는 NX_IP_VERSION_V6입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-925">Supported values are either NX_IP_VERSION_V4 or NX_IP_VERSION_V6.</span></span> <span data-ttu-id="c7e83-926">*nxd_ip_version* 은 *nxd_ip_address* union에서 IP 주소로 사용할 필드를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-926">*nxd_ip_version* indicates which field in the *nxd_ip_address* union to use as the IP address.</span></span> <span data-ttu-id="c7e83-927">NetX Duo API 서비스는 일반적으로 ULONG(32비트) IP 주소 대신 입력 인수로 NXD_ADDRESS 구조에 대한 포인터를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-927">NetX Duo API services typically take a pointer to NXD_ADDRESS structure as input argument in lieu of the ULONG (32 bit) IP address.</span></span>

### <a name="link-local-addresses"></a><span data-ttu-id="c7e83-928">링크 로컬 주소</span><span class="sxs-lookup"><span data-stu-id="c7e83-928">Link Local Addresses</span></span>     
<span data-ttu-id="c7e83-929">링크-로컬 주소는 로컬 네트워크에서만 유효합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-929">A link-local address is only valid on the local network.</span></span> <span data-ttu-id="c7e83-930">디바이스는 유효한 링크 로컬 주소를 할당한 후 동일한 네트워크의 다른 디바이스로 패킷을 주고받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-930">A device can send and receive packets to another device on the same network after a valid link local address is assigned to it.</span></span> <span data-ttu-id="c7e83-931">애플리케이션에서는 접두사 길이 매개 변수가 10으로 설정된 NetX Duo 서비스 ***nxd_ipv6_address_set*** 을 호출하여 링크-로컬 주소를 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-931">An application assigns a link-local address by calling the NetX Duo service ***nxd_ipv6_address_set***, with the prefix length parameter set to 10.</span></span> <span data-ttu-id="c7e83-932">애플리케이션은 서비스에 링크-로컬 주소를 제공하거나, 단순히 NX_NULL을 링크-로컬 주소로 사용하고 NetX Duo가 디바이스의 MAC 주소를 기반으로 링크-로컬 주소를 생성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-932">The application may supply a link-local address to the service, or it may simply use NX_NULL as the link-local address and allow NetX Duo to construct a link-local address based on the device's MAC address.</span></span>

<span data-ttu-id="c7e83-933">다음 예에서는 NetX Duo가 MAC 주소를 사용하여 기본 디바이스(인덱스 0)에서 접두사 길이가 10인 링크-로컬 주소를 구성하도록 지시합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-933">The following example instructs NetX Duo to configure the link-local address with a prefix length of 10 on the primary device (index 0) using its MAC address:</span></span>

```c
nxd_ipv6_address_set(ip_ptr, 0, NX_NULL, 10, NX_NULL);
```
<span data-ttu-id="c7e83-934">위의 예에서 인터페이스의 MAC 주소가 54:32:10:1A:BC:67인 경우 해당 링크- 로컬 주소는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-934">In the example above, if the MAC address of the interface is 54:32:10:1A:BC:67, the corresponding link-local address would be:</span></span>

```c
FE80::5632:10FF:FE1A:BC67
```
<span data-ttu-id="c7e83-935">IPv6 주소(**5632:10FF:FE1A:BC67**)의 호스트 ID 부분은 다음과 같은 수정 사항을 포함하여 6바이트 MAC 주소로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-935">Note that the host ID portion of the IPv6 address (**5632:10FF:FE1A:BC67**) is made up of the 6-byte MAC address, with the following modifications:</span></span>

- <span data-ttu-id="c7e83-936">MAC 주소의 바이트 3과 바이트 4 사이에 **0xFFFE** 삽입됨</span><span class="sxs-lookup"><span data-stu-id="c7e83-936">**0xFFFE** inserted between byte 3 and byte 4 of the MAC address</span></span>
- <span data-ttu-id="c7e83-937">MAC 주소(U/L 비트)의 첫 번째 바이트의 두 번째로 낮은 비트가 1로 설정됨</span><span class="sxs-lookup"><span data-stu-id="c7e83-937">Second lowest bit of the first byte of the MAC address (U/L bit) is set to 1</span></span>

<span data-ttu-id="c7e83-938">인터페이스 MAC 주소에서 IPv6 주소의 호스트 부분을 구성하는 방법에 대한 자세한 내용은 RFC 2464(이더넷 네트워크를 통한 IPv6 패킷 전송)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="c7e83-938">Refer to RFC 2464 (Transmission of IPv6 Packets over Ethernet Network) for more information on how to construct the host portion of an IPv6 address from its interface MAC address.</span></span>

<span data-ttu-id="c7e83-939">IPv6에서 하나 이상의 호스트로 멀티캐스트 메시지를 전송하기 위한 몇 가지 특수한 멀티캐스트 주소가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-939">There are a few special multicast addresses for sending multicast messages to one or more hosts in IPv6:</span></span>

| <span data-ttu-id="c7e83-940">그룹</span><span class="sxs-lookup"><span data-stu-id="c7e83-940">Group</span></span>  | <span data-ttu-id="c7e83-941">주소</span><span class="sxs-lookup"><span data-stu-id="c7e83-941">Address</span></span>   | <span data-ttu-id="c7e83-942">Description</span><span class="sxs-lookup"><span data-stu-id="c7e83-942">Description</span></span>  |
|---|---|---|
|<span data-ttu-id="c7e83-943">모든 노드 그룹</span><span class="sxs-lookup"><span data-stu-id="c7e83-943">All nodes group</span></span> |<span data-ttu-id="c7e83-944">**FF02::1**</span><span class="sxs-lookup"><span data-stu-id="c7e83-944">**FF02::1**</span></span> |<span data-ttu-id="c7e83-945">로컬 네트워크의 모든 호스트</span><span class="sxs-lookup"><span data-stu-id="c7e83-945">All hosts on the local network</span></span>|
|<span data-ttu-id="c7e83-946">모든 라우터 그룹</span><span class="sxs-lookup"><span data-stu-id="c7e83-946">All routers group</span></span> |<span data-ttu-id="c7e83-947">**FF02::2**</span><span class="sxs-lookup"><span data-stu-id="c7e83-947">**FF02::2**</span></span> |<span data-ttu-id="c7e83-948">로컬 네트워크의 모든 라우터</span><span class="sxs-lookup"><span data-stu-id="c7e83-948">All routers on the local network</span></span>|
|<span data-ttu-id="c7e83-949">요청된 노드</span><span class="sxs-lookup"><span data-stu-id="c7e83-949">Solicited-node</span></span> |<span data-ttu-id="c7e83-950">**FF02::1:FF00:0/104**</span><span class="sxs-lookup"><span data-stu-id="c7e83-950">**FF02::1:FF00:0/104**</span></span> |<span data-ttu-id="c7e83-951">아래 설명을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="c7e83-951">Explained below</span></span>|

<span data-ttu-id="c7e83-952">요청된 노드 멀티캐스트 주소는 모든 IPv6 호스트가 아닌 로컬 링크의 특정 호스트를 대상으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-952">A solicited-node multicast address targets specific hosts on the local link rather than all the IPv6 hosts.</span></span> <span data-ttu-id="c7e83-953">104비트인 접두사 **FF02::1:FF00:0/104** 와 대상 IPv6 주소의 마지막 24비트로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-953">It consists of the prefix **FF02::1:FF00:0/104**, which is 104 bits and the last 24-bits of the target IPv6 address.</span></span> <span data-ttu-id="c7e83-954">예를 들어, IPv6 주소 **205B:209D:D028::F058:D1C8:1024** 에는 주소 **FF02::1:FFC8:1024** 의 요청된 노드 멀티캐스트 주소가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-954">For example, an IPv6 address **205B:209D:D028::F058:D1C8:1024** has a solicitednode multicast address of address **FF02::1:FFC8:1024**.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="c7e83-955">이중 콜론 표기법은 중간 비트가 모두 0임을 나타냅니다. 완전히 확장된 **FF02::1:FF00:0/104** 는 **FF02:0000:0000:0000:0000:0001:FF00:0000** 과 같이 보입니다. </span><span class="sxs-lookup"><span data-stu-id="c7e83-955">*The double colon notation indicates the intervening bits are all zeroes. **FF02::1:FF00:0/104** fully expanded looks like* **FF02:0000:0000:0000:0000:0001:FF00:0000**</span></span>

### <a name="global-addresses"></a><span data-ttu-id="c7e83-956">글로벌 주소</span><span class="sxs-lookup"><span data-stu-id="c7e83-956">Global Addresses</span></span>    
<span data-ttu-id="c7e83-957">IPv6 글로벌 주소의 예는 **2001:0123:4567:89AB:CDEF::1** 입니다. NetX Duo는 IPv6 주소를 NXD_ADDRESS 구조에 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-957">An example of an IPv6 global address is **2001:0123:4567:89AB:CDEF::1** NetX Duo stores IPv6 addresses in the NXD_ADDRESS structure.</span></span> <span data-ttu-id="c7e83-958">아래 예에서 NXD_ADDRESS 변수 **global_ipv6_address** 에 유니캐스트 IPv6 주소가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-958">In the example below, the NXD_ADDRESS variable **global_ipv6_address** contains a unicast IPv6 address.</span></span> <span data-ttu-id="c7e83-959">다음 예에서는 NetX Duo 디바이스가 기본 디바이스의 특정 IPv6 글로벌 주소를 만드는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-959">The following example demonstrates a NetX Duo device creating a specific IPv6 global address for its primary device:</span></span>

```c
NXD_ADDRESS global_ipv6_address;
UINT        primary_interface_index = 0;

global_ipv6_address.nxd_ip_version = NX_IP_VERSION_V6;
global_ipv6_address.nxd_ip_address.v6[0] = 0x20010123;
global_ipv6_address.nxd_ip_address.v6[1] = 0x456789AB;
global_ipv6_address.nxd_ip_address.v6[2] = 0xCDEF0000;
global_ipv6_address.nxd_ip_address.v6[3] = 0x00000001;

status = nxd_ipv6_address_set(
            &ip_0,
            primary_interface_index,
            &global_ipv6_address,
            64,
            NX_NULL);
```
<span data-ttu-id="c7e83-960">이 IPv6 주소의 접두사는 **2001:0123:4567:89AB** 이며 길이는 64비트로서 이더넷의 글로벌 유니캐스트 IPv6 주소에 대한 일반적인 접두사 길이입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-960">Note that the prefix of this IPv6 address is **2001:0123:4567:89AB**, which is 64 bits long and is a common prefix length for global unicast IPv6 addresses on Ethernet.</span></span>

<span data-ttu-id="c7e83-961">또한 NXD_ADDRESS 구조에는 IPv4 주소도 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-961">The NXD_ADDRESS structure also holds IPv4 addresses.</span></span> <span data-ttu-id="c7e83-962">global_ipv4_address에 저장된 **192.1.168.10**(**0xC001A80A**)의 IP 주소는 다음과 같은 메모리 레이아웃을 갖습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-962">An IP address of **192.1.168.10** (**0xC001A80A**) stored in global_ipv4_address would have the following memory layout:</span></span>

|<span data-ttu-id="c7e83-963">필드</span><span class="sxs-lookup"><span data-stu-id="c7e83-963">Field</span></span> |<span data-ttu-id="c7e83-964">값</span><span class="sxs-lookup"><span data-stu-id="c7e83-964">Value</span></span> |
|---|---|
|<span data-ttu-id="c7e83-965">global_ipv4_address.nxd_ip_version</span><span class="sxs-lookup"><span data-stu-id="c7e83-965">global_ipv4_address.nxd_ip_version</span></span> |<span data-ttu-id="c7e83-966">NX_IP_VERSION_V4</span><span class="sxs-lookup"><span data-stu-id="c7e83-966">NX_IP_VERSION_V4</span></span>|
|<span data-ttu-id="c7e83-967">global_ipv4_address.nxd_ip_address.v4</span><span class="sxs-lookup"><span data-stu-id="c7e83-967">global_ipv4_address.nxd_ip_address.v4</span></span> |<span data-ttu-id="c7e83-968">0xC001A80A</span><span class="sxs-lookup"><span data-stu-id="c7e83-968">0xC001A80A</span></span>|

<span data-ttu-id="c7e83-969">애플리케이션이 NetX Duo 서비스에 주소를 전달할 때 *nxd_ip_version* 필드는 적절한 패킷 처리를 위한 올바른 IP 버전을 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-969">When an application passes an address to NetX Duo services, the *nxd_ip_version* field must specify the correct IP version for proper packet handling.</span></span>

<span data-ttu-id="c7e83-970">기존 NetX 애플리케이션이 이전 버전과의 호환을 위해 NetX Duo는 모든 NetX 서비스를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-970">To be backward compatible with existing NetX applications, NetX Duo supports all NetX services.</span></span> <span data-ttu-id="c7e83-971">내부적으로 NetX Duo는 IPv4 주소 형식 ULONG을 NXD_ADDRESS 데이터 형식으로 변환한 후 실제 NetX Duo 서비스로 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-971">Internally, NetX Duo converts the IPv4 address type ULONG to an NXD_ADDRESS data type before forwarding it to the actual NetX Duo service.</span></span>

<span data-ttu-id="c7e83-972">다음 예에서는 NetX와 NetX Duo의 서비스 간 유사성과 차이점을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-972">The following example illustrates the similarity and the differences between services in NetX and NetX Duo.</span></span>

```c
/* Make a connection to the destination IPv4 address
   192.1.168.12 through an already created TCP socket bound
   to the well known HTTP port number 80. */

global_ipv4_address.nxd_ip_version = NX_IP_VERSION_V4;
global_ipv4_address.nxd_ip_address.v4 = 0xC001A80C;

nxd_tcp_client_socket_connect(&tcp_socket,
                              &global_ipv4_address,
                              port_number,
                              NX_WAIT_FOREVER);
```

<span data-ttu-id="c7e83-973">다음은 동일한 NetX API입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-973">The following is the equivalent NetX API:</span></span>

```c
ULONG         server_ip = 0xC001A80C;
NX_TCP_SOCKET tcp_socket;
UINT          port_number = 80;

nx_tcp_client_socket_connect(&tcp_socket,
                             server_ip,
                             port_number,
                             NX_WAIT_FOREVER); 
```

> [!IMPORTANT]
> <span data-ttu-id="c7e83-974">애플리케이션 개발자는 이러한 API의 nxd 버전을 사용하도록 권장됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-974">*Application developers are encouraged to use the nxd version of these APIs*.</span></span>

### <a name="ipv6-default-routers"></a><span data-ttu-id="c7e83-975">IPv6 기본 라우터</span><span class="sxs-lookup"><span data-stu-id="c7e83-975">IPv6 Default Routers</span></span>    
<span data-ttu-id="c7e83-976">IPv6는 기본 라우터를 사용하여 오프 링크 대상에 패킷을 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-976">IPv6 uses a default router to forward packets to offlink destinations.</span></span> <span data-ttu-id="c7e83-977">NetX Duo 서비스 ***nxd_ipv6_default_router_add*** 를 사용하면 애플리케이션에서 IPv6 라우터를 기본 라우터 테이블에 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-977">The NetX Duo service ***nxd_ipv6_default_router_add*** enables an application to add an IPv6 router to the default router table.</span></span> <span data-ttu-id="c7e83-978">NetX Duo에서 제공하는 기본적인 라우터 서비스는 4장 “서비스 설명”을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="c7e83-978">See Chapter 4 "Description of Services" for more default router services offered by NetX Duo.</span></span>  

<span data-ttu-id="c7e83-979">IPv6 패킷을 전달할 때 NetX Duo는 먼저 패킷 대상이 온-링크인지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-979">When forwarding IPv6 packets, NetX Duo first checks if the packet destination is on-link.</span></span> <span data-ttu-id="c7e83-980">그러지 않은 경우 NetX Duo는 기본 라우팅 테이블에서 오프-링크 패킷을 전달할 유효한 라우터를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-980">If not, NetX Duo checks the default routing table for a valid router to forward the off-link packet to.</span></span>  

<span data-ttu-id="c7e83-981">IPv6 기본 라우터 테이블에서 라우터를 제거하려면 애플리케이션은 \***nxd_ipv6_default_router_delete** _ 서비스를 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-981">To remove a router from the IPv6 default router table, application shall use the service \***nxd_ipv6_default_router_delete** _.</span></span> <span data-ttu-id="c7e83-982">IPv6 기본 라우터 테이블의 항목을 가져오려면 _*_nxd_ipv6_default_router_entry_get_*\* 서비스를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-982">To obtain entries of the IPv6 default router table, use the service _\*_nxd_ipv6_default_router_entry_get_\*\*.</span></span>

### <a name="ipv6-header"></a><span data-ttu-id="c7e83-983">IPv6 헤더</span><span class="sxs-lookup"><span data-stu-id="c7e83-983">IPv6 Header</span></span>    
<span data-ttu-id="c7e83-984">IPv6 헤더가 IPv4 헤더에서 수정되었습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-984">The IPv6 header has been modified from the IPv4 header.</span></span> <span data-ttu-id="c7e83-985">패킷을 할당할 때 호출자는 애플리케이션 프로토콜(예: UDP, TCP), 버퍼 크기(바이트), 홉 제한을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-985">When allocating a packet, the caller specifies the application protocol (e.g., UDP, TCP), buffer size in bytes, and hop limit.</span></span>   

<span data-ttu-id="c7e83-986">그림 9는 IPv6 헤더의 형식을 보여주며 표에는 헤더 구성 요소가 나열되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-986">Figure 9 shows the format of the IPv6 header and the table lists the header components.</span></span>

![IPv6 헤더 형식 다이어그램입니다.](./media/user-guide/image18.png)

<span data-ttu-id="c7e83-988">**그림 9. IPv6 헤더 형식**</span><span class="sxs-lookup"><span data-stu-id="c7e83-988">**FIGURE 9. IPv6 Header Format**</span></span>

|<span data-ttu-id="c7e83-989">IP 헤더</span><span class="sxs-lookup"><span data-stu-id="c7e83-989">IP header</span></span> | <span data-ttu-id="c7e83-990">목적</span><span class="sxs-lookup"><span data-stu-id="c7e83-990">Purpose</span></span> |
|---|---|
|<span data-ttu-id="c7e83-991">버전</span><span class="sxs-lookup"><span data-stu-id="c7e83-991">Version</span></span> |<span data-ttu-id="c7e83-992">IP 버전의 4비트 필드입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-992">4-bit field for IP version.</span></span> <span data-ttu-id="c7e83-993">IPv6 네트워크의 경우 이 필드의 값은 6이어야 하며 IPv4 네트워크의 경우 4여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-993">For IPv6 networks, the value in this field must be 6; For IPv4 networks it must be 4.</span></span>|
|<span data-ttu-id="c7e83-994">트래픽 클래스</span><span class="sxs-lookup"><span data-stu-id="c7e83-994">Traffic Class</span></span> |<span data-ttu-id="c7e83-995">트래픽 클래스 정보를 저장하는 8비트 필드입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-995">8-bit field that stores the traffic class information.</span></span> <span data-ttu-id="c7e83-996">이 필드는 NetX Duo에서 사용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-996">This field is not used by NetX Duo.</span></span>|
|<span data-ttu-id="c7e83-997">흐름 레이블</span><span class="sxs-lookup"><span data-stu-id="c7e83-997">Flow Label</span></span> |<span data-ttu-id="c7e83-998">패킷이 연결된 흐름(있는 경우)을 고유하게 식별하는 20비트 필드입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-998">20-bit field to uniquely identify the flow, if any, that a packet is associated with.</span></span> <span data-ttu-id="c7e83-999">값이 0이면 패킷이 특정 흐름에 속하지 않음을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-999">A value of zero indicates the packet does not belong to a particular flow.</span></span> <span data-ttu-id="c7e83-1000">이 필드는 IPv4의 *TOS* 필드를 대체합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1000">This field replaces the *TOS* field in IPv4.</span></span>|
|<span data-ttu-id="c7e83-1001">페이로드 길이</span><span class="sxs-lookup"><span data-stu-id="c7e83-1001">Payload Length</span></span> |<span data-ttu-id="c7e83-1002">IPv6 기본 헤더 뒤에 있는 IPv6 패킷의 바이트 단위의 데이터 양을 나타내는 16비트 필드입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1002">16-bit field indicating the amount of data in bytes of the IPv6 packet following the IPv6 base header.</span></span> <span data-ttu-id="c7e83-1003">여기에는 모든 캡슐화된 프로토콜 헤더와 데이터가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1003">This includes all encapsulated protocol header and data.</span></span>|
|<span data-ttu-id="c7e83-1004">다음 헤더</span><span class="sxs-lookup"><span data-stu-id="c7e83-1004">Next Header</span></span> | <span data-ttu-id="c7e83-1005">IPv6 기본 헤더 뒤에 오는 확장 헤더의 형식을 나타내는 8비트 필드입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1005">8-bit field indicating the type of the extension header that follows the IPv6 base header.</span></span> <span data-ttu-id="c7e83-1006">이 필드는 IPv4의 ‘프로토콜’ 필드를 대체합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1006">This field replaces the *Protocol* field in IPv4.</span></span>|
|<span data-ttu-id="c7e83-1007">홉 제한</span><span class="sxs-lookup"><span data-stu-id="c7e83-1007">Hop Limit</span></span> |<span data-ttu-id="c7e83-1008">패킷이 통과할 수 있는 라우터 수를 제한하는 8비트 필드입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1008">8-bit field that limits the number of routers the packet is allowed to go through.</span></span> <span data-ttu-id="c7e83-1009">이 필드는 IPv4의 *TTL* 필드를 대체합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1009">This field replaces the *TTL* field in IPv4.</span></span>|
|<span data-ttu-id="c7e83-1010">소스 주소</span><span class="sxs-lookup"><span data-stu-id="c7e83-1010">Source Address</span></span> |<span data-ttu-id="c7e83-1011">보낸 사람의 IPv6 주소를 저장하는 128비트 필드입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1011">128-bit field that stores the IPv6 address of the sender.</span></span>|
|<span data-ttu-id="c7e83-1012">대상 주소</span><span class="sxs-lookup"><span data-stu-id="c7e83-1012">Destination Address</span></span> |<span data-ttu-id="c7e83-1013">대상의 IPv6 주소를 저장하는 128비트 필드입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1013">128-bit field that sores the IPv6 address of the destination.</span></span>|

### <a name="enabling-ipv6-in-netx-duo"></a><span data-ttu-id="c7e83-1014">NetX Duo에서 IPv6 사용</span><span class="sxs-lookup"><span data-stu-id="c7e83-1014">Enabling IPv6 in NetX Duo</span></span>    
<span data-ttu-id="c7e83-1015">기본적으로 IPv6는 NetX Duo에서 사용하도록 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1015">By default IPv6 is enabled in NetX Duo.</span></span> <span data-ttu-id="c7e83-1016">구성 가능한 옵션 ***NX_DISABLE_IPV6** _가 _nx_user.h*에서 정의되지 않은 경우 IPv6 서비스는 NetX Duo에서 사용할 수 있도록 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1016">IPv6 services are enabled in NetX Duo if the configurable option ***NX_DISABLE_IPV6** _ in _nx_user.h* is not defined.</span></span> <span data-ttu-id="c7e83-1017">***NX_DISABLE_IPV6*** 가 정의되면 NetX Duo는 IPv4 서비스만 제공할 뿐 모든 IPv6 관련 모듈과 서비스는 NetX Duo 라이브러리에 기본 제공되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1017">If ***NX_DISABLE_IPV6*** is defined, NetX Duo will only offer IPv4 services, and all the IPv6-related modules and services are not built into NetX Duo library.</span></span>

<span data-ttu-id="c7e83-1018">디바이스 IPv6 주소를 구성하는 애플리케이션에 대해 다음 서비스가 제공됩니다. ***nxd_ipv6_address_set***</span><span class="sxs-lookup"><span data-stu-id="c7e83-1018">The following service is provided for applications to configure the device IPv6 address: ***nxd_ipv6_address_set***</span></span>

<span data-ttu-id="c7e83-1019">시스템은 디바이스의 IPv6 주소를 수동으로 설정할 뿐 아니라 상태 비저장 주소 자동 구성도 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1019">In addition to manually setting the device's IPv6 addresses, the system may also use Stateless Address Autoconfiguration.</span></span> <span data-ttu-id="c7e83-1020">이 옵션을 사용하려면 애플리케이션에서 \***nxd_ipv6_enable** _을 호출하여 디바이스에서 IPv6 서비스를 시작해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1020">To use this option, the application must call \***nxd_ipv6_enable** _ to start IPv6 services on the device.</span></span> <span data-ttu-id="c7e83-1021">또한 _*_nxd_icmp_enable_*_ 을 호출하여 ICMPv6 서비스를 시작해야 하며 이를 통해 NetX Duo에서 라우터 요청, 인접 노드 검색, 중복 주소 검색 등의 서비스를 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1021">In addition, ICMPv6 services must be started by calling _*_nxd_icmp_enable_*_, which enables NetX Duo to perform services such as Router Solicitation, Neighbor Discovery, and Duplicate Address Detection.</span></span> <span data-ttu-id="c7e83-1022">_*_nx_icmp_enable_*_ 은 IPv4 서비스에 대해서만 ICMP를 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1022">Note that _*_nx_icmp_enable_*_ only starts ICMP for IPv4 services.</span></span> <span data-ttu-id="c7e83-1023">_*_nxd_icmp_enable_*_ 은 IPv4 및 IPv6 모두에 대해 ICMP 서비스를 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1023">_*_nxd_icmp_enable_*_ starts ICMP services for both IPv4 and IPv6.</span></span> <span data-ttu-id="c7e83-1024">시스템에 ICMPv6 서비스가 필요하지 않은 경우 _ \*_nx_icmp_enable_\*\*을 사용하여 ICMPv6 모듈이 시스템에 연결되지 않도록 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1024">If the system does not need ICMPv6 services, then _ *_nx_icmp_enable_*\* can be used so the ICMPv6 module is not linked into the system.</span></span>

<span data-ttu-id="c7e83-1025">다음 예는 일반적인 NetX Duo IPv6 초기화 프로시저를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1025">The following example shows a typical NetX Duo IPv6 initialization procedure.</span></span>

```c
/* Assume ip_0 has been created and IPv4 services (such as ARP,
   ICMP, have been enabled. */
#define SECONDARY_INTERFACE 1

/* Enable IPv6 */
status = nxd_ipv6_enable(&ip_0);

if(status != NX_SUCCESS)
{
    /* nxd_ipv6_enable failed. */
}

/* Enable ICMPv6 */
status = nxd_icmp_enable(&ip_0);
if(status != NX_SUCCESS)
{
    /* nxd_icmp_enable failed. */
}

/* Configure the link local address on the primary interface. */
status = nxd_ipv6_address_set(&ip_0, 0, NX_NULL, 10, NX_NULL);

/* Configure ip_0 primary interface global address. */
ip_address.nxd_ip_version = NX_IP_VERSION_V6
ip_address.nxd_ip_address.v6[0] = 0x20010db8;
ip_address.nxd_ip_address.v6[1] = 0x0000f101;
ip_address.nxd_ip_address.v6[2] = 0;
ip_address.nxd_ip_address.v6[3] = 0x202;

/* Configure global address of the primary interface. */
status = nxd_ipv6_address_set(&ip_0, SECONDARY_INTERFACE,
                              &ip_address, 64, NX_NULL);
```                              

<span data-ttu-id="c7e83-1026">상위 계층 프로토콜(예: TCP 및 UDP)은 IPv6 시작 전이나 후에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1026">Upper layer protocols (such as TCP and UDP) can be enabled either before or after IPv6 starts.</span></span>

> [!IMPORTANT]  
> <span data-ttu-id="c7e83-1027">IPv6 서비스는 IP 스레드를 초기화하고 디바이스가 사용하도록 설정된 후에만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1027">*IPv6 services are available only after IP thread is initialized and the device is enabled.*</span></span>

<span data-ttu-id="c7e83-1028">인터페이스를 사용하도록 설정한 후(즉, 인터페이스 디바이스 드라이버가 데이터를 주고받을 준비가 되어 있고 유효한 링크 로컬 주소를 가져온 경우) 디바이스는 다음 방법의 하나로 글로벌 IPv6 주소를 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1028">After the interface is enabled (i.e.,the interface device driver is ready to send and receive data, and a valid link local address has been obtained), the device may obtain global IPv6 addresses by one of the these methods:</span></span>

- <span data-ttu-id="c7e83-1029">상태 비저장 주소 자동 구성</span><span class="sxs-lookup"><span data-stu-id="c7e83-1029">Stateless Address Auto Configuration;</span></span>  
- <span data-ttu-id="c7e83-1030">수동 IPv6 주소 구성</span><span class="sxs-lookup"><span data-stu-id="c7e83-1030">Manual IPv6 address configuration;</span></span>  
- <span data-ttu-id="c7e83-1031">DHCPv6를 통한 주소 구성(선택 사항인 DHCPv6 패키지 포함)</span><span class="sxs-lookup"><span data-stu-id="c7e83-1031">Address configuration via DHCPv6 (with optional DHCPv6 package)</span></span>

<span data-ttu-id="c7e83-1032">처음 두 가지 방법은 아래에 설명되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1032">The first two methods are described below.</span></span> <span data-ttu-id="c7e83-1033">세 번째 방법(DHCPv6)은 DHCP 패키지에 설명되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1033">The 3rd method (DHCPv6) is described in the DHCP package.</span></span>

### <a name="stateless-address-autoconfiguration-using-router-solicitation"></a><span data-ttu-id="c7e83-1034">라우터 요청을 사용한 상태 비저장 주소 자동 구성</span><span class="sxs-lookup"><span data-stu-id="c7e83-1034">Stateless Address Autoconfiguration Using Router Solicitation</span></span>      
<span data-ttu-id="c7e83-1035">NetX Duo 디바이스는 접두사 정보를 제공하는 라우터를 사용하여 IPv6 네트워크에 연결하면 인터페이스를 자동으로 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1035">NetX Duo devices can configure their interfaces automatically when connected to an IPv6 network with a router that supplies prefix information.</span></span> <span data-ttu-id="c7e83-1036">상태 비저장 주소 자동 구성이 필요한 디바이스는 RS(라우터 요청) 메시지를 전송합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1036">Devices that require Stateless Address Autoconfiguration send out router solicitation (RS) messages.</span></span> <span data-ttu-id="c7e83-1037">네트워크의 라우터는 요청된 RA(라우터 알림) 메시지로 응답합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1037">Routers on the network respond with solicited router advertisement (RA) messages.</span></span> <span data-ttu-id="c7e83-1038">RA 메시지는 링크와 연결된 네트워크 주소를 식별하는 접두사를 보급합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1038">RA messages advertise prefixes that identify the network addresses associated with a link.</span></span> <span data-ttu-id="c7e83-1039">그런 다음 디바이스는 디바이스가 연결된 네트워크에 대한 고유 식별자를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1039">Devices then generate a unique identifier for the network the device is attached to.</span></span> <span data-ttu-id="c7e83-1040">주소는 접두사와 고유 식별자를 결합하여 형성됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1040">The address is formed by combining the prefix and its unique identifier.</span></span> <span data-ttu-id="c7e83-1041">이러한 방식으로 RA 메시지를 수신하면 호스트는 IP 주소를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1041">In this manner on receiving the RA messages, hosts generate their IP address.</span></span> <span data-ttu-id="c7e83-1042">라우터는 주기적으로 원치 않는 RA 메시지를 전송할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1042">Routers may also send periodic unsolicited RA messages.</span></span> 

> [!WARNING]
> <span data-ttu-id="c7e83-1043">NetX Duo를 사용하면 애플리케이션이 런타임에 상태 비저장 주소 자동 구성을 사용하거나 사용하지 않도록 설정할 수 있습니다. 이 기능을 사용하려면 **NX_IPV6_STATELESS_AUTOCONFIG_CONTROL** 이 정의된 상태로 NetX Duo 라이브러리를 컴파일해야 합니다. 이 기능을 사용하도록 설정한 후 애플리케이션이 **nxd_ipv6_stateless_address_autoconfigure_enable** 및 **nxd_ipv6_stateless_address_autocofigure_disable** 을 사용하여 IPv6 상태 비저장 주소 자동 구성을 사용하거나 사용하지 않도록 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1043">*NetX Duo allows an application to enable or disable Stateless Address Autoconfiguration at run time. To enable this feature, NetX Duo library must be compiled with **NX_IPV6_STATELESS_AUTOCONFIG_CONTROL** defined. Once this feature is enabled, applications may use **nxd_ipv6_stateless_address_autoconfigure_enable** and **nxd_ipv6_stateless_address_autocofigure_disable** to enable or disable IPv6 stateless address autoconfiguration*.</span></span>

### <a name="manual-ipv6-address-configuration"></a><span data-ttu-id="c7e83-1044">수동 IPv6 주소 구성</span><span class="sxs-lookup"><span data-stu-id="c7e83-1044">Manual IPv6 Address Configuration</span></span>     
<span data-ttu-id="c7e83-1045">특정 IPv6 주소가 필요한 경우 애플리케이션은 ***nxd_ipv6_address_set*** 을 사용하여 IPv6 주소를 수동으로 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1045">If a specific IPv6 address is needed, the application may use ***nxd_ipv6_address_set*** to manually configure an IPv6 address.</span></span> <span data-ttu-id="c7e83-1046">네트워크 인터페이스에는 여러 IPv6 주소가 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1046">A network interface may have multiple IPv6 addresses.</span></span> <span data-ttu-id="c7e83-1047">그러나 상태 비저장 주소 자동 구성을 통하거나 수동 구성을 통해 얻어진 시스템의 총 IPv6 주소 수는 ***NX_MAX_IPV6_ADDRESSES*** 를 초과할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1047">However keep in mind that the total number of IPv6 addresses in a system, either obtained through Stateless Address Autoconfiguration, or through the Manual Configuration, cannot exceed ***NX_MAX_IPV6_ADDRESSES***.</span></span>

<span data-ttu-id="c7e83-1048">다음 예에서는 ip_0의 기본 인터페이스(디바이스 0)에서 글로벌 주소를 수동으로 구성하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1048">The following example illustrates how to manually configure a global address on the primary interface (device 0) in ip_0:</span></span>

```c
NXD_ADDRESS global_address;
global_address.nxd_ip_version = NX_IP_VERSION_V6;
global_address.nxd_ip_address.v6[0] = 0x20010000;
global_address.nxd_ip_address.v6[1] = 0x00000000;
global_address.nxd_ip_address.v6[2] = 0x00000000;
global_address.nxd_ip_address.v6[3] = 0x0000ABCD;
```

<span data-ttu-id="c7e83-1049">그런 다음 호스트는 다음 NetX Duo 서비스를 호출하여 이 주소를 글로벌 IP 주소로 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1049">The host then calls the following NetX Duo service to assign this address as its global IP address:</span></span>

```c
status = nxd_ipv6_address_set(&ip_0, 0,  
                              &global_address, 64
                              NX_NULL);
```

### <a name="duplicate-address-detection-dad"></a><span data-ttu-id="c7e83-1050">DAD(중복 주소 검색)</span><span class="sxs-lookup"><span data-stu-id="c7e83-1050">Duplicate Address Detection (DAD)</span></span>    
<span data-ttu-id="c7e83-1051">시스템에서 IPv6 주소를 구성하면 주소가 *TENTATIVE* 로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1051">After a system configures its IPv6 address, the address is marked as *TENTATIVE*.</span></span> <span data-ttu-id="c7e83-1052">RFC 4862에 설명된 DAD(중복 주소 검색)를 사용하도록 설정하면 NetX Duo는 이 임시 주소를 대상으로 NS(인접 노드 요청) 메시지를 자동으로 전송합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1052">If Duplicate Address Detection (DAD), described in RFC 4862, is enabled, NetX Duo automatically sends neighbor solicitation (NS) messages with this tentative address as the destination.</span></span> <span data-ttu-id="c7e83-1053">네트워크에 있는 호스트가 주어진 시간 내에 NS 메시지에 응답하지 않으면 해당 주소는 로컬 링크에서 고유한 것으로 간주되고 그 상태는 VALID 상태로 전환됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1053">If no hosts on the network respond to these NS messages within a given period of time, the address is assumed to be unique on the local link, and its state transits to the VALID state.</span></span> <span data-ttu-id="c7e83-1054">이때 애플리케이션은 이 IP 주소를 사용하여 통신을 시작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1054">At this point the application may start using this IP address for communication.</span></span>  

<span data-ttu-id="c7e83-1055">DAD 기능은 ICMPv6 모듈의 일부입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1055">The DAD functionality is part of the ICMPv6 module.</span></span> <span data-ttu-id="c7e83-1056">따라서 새로 구성된 주소가 DAD 프로세스를 통과하려면 애플리케이션이 ICMPv6 서비스를 사용하도록 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1056">Therefore, the application must enable ICMPv6 services before a newly configured address can go through the DAD process.</span></span> <span data-ttu-id="c7e83-1057">또는 NetX Duo 라이브러리 빌드 환경(_*_nx_user.h_*_ 로 정의됨)에서 \***NX_DISABLE_IPV6_DAD** _ 옵션을 정의하여 DAD 프로세스를 해제할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1057">Alternatively, the DAD process may be turned off by defining ***NX_DISABLE_IPV6_DAD** _ option in the NetX Duo library build environment (defined as _*_nx_user.h_\*_).</span></span> <span data-ttu-id="c7e83-1058">DAD 프로세스 중에 _*_NX_IPV6_DAD_TRANSMITS_*_ 매개 변수는 주소가 고유하다는 응답을 수신하지 않고 NetX Duo에서 보낸 NS 메시지 수를 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1058">During the DAD process, the _*_NX_IPV6_DAD_TRANSMITS_*_ parameter determines the number of NS messages sent by NetX Duo without receiving a response to determine that the address is unique.</span></span> <span data-ttu-id="c7e83-1059">기본적으로 RFC 4862에서 권장되며 _ \*_NX_IPV6_DAD_TRANSMITS_\*\*는 3으로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1059">By default and recommended by RFC 4862, _ *_NX_IPV6_DAD_TRANSMITS_*\* is set at 3.</span></span> <span data-ttu-id="c7e83-1060">이 기호를 0으로 설정하면 DAD를 효과적으로 사용하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1060">Setting this symbol to zero effectively disables DAD.</span></span>

<span data-ttu-id="c7e83-1061">애플리케이션이 IPv6 주소를 할당할 때 ICMPv6 또는 DAD를 사용하도록 설정하지 않으면 DAD가 수행되지 않고 NetX Duo는 IPv6 주소의 상태를 즉시 VALID로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1061">If ICMPv6 or DAD is not enabled at the time the application assigns an IPv6 address, DAD is not performed and NetX Duo sets the state of the IPv6 address to VALID immediately.</span></span>

<span data-ttu-id="c7e83-1062">NetX Duo는 해당 링크 로컬 및/또는 글로벌 주소가 유효할 때까지 IPv6 네트워크에서 통신할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1062">NetX Duo cannot communicate on the IPv6 network until its link local and/or global address is valid.</span></span> <span data-ttu-id="c7e83-1063">유효한 주소를 가져온 후, NetX Duo는 구성된 IPv6 주소 또는 활성화된 멀티캐스트 주소 중 하나에 대해 들어오는 패킷의 대상 주소를 일치시키려고 시도합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1063">After a valid address is obtained, NetX Duo attempts to match the destination address of an incoming packet against one of its configured IPv6 address or an enabled multicast address.</span></span> <span data-ttu-id="c7e83-1064">일치하는 항목이 없으면 패킷이 삭제됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1064">If no matches are found, the packet is dropped.</span></span> 

> [!WARNING]  
> <span data-ttu-id="c7e83-1065">\*DAD 프로세스 중에 전송할 DAD NS 패킷 수는 \***NX_IPV6_DAD_TRANSMITS**_로 정의되며 기본값은 3으로 설정되고, 기본적으로 각 DAD NS 메시지가 전송되는 사이에 1초 지연이 발생합니다. 따라서 DAD를 사용하는 시스템에서 IPv6 주소가 할당된 후(중복된 주소가 아닌 경우) IP 주소가 VALID 상태로 통신할 준비가 되기까지 약 3초 지연이 발생합니다._</span><span class="sxs-lookup"><span data-stu-id="c7e83-1065">\*During the DAD process, the number of DAD NS packets to be transmitted is defined by \***NX_IPV6_DAD_TRANSMITS**_, which defaults to 3, and by default there is a one second delay between each DAD NS message is sent. Therefore, in a system with DAD enabled, after an IPv6 address is assigned (and assuming this is not a duplicated address), there is approximately 3 seconds delay before the IP address is in a VALID state and is ready for communication._</span></span>

<span data-ttu-id="c7e83-1066">애플리케이션에서 시스템의 IPv6 주소가 변경될 때 알림을 수신하려고 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1066">Applications may want to receive notifications when IPv6 addresses in the system are changed.</span></span> <span data-ttu-id="c7e83-1067">IPv6 주소 변경 알림 기능을 사용하도록 설정하려면 **NX_ENABLE_IPV6_ADDRESS_CHANGE_NOTIFY** 가 정의된 기호를 사용하여 NetX Duo 라이브러리를 빌드해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1067">To enable the IPv6 address change notification feature, the NetX Duo library must be built with the symbol **NX_ENABLE_IPV6_ADDRESS_CHANGE_NOTIFY** defined.</span></span> <span data-ttu-id="c7e83-1068">해당 기능을 사용하도록 설정한 후에는 애플리케이션이 **_nxd_ipv6_address_change_notify_** 서비스를 사용하여 콜백 함수를 설치할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1068">Once the feature is enabled, applications may install the callback function by using the **_nxd_ipv6_address_change_notify_** service.</span></span>

<span data-ttu-id="c7e83-1069">IPv6 주소가 변경되거나 잘못되면 다음 정보를 사용하여 사용자 제공 콜백 함수가 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1069">Once an IPv6 address is changed, or becomes invalid, the user-supplied callback function is invoked with the following information:</span></span>

| <span data-ttu-id="c7e83-1070">기능</span><span class="sxs-lookup"><span data-stu-id="c7e83-1070">Function</span></span>  | <span data-ttu-id="c7e83-1071">Description</span><span class="sxs-lookup"><span data-stu-id="c7e83-1071">Description</span></span>  |
|---|---|
|<span data-ttu-id="c7e83-1072">ip_ptr</span><span class="sxs-lookup"><span data-stu-id="c7e83-1072">ip_ptr</span></span> |<span data-ttu-id="c7e83-1073">IP 인스턴스에 대한 포인터</span><span class="sxs-lookup"><span data-stu-id="c7e83-1073">Pointer to the IP instance</span></span>|
|<span data-ttu-id="c7e83-1074">interface_index</span><span class="sxs-lookup"><span data-stu-id="c7e83-1074">interface_index</span></span> |<span data-ttu-id="c7e83-1075">이 IPv6 주소가 연결된 네트워크 인터페이스에 대한 인덱스</span><span class="sxs-lookup"><span data-stu-id="c7e83-1075">Index to the network interface that this IPv6 address is associated with</span></span>
|<span data-ttu-id="c7e83-1076">ipv6_addr_index</span><span class="sxs-lookup"><span data-stu-id="c7e83-1076">ipv6_addr_index</span></span> |<span data-ttu-id="c7e83-1077">IPv6 주소 테이블에 대한 인덱스</span><span class="sxs-lookup"><span data-stu-id="c7e83-1077">Index to the IPv6 address table</span></span>|
|<span data-ttu-id="c7e83-1078">ipv6_address</span><span class="sxs-lookup"><span data-stu-id="c7e83-1078">ipv6_address</span></span> |<span data-ttu-id="c7e83-1079">4개의 ULONG 정수 배열 형식의 IPv6 주소에 대한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1079">Pointer to the IPv6 address, in the form of an array of four ULONG integers.</span></span> <span data-ttu-id="c7e83-1080">IPv6 주소는 호스트 바이트 순서로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1080">Pv6 addresses are presented in host byte order.</span></span>|

### <a name="ipv6-multicast-support-in-netx-duo"></a><span data-ttu-id="c7e83-1081">NetX Duo의 IPv6 멀티캐스트 지원</span><span class="sxs-lookup"><span data-stu-id="c7e83-1081">IPv6 Multicast Support In NetX Duo</span></span>      
<span data-ttu-id="c7e83-1082">멀티캐스트 주소는 인터넷에 있는 동적 호스트 그룹을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1082">Multicast addresses specify a dynamic group of hosts on the Internet.</span></span> <span data-ttu-id="c7e83-1083">멀티캐스트 그룹의 멤버는 언제든지 가입하고 탈퇴할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1083">Members of the multicast group may join and leave whenever they wish.</span></span> <span data-ttu-id="c7e83-1084">NetX Duo는 IP 멀티캐스트 기능이 필요한 중복 주소 검색, 인접 노드 검색, 라우터 검색을 포함한 여러 ICMPv6 프로토콜을 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1084">NetX Duo implements several ICMPv6 protocols, including Duplicate Address Detection, Neighbor Discovery, and Router Discovery, which require IP multicast capability.</span></span> <span data-ttu-id="c7e83-1085">따라서 NetX Duo는 기본 디바이스 드라이버가 멀티캐스트 작업을 지원할 것으로 예상합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1085">Therefore, NetX Duo expects the underlying device driver to support multicast operations.</span></span>

<span data-ttu-id="c7e83-1086">NetX Duo가 멀티캐스트 그룹(예: 모든 노드 멀티캐스트 주소 및 ‘요청된 노드’ 멀티캐스트 주소)에 가입하거나 이 그룹에서 탈퇴해야 할 때, 멀티캐스트 MAC 주소에 가입하거나 이 주소에서 탈퇴하라는 드라이버 명령을 디바이스 드라이버에 대해 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1086">When NetX Duo needs to join or leave a multicast group (such as the all-node multicast address, and the *solicited-node* multicast address), it issues a driver command to the device driver to join or leave a multicast MAC address.</span></span> <span data-ttu-id="c7e83-1087">멀티캐스트 주소에 가입하라는 드라이버 명령은 \***NX_LINK_MULTICAST_JOIN** _입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1087">The driver command for joining the multicast address is \***NX_LINK_MULTICAST_JOIN** _.</span></span> <span data-ttu-id="c7e83-1088">멀티캐스트 주소에서 탈퇴하기 위해 NetX Duo는 _*_NX_LINK_MULTICAST_LEAVE_*\* 드라이버 명령을 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1088">To leave a multicast address, NetX Duo issues the driver command _\*_NX_LINK_MULTICAST_LEAVE_\*\*.</span></span> <span data-ttu-id="c7e83-1089">ICMPv6 프로토콜이 제대로 작동하려면 디바이스 드라이버가 이 두 명령을 구현해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1089">The device driver must implement these two commands for ICMPv6 protocols to work properly.</span></span>

<span data-ttu-id="c7e83-1090">애플리케이션은 \***nxd_ipv6_multicast_interface_join\*.** 서비스를 사용하여 IPv6 멀티캐스트 그룹에 가입할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1090">Applications may join an IPv6 multicast group by using the service \***nxd_ipv6_multicast_interface_join\*.**</span></span> <span data-ttu-id="c7e83-1091">이 서비스는 IP 스택을 사용하여 멀티캐스트 주소를 등록한 다음, 지정된 디바이스 드라이버에 IPv6 멀티캐스트 주소를 알립니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1091">This service registers the multicast address with the IP stack, and then notifies the specified device driver of the IPv6 multicast address.</span></span> <span data-ttu-id="c7e83-1092">멀티캐스트 그룹에서 탈퇴하기 위해 애플리케이션은 ***nxd_ipv6_multicast_interface_leave*** 서비스를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1092">To leave a multicast group, applications use the service ***nxd_ipv6_multicast_interface_leave.***</span></span>

### <a name="neighbor-discovery-nd"></a><span data-ttu-id="c7e83-1093">ND(인접 노드 검색)</span><span class="sxs-lookup"><span data-stu-id="c7e83-1093">Neighbor Discovery (ND)</span></span>    
<span data-ttu-id="c7e83-1094">인접 노드 검색은 IPv6 주소(글로벌 주소 또는 링크-로컬 주소)에 물리적 주소를 매핑하기 위한 IPv6 네트워크의 프로토콜입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1094">Neighbor Discovery is a protocol in IPv6 networks for mapping physical addresses to the IPv6 addresses (global address or link-local address).</span></span> <span data-ttu-id="c7e83-1095">이 매핑은 ND Cache(인접 노드 검색 캐시)에서 유지 관리됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1095">This mapping is maintained in the Neighbor Discovery Cache (ND Cache).</span></span> <span data-ttu-id="c7e83-1096">ND 프로세스는 IPv4의 ARP 프로세스와 동일하며 ND 캐시는 ARP 테이블과 유사합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1096">The ND process is the equivalent of the ARP process in IPv4, and the ND Cache is similar to the ARP table.</span></span> <span data-ttu-id="c7e83-1097">IPv6 노드는 ND(인접 노드 검색) 프로토콜을 사용하여 인접 노드의 MAC 주소를 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1097">An IPv6 node can obtain its neighbor's MAC address using the Neighbor Discovery (ND) protocol.</span></span> <span data-ttu-id="c7e83-1098">이는 모든 노드의 요청된 노드 멀티캐스트 주소에 NS(인접 노드 요청) 메시지를 보내고, 해당하는 NA(인접 노드 알림) 메시지를 기다립니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1098">It sends out a neighbor solicitation (NS) message to the all-node solicited node multicast address, and waits for a corresponding neighbor advertisement (NA) message.</span></span> <span data-ttu-id="c7e83-1099">이 프로세스를 통해 가져온 MAC 주소는 ND 캐시에 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1099">The MAC address obtained through this process is stored in the ND Cache.</span></span>

<span data-ttu-id="c7e83-1100">각 IP 인스턴스에는 하나의 ND 캐시가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1100">Each IP instance has one ND cache.</span></span> <span data-ttu-id="c7e83-1101">ND 캐시는 항목 배열로 유지 관리됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1101">The ND Cache is maintained as an array of entries.</span></span> <span data-ttu-id="c7e83-1102">배열의 크기는 컴파일 시간에 ***NX_IPV6_NEIGHBOR_CACHE_SIZE** _에 있는 _*_nx_user.h_\*\* 옵션을 설정하여 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1102">The size of the array is defined at compilation time by setting the option ***NX_IPV6_NEIGHBOR_CACHE_SIZE** _ which in _*_nx_user.h_\*\*.</span></span> <span data-ttu-id="c7e83-1103">IP 인스턴스에 연결된 모든 인터페이스는 동일한 ND 캐시를 공유합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1103">Note that all interfaces attached to an IP instance share the same ND cache.</span></span>

<span data-ttu-id="c7e83-1104">NetX Duo가 시작될 때 전체 ND 캐시는 비어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1104">The entire ND Cache is empty when NetX Duo starts up.</span></span> <span data-ttu-id="c7e83-1105">시스템이 실행되면 NetX Duo는 ND 캐시를 자동으로 업데이트하여 ND 프로토콜에 따라 항목을 추가 및 삭제합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1105">As the system runs, NetX Duo automatically updates the ND Cache, adding and deleting entries as per ND protocol.</span></span> <span data-ttu-id="c7e83-1106">그러나 애플리케이션은 다음 NetX Duo 서비스를 사용하여 캐시 항목을 수동으로 추가하고 삭제함으로써 ND 캐시를 업데이트할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1106">However, an application may also update the ND Cache by manually adding and deleting cache entries using the following NetX Duo services:</span></span>

- <span data-ttu-id="c7e83-1107">***nxd_nd_cache_entry_delete***</span><span class="sxs-lookup"><span data-stu-id="c7e83-1107">***nxd_nd_cache_entry_delete***</span></span>  
- <span data-ttu-id="c7e83-1108">***nxd_nd_cache_entry_set***</span><span class="sxs-lookup"><span data-stu-id="c7e83-1108">***nxd_nd_cache_entry_set***</span></span>   
- <span data-ttu-id="c7e83-1109">***nxd_nd_cache_invalidate***</span><span class="sxs-lookup"><span data-stu-id="c7e83-1109">***nxd_nd_cache_invalidate***</span></span>

<span data-ttu-id="c7e83-1110">IPv6 패킷을 주고받을 때 NetX Duo는 ND 캐시 테이블을 자동으로 업데이트합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1110">When sending and receiving IPv6 packets, NetX Duo automatically updates the ND Cache table.</span></span>

## <a name="internet-control-message-protocol-in-ipv6-icmpv6"></a><span data-ttu-id="c7e83-1111">ICMPv6(IPv6의 Internet Control Message Protocol)</span><span class="sxs-lookup"><span data-stu-id="c7e83-1111">Internet Control Message Protocol in IPv6 (ICMPv6)</span></span>  

<span data-ttu-id="c7e83-1112">IPv6에서 ICMPv6의 역할이 크게 확장되어 IPv6 주소 매핑과 라우터 검색을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1112">The role of ICMPv6 in IPv6 has been greatly expanded to support IPv6 address mapping and router discovery.</span></span> <span data-ttu-id="c7e83-1113">또한 NetX Duo ICMPv6는 에코 요청 및 응답, ICMPv6 오류 보고서, ICMPv6 리디렉션 메시지를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1113">In addition, NetX Duo ICMPv6 supports echo request and response, ICMPv6 error reports, and ICMPv6 redirect messages.</span></span>

### <a name="icmpv6-enable"></a><span data-ttu-id="c7e83-1114">ICMPv6 사용</span><span class="sxs-lookup"><span data-stu-id="c7e83-1114">ICMPv6 Enable</span></span>    
<span data-ttu-id="c7e83-1115">NetX Duo에서 ICMPv6 메시지를 처리하려면 먼저 애플리케이션이 앞에서 설명한 대로 ***nxd_icmp_enable*** 서비스를 호출하여 ICMPv6를 처리하도록 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1115">Before ICMPv6 messages can be processed by NetX Duo, the application must call the ***nxd_icmp_enable*** service to enable ICMPv6 processing as explained previously.</span></span> 

### <a name="icmpv6-messages"></a><span data-ttu-id="c7e83-1116">ICMPv6 메시지</span><span class="sxs-lookup"><span data-stu-id="c7e83-1116">ICMPv6 Messages</span></span>     
<span data-ttu-id="c7e83-1117">ICMPv6 헤더 구조는 ICMPv4 헤더 구조와 유사합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1117">The ICMPv6 header structure is similar to the ICMPv4 header structure.</span></span> <span data-ttu-id="c7e83-1118">아래와 같이 기본 ICMPv6 헤더에는 형식, 코드, 체크섬의 세 필드와 ICMPv6 옵션 데이터의 가변 길이가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1118">As shown below, the basic ICMPv6 header contains the three fields, type, code, and checksum, plus variable length of ICMPv6 option data.</span></span> 

![기본 ICMPv6 헤더의 다이어그램입니다.](./media/user-guide/image19.png)

<span data-ttu-id="c7e83-1120">**그림 10. 기본 ICMPv6 헤더**</span><span class="sxs-lookup"><span data-stu-id="c7e83-1120">**FIGURE 10. Basic ICMPv6 Header**</span></span>

|<span data-ttu-id="c7e83-1121">필드</span><span class="sxs-lookup"><span data-stu-id="c7e83-1121">Field</span></span> |<span data-ttu-id="c7e83-1122">크기(바이트)</span><span class="sxs-lookup"><span data-stu-id="c7e83-1122">Size(bytes)</span></span> |<span data-ttu-id="c7e83-1123">Description</span><span class="sxs-lookup"><span data-stu-id="c7e83-1123">Description</span></span> |
|-----|-----|-----|
|     | <span data-ttu-id="c7e83-1124">1</span><span class="sxs-lookup"><span data-stu-id="c7e83-1124">1</span></span>   |<span data-ttu-id="c7e83-1125">ICMPv6 메시지 유형을 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1125">Identifies the ICMPv6 message type;</span></span> |
|     |     |<span data-ttu-id="c7e83-1126">1 대상에 연결할 수 없음</span><span class="sxs-lookup"><span data-stu-id="c7e83-1126">1 Destination Unreachable</span></span> |
|     |     |<span data-ttu-id="c7e83-1127">2 패킷이 너무 큼</span><span class="sxs-lookup"><span data-stu-id="c7e83-1127">2 Packet Too Big</span></span> |
|     |     |<span data-ttu-id="c7e83-1128">3 시간 초과</span><span class="sxs-lookup"><span data-stu-id="c7e83-1128">3 Time Exceeded</span></span> |
|     |     |<span data-ttu-id="c7e83-1129">4 매개 변수 문제</span><span class="sxs-lookup"><span data-stu-id="c7e83-1129">4 Parameter Problem</span></span> |
|     |     |<span data-ttu-id="c7e83-1130">128 에코 요청</span><span class="sxs-lookup"><span data-stu-id="c7e83-1130">128 Echo Request</span></span> |
|     |     |<span data-ttu-id="c7e83-1131">129 에코 응답</span><span class="sxs-lookup"><span data-stu-id="c7e83-1131">129 Echo Reply</span></span> |
|     |     |<span data-ttu-id="c7e83-1132">133 라우터 요청</span><span class="sxs-lookup"><span data-stu-id="c7e83-1132">133 Router Solicitation</span></span> |
|     |     |<span data-ttu-id="c7e83-1133">134 라우터 알림</span><span class="sxs-lookup"><span data-stu-id="c7e83-1133">134 Router Advertisement</span></span> |
|     |     |<span data-ttu-id="c7e83-1134">135 인접 노드 요청</span><span class="sxs-lookup"><span data-stu-id="c7e83-1134">135 Neighbor Solicitation</span></span> |
|     |     |<span data-ttu-id="c7e83-1135">136 인접 노드 알림</span><span class="sxs-lookup"><span data-stu-id="c7e83-1135">136 Neighbor Advertisement</span></span> |
|     |     |<span data-ttu-id="c7e83-1136">137 리디렉션 메시지</span><span class="sxs-lookup"><span data-stu-id="c7e83-1136">137 Redirect Message</span></span> |
|<span data-ttu-id="c7e83-1137">코드</span><span class="sxs-lookup"><span data-stu-id="c7e83-1137">Code</span></span> | <span data-ttu-id="c7e83-1138">1</span><span class="sxs-lookup"><span data-stu-id="c7e83-1138">1</span></span>   |<span data-ttu-id="c7e83-1139">ICMPv6 메시지 유형을 추가로 검증합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1139">Further qualifies the ICMPv6 message type.</span></span> <span data-ttu-id="c7e83-1140">일반적으로 오류 메시지와 함께 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1140">Generally used with error messages.</span></span> <span data-ttu-id="c7e83-1141">사용되지 않으면 0으로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1141">If not used, it is set to zero.</span></span> <span data-ttu-id="c7e83-1142">에코 요청/응답 및 NS 메시지는 이를 사용하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1142">Echo request/reply and NS messages do not use it.</span></span>|
|<span data-ttu-id="c7e83-1143">체크섬</span><span class="sxs-lookup"><span data-stu-id="c7e83-1143">Checksum</span></span> | <span data-ttu-id="c7e83-1144">2</span><span class="sxs-lookup"><span data-stu-id="c7e83-1144">2</span></span> |<span data-ttu-id="c7e83-1145">ICMP 헤더에 대한 16비트 체크섬 필드입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1145">16-bit checksum field for the ICMP Header.</span></span> <span data-ttu-id="c7e83-1146">이는 ICMPv6 헤더를 포함한 전체 ICMPv6 메시지의 16비트 보수입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1146">This is a 16-bit complement of the entire ICMPv6 message, including the ICMPv6 header.</span></span> <span data-ttu-id="c7e83-1147">또한 IPv6 소스 주소, 대상 주소, 패킷 페이로드 길이의 의사 헤더도 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1147">It also includes a pseudo-header of the IPv6 source address, destination address, and packet payload length.</span></span> |

<span data-ttu-id="c7e83-1148">다음은 인접 노드 요청 헤더의 예제입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1148">An example Neighbor Solicitation header is shown below.</span></span>

![인접 노드 요청 헤더 예제의 다이어그램입니다.](./media/user-guide/image20.jpg)

<span data-ttu-id="c7e83-1150">**그림 11. 인접 노드 요청 메시지의 ICMPv6 헤더**</span><span class="sxs-lookup"><span data-stu-id="c7e83-1150">**FIGURE 11. ICMPv6 Header for a Neighbor Solicitation Message**</span></span>

|<span data-ttu-id="c7e83-1151">필드</span><span class="sxs-lookup"><span data-stu-id="c7e83-1151">Field</span></span> |<span data-ttu-id="c7e83-1152">크기(바이트)</span><span class="sxs-lookup"><span data-stu-id="c7e83-1152">Size(bytes)</span></span> |<span data-ttu-id="c7e83-1153">Description</span><span class="sxs-lookup"><span data-stu-id="c7e83-1153">Description</span></span> |
|-----|-----|-----|
|<span data-ttu-id="c7e83-1154">형식</span><span class="sxs-lookup"><span data-stu-id="c7e83-1154">Type</span></span> | <span data-ttu-id="c7e83-1155">1</span><span class="sxs-lookup"><span data-stu-id="c7e83-1155">1</span></span>   |<span data-ttu-id="c7e83-1156">인접 노드 요청 메시지의 ICMPv6 메시지 유형을 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1156">Identifies the ICMPv6 message type for neighbor solicitation messages.</span></span> <span data-ttu-id="c7e83-1157">값은 135입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1157">Value is 135.</span></span> |
|<span data-ttu-id="c7e83-1158">코드</span><span class="sxs-lookup"><span data-stu-id="c7e83-1158">Code</span></span> | <span data-ttu-id="c7e83-1159">1</span><span class="sxs-lookup"><span data-stu-id="c7e83-1159">1</span></span>   |<span data-ttu-id="c7e83-1160">사용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1160">Not used.</span></span> <span data-ttu-id="c7e83-1161">0으로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1161">Set to 0.</span></span> |
|<span data-ttu-id="c7e83-1162">체크섬</span><span class="sxs-lookup"><span data-stu-id="c7e83-1162">Checksum</span></span> | <span data-ttu-id="c7e83-1163">2</span><span class="sxs-lookup"><span data-stu-id="c7e83-1163">2</span></span>  |<span data-ttu-id="c7e83-1164">ICMPv6 헤더에 대한 16비트 체크섬 필드입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1164">16-bit checksum field for the ICMPv6 header.</span></span> |
|<span data-ttu-id="c7e83-1165">예약됨</span><span class="sxs-lookup"><span data-stu-id="c7e83-1165">Reserved</span></span> | <span data-ttu-id="c7e83-1166">4</span><span class="sxs-lookup"><span data-stu-id="c7e83-1166">4</span></span>  |<span data-ttu-id="c7e83-1167">예약된 4바이트가 0으로 설정되었습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1167">4 reserved bytes set to 0.</span></span> |
|<span data-ttu-id="c7e83-1168">대상 주소</span><span class="sxs-lookup"><span data-stu-id="c7e83-1168">Target Address</span></span> | <span data-ttu-id="c7e83-1169">16</span><span class="sxs-lookup"><span data-stu-id="c7e83-1169">16</span></span>  |<span data-ttu-id="c7e83-1170">요청 대상의 IPv6 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1170">IPv6 address of target of the solicitation.</span></span> <span data-ttu-id="c7e83-1171">IPv6 주소 확인을 위해 링크 계층 주소를 확인해야 하는 디바이스의 실제 유니캐스트 IP 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1171">For IPv6 address resolution, this is the actual unicast IP address of the device whose link layer address needs to be resolved.</span></span> |
|<span data-ttu-id="c7e83-1172">옵션</span><span class="sxs-lookup"><span data-stu-id="c7e83-1172">Options</span></span> | <span data-ttu-id="c7e83-1173">변수</span><span class="sxs-lookup"><span data-stu-id="c7e83-1173">Variable</span></span> |<span data-ttu-id="c7e83-1174">인접 노드 검색 프로토콜에서 지정한 선택적 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1174">Optional information specified by the Neighbor Discovery Protocol.</span></span> |

### <a name="icmpv6-ping-request"></a><span data-ttu-id="c7e83-1175">ICMPv6 Ping 요청</span><span class="sxs-lookup"><span data-stu-id="c7e83-1175">ICMPv6 Ping Request</span></span>
<span data-ttu-id="c7e83-1176">NetX Duo 애플리케이션에서 ***nxd_icmp_ping*** 을 사용하여 매개 변수에 지정된 대상 IP 주소를 기반으로 IPv6 또는 IPv4 ping 요청을 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1176">In NetX Duo applications use ***nxd_icmp_ping*** to issue either IPv6 or IPv4 ping requests, based on the destination IP address specified in the parameters.</span></span>  

### <a name="icmpv6-ping-response"></a><span data-ttu-id="c7e83-1177">ICMPv6 Ping 응답</span><span class="sxs-lookup"><span data-stu-id="c7e83-1177">ICMPv6 Ping Response</span></span>
<span data-ttu-id="c7e83-1178">ICMPv6 ping 응답은 ICMPv6 구성 요소에서 외부 ICMPv6 ping 요청에 응답하여 내부적으로 생성하는 또 다른 유형의 ICMPv6 메시지입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1178">An ICMPv6 ping response is another type of ICMPv6 message that is generated internally by the ICMPv6 component in response to an external ICMPv6 ping request.</span></span> <span data-ttu-id="c7e83-1179">ICMPv6 ping 응답에는 승인 외에도 ICMPv6 ping 요청에 제공된 사용자 데이터 복사본도 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1179">In additional to acknowledgement, the ICMPv6 ping response also contains a copy of the user data supplied in the ICMPv6 ping request.</span></span>  

### <a name="thread-suspension"></a><span data-ttu-id="c7e83-1180">스레드 일시 중단</span><span class="sxs-lookup"><span data-stu-id="c7e83-1180">Thread Suspension</span></span>
<span data-ttu-id="c7e83-1181">다른 네트워크 멤버를 ping하는 동안 애플리케이션 스레드가 일시 중단될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1181">Application threads can suspend while attempting to ping another network member.</span></span> <span data-ttu-id="c7e83-1182">ping 응답이 수신되면 ping 응답 메시지가 일시 중단된 첫 번째 스레드에 전달되고 해당 스레드가 다시 시작됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1182">After a ping response is received, the ping response message is given to the first thread suspended and that thread is resumed.</span></span> <span data-ttu-id="c7e83-1183">모든 NetX Duo 서비스와 마찬가지로 ping 요청이 일시 중단되면 선택적 시간 제한이 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1183">Like all NetX Duo services, suspending on a ping request has an optional timeout.</span></span>  

### <a name="other-icmpv6-messages"></a><span data-ttu-id="c7e83-1184">기타 ICMPv6 메시지</span><span class="sxs-lookup"><span data-stu-id="c7e83-1184">Other ICMPv6 Messages</span></span>
<span data-ttu-id="c7e83-1185">ICMPv6 메시지는 다음과 같은 기능에 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1185">ICMPv6 messages are required for the following features:</span></span>  

- <span data-ttu-id="c7e83-1186">네트워크 환경 검색</span><span class="sxs-lookup"><span data-stu-id="c7e83-1186">Neighbor Discovery</span></span>  
- <span data-ttu-id="c7e83-1187">상태 비저장 주소 자동 구성</span><span class="sxs-lookup"><span data-stu-id="c7e83-1187">Stateless Address Autoconfiguration</span></span> 
- <span data-ttu-id="c7e83-1188">라우터 검색</span><span class="sxs-lookup"><span data-stu-id="c7e83-1188">Router Discovery</span></span> 
- <span data-ttu-id="c7e83-1189">인접 노드 연결 불가 감지</span><span class="sxs-lookup"><span data-stu-id="c7e83-1189">Neighbor Unreachability Detection</span></span>  

### <a name="neighbor-unreachability-router-and-prefix-discovery"></a><span data-ttu-id="c7e83-1190">인접 노드 연결 불가, 라우터 및 접두사 검색</span><span class="sxs-lookup"><span data-stu-id="c7e83-1190">Neighbor Unreachability, Router and Prefix Discovery</span></span>    
<span data-ttu-id="c7e83-1191">인접 노드 연결 불가 감지, 라우터 검색, 접두사 검색은 인접 노드 검색 프로토콜을 기반으로 하며 아래에 설명되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1191">Neighbor Unreachability Detection, Router Discovery, and Prefix Discovery are based on the Neighbor Discovery protocol and are described below.</span></span> 

<span data-ttu-id="c7e83-1192">***인접 노드 연결 불가 감지:*** IPv6 디바이스는 패킷을 전송하려 할 때 대상 링크 계층 주소를 찾기 위해 ND(인접 노드 검색) 캐시를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1192">***Neighbor Unreachability Detection:*** An IPv6 device searches its Neighbor Discovery (ND) Cache for the destination link layer address when it wishes to send a packet.</span></span> <span data-ttu-id="c7e83-1193">‘다음 홉’이라고도 하는 직접 대상은 동일한 링크의 실제 대상이 될 수도 있고 대상이 오프 링크일 경우에는 라우터가 될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1193">The immediate destination, sometimes referred to as the 'next hop,' may be the actual destination on the same link or it may be a router if the destination is off link.</span></span> <span data-ttu-id="c7e83-1194">ND 캐시 항목은 인접 노드의 연결 가능성에 대한 상태를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1194">An ND cache entry contains the status on a neighbor's reachability.</span></span>

<span data-ttu-id="c7e83-1195">REACHABLE 상태는 인접 노드가 연결할 수 있는 것으로 간주됨을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1195">A REACHABLE status indicates the neighbor is considered reachable.</span></span> <span data-ttu-id="c7e83-1196">인접 노드로 전송된 패킷이 수신되었다는 확인을 최근에 받은 경우 인접 노드에 연결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1196">A neighbor is reachable if it has recently received confirmation that packets sent to the neighbor have been received.</span></span> <span data-ttu-id="c7e83-1197">NetX Duo의 확인은 NetX Duo 디바이스에 의해 전송되는 NS 메시지에 대한 응답으로 인접 노드로부터 NA 메시지를 수신하는 형태를 취합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1197">Confirmation in NetX Duo take the form of receiving an NA message from the neighbor in response to an NS message sent by the NetX Duo device.</span></span> <span data-ttu-id="c7e83-1198">또한 NetX Duo는 애플리케이션에서 NetX Duo 서비스 ***nxd_nd_cache_entry_set*** 을 호출하여 캐시 레코드를 수동으로 입력하는 경우 인접 노드의 상태를 REACHABLE로 변경합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1198">NetX Duo will also change the state of the neighbor status to REACHABLE if the application calls the NetX Duo service ***nxd_nd_cache_entry_set*** to manually enter a cache record.</span></span>

<span data-ttu-id="c7e83-1199">***라우터 검색:*** IPv6 디바이스는 라우터를 사용하여 오프 링크 대상으로 지정된 모든 패킷을 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1199">***Router Discovery:*** An IPv6 device uses a router to forward all packets intended for off link destinations.</span></span> <span data-ttu-id="c7e83-1200">또한 라우터에서 보내는 RA(라우터 알림) 메시지와 같은 정보를 사용하여 글로벌 IPv6 주소를 구성할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1200">It may also use information sent by the router, such as router advertisement (RA) messages, to configure its global IPv6 addresses.</span></span>

<span data-ttu-id="c7e83-1201">네트워크의 디바이스는 RS(라우터 요청) 메시지를 모든 라우터 멀티캐스트 주소(FF01::2)로 전송하여 라우터 검색 프로세스를 시작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1201">A device on the network may initiate the Router Discovery process by sending a router solicitation (RS) message to the all-router multicast address (FF01::2).</span></span> <span data-ttu-id="c7e83-1202">또는 라우터에서 주기적인 RA를 위해 모든 노드 멀티캐스트 주소(FF::1)에서 대기할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1202">Or it can wait on the all-node multicast address (FF::1) for a periodic RA from the routers.</span></span>

<span data-ttu-id="c7e83-1203">RA 메시지에는 해당 네트워크의 IPv6 주소를 구성하기 위한 접두사 정보가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1203">An RA message contains the prefix information for configuring an IPv6 address for that network.</span></span> <span data-ttu-id="c7e83-1204">NetX Duo에서 라우터 요청은 기본적으로 사용하도록 설정되어 있으며, _\*_nx_user.h_\*\*에서 구성 옵션 \***NX_DISABLE_ICMPV6_ROUTER_SOLICITATION** _을 설정하여 사용하지 않도록 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1204">In NetX Duo, router solicitation is by default enabled and can be disabled by setting the configuration option ***NX_DISABLE_ICMPV6_ROUTER_SOLICITATION** _ in _*_nx_user.h_\*\*.</span></span> <span data-ttu-id="c7e83-1205">라우터 요청 매개 변수 설정에 대한 자세한 내용은 “NetX Duo의 설치 및 사용” 장의 구성 옵션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1205">See Configuration Options in the "Installation and Use of NetX Duo" chapter for more details on setting Router Solicitation parameters.</span></span> 

<span data-ttu-id="c7e83-1206">***접두사 검색***: IPv6 디바이스는 접두사 검색을 사용하여 라우터를 통하지 않고 직접 액세스할 수 있는 대상 호스트를 알아봅니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1206">***Prefix Discovery***: An IPv6 device uses prefix discovery to learn which target hosts are accessible directly without going through a router.</span></span> <span data-ttu-id="c7e83-1207">이 정보는 라우터의 RA 메시지에서 IPv6 디바이스에 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1207">This information is made available to the IPv6 device from RA messages from the router.</span></span> <span data-ttu-id="c7e83-1208">IPv6 디바이스는 접두사 테이블에 접두사 정보를 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1208">The IPv6 device stores the prefix information in a prefix table.</span></span> <span data-ttu-id="c7e83-1209">접두사 검색은 IPv6 디바이스 접두사 테이블의 접두사를 대상 주소에 일치시킵니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1209">Prefix discovery is matching a prefix from the IPv6 device prefix table to a target address.</span></span> <span data-ttu-id="c7e83-1210">접두사의 모든 비트가 대상 주소의 가장 중요한 비트와 일치하는 경우 접두사는 대상 주소와 일치합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1210">A prefix matches a target address if all the bits in the prefix match the most significant bits of the target address.</span></span> <span data-ttu-id="c7e83-1211">두 개 이상의 접두사가 주소에 사용되는 경우 가장 긴 접두사가 선택됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1211">If more than one prefix covers an address, the longest prefix is selected.</span></span>

### <a name="icmpv6-error-messages"></a><span data-ttu-id="c7e83-1212">ICMPv6 오류 메시지</span><span class="sxs-lookup"><span data-stu-id="c7e83-1212">ICMPv6 Error Messages</span></span>    
<span data-ttu-id="c7e83-1213">다음 ICMPv6 오류 메시지는 NetX Duo에서 지원됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1213">The following ICMPv6 error messages are supported in NetX Duo:</span></span>  

- <span data-ttu-id="c7e83-1214">대상에 연결할 수 없음</span><span class="sxs-lookup"><span data-stu-id="c7e83-1214">Destination Unreachable</span></span>  
- <span data-ttu-id="c7e83-1215">패킷이 너무 큼</span><span class="sxs-lookup"><span data-stu-id="c7e83-1215">Packet Too Big</span></span>  
- <span data-ttu-id="c7e83-1216">시간 초과</span><span class="sxs-lookup"><span data-stu-id="c7e83-1216">Time Exceed</span></span>  
- <span data-ttu-id="c7e83-1217">매개 변수 문제</span><span class="sxs-lookup"><span data-stu-id="c7e83-1217">Parameter Problem</span></span>  

## <a name="user-datagram-protocol-udp"></a><span data-ttu-id="c7e83-1218">UDP(User Datagram Protocol)</span><span class="sxs-lookup"><span data-stu-id="c7e83-1218">User Datagram Protocol (UDP)</span></span>

<span data-ttu-id="c7e83-1219">UDP(User Datagram Protocol)는 네트워크 멤버(RFC 768) 간에 가장 간단한 형식으로 데이터를 전송합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1219">The User Datagram Protocol (UDP) provides the simplest form of data transfer between network members (RFC 768).</span></span> <span data-ttu-id="c7e83-1220">UDP 데이터 패킷은 한 네트워크 멤버에서 다른 네트워크 멤버로 최상의 방법으로 전송됩니다. 즉, 패킷 수신자의 확인을 위한 기본 제공 메커니즘은 제공되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1220">UDP data packets are sent from one network member to another in a best effort fashion; i.e., there is no built-in mechanism for acknowledgement by the packet recipient.</span></span> <span data-ttu-id="c7e83-1221">또한 UDP 패킷을 전송할 때 미리 연결할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1221">In addition, sending a UDP packet does not require any connection to be established in advance.</span></span> <span data-ttu-id="c7e83-1222">따라서 UDP 패킷 전송은 매우 효율적입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1222">Because of this, UDP packet transmission is very efficient.</span></span>

<span data-ttu-id="c7e83-1223">NetX 애플리케이션을 NetX Duo로 마이그레이션하는 개발자의 경우 NetX와 NetX Duo 간의 UDP 기능에 몇 가지 기본적인 변경 사항만 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1223">For developers migrating their NetX applications to NetX Duo there are only a few basic changes in UDP functionality between NetX and NetX Duo.</span></span> <span data-ttu-id="c7e83-1224">이는 IPv6가 주로 기본 IP 계층과 관련이 있기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1224">This is because IPv6 is primarily concerned with the underlying IP layer.</span></span> <span data-ttu-id="c7e83-1225">모든 NetX Duo UDP 서비스는 IPv4 또는 IPv6 연결에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1225">All NetX Duo UDP services can be used for either IPv4 or IPv6 connectivity.</span></span>

### <a name="udp-header"></a><span data-ttu-id="c7e83-1226">UDP 헤더</span><span class="sxs-lookup"><span data-stu-id="c7e83-1226">UDP Header</span></span>       
<span data-ttu-id="c7e83-1227">UDP는 전송 중인 애플리케이션의 데이터 앞에 간단한 패킷 헤더를 배치하고, 수신된 UDP 패킷을 애플리케이션에 전송하기 전에 수신한 패킷에서 유사한 UDP 헤더를 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1227">UDP places a simple packet header in front of the application's data on transmission, and removes a similar UDP header from the packet on reception before delivering a received UDP packet to the application.</span></span> <span data-ttu-id="c7e83-1228">UDP는 패킷을 주고받기 위해 IP 프로토콜을 활용하는데, 이는 패킷이 네트워크에 있을 때 UDP 헤더 앞에 IP 헤더가 있음을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1228">UDP utilizes the IP protocol for sending and receiving packets, which means there is an IP header in front of the UDP header when the packet is on the network.</span></span> <span data-ttu-id="c7e83-1229">그림 12는 UDP 헤더의 형식을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1229">Figure 12 shows the format of the UDP header.</span></span>

![UDP 헤더 형식 다이어그램입니다.](./media/user-guide/image21.png)

### <a name="figure-12-udp-header"></a><span data-ttu-id="c7e83-1231">그림 12.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1231">FIGURE 12.</span></span> <span data-ttu-id="c7e83-1232">UDP 헤더</span><span class="sxs-lookup"><span data-stu-id="c7e83-1232">UDP Header</span></span>

> [!NOTE]
> <span data-ttu-id="c7e83-1233">UDP/IP 구현의 모든 헤더는 **big endian** 형식이어야 합니다. 이 형식에서 단어의 가장 중요한 바이트는 가장 낮은 바이트 주소에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1233">*All headers in the UDP/IP implementation are expected to be in **big endian** format. In this format, the most significant byte of the word resides at the lowest byte address.*</span></span>

<span data-ttu-id="c7e83-1234">다음은 UDP 헤더 형식에 대한 설명입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1234">The following describes the UDP header format:</span></span>

|<span data-ttu-id="c7e83-1235">헤더 필드</span><span class="sxs-lookup"><span data-stu-id="c7e83-1235">Header Field</span></span> |<span data-ttu-id="c7e83-1236">목적</span><span class="sxs-lookup"><span data-stu-id="c7e83-1236">Purpose</span></span> |
|---|---|
|<span data-ttu-id="c7e83-1237">**16비트 소스 포트 번호**</span><span class="sxs-lookup"><span data-stu-id="c7e83-1237">**16-bit source port number**</span></span> |<span data-ttu-id="c7e83-1238">이 필드에는 UDP 패킷을 전송할 포트가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1238">This field contains the port on which the UDP packet is being sent from.</span></span> <span data-ttu-id="c7e83-1239">유효한 UDP 포트의 범위는 1에서 0xFFFF까지입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1239">Valid UDP ports range from 1 through 0xFFFF.</span></span> |
|<span data-ttu-id="c7e83-1240">**16비트 대상 포트 번호**</span><span class="sxs-lookup"><span data-stu-id="c7e83-1240">**16-bit destination port number**</span></span> |<span data-ttu-id="c7e83-1241">이 필드에는 패킷을 전송할 UDP 포트가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1241">This field contains the UDP port to which the packet is being sent to.</span></span> <span data-ttu-id="c7e83-1242">유효한 UDP 포트의 범위는 1에서 0xFFFF까지입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1242">Valid UDP ports range from 1 through 0xFFFF.</span></span> |
|<span data-ttu-id="c7e83-1243">**16비트 UDP 길이**</span><span class="sxs-lookup"><span data-stu-id="c7e83-1243">**16-bit UDP length**</span></span> |<span data-ttu-id="c7e83-1244">이 필드에는 UDP 헤더의 크기를 포함하여 UDP 패킷의 바이트 수가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1244">This field contains the number of bytes in the UDP packet, including the size of the UDP header.</span></span> |
|<span data-ttu-id="c7e83-1245">**16비트 UDP 체크섬**</span><span class="sxs-lookup"><span data-stu-id="c7e83-1245">**16-bit UDP checksum**</span></span> |<span data-ttu-id="c7e83-1246">이 필드에는 UDP 헤더, 패킷 데이터 영역, 의사 IP 헤더를 포함하여 패킷에 대한 16비트 체크섬이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1246">This field contains the 16-bit checksum for the packet, including the UDP header, the packet data area, and the pseudo IP header.</span></span> |

### <a name="udp-enable"></a><span data-ttu-id="c7e83-1247">UDP 사용</span><span class="sxs-lookup"><span data-stu-id="c7e83-1247">UDP Enable</span></span>   
<span data-ttu-id="c7e83-1248">UDP 패킷을 전송하려면 먼저 ***nx_udp_enable*** 서비스를 호출하여 애플리케이션에서 UDP를 사용하도록 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1248">Before UDP packet transmission is possible, the application must first enable UDP by calling the ***nx_udp_enable*** service.</span></span> <span data-ttu-id="c7e83-1249">사용하도록 설정된 후 애플리케이션은 UDP 패킷을 자유롭게 주고받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1249">After enabled, the application is free to send and receive UDP packets.</span></span>  

### <a name="udp-socket-create"></a><span data-ttu-id="c7e83-1250">UDP 소켓 만들기</span><span class="sxs-lookup"><span data-stu-id="c7e83-1250">UDP Socket Create</span></span>    
<span data-ttu-id="c7e83-1251">UDP 소켓은 초기화 중에 또는 애플리케이션 스레드에 의한 런타임 중에 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1251">UDP sockets are created either during initialization or during runtime by application threads.</span></span> <span data-ttu-id="c7e83-1252">초기 서비스 유형, TTL(Time to Live), 수신 큐 깊이는 ***nx_udp_socket_create*** 서비스에 의해 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1252">The initial type of service, time to live, and receive queue depth are defined by the ***nx_udp_socket_create*** service.</span></span> <span data-ttu-id="c7e83-1253">애플리케이션의 UDP 소켓 수에는 제한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1253">There are no limits on the number of UDP sockets in an application.</span></span>

### <a name="udp-checksum"></a><span data-ttu-id="c7e83-1254">UDP 체크섬</span><span class="sxs-lookup"><span data-stu-id="c7e83-1254">UDP Checksum</span></span>   
<span data-ttu-id="c7e83-1255">IPv6 프로토콜에는 패킷 데이터에 UDP 헤더 체크섬 계산이 필요하지만 IPv4 프로토콜에서는 선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1255">IPv6 protocol requires a UDP header checksum computation on packet data, whereas in the IPv4 protocol it is optional.</span></span>  

<span data-ttu-id="c7e83-1256">UDP는 IP 의사 헤더(소스 IP 주소, 대상 IP 주소, 프로토콜/길이 IP 단어로 구성), UDP 헤더, UDP 패킷 데이터를 포함하는 1의 보수 16비트 체크섬을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1256">UDP specifies a one's complement 16-bit checksum that covers the IP pseudo header (consisting of the source IP address, destination IP address, and the protocol/length IP word), the UDP header, and the UDP packet data.</span></span> <span data-ttu-id="c7e83-1257">IPv4와 IPv6 UDP 패킷 헤더 체크섬의 유일한 차이점은 소스 및 대상 IP 주소가 IPv4에서 32비트인 반면 IPv6에서는 128비트라는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1257">The only differences between IPv4 and IPv6 UDP packet header checksums is that the source and destination IP addresses are 32 bit in IPv4 while in IPv6 they are 128 bit.</span></span> <span data-ttu-id="c7e83-1258">계산된 UDP 체크섬이 0이면 모두 1로 저장됩니다(0xFFFF).</span><span class="sxs-lookup"><span data-stu-id="c7e83-1258">If the calculated UDP checksum is 0, it is stored as all ones (0xFFFF).</span></span> <span data-ttu-id="c7e83-1259">전송 소켓에 UDP 체크섬 논리가 사용할 수 없는 경우, 0이 UDP 체크섬 필드에 배치되어 체크섬이 계산되지 않았음을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1259">If the sending socket has the UDP checksum logic disabled, a zero is placed in the UDP checksum field to indicate the checksum was not calculated.</span></span>

<span data-ttu-id="c7e83-1260">UDP 체크섬이 받는 사람에 의해 계산된 체크섬과 일치하지 않으면 UDP 패킷은 폐기됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1260">If the UDP checksum does not match the computed checksum by the receiver, the UDP packet is simply discarded.</span></span>

<span data-ttu-id="c7e83-1261">IPv4 네트워크에서 UDP 체크섬은 선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1261">On the IPv4 network, UDP checksum is optional.</span></span> <span data-ttu-id="c7e83-1262">NetX Duo를 사용하면 애플리케이션이 소켓 단위로 UDP 체크섬 계산을 사용하거나 사용하지 않도록 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1262">NetX Duo allows an application to enable or disable UDP checksum calculation on a per-socket basis.</span></span> <span data-ttu-id="c7e83-1263">기본적으로 UDP 소켓 체크섬 논리를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1263">By default, the UDP socket checksum logic is enabled.</span></span> <span data-ttu-id="c7e83-1264">애플리케이션은 \***nx_udp_socket_checksum_disable** _ 서비스를 호출하여 특정 UDP 소켓에 대한 체크섬 논리를 사용하지 않도록 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1264">The application can disable checksum logic for a particular UDP socket by calling the \***nx_udp_socket_checksum_disable** _ service.</span></span> <span data-ttu-id="c7e83-1265">그러나 IPv6 네트워크에서는 UDP 체크섬이 필수입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1265">On the IPv6 network, however, UDP checksum is mandatory.</span></span> <span data-ttu-id="c7e83-1266">따라서 IPv6 네트워크를 통해 패킷을 전송할 때 _ *_nx_udp_socket_checksum_disable_*\* 서비스가 UDP 체크섬 논리를 사용하지 않도록 설정하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1266">Therefore, the service _ *_nx_udp_socket_checksum_disable_*\* would not disable UDP checksum logic when sending a packet through the IPv6 network.</span></span>

<span data-ttu-id="c7e83-1267">특정 이더넷 컨트롤러는 즉시 UDP 체크섬을 생성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1267">Certain Ethernet controllers are able to generate the UDP checksum on the fly.</span></span> <span data-ttu-id="c7e83-1268">시스템이 하드웨어 체크섬 계산 기능을 사용할 수 있는 경우, NetX Duo 라이브러리를 체크섬 논리 없이 빌드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1268">If the system is able to use hardware checksum computation feature, the NetX Duo library can be built without the checksum logic.</span></span> <span data-ttu-id="c7e83-1269">UDP 소프트웨어 체크섬을 사용하지 않도록 설정하려면 다음 기호를 정의하여 NetX Duo 라이브러리를 빌드해야 합니다. 기호 ***NX_DISABLE_UDP_TX_CHECKSUM** _ 및 _*_NX_DISABLE_UDP_RX_CHECKSUM_\*_ 은 2장에 설명되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1269">To disable UDP software checksum, the NetX Duo library must be built with the following symbols defined: ***NX_DISABLE_UDP_TX_CHECKSUM** _ and _*_NX_DISABLE_UDP_RX_CHECKSUM_\*_ (described in Chapter two).</span></span> <span data-ttu-id="c7e83-1270">구성 옵션은 NetX Duo에서 UDP 체크섬 논리를 완전히 제거할 수 있지만 _ *_nx_udp_socket_checksum_disable_*\* 서비스를 호출하면 애플리케이션에서 소켓 단위로 IPv4 UDP 체크섬 처리를 사용하지 않도록 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1270">The configuration options remove UDP checksum logic from NetX Duo entirely, while calling the _ *_nx_udp_socket_checksum_disable_*\* service allows the application to disable IPv4 UDP checksum processing on a per socket basis.</span></span>

### <a name="udp-ports-and-binding"></a><span data-ttu-id="c7e83-1271">UDP 포트 및 바인딩</span><span class="sxs-lookup"><span data-stu-id="c7e83-1271">UDP Ports and Binding</span></span>      
<span data-ttu-id="c7e83-1272">UDP 포트는 UDP 프로토콜의 논리적 끝점입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1272">A UDP port is a logical end point in the UDP protocol.</span></span> <span data-ttu-id="c7e83-1273">NetX Duo의 UDP 구성 요소에는 65,535개의 유효한 포트가 있으며, 범위는 1~0xFFFF입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1273">There are 65,535 valid ports in the UDP component of NetX Duo, ranging from 1 through 0xFFFF.</span></span> <span data-ttu-id="c7e83-1274">UDP 데이터를 주고받으려면 먼저 애플리케이션에서 UDP 소켓을 만든 다음 원하는 포트에 바인딩해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1274">To send or receive UDP data, the application must first create a UDP socket, then bind it to a desired port.</span></span> <span data-ttu-id="c7e83-1275">UDP 소켓을 포트에 바인딩한 후 애플리케이션은 해당 소켓에서 데이터를 주고받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1275">After binding a UDP socket to a port, the application may send and receive data on that socket.</span></span>

### <a name="udp-fast-pathtrade"></a><span data-ttu-id="c7e83-1276">UDP 빠른 경로&trade;</span><span class="sxs-lookup"><span data-stu-id="c7e83-1276">UDP Fast Path&trade;</span></span>   
<span data-ttu-id="c7e83-1277">UDP 빠른 경로&trade;는 NetX Duo UDP 구현을 통한 낮은 패킷 오버헤드 경로에 대한 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1277">The UDP Fast Path&trade; is the name for a low packet overhead path through the NetX Duo UDP implementation.</span></span> <span data-ttu-id="c7e83-1278">UDP 패킷을 전송하려면 ***nx_udp_socket_send** _, _*_nx_ip_packet_send_\*_, 네트워크 드라이버에 대한 최종 호출과 같은 몇 가지 함수 호출만 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1278">Sending a UDP packet requires just a few function calls: ***nx_udp_socket_send** _, _*_nx_ip_packet_send_\*_, and the eventual call to the network driver.</span></span> <span data-ttu-id="c7e83-1279">_*_nx_udp_socket_send_*_ 는 기존 NetX 애플리케이션에 대해 NetX Duo에서 사용할 수 있으며 IPv4 패킷에만 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1279">_*_nx_udp_socket_send_*_ is available in NetX Duo for existing NetX applications and is only applicable for IPv4 packets.</span></span> <span data-ttu-id="c7e83-1280">그러나 기본 방법은 아래에서 설명하는 _ *_nxd_udp_socket_send_*\* 서비스를 사용하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1280">The preferred method, however, is to use _ *_nxd_udp_socket_send_*\* service discussed below.</span></span> <span data-ttu-id="c7e83-1281">UDP 패킷 수신 시, UDP 패킷은 적절한 UDP 소켓 수신 큐에 배치되거나 네트워크 드라이버 수신 인터럽트 처리에서 단일 함수 호출로 일시 중단된 애플리케이션 스레드에 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1281">On UDP packet reception, the UDP packet is either placed on the appropriate UDP socket receive queue or delivered to a suspended application thread in a single function call from the network driver's receive interrupt processing.</span></span> <span data-ttu-id="c7e83-1282">UDP 패킷을 주고받기 위해 최적화된 이 논리는 UDP 빠른 경로 기술의 핵심입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1282">This highly optimized logic for sending and receiving UDP packets is the essence of UDP Fast Path technology.</span></span>  

### <a name="udp-packet-send"></a><span data-ttu-id="c7e83-1283">UDP 패킷 전송</span><span class="sxs-lookup"><span data-stu-id="c7e83-1283">UDP Packet Send</span></span>    
<span data-ttu-id="c7e83-1284">IPv6 또는 IPv4 네트워크를 통해 UDP 데이터를 전송하는 작업은 \***nxd_udp_socket_send** _ 함수를 호출하여 쉽게 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1284">Sending UDP data over IPv6 or IPv4 networks is easily accomplished by calling the \***nxd_udp_socket_send** _ function.</span></span> <span data-ttu-id="c7e83-1285">호출자는 NXD_ADDRESS 포인터 매개 변수의 _nx_ip_version\* 필드에 IP 버전을 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1285">The caller must set the IP version in the _nx_ip_version\* field of the NXD_ADDRESS pointer parameter.</span></span> <span data-ttu-id="c7e83-1286">NetX Duo는 대상 IPv4/IPv6 주소를 기반으로 전송된 UDP 패킷에 가장 적합한 소스 주소를 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1286">NetX Duo will determine the best source address for transmitted UDP packets based on the destination IPv4/IPv6 address.</span></span> <span data-ttu-id="c7e83-1287">이 서비스는 패킷 데이터 앞에 UDP 헤더를 배치하고 내부 IP 전송 루틴을 사용하여 이를 네트워크로 전송합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1287">This service places a UDP header in front of the packet data and sends it out onto the network using an internal IP send routine.</span></span> <span data-ttu-id="c7e83-1288">모든 UDP 패킷 전송이 즉시 처리되므로 UDP 패킷을 전송할 때 스레드가 일시 중단되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1288">There is no thread suspension on sending UDP packets because all UDP packet transmissions are processed immediately.</span></span> 

<span data-ttu-id="c7e83-1289">멀티캐스트 또는 브로드캐스트 대상에 대해 애플리케이션은 NetX Duo 디바이스가 선택할 여러 IP 주소를 가지고 있는 경우 사용할 소스 IP 주소를 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1289">For multicast or broadcast destinations, the application should specify the source IP address to use if the NetX Duo device has multiple IP addresses to choose from.</span></span> <span data-ttu-id="c7e83-1290">이 작업은 ***nxd_udp_socket_source_send*** 서비스를 이용하여 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1290">This can be done with the services ***nxd_udp_socket_source_send.***</span></span>

> [!IMPORTANT]    
> <span data-ttu-id="c7e83-1291">**nx_udp_socket_send** 가 멀티캐스트 또는 브로드캐스트 패킷 전송에 사용되는 경우 첫 번째 사용 가능한 인터페이스의 IP 주소가 소스 주소로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1291">*If **nx_udp_socket_send** is used for transmitting multicast or broadcast packets, the IP address of the first enabled interface is used as source address*.</span></span>

> [!NOTE] 
> <span data-ttu-id="c7e83-1292">이 소켓에 대해 UDP 체크섬 논리를 사용하는 경우 UDP 또는 IP 데이터 구조에 대한 액세스를 차단하지 않고 호출 스레드의 컨텍스트에서 체크섬 작업이 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1292">*If UDP checksum logic is enabled for this socket, the checksum operation is performed in the context of the calling thread, without blocking access to the UDP or IP data structures*.</span></span> 

> [!WARNING]    
> <span data-ttu-id="c7e83-1293">NX_PACKET 구조에 있는 UDP 페이로드 데이터는 긴 단어 경계에 있어야 합니다. 애플리케이션에서 NetX Duo가 UDP, IP, 실제 미디어 헤더를 배치할 수 있도록 앞에 추가 포인터와 데이터 시작 포인터 사이에 충분한 공간을 남겨 두어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1293">*The UDP payload data residing in the NX_PACKET structure should reside on a long-word boundary. The application needs to leave sufficient space between the prepend pointer and the data start pointer for NetX Duo to place the UDP, IP, and physical media headers*.</span></span>

### <a name="udp-packet-receive"></a><span data-ttu-id="c7e83-1294">UDP 패킷 수신</span><span class="sxs-lookup"><span data-stu-id="c7e83-1294">UDP Packet Receive</span></span>    
<span data-ttu-id="c7e83-1295">애플리케이션 스레드는 ***nx_udp_socket_receive*** 를 호출하여 특정 소켓에서 UDP 패킷을 수신할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1295">Application threads may receive UDP packets from a particular socket by calling ***nx_udp_socket_receive***.</span></span> <span data-ttu-id="c7e83-1296">소켓 수신 함수는 소켓의 수신 큐에서 가장 오래된 패킷을 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1296">The socket receive function delivers the oldest packet on the socket's receive queue.</span></span> <span data-ttu-id="c7e83-1297">수신 큐에 패킷이 없는 경우 패킷이 도착할 때까지 호출 스레드가 선택적 시간 제한으로 일시 중단될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1297">If there are no packets on the receive queue, the calling thread can suspend (with an optional timeout) until a packet arrives.</span></span>

<span data-ttu-id="c7e83-1298">UDP 수신 패킷 처리(일반적으로 네트워크 드라이버의 수신 인터럽트 처리기에서 호출됨)는 패킷을 UDP 소켓의 수신 큐에 배치하거나 패킷을 대기 중인 첫 번째 일시 중단된 스레드로 전달하는 역할을 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1298">The UDP receive packet processing (usually called from the network driver's receive interrupt handler) is responsible for either placing the packet on the UDP socket's receive queue or delivering it to the first suspended thread waiting for a packet.</span></span> <span data-ttu-id="c7e83-1299">패킷이 큐에 있는 경우 수신 처리는 소켓과 관련된 최대 수신 큐 깊이도 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1299">If the packet is queued, the receive processing also checks the maximum receive queue depth associated with the socket.</span></span> <span data-ttu-id="c7e83-1300">새로 큐에 배치된 패킷이 큐 깊이를 초과하면 큐에서 가장 오래된 패킷이 삭제됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1300">If this newly queued packet exceeds the queue depth, the oldest packet in the queue is discarded.</span></span>

### <a name="udp-receive-notify"></a><span data-ttu-id="c7e83-1301">UDP 수신 알림</span><span class="sxs-lookup"><span data-stu-id="c7e83-1301">UDP Receive Notify</span></span>   
<span data-ttu-id="c7e83-1302">애플리케이션 스레드가 둘 이상의 소켓에서 수신된 데이터를 처리해야 하는 경우 ***nx_udp_socket_receive_notify*** 함수를 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1302">If the application thread needs to process received data from more than one socket, the ***nx_udp_socket_receive_notify*** function should be used.</span></span> <span data-ttu-id="c7e83-1303">이 함수는 소켓에 대한 수신 패킷 콜백 함수를 등록합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1303">This function registers a receive packet callback function for the socket.</span></span> <span data-ttu-id="c7e83-1304">패킷이 소켓에 수신될 때마다 콜백 함수가 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1304">Whenever a packet is received on the socket, the callback function is executed.</span></span>

<span data-ttu-id="c7e83-1305">콜백 함수의 콘텐츠는 애플리케이션에 따라 다르겠지만, 이제 해당 소켓에서 패킷을 사용할 수 있음을 처리 스레드에 알리는 논리가 포함될 가능성이 높습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1305">The contents of the callback function is applicationspecific; however, it would most likely contain logic to inform the processing thread that a packet is now available on the corresponding socket.</span></span>

### <a name="peer-address-and-port"></a><span data-ttu-id="c7e83-1306">피어 주소 및 포트</span><span class="sxs-lookup"><span data-stu-id="c7e83-1306">Peer Address and Port</span></span>   
<span data-ttu-id="c7e83-1307">UDP 패킷을 수신하면 애플리케이션에서 ***nx_udp_packet_info_extract*** 서비스를 사용하여 송신자의 IP 주소와 포트 번호를 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1307">On receiving a UDP packet, application may find the sender's IP address and port number by using the service ***nx_udp_packet_info_extract***.</span></span> <span data-ttu-id="c7e83-1308">성공적으로 반환되면 이 서비스는 송신자의 IP 주소, 송신자의 포트 번호, 패킷을 수신한 로컬 인터페이스에 대한 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1308">On successful return, this service provides information on the sender's IP address, sender's port number, and the local interface through which the packet was received.</span></span>  

### <a name="thread-suspension"></a><span data-ttu-id="c7e83-1309">스레드 일시 중단</span><span class="sxs-lookup"><span data-stu-id="c7e83-1309">Thread Suspension</span></span>   
<span data-ttu-id="c7e83-1310">앞에서 설명한 대로 애플리케이션 스레드는 특정 UDP 포트에서 UDP 패킷을 수신하려 하는 동안 일시 중단할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1310">As mentioned previously, application threads can suspend while attempting to receive a UDP packet on a particular UDP port.</span></span> <span data-ttu-id="c7e83-1311">해당 포트에서 패킷이 수신되면 패킷이 일시 중단된 첫 번째 스레드에 제공되고 해당 스레드가 다시 시작됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1311">After a packet is received on that port, it is given to the first thread suspended and that thread is then resumed.</span></span> <span data-ttu-id="c7e83-1312">대부분의 NetX Duo 서비스에서 사용할 수 있는 기능인 UDP 수신 패킷을 일시 중단할 경우 선택적 시간 제한을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1312">An optional timeout is available when suspending on a UDP receive packet, a feature available for most NetX Duo services.</span></span>  

### <a name="udp-socket-statistics-and-errors"></a><span data-ttu-id="c7e83-1313">UDP 소켓 통계 및 오류</span><span class="sxs-lookup"><span data-stu-id="c7e83-1313">UDP Socket Statistics and Errors</span></span>     
<span data-ttu-id="c7e83-1314">사용하도록 설정된 경우 NetX Duo UDP 소켓 소프트웨어는 애플리케이션에 유용할 수 있는 몇 가지 통계 및 오류를 추적합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1314">If enabled, the NetX Duo UDP socket software keeps track of several statistics and errors that may be useful to the application.</span></span> <span data-ttu-id="c7e83-1315">각 IP/UDP 인스턴스에 대해 다음 통계 및 오류 보고서가 유지 관리됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1315">The following statistics and error reports are maintained for each IP/UDP instance:</span></span>

- <span data-ttu-id="c7e83-1316">전송된 총 UDP 패킷</span><span class="sxs-lookup"><span data-stu-id="c7e83-1316">Total UDP Packets Sent</span></span>  
- <span data-ttu-id="c7e83-1317">전송된 총 UDP 바이트</span><span class="sxs-lookup"><span data-stu-id="c7e83-1317">Total UDP Bytes Sent</span></span>  
- <span data-ttu-id="c7e83-1318">수신된 총 UDP 패킷</span><span class="sxs-lookup"><span data-stu-id="c7e83-1318">Total UDP Packets Received</span></span>   
- <span data-ttu-id="c7e83-1319">수신된 총 UDP 바이트</span><span class="sxs-lookup"><span data-stu-id="c7e83-1319">Total UDP Bytes Received</span></span>  
- <span data-ttu-id="c7e83-1320">총 UDP 잘못된 패킷</span><span class="sxs-lookup"><span data-stu-id="c7e83-1320">Total UDP Invalid Packets</span></span>  
- <span data-ttu-id="c7e83-1321">삭제된 총 UDP 수신 패킷</span><span class="sxs-lookup"><span data-stu-id="c7e83-1321">Total UDP Receive Packets Dropped</span></span>  
- <span data-ttu-id="c7e83-1322">총 UDP 수신 체크섬 오류</span><span class="sxs-lookup"><span data-stu-id="c7e83-1322">Total UDP Receive Checksum Errors</span></span>  
- <span data-ttu-id="c7e83-1323">전송된 UDP 소켓 패킷</span><span class="sxs-lookup"><span data-stu-id="c7e83-1323">UDP Socket Packets Sent</span></span>  
- <span data-ttu-id="c7e83-1324">전송된 UDP 소켓 바이트</span><span class="sxs-lookup"><span data-stu-id="c7e83-1324">UDP Socket Bytes Sent</span></span>  
- <span data-ttu-id="c7e83-1325">수신된 UDP 소켓 패킷</span><span class="sxs-lookup"><span data-stu-id="c7e83-1325">UDP Socket Packets Received</span></span>   
- <span data-ttu-id="c7e83-1326">수신된 UDP 소켓 바이트</span><span class="sxs-lookup"><span data-stu-id="c7e83-1326">UDP Socket Bytes Received</span></span>  
- <span data-ttu-id="c7e83-1327">큐에 있는 UDP 소켓 패킷</span><span class="sxs-lookup"><span data-stu-id="c7e83-1327">UDP Socket Packets Queued</span></span>  
- <span data-ttu-id="c7e83-1328">삭제된 UDP 소켓 수신 패킷</span><span class="sxs-lookup"><span data-stu-id="c7e83-1328">UDP Socket Receive Packets Dropped</span></span>  
- <span data-ttu-id="c7e83-1329">UDP 소켓 체크섬 오류</span><span class="sxs-lookup"><span data-stu-id="c7e83-1329">UDP Socket Checksum Errors</span></span>  

<span data-ttu-id="c7e83-1330">이 모든 통계 및 오류 보고서는 모든 UDP 소켓을 모은 UDP 통계를 위한 ***nx_udp_info_get** _ 서비스와 지정된 UDP 소켓의 UDP 통계를 위한 _ *_nx_udp_socket_info_get_** 서비스를 통해 애플리케이션에서 이용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1330">All these statistics and error reports are available to the application with the ***nx_udp_info_get** _ service for UDP statistics amassed over all UDP sockets, and the _ *_nx_udp_socket_info_get_** service for UDP statistics on the specified UDP socket.</span></span>

### <a name="udp-socket-control-block-nx_udp_socket"></a><span data-ttu-id="c7e83-1331">UDP 소켓 제어 블록 NX_UDP_SOCKET</span><span class="sxs-lookup"><span data-stu-id="c7e83-1331">UDP Socket Control Block NX_UDP_SOCKET</span></span>
<span data-ttu-id="c7e83-1332">각 UDP 소켓의 특성은 관련된 NX_UDP_SOCKET 제어 블록에서 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1332">The characteristics of each UDP socket are found in the associated NX_UDP_SOCKET control block.</span></span> <span data-ttu-id="c7e83-1333">IP 데이터 구조에 대한 링크, 정신 및 수신 경로에 대한 네트워크 인터페이스, 바인딩된 포트, 수신 패킷 큐와 같은 유용한 정보를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1333">It contains useful information such as the link to the IP data structure, the network interface for the sending and receiving paths, the bound port, and the receive packet queue.</span></span> <span data-ttu-id="c7e83-1334">이 구조는 ***nx_api.h*** 파일에서 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1334">This structure is defined in the ***nx_api.h*** file.</span></span>

## <a name="transmission-control-protocol-tcp"></a><span data-ttu-id="c7e83-1335">TCP(Transmission Control Protocol)</span><span class="sxs-lookup"><span data-stu-id="c7e83-1335">Transmission Control Protocol (TCP)</span></span>

<span data-ttu-id="c7e83-1336">TCP(Transmission Control Protocol)는 두 네트워크 멤버(RFC 793) 간의 신뢰할 수 있는 스트림 데이터 전송을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1336">The Transmission Control Protocol (TCP) provides reliable stream data transfer between two network members (RFC 793).</span></span> <span data-ttu-id="c7e83-1337">한 네트워크 멤버에서 전송된 모든 데이터는 수신 멤버에 의해 확인되고 승인됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1337">All data sent from one network member are verified and acknowledged by the receiving member.</span></span> <span data-ttu-id="c7e83-1338">또한 두 멤버는 데이터를 전송하기 전에 연결을 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1338">In addition, the two members must have established a connection prior to any data transfer.</span></span> <span data-ttu-id="c7e83-1339">이로 인해 신뢰할 수 있는 데이터 전송이 가능하지만 앞에서 설명한 UDP 데이터 전송보다 훨씬 많은 오버헤드를 필요로 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1339">All this results in reliable data transfer; however, it does require substantially more overhead than the previously described UDP data transfer.</span></span>

<span data-ttu-id="c7e83-1340">명시된 경우를 제외하고, IPv6는 주로 기본 IP 계층과 관련이 있기 때문에 NetX와 NetX Duo 사이에 TCP 프로토콜 API 서비스에 변경 사항이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1340">Except where noted, there are no changes in TCP protocol API services between NetX and NetX Duo because IPv6 is primarily concerned with the underlying IP layer.</span></span> <span data-ttu-id="c7e83-1341">모든 NetX Duo TCP 서비스는 IPv4 또는 IPv6 연결에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1341">All NetX Duo TCP services can be used for either IPv4 or IPv6 connections.</span></span>

### <a name="tcp-header"></a><span data-ttu-id="c7e83-1342">TCP 헤더</span><span class="sxs-lookup"><span data-stu-id="c7e83-1342">TCP Header</span></span>   
<span data-ttu-id="c7e83-1343">전송 시 TCP 헤더는 사용자의 데이터 앞에 배치됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1343">On transmission, TCP header is placed in front of the data from the user.</span></span> <span data-ttu-id="c7e83-1344">수신 시 TCP 헤더가 들어오는 패킷에서 제거되고 사용자 데이터만 애플리케이션에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1344">On reception, TCP header is removed from the incoming packet, leaving only the user data available to the application.</span></span> <span data-ttu-id="c7e83-1345">TCP는 IP 프로토콜을 활용하여 패킷을 주고받는데, 이는 패킷이 네트워크에 있을 때 TCP 헤더 앞에 IP 헤더가 있다는 것을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1345">TCP utilizes the IP protocol to send and receive packets, which means there is an IP header in front of the TCP header when the packet is on the network.</span></span> <span data-ttu-id="c7e83-1346">그림 13에서는 TCP 헤더의 형식을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1346">Figure 13 shows the format of the TCP header.</span></span>

![TCP 헤더 형식 다이어그램입니다.](./media/user-guide/image22.png)

### <a name="figure-13-tcp-header"></a><span data-ttu-id="c7e83-1348">그림 13.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1348">FIGURE 13.</span></span> <span data-ttu-id="c7e83-1349">TCP 헤더</span><span class="sxs-lookup"><span data-stu-id="c7e83-1349">TCP Header</span></span>

<span data-ttu-id="c7e83-1350">다음은 TCP 헤더 형식에 대한 설명입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1350">The following describes the TCP header format:</span></span>

|<span data-ttu-id="c7e83-1351">헤더&nbsp;필드</span><span class="sxs-lookup"><span data-stu-id="c7e83-1351">Header&nbsp;Field</span></span> |<span data-ttu-id="c7e83-1352">목적</span><span class="sxs-lookup"><span data-stu-id="c7e83-1352">Purpose</span></span> |
|------|------|
| <span data-ttu-id="c7e83-1353">**16비트 소스 포트 번호**</span><span class="sxs-lookup"><span data-stu-id="c7e83-1353">**16-bit source port number**</span></span> | <span data-ttu-id="c7e83-1354">이 필드에는 TCP 패킷이 전송되는 포트가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1354">This field contains the port the TCP packet is being sent out on.</span></span> <span data-ttu-id="c7e83-1355">유효한 TCP 포트 범위는 1에서 0xFFFF까지입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1355">Valid TCP ports range from 1 through 0xFFFF.</span></span> |
| <span data-ttu-id="c7e83-1356">**16비트 대상 포트**</span><span class="sxs-lookup"><span data-stu-id="c7e83-1356">**16-bit destination port**</span></span> | <span data-ttu-id="c7e83-1357">이 필드에는 패킷이 전송되는 TCP 포트가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1357">This field contains the TCP port the packet is being sent to.</span></span> <span data-ttu-id="c7e83-1358">유효한 TCP 포트 범위는 1에서 0xFFFF까지입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1358">Valid TCP ports range from 1 through 0xFFFF.</span></span> |
| <span data-ttu-id="c7e83-1359">**32비트 시퀀스 번호**</span><span class="sxs-lookup"><span data-stu-id="c7e83-1359">**32-bit sequence number**</span></span> | <span data-ttu-id="c7e83-1360">이 필드에는 연결의 이쪽 끝에서 전송된 데이터의 시퀀스 번호가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1360">This field contains the sequence number for data sent from this end of the connection.</span></span> <span data-ttu-id="c7e83-1361">원래 시퀀스는 두 TCP 노드 간의 초기 연결 시퀀스 중에 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1361">The original sequence is established during the initial connection sequence between two TCP nodes.</span></span> <span data-ttu-id="c7e83-1362">해당 지점에서 데이터를 전송할 때마다 시퀀스 번호가 전송된 바이트 양만큼 증가합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1362">Every data transfer from that point results in an increment of the sequence number by the amount bytes sent.</span></span> |
| <span data-ttu-id="c7e83-1363">**32비트 승인 번호**</span><span class="sxs-lookup"><span data-stu-id="c7e83-1363">**32-bit acknowledgement number**</span></span> | <span data-ttu-id="c7e83-1364">이 필드에는 연결의 이 쪽에서 마지막으로 수신된 바이트에 해당하는 시퀀스 번호가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1364">This field contains the sequence number corresponding to the last byte received by this side of the connection.</span></span> <span data-ttu-id="c7e83-1365">이는 이전에 전송된 데이터가 연결의 다른 쪽 끝에서 성공적으로 수신되었는지 여부를 확인하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1365">This is used to determine whether or not data previously sent has successfully been received by the other end of the connection.</span></span> |
| <span data-ttu-id="c7e83-1366">**4비트 헤더 길이**</span><span class="sxs-lookup"><span data-stu-id="c7e83-1366">**4-bit header length**</span></span> | <span data-ttu-id="c7e83-1367">이 필드에는 TCP 헤더의 32비트 단어 수가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1367">This field contains the number of 32-bit words in the TCP header.</span></span> <span data-ttu-id="c7e83-1368">TCP 헤더에 옵션이 없는 경우 이 필드는 5입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1368">If no options are present in the TCP header, this field is 5.</span></span> |
| <span data-ttu-id="c7e83-1369">**6비트 코드 비트**</span><span class="sxs-lookup"><span data-stu-id="c7e83-1369">**6-bit code bits**</span></span> |<span data-ttu-id="c7e83-1370">이 필드에는 연결과 관련된 다양한 제어 정보를 나타내는 데 사용되는 6개의 서로 다른 코드 비트가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1370">This field contains the six different code bits used to indicate various control information associated with the connection.</span></span> <span data-ttu-id="c7e83-1371">제어 비트는 다음과 같이 정의됩니다.<br \> - URG(21): 긴급 데이터 표시<br \> - ACK(20): 승인 번호 유효<br \> - PSH(19): 이 데이터 즉시 처리<br \> - RST(18): 연결 다시 설정<br \> - SYN(17): 시퀀스 번호 동기화(연결 설정에 사용)<br \> - FIN(16): 보낸 사람 전송 완료(연결 종료에 사용)</span><span class="sxs-lookup"><span data-stu-id="c7e83-1371">The control bits are defined as follows:<br \> - URG (21): Urgent data presen<br \> - ACK (20): Acknowledgement number is valid<br \> - PSH (19): Handle this data immediately<br \> - RST (18): Reset the connection<br \> - SYN (17): Synchronize sequence numbers (used to establish connection)<br \> - FIN (16): Sender is finished with transmit (used to close connection)</span></span> |
|<span data-ttu-id="c7e83-1372">**16비트 창**</span><span class="sxs-lookup"><span data-stu-id="c7e83-1372">**16-bit window**</span></span> |<span data-ttu-id="c7e83-1373">이 필드는 흐름 제어에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1373">This field is used for flow control.</span></span> <span data-ttu-id="c7e83-1374">소켓이 현재 수신할 수 있는 바이트의 양이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1374">It contains the amount of bytes the socket can currently receive.</span></span> <span data-ttu-id="c7e83-1375">이는 기본적으로 흐름 제어에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1375">This basically is used for flow control.</span></span> <span data-ttu-id="c7e83-1376">보낸 사람은 전송할 데이터가 받는 사람의 보급된 창에 맞는지 확인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1376">The sender is responsible for making sure the data to send will fit into the receiver's advertised window.</span></span> |
|<span data-ttu-id="c7e83-1377">**16비트 TCP 체크섬**</span><span class="sxs-lookup"><span data-stu-id="c7e83-1377">**16-bit TCP checksum**</span></span> |<span data-ttu-id="c7e83-1378">이 필드에는 TCP 헤더, 패킷 데이터 영역, 의사 IP 헤더를 포함하는 패킷에 대한 16비트 체크섬이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1378">This field contains the 16-bit checksum for the packet including the TCP header, the packet data area, and the pseudo IP header.</span></span> |
|<span data-ttu-id="c7e83-1379">**16비트 긴급 포인터**</span><span class="sxs-lookup"><span data-stu-id="c7e83-1379">**16-bit urgent pointer**</span></span> |<span data-ttu-id="c7e83-1380">이 필드에는 긴급 데이터의 마지막 바이트의 양수 오프셋이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1380">This field contains the positive offset of the last byte of the urgent data.</span></span> <span data-ttu-id="c7e83-1381">이 필드는 URG 코드 비트가 헤더에 설정된 경우에만 유효합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1381">This field is only valid if the URG code bit is set in the header.</span></span> |

> [!NOTE]  
> <span data-ttu-id="c7e83-1382">TCP/IP 구현의 모든 헤더는 **big endian** 형식이어야 합니다. 이 형식에서 단어의 가장 중요한 바이트는 가장 낮은 바이트 주소에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1382">*All headers in the TCP/IP implementation are expected to be in **big endian** format. In this format, the most significant byte of the word resides at the lowest byte address*.</span></span>

### <a name="tcp-enable"></a><span data-ttu-id="c7e83-1383">TCP 사용</span><span class="sxs-lookup"><span data-stu-id="c7e83-1383">TCP Enable</span></span>       
<span data-ttu-id="c7e83-1384">TCP 연결 및 패킷 전송을 사용하려면 먼저 애플리케이션이 ***nx_tcp_enable*** 서비스를 호출하여 TCP를 사용하도록 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1384">Before TCP connections and packet transmissions are possible, the application must first enable TCP by calling the ***nx_tcp_enable*** service.</span></span> <span data-ttu-id="c7e83-1385">사용하도록 설정된 후 애플리케이션은 모든 TCP 서비스에 자유롭게 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1385">After enabled, the application is free to access all TCP services.</span></span>  

### <a name="tcp-socket-create"></a><span data-ttu-id="c7e83-1386">TCP 소켓 만들기</span><span class="sxs-lookup"><span data-stu-id="c7e83-1386">TCP Socket Create</span></span>    
<span data-ttu-id="c7e83-1387">TCP 소켓은 초기화 중에 또는 애플리케이션 스레드에 의한 런타임 중에 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1387">TCP sockets are created either during initialization or during runtime by application threads.</span></span> <span data-ttu-id="c7e83-1388">초기 서비스 형식, TTL(Time to Live), 창 크기는 ***nx_tcp_socket_create*** 서비스에 의해 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1388">The initial type of service, time to live, and window size are defined by the ***nx_tcp_socket_create*** service.</span></span> <span data-ttu-id="c7e83-1389">애플리케이션의 TCP 소켓 수에는 제한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1389">There are no limits on the number of TCP sockets in an application.</span></span>  

### <a name="tcp-checksum"></a><span data-ttu-id="c7e83-1390">TCP 체크섬</span><span class="sxs-lookup"><span data-stu-id="c7e83-1390">TCP Checksum</span></span>     
<span data-ttu-id="c7e83-1391">TCP는 IP 의사 헤더(소스 IP 주소, 대상 IP 주소, 프로토콜/길이 IP 단어로 구성), TCP 헤더, TCP 패킷 데이터를 포함하는 1의 보수 16비트 체크섬을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1391">TCP specifies a one's complement 16-bit checksum that covers the IP pseudo header, (consisting of the source IP address, destination IP address, and the protocol/length IP word), the TCP header, and the TCP packet data.</span></span> <span data-ttu-id="c7e83-1392">IPv4와 IPv6 TCP 패킷 헤더 체크섬의 유일한 차이점은 소스 및 대상 IP 주소가 IPv4에서는 32비트이고 IPv6에서는 128비트라는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1392">The only difference between IPv4 and IPv6 TCP packet header checksums is that the source and destination IP addresses are 32 bit in IPv4 and 128 bit in IPv6.</span></span> 

<span data-ttu-id="c7e83-1393">특정 네트워크 컨트롤러는 하드웨어에서 TCP 체크섬 계산 및 유효성 검사를 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1393">Certain network controllers are able to perform TCP checksum computation and validation in hardware.</span></span> <span data-ttu-id="c7e83-1394">이러한 시스템의 경우, 애플리케이션은 런타임 오버헤드를 줄이기 위해 가능한 한 많은 하드웨어 체크섬 논리를 사용해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1394">For such systems, applications may want to use hardware checksum logic as much as possible to reduce runtime overhead.</span></span> <span data-ttu-id="c7e83-1395">애플리케이션은 빌드 시 ***NX_DISABLE_TCP_TX_CHECKSUM** _ 및 _*_NX_DISABLE_TCP_RX_CHECKSUM_\*\*을 정의하여 NetX Duo 라이브러리에서 TCP 체크섬 계산 논리를 모두 사용하지 않도록 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1395">Applications may disable TCP checksum computation logic from the NetX Duo library altogether at build time by defining ***NX_DISABLE_TCP_TX_CHECKSUM** _ and _*_NX_DISABLE_TCP_RX_CHECKSUM_\*\*.</span></span> <span data-ttu-id="c7e83-1396">이렇게 하면 TCP 체크섬 코드는 컴파일되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1396">This way, the TCP checksum code is not compiled in.</span></span> <span data-ttu-id="c7e83-1397">그러나 선택적 NetX Duo IPsec 패키지가 설치되어 있고 TCP 연결이 보안 채널을 통해 트래버스해야 하는 경우에는 주의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1397">However one should exercise caution if the optional NetX Duo IPsec package is installed, and the TCP connection may need to traverse through a secure channel.</span></span> <span data-ttu-id="c7e83-1398">이 경우 TCP 연결에 속하는 패킷의 데이터는 이미 암호화되어 있으며, 네트워크 드라이버에 있는 대부분의 하드웨어 TCP 체크섬 모듈은 암호화된 TCP 페이로드에서 올바른 체크섬 값을 생성할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1398">In this case, data in packets belonging to the TCP connection is already encrypted, and most hardware TCP checksum modules present in the network driver are unable to generate correct checksum value from the encrypted TCP payload.</span></span>

<span data-ttu-id="c7e83-1399">이 문제를 해결하기 위해 애플리케이션은 TCP 체크섬 논리를 라이브러리에서 사용할 수 있도록 유지하고 인터페이스 기능을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1399">To address this issue, application shall keep the TCP checksum logic available in the library and use the interface capability feature.</span></span> <span data-ttu-id="c7e83-1400">인터페이스 기능을 사용하도록 설정하면 TCP 모듈은 드라이버가 체크섬 값을 계산할 수 있는 경우 TCP 체크섬을 올바르게 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1400">With interface capability feature enabled, the TCP module knows how to properly handle the TCP checksum if the driver is also able to compute the checksum value:</span></span>

1) <span data-ttu-id="c7e83-1401">TCP 패킷이 IPsec 프로세스의 적용을 받지 않는 경우 네트워크 인터페이스 하드웨어는 체크섬을 계산할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1401">If the TCP packet is not subject to IPsec process, the network interface hardware is able to compute the checksum.</span></span> <span data-ttu-id="c7e83-1402">따라서 TCP 모듈은 체크섬 계산을 시도하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1402">Therefore the TCP module does not attempt to compute the checksum;</span></span>

2) <span data-ttu-id="c7e83-1403">IPsec 패키지가 설치되어 있고 TCP 패킷이 IPsec 프로세스의 적용을 받는 경우, TCP 모듈은 패킷을 IPsec 계층으로 전송하기 전에 소프트웨어에서 체크섬을 계산합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1403">If IPsec package is installed, and the TCP packet is subject to IPsec process, the TCP module computes checksum in software before sending the packet to IPsec layer.</span></span>

### <a name="tcp-port"></a><span data-ttu-id="c7e83-1404">TCP 포트</span><span class="sxs-lookup"><span data-stu-id="c7e83-1404">TCP Port</span></span>     
<span data-ttu-id="c7e83-1405">TCP 포트는 TCP 프로토콜의 논리적 연결 지점입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1405">A TCP port is a logical connection point in the TCP protocol.</span></span> <span data-ttu-id="c7e83-1406">NetX Duo의 TCP 구성 요소에는 65,535개의 유효한 포트가 있으며, 범위는 1~0xFFFF입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1406">There are 65,535 valid ports in the TCP component of NetX Duo, ranging from 1 through 0xFFFF.</span></span> <span data-ttu-id="c7e83-1407">한 포트의 데이터를 다른 대상 포트로 전송할 수 있는 UDP와 달리 TCP 포트는 다른 특정 TCP 포트에 연결되며 이 연결이 설정될 때, 연결을 구성하는 두 포트 사이에서만 데이터 전송이 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1407">Unlike UDP in which data from one port can be sent to any other destination port, a TCP port is connected to another specific TCP port, and only when this connection is established can any data transfer take place—and only between the two ports making up the connection.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="c7e83-1408">TCP 포트는 UDP 포트와 완전히 분리되어 있습니다. 예를 들어, UDP 포트 번호 1은 TCP 포트 번호 1과 관련이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1408">*TCP ports are completely separate from UDP ports; e.g., UDP port number 1 has no relation to TCP port number 1*.</span></span>

### <a name="client-server-model"></a><span data-ttu-id="c7e83-1409">클라이언트 서버 모델</span><span class="sxs-lookup"><span data-stu-id="c7e83-1409">Client-Server Model</span></span>     
<span data-ttu-id="c7e83-1410">데이터 전송에 TCP를 사용하려면 먼저 두 TCP 소켓 사이에 연결을 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1410">To use TCP for data transfer, a connection must first be established between the two TCP sockets.</span></span> <span data-ttu-id="c7e83-1411">연결 설정은 클라이언트 서버 방식으로 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1411">The establishment of the connection is done in a client-server fashion.</span></span> <span data-ttu-id="c7e83-1412">연결의 클라이언트 쪽은 연결을 시작하는 쪽이고, 서버 쪽은 처리가 완료되기 전에 클라이언트 연결 요청을 기다리기만 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1412">The client side of the connection is the side that initiates the connection, while the server side simply waits for client connection requests before any processing is done.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="c7e83-1413">멀티홈 디바이스의 경우, NetX Duo는 연결에 사용할 소스 주소와 연결의 대상 IP 주소를 기반으로 다음 홉 주소를 자동으로 결정합니다. TCP는 유니캐스트(예: 비방송) 대상 주소에 패킷을 전송하는 것으로 제한되기 때문에 NetX Duo는 소스 IPv6 주소를 선택하기 위한 “힌트”가 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1413">*For multihome devices, NetX Duo automatically determines the source address to use for the connection, and the next hop address based on the destination IP address of the connection. Because TCP is limited to sending packets to unicast (e.g.nonbroadcast) destination addresses, NetX Duo does not require a "hint" for choosing the source IPv6 address*.</span></span>

### <a name="tcp-socket-state-machine"></a><span data-ttu-id="c7e83-1414">TCP 소켓 상태 시스템</span><span class="sxs-lookup"><span data-stu-id="c7e83-1414">TCP Socket State Machine</span></span>      
<span data-ttu-id="c7e83-1415">두 TCP 소켓(하나의 클라이언트와 하나의 서버) 간의 연결이 복잡하며 상태 시스템 방식으로 관리됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1415">The connection between two TCP sockets (one client and one server) is complex and is managed in a state machine manner.</span></span> <span data-ttu-id="c7e83-1416">각 TCP 소켓은 CLOSED 상태로 시작됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1416">Each TCP socket starts in a CLOSED state.</span></span> <span data-ttu-id="c7e83-1417">연결 이벤트를 통해 각 소켓의 상태 시스템은 TCP 데이터 전송의 대부분을 ESTABLISHED 상태로 마이그레이션합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1417">Through connection events each socket's state machine migrates into the ESTABLISHED state, which is where the bulk of the data transfer in TCP takes place.</span></span> <span data-ttu-id="c7e83-1418">연결의 한쪽이 더 이상 데이터를 전송하지 않으려는 경우 연결이 끊어집니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1418">When one side of the connection no longer wishes to send data, it disconnects.</span></span> <span data-ttu-id="c7e83-1419">다른 쪽의 연결이 끊긴 후, 결국 TCP 소켓은 CLOSED 상태로 돌아갑니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1419">After the other side disconnects, eventually the TCP socket returns to the CLOSED state.</span></span> <span data-ttu-id="c7e83-1420">이 프로세스는 TCP 클라이언트와 서버가 연결을 설정하고 닫을 때마다 반복됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1420">This process repeats each time a TCP client and server establish and close a connection.</span></span> <span data-ttu-id="c7e83-1421">그림 14에서는 TCP 상태 시스템의 다양한 상태를 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1421">Figure 14 shows the various states of the TCP state machine.</span></span>

### <a name="tcp-client-connection"></a><span data-ttu-id="c7e83-1422">TCP 클라이언트 연결</span><span class="sxs-lookup"><span data-stu-id="c7e83-1422">TCP Client Connection</span></span>       
<span data-ttu-id="c7e83-1423">앞에서 설명한 대로 TCP 연결의 클라이언트 측에서 TCP 서버에 대한 연결 요청을 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1423">As mentioned previously, the client side of the TCP connection initiates a connection request to a TCP server.</span></span> <span data-ttu-id="c7e83-1424">연결 요청을 하려면 먼저 클라이언트 IP 인스턴스에서 TCP를 사용하도록 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1424">Before a connection request can be made, TCP must be enabled on the client IP instance.</span></span> <span data-ttu-id="c7e83-1425">또한 클라이언트 TCP 소켓은 다음에 ***nx_tcp_socket_create** _ 서비스를 사용하여 만들고 _ *_nx_tcp_client_socket_bind_** 서비스를 통해 포트에 바인딩되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1425">In addition, the client TCP socket must next be created with the ***nx_tcp_socket_create** _ service and bound to a port via the _ *_nx_tcp_client_socket_bind_** service.</span></span>

<span data-ttu-id="c7e83-1426">클라이언트 소켓이 바인딩된 후에는 ***nxd_tcp_client_socket_connect*** 서비스를 사용하여 TCP 서버와의 연결을 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1426">After the client socket is bound, the ***nxd_tcp_client_socket_connect*** service is used to establish a connection with a TCP server.</span></span> <span data-ttu-id="c7e83-1427">연결 시도를 시작하려면 소켓이 CLOSED 상태여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1427">Note the socket must be in a CLOSED state to initiate a connection attempt.</span></span> <span data-ttu-id="c7e83-1428">연결 설정은 NetX Duo가 SYN 패킷을 실행한 다음 서버에서 SYN ACK 패킷을 다시 대기하는 것으로 시작하며 이는 연결 요청에 대한 승인을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1428">Establishing the connection starts with NetX Duo issuing a SYN packet and then waiting for a SYN ACK packet back from the server, which signifies acceptance of the connection request.</span></span> <span data-ttu-id="c7e83-1429">SYN ACK가 수신되면 NetX Duo는 ACK 패킷으로 응답하고 클라이언트 소켓을 ESTABLISHED 상태로 수준을 올립니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1429">After the SYN ACK is received, NetX Duo responds with an ACK packet and promotes the client socket to the ESTABLISHED state.</span></span>

![TCP 상태 시스템의 상태 다이어그램입니다.](./media/user-guide/image24.png)   

<span data-ttu-id="c7e83-1431">**그림 14. TCP 상태 시스템의 상태**</span><span class="sxs-lookup"><span data-stu-id="c7e83-1431">**FIGURE 14. States of the TCP State Machine**</span></span>


> [!WARNING]
> <span data-ttu-id="c7e83-1432">애플리케이션은 IPv4 및 IPv6 TCP 연결에 대해 **nxd_tcp_client_socket_connect** 를 사용해야 합니다. 여전히 애플리케이션은 IPv4 TCP 연결에 대한 **nx_tcp_client_socket_connect** 를 사용할 수 있지만 **nx_tcp_client_socket_connect** 가 결국 더 이상 사용되지 않으므로 개발자는 **nxd_tcp_client_socket_connect** 를 사용할 것을 권장합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1432">*Applications should use **nxd_tcp_client_socket_connect** for either IPv4 and IPv6 TCP connections. Applications can still use **nx_tcp_client_socket_connect** for IPv4 TCP connections, but developers are encouraged to use **nxd_tcp_client_socket_connect** since **nx_tcp_client_socket_connect** will eventually be deprecated*.</span></span>

<span data-ttu-id="c7e83-1433">마찬가지로 **nxd_tcp_socket_peer_info_get** 은 IPv4 또는 IPv6 TCP 연결을 사용합니다. 그러나 레거시 애플리케이션에서는 **nx_tcp_socket_peer_info_get** 을 계속 사용할 수 있습니다. 개발자는 앞으로 **nxd_tcp_socket_peer_info_get** 을 사용할 것을 권장합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1433">*Similarly, **nxd_tcp_socket_peer_info_get** works with either IPv4 or IPv6 TCP connections. However, **nx_tcp_socket_peer_info_get** is still available for legacy applications. Developers are encouraged to use **nxd_tcp_socket_peer_info_get** going forward*.</span></span>

### <a name="tcp-client-disconnection"></a><span data-ttu-id="c7e83-1434">TCP 클라이언트 연결 끊기</span><span class="sxs-lookup"><span data-stu-id="c7e83-1434">TCP Client Disconnection</span></span>    
<span data-ttu-id="c7e83-1435">***nx_tcp_socket_disconnect*** 를 호출하여 연결을 닫습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1435">Closing the connection is accomplished by calling ***nx_tcp_socket_disconnect***.</span></span> <span data-ttu-id="c7e83-1436">일시 중단이 지정되지 않은 경우 클라이언트 소켓은 RST 패킷을 서버 소켓으로 전송하고 소켓을 CLOSED 상태로 둡니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1436">If no suspension is specified, the client socket sends a RST packet to the server socket and places the socket in the CLOSED state.</span></span> <span data-ttu-id="c7e83-1437">그러지 않고 일시 중단이 요청되면 다음과 같이 전체 TCP 연결 끊기 프로토콜이 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1437">Otherwise, if a suspension is requested, the full TCP disconnect protocol is performed, as follows:</span></span> 

- <span data-ttu-id="c7e83-1438">서버가 이전에 연결 끊기 요청을 시작한 경우(클라이언트 소켓이 이미 FIN 패킷을 수신하여 ACK로 응답하고 CLOSE WAIT 상태에 있음), NetX Duo는 클라이언트 TCP 소켓 상태를 LAST ACK 상태로 승격하고 FIN 패킷을 전송합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1438">If the server previously initiated a disconnect request (the client socket has already received a FIN packet, responded with an ACK, and is in the CLOSE WAIT state), NetX Duo promotes the client TCP socket state to the LAST ACK state and sends a FIN packet.</span></span> <span data-ttu-id="c7e83-1439">그런 다음 서버로부터 ACK를 기다렸다가 연결을 끊고 CLOSED 상태로 들어갑니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1439">It then waits for an ACK from the server before completing the disconnect and entering the CLOSED state.</span></span>

- <span data-ttu-id="c7e83-1440">반면에 클라이언트가 연결 해제 요청을 가장 먼저 시작하는 경우(서버는 연결이 끊기지 않았으며 소켓은 여전히 ESTABLISHED 상태) NetX Duo는 연결을 해제하기 위해 FIN 패킷을 전송하고 서버로부터 FIN과 ACK를 받기 위해 대기한 후 연결을 완전히 끊고 소켓을 CLOSED 상태로 둡니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1440">If on the other hand, the client is the first to initiate a disconnect request (the server has not disconnected and the socket is still in the ESTABLISHED state), NetX Duo sends a FIN packet to initiate the disconnect and waits to receive a FIN and an ACK from the server before completing the disconnect and placing the socket in a CLOSED state.</span></span>

<span data-ttu-id="c7e83-1441">소켓 전송 큐에 여전히 패킷이 있는 경우 NetX Duo는 패킷을 승인할 수 있도록 지정된 시간 제한을 일시 중단합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1441">If there are still packets on the socket transmit queue, NetX Duo suspends for the specified timeout to allow the packets to be acknowledged.</span></span> <span data-ttu-id="c7e83-1442">시간 제한이 만료되면 NetX Duo는 클라이언트 소켓의 전송 큐를 비웁니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1442">If the timeout expires, NetX Duo empties the transmit queue of the client socket.</span></span> 

<span data-ttu-id="c7e83-1443">클라이언트 소켓에서 포트의 바인딩을 해제하기 위해 애플리케이션은 ***nx_tcp_client_socket_unbind*** 를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1443">To unbind the port from the client socket, the application calls ***nx_tcp_client_socket_unbind***.</span></span> <span data-ttu-id="c7e83-1444">포트가 해제되기 전에 소켓이 CLOSED 상태이거나 연결을 끊는 중(TIMED WAIT 상태)이어야 합니다. 그러지 않으면 오류가 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1444">The socket must be in a CLOSED state or in the process of disconnecting (i.e., TIMED WAIT state) before the port is released; otherwise, an error is returned.</span></span>

<span data-ttu-id="c7e83-1445">마지막으로, 애플리케이션이 더 이상 클라이언트 소켓을 필요로 하지 않으면 ***nx_tcp_socket_delete*** 를 호출하여 소켓을 삭제합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1445">Finally, if the application no longer needs the client socket, it calls ***nx_tcp_socket_delete*** to delete the socket.</span></span>

### <a name="tcp-server-connection"></a><span data-ttu-id="c7e83-1446">TCP 서버 연결</span><span class="sxs-lookup"><span data-stu-id="c7e83-1446">TCP Server Connection</span></span>      
<span data-ttu-id="c7e83-1447">TCP 연결의 서버 측은 수동적입니다. 즉, 서버는 클라이언트가 연결 요청을 시작할 때까지 기다립니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1447">The server side of a TCP connection is passive; i.e., the server waits for a client to initiate connection request.</span></span> <span data-ttu-id="c7e83-1448">클라이언트 연결을 허용하려면 먼저 \***nx_tcp_enable** _ 서비스를 호출하여 IP 인스턴스에서 TCP를 사용하도록 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1448">To accept a client connection, TCP must first be enabled on the IP instance by calling the service \***nx_tcp_enable** _.</span></span> <span data-ttu-id="c7e83-1449">다음으로 애플리케이션은 _ _nx_tcp_socket_create_\* 서비스를 사용하여 TCP 소켓을 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1449">Next, the application must create a TCP socket using the _ *_nx_tcp_socket_create_*\* service.</span></span>  

<span data-ttu-id="c7e83-1450">서버 소켓이 연결 요청을 수신 대기하도록 설정되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1450">The server socket must also be set up for listening for connection requests.</span></span> <span data-ttu-id="c7e83-1451">이 작업은 ***nx_tcp_server_socket_listen*** 서비스를 사용하여 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1451">This is achieved by using the ***nx_tcp_server_socket_listen*** service.</span></span> <span data-ttu-id="c7e83-1452">이 서비스는 서버 소켓을 LISTEN 상태로 두고 지정된 서버 포트를 소켓에 바인딩합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1452">This service places the server socket in the LISTEN state and binds the specified server port to the socket.</span></span>

> [!NOTE] 
> <span data-ttu-id="c7e83-1453">소켓 수신 대기 콜백 루틴을 설정하기 위해 애플리케이션은 **nx_tcp_server_socket_listen** 서비스의 tcp_listen_callback 인수에 대해 적절한 콜백 함수를 지정합니다. 그런 다음 이 애플리케이션 콜백 함수는 이 서버 포트에서 새로운 연결이 요청될 때마다 NetX Duo에 의해 실행됩니다. 콜백의 처리는 애플리케이션 제어 중입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1453">*To set a socket listen callback routine the application specifies the appropriate callback function for the tcp_listen_callback argument of the **nx_tcp_server_socket_listen** service. This application callback function is then executed by NetX Duo whenever a new connection is requested on this server port. The processing in the callback is under application control.*</span></span>

<span data-ttu-id="c7e83-1454">클라이언트 연결 요청을 수락하기 위해 애플리케이션은 \***nx_tcp_server_socket_accept** _ 서비스를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1454">To accept client connection requests, the application calls the \***nx_tcp_server_socket_accept** _ service.</span></span> <span data-ttu-id="c7e83-1455">수락 서비스를 호출하려면 서버 소켓이 LISTEN 상태 또는 SYN RECEIVED 상태(즉, 서버가 LISTEN 상태이고 연결을 요청하는 클라이언트로부터 SYN 패킷을 수신함)여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1455">The server socket must either be in a LISTEN state or a SYN RECEIVED state (i.e., the server is in the LISTEN state and has received a SYN packet from a client requesting a connection) to call the accept service.</span></span> <span data-ttu-id="c7e83-1456">_ \*_nx_tcp_server_socket_accept_\*\*에서 성공적으로 반환되면 연결이 설정되었으며 서버 소켓이 ESTABLISHED 상태에 있음을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1456">A successful return status from _ *_nx_tcp_server_socket_accept_*\* indicates the connection has been set up and the server socket is in the ESTABLISHED state.</span></span>

<span data-ttu-id="c7e83-1457">서버 소켓에 유효한 연결이 있으면 추가 클라이언트 연결 요청이 *listen_queue_size* 에 의해 지정된 깊이까지 큐에 대기하고 \***nx_tcp_server_socket_listen** _ 서비스에 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1457">After the server socket has a valid connection, additional client connection requests are queued up to the depth specified by the *listen_queue_size, passed into the* \***nx_tcp_server_socket_listen** _ service.</span></span> <span data-ttu-id="c7e83-1458">서버 포트에서 후속 연결을 처리하려면 애플리케이션은 사용 가능한 소켓(즉, CLOSED 상태의 소켓)을 사용하여 _ \*_nx_tcp_server_socket_relisten_\*\*를 호출해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1458">In order to process subsequent connections on a server port, the application must call _ *_nx_tcp_server_socket_relisten_*\* with an available socket (i.e., a socket in a CLOSED state).</span></span> <span data-ttu-id="c7e83-1459">소켓과 연결된 이전 연결이 완료되고 소켓이 CLOSED 상태인 경우 동일한 서버 소켓을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1459">Note that the same server socket could be used if the previous connection associated with the socket is now finished and the socket is in the CLOSED state.</span></span>

### <a name="tcp-server-disconnection"></a><span data-ttu-id="c7e83-1460">TCP 서버 연결 끊기</span><span class="sxs-lookup"><span data-stu-id="c7e83-1460">TCP Server Disconnection</span></span>     
<span data-ttu-id="c7e83-1461">***nx_tcp_socket_disconnect*** 를 호출하여 연결을 닫습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1461">Closing the connection is accomplished by calling ***nx_tcp_socket_disconnect***.</span></span> <span data-ttu-id="c7e83-1462">일시 중단이 지정되지 않은 경우 서버 소켓은 RST 패킷을 클라이언트 소켓으로 전송하고 소켓을 CLOSED 상태로 둡니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1462">If no suspension is specified, the server socket sends a RST packet to the client socket and places the socket in the CLOSED state.</span></span> <span data-ttu-id="c7e83-1463">그러지 않고 일시 중단이 요청되면 다음과 같이 전체 TCP 연결 끊기 프로토콜이 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1463">Otherwise, if a suspension is requested, the full TCP disconnect protocol is performed, as follows:</span></span>

- <span data-ttu-id="c7e83-1464">클라이언트가 이전에 연결 끊기 요청을 시작한 경우(서버 소켓이 이미 FIN 패킷을 수신하여 ACK로 응답하고 CLOSE WAIT 상태에 있음), NetX Duo는 TCP 소켓 상태를 LAST ACK 상태로 승격하고 FIN 패킷을 전송합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1464">If the client previously initiated a disconnect request (the server socket has already received a FIN packet, responded with an ACK, and is in the CLOSE WAIT state), NetX Duo promotes the TCP socket state to the LAST ACK state and sends a FIN packet.</span></span> <span data-ttu-id="c7e83-1465">그런 다음 클라이언트로부터 ACK를 기다렸다가 연결을 끊고 CLOSED 상태로 들어갑니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1465">It then waits for an ACK from the client before  completing the disconnect and entering the CLOSED state.</span></span>

- <span data-ttu-id="c7e83-1466">반면에 서버가 연결 해제 요청을 가장 먼저 시작하는 경우(클라이언트는 연결이 끊기지 않았으며 소켓은 여전히 ESTABLISHED 상태) NetX Duo는 연결을 해제하기 위해 FIN 패킷을 전송하고 클라이언트로부터 FIN과 ACK를 받기 위해 대기한 후 연결을 완전히 끊고 소켓을 CLOSED 상태로 둡니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1466">If on the other hand, the server is the first to initiate a disconnect request (the client has not disconnected and the socket is still in the ESTABLISHED state), NetX Duo sends a FIN packet to initiate the disconnect and waits to receive a FIN and an ACK from the client before completing the disconnect and placing the socket in a CLOSED state.</span></span>

<span data-ttu-id="c7e83-1467">소켓 전송 큐에 여전히 패킷이 있는 경우 NetX Duo는 패킷을 승인할 수 있도록 지정된 시간 제한을 일시 중단합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1467">If there are still packets on the socket transmit queue, NetX Duo suspends for the specified timeout to allow those packets to be acknowledged.</span></span> <span data-ttu-id="c7e83-1468">시간 제한이 만료되면 NetX Duo는 서버 소켓의 전송 큐를 플러시합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1468">If the timeout expires, NetX Duo flushes the transmit queue of the server socket.</span></span>

<span data-ttu-id="c7e83-1469">연결 끊기 처리가 완료되고 서버 소켓이 CLOSED 상태이면 애플리케이션은 \***nx_tcp_server_socket_unaccept** _ 서비스를 호출하여 이 소켓과 서버 포트와의 연결을 종료해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1469">After the disconnect processing is complete and the server socket is in the CLOSED state, the application must call the \***nx_tcp_server_socket_unaccept** _ service to end the association of this socket with the server port.</span></span> <span data-ttu-id="c7e83-1470">_*_nx_tcp_socket_disconnect_*_ 또는 _*_nx_tcp_server_socket_accept_*_ 를 오류 상태로 반환하는 경우에도 애플리케이션에서 이 서비스를 호출해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1470">Note this service must be called by the application even if _*_nx_tcp_socket_disconnect_*_ or _*_nx_tcp_server_socket_accept_*_ return an error status.</span></span> <span data-ttu-id="c7e83-1471">_*_nx_tcp_server_socket_unaccept_*_ 를 반환한 후, 소켓을 클라이언트나 서버 소켓으로 사용할 수 있으며 더 이상 필요하지 않은 경우에는 삭제할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1471">After the _*_nx_tcp_server_socket_unaccept_*_ returns, the socket can be used as a client or server socket, or even deleted if it is no longer needed.</span></span> <span data-ttu-id="c7e83-1472">동일한 서버 포트에서 다른 클라이언트 연결을 허용하려면 이 소켓에서 _ *_nx_tcp_server_socket_relisten_*\* 서비스를 호출해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1472">If accepting another client connection on the same server port is desired, the _ *_nx_tcp_server_socket_relisten_*\* service should be called on this socket.</span></span>

<span data-ttu-id="c7e83-1473">다음 코드 세그먼트는 일반적인 TCP 서버가 사용하는 호출 시퀀스를 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1473">The following code segment illustrates the sequence of calls a typical TCP server uses:</span></span>

```c
/* Set up a previously created TCP socket to
   listen on port 12 */
nx_tcp_server_socket_listen()

/* Loop to make a (another) connection. */
while(1)
{
    /* Wait for a client socket connection request
       for 100 ticks. */
    nx_tcp_server_socket_accept();

    /* (Send and receive TCP messages with the TCP
       client) */

    /* Disconnect the server socket. */
    nx_tcp_socket_disconnect();

    /* Remove this server socket from listening on
       the port. */
    nx_tcp_server_socket_unaccept(&server_socket);
    /* Set up server socket to relisten on the
       same port for the next client. */
    nx_tcp_server_socket_relisten();
}
```

### <a name="mss-validation"></a><span data-ttu-id="c7e83-1474">MSS 유효성 검사</span><span class="sxs-lookup"><span data-stu-id="c7e83-1474">MSS Validation</span></span>      
<span data-ttu-id="c7e83-1475">MSS(최대 세그먼트 크기)는 TCP 호스트가 기본 IP 계층에 의해 조각나지 않고 수신할 수 있는 최대 바이트 수입니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1475">The Maximum Segment Size (MSS) is the maximum amount of bytes a TCP host can receive without being fragmented by the underlying IP layer.</span></span> <span data-ttu-id="c7e83-1476">TCP 연결 설정 단계를 수행하는 동안 양쪽 끝에서 자체 TCP MSS 값을 교환하여 보낸 사람이 받는 사람의 MSS보다 큰 TCP 데이터 세그먼트를 전송하지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1476">During TCP connection establishment phase, both ends exchanges its own TCP MSS value, so that the sender does not send a TCP data segment that is larger than the receiver's MSS.</span></span> <span data-ttu-id="c7e83-1477">NetX Duo TCP 모듈은 연결을 설정하기 전에 피어의 보급된 MSS 값의 유효성을 선택적으로 검사합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1477">NetX Duo TCP module will optionally validate its peer's advertised MSS value before establishing a connection.</span></span> <span data-ttu-id="c7e83-1478">기본적으로 NetX Duo는 이러한 검사를 사용하도록 설정하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1478">By default NetX Duo does not enable such a check.</span></span> <span data-ttu-id="c7e83-1479">MSS 유효성 검사를 수행하려는 애플리케이션은 NetX Duo 라이브러리를 빌드할 때 ***NX_ENABLE_TCP_MSS_CHECK** _를 정의해야 하며 최솟값은 _*_NX_TCP_MSS_MINIMUM_\*_ 에 정의되어 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1479">Applications wishing to perform MSS validation shall define ***NX_ENABLE_TCP_MSS_CHECK** _ when building the NetX Duo library, and the minimum value shall be defined in _*_NX_TCP_MSS_MINIMUM_\*_.</span></span> <span data-ttu-id="c7e83-1480">MSS 값이 _ *_NX_TCP_MSS_MINIMUM_*\* 미만으로 들어오는 TCP 연결이 삭제됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1480">Incoming TCP connections with MSS values below _ *_NX_TCP_MSS_MINIMUM_*\* are dropped.</span></span>

### <a name="stop-listening-on-a-server-port"></a><span data-ttu-id="c7e83-1481">서버 포트에서 수신 대기 중지</span><span class="sxs-lookup"><span data-stu-id="c7e83-1481">Stop Listening on a Server Port</span></span>    
<span data-ttu-id="c7e83-1482">애플리케이션이 이전에 ***nx_tcp_server_socket_listen** _ 서비스에 대한 호출로 이전에 지정된 서버 포트에서 클라이언트 연결 요청을 더 이상 수신 대기하지 않으려는 경우, 애플리케이션은 _ *_nx_tcp_server_socket_unlisten_** 서비스를 호출하기만 하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1482">If the application no longer wishes to listen for client connection requests on a server port that was previously specified by a call to the ***nx_tcp_server_socket_listen** _ service, the application simply calls the _ *_nx_tcp_server_socket_unlisten_** service.</span></span> <span data-ttu-id="c7e83-1483">이 서비스는 연결을 기다리는 소켓을 다시 CLOSED 상태로 두고 큐에 있는 클라이언트 연결 요청 패킷을 모두 해제합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1483">This service places any socket waiting for a connection back in the CLOSED state and releases any queued client connection request packets.</span></span> 

### <a name="tcp-window-size"></a><span data-ttu-id="c7e83-1484">TCP 창 크기</span><span class="sxs-lookup"><span data-stu-id="c7e83-1484">TCP Window Size</span></span>   
<span data-ttu-id="c7e83-1485">연결의 설정 및 데이터 전송 단계를 수행하는 동안 각 포트는 처리할 수 있는 데이터 양을 보고합니다. 이를 창 크기라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1485">During both the setup and data transfer phases of the connection, each port reports the amount of data it can handle, which is called its window size.</span></span> <span data-ttu-id="c7e83-1486">데이터가 수신되고 처리되면 이 창 크기는 동적으로 조정됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1486">As data are received and processed, this window size is adjusted dynamically.</span></span> <span data-ttu-id="c7e83-1487">TCP에서 송신자는 수신자의 창에 맞는 양의 데이터만 전송할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1487">In TCP, a sender can only send an amount of data that fits into the receiver's window.</span></span> <span data-ttu-id="c7e83-1488">기본적으로 창 크기는 연결의 각 방향에서 데이터 전송을 위한 흐름 제어를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1488">In essence, the window size provides flow control for data transfer in each direction of the connection.</span></span>   

### <a name="tcp-packet-send"></a><span data-ttu-id="c7e83-1489">TCP 패킷 전송</span><span class="sxs-lookup"><span data-stu-id="c7e83-1489">TCP Packet Send</span></span>     
<span data-ttu-id="c7e83-1490">***nx_tcp_socket_send*** 함수를 호출하여 TCP 데이터 전송을 쉽게 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1490">Sending TCP data is easily accomplished by calling the ***nx_tcp_socket_send*** function.</span></span> <span data-ttu-id="c7e83-1491">전송 중인 데이터의 크기가 소켓의 MSS 값 또는 현재 피어 수신 창 크기 중 더 작은 값보다 클 경우, TCP 내부 논리는 전송을 위해 최소 크기(MSS, 피어 수신 창)에 맞는 데이터를 잘라냅니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1491">If the size of the data being transmitted is larger than the MSS value of the socket or the current peer receive window size, whichever is smaller, TCP internal logic carves off the data that fits into min (MSS, peer receive Window) for transmission.</span></span> <span data-ttu-id="c7e83-1492">그런 다음, 이 서비스는 체크섬 계산을 포함하여 패킷 앞에 TCP 헤더를 빌드합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1492">This service then builds a TCP header in front of the packet (including the checksum calculation).</span></span> <span data-ttu-id="c7e83-1493">수신자의 창 크기가 0이 아닌 경우, 호출자는 수신자 창 크기를 채울 수 있는 만큼의 최대한 많은 데이터를 전송합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1493">If the receiver's window size is not zero, the caller will send as much data as it can to fill up the receiver window size.</span></span> <span data-ttu-id="c7e83-1494">수신 창이 0이 되면, 호출자는 이 패킷을 보낼 수 있을 만큼 수신자의 창 크기가 커지기를 일시 중단하고 대기할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1494">If the receive window becomes zero, the caller may suspend and wait for the receiver's window size to increase enough for this packet to be sent.</span></span> <span data-ttu-id="c7e83-1495">언제든지 여러 스레드가 동일한 소켓을 통해 데이터를 전송하는 동안 스레드는 일시 중단될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1495">At any given time, multiple threads may suspend while trying to send data through the same socket.</span></span> 

> [!WARNING]  
> <span data-ttu-id="c7e83-1496">NX_PACKET 구조에 있는 TCP 데이터는 긴 단어 경계에 있어야 합니다. 또한 앞에 추가 포인터와 데이터 시작 포인터 사이에 TCP, IP, 실제 미디어 헤더가 배치될 수 있도록 충분한 공간이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1496">*The TCP data residing in the NX_PACKET structure should reside on a long-word boundary. In addition, there needs to be sufficient space between the prepend pointer and the data start pointer to place the TCP, IP, and physical media headers*.</span></span>

### <a name="tcp-packet-retransmit"></a><span data-ttu-id="c7e83-1497">TCP 패킷 재전송</span><span class="sxs-lookup"><span data-stu-id="c7e83-1497">TCP Packet Retransmit</span></span>      
<span data-ttu-id="c7e83-1498">이전에 전송된 TCP 패킷은 ACK가 연결의 다른 쪽에서 반환될 때까지 실제로 내부적으로 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1498">Previously transmitted TCP packets sent actually stored internally until an ACK is returned from the other side of the connection.</span></span> <span data-ttu-id="c7e83-1499">전송된 데이터가 시간 제한 기간 내에 승인되지 않으면 저장된 패킷이 다시 전송되고 다음 시간 제한 기간이 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1499">If transmitted data is not acknowledged within the timeout period, the stored packet is re-sent and the next timeout period is set.</span></span> <span data-ttu-id="c7e83-1500">ACK가 수신되면 내부 전송 큐의 승인 번호로 처리되는 모든 패킷이 최종적으로 해제됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1500">When an ACK is received, all packets covered by the acknowledgement number in the internal transmit queue are finally released.</span></span>  

> [!WARNING]   
> <span data-ttu-id="c7e83-1501">애플리케이션은 NX_SUCCESS를 사용하여 nx_tcp_socket_send()를 반환한 후 패킷을 재사용하거나 패킷의 콘텐츠를 변경하지 않아야 합니다. 전송된 패킷은 데이터가 다른 쪽 끝에서 승인된 후 NetX Duo 내부 처리에 의해 최종적으로 해제됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1501">*Application shall not reuse the packet or alter the contents of the packet after nx_tcp_socket_send() returns with NX_SUCCESS. The transmitted packet is eventually released by NetX Duo internal processing after the data is acknowledged by the other end*.</span></span>

### <a name="tcp-keepalive"></a><span data-ttu-id="c7e83-1502">TCP Keepalive</span><span class="sxs-lookup"><span data-stu-id="c7e83-1502">TCP Keepalive</span></span>     
<span data-ttu-id="c7e83-1503">TCP Keepalive 기능을 사용하면 소켓이 적절한 종료(예: 피어 크래시) 없이 피어 연결이 끊어졌는지 여부를 감지하거나 특정 네트워크 모니터링 기능이 장시간 유휴 상태에서 연결이 종료되는 것을 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1503">TCP Keepalive feature allows a socket to detect whether or not its peer disconnects without proper termination (for example, the peer crashed), or to prevent certain network monitoring facilities to terminate a connection for long periods of idle.</span></span> <span data-ttu-id="c7e83-1504">TCP Keepalive는 데이터가 없는 TCP 프레임을 주기적으로 전송하고, 시퀀스 번호가 현재 시퀀스 번호보다 작은 값으로 설정됨으로써 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1504">TCP Keepalive works by periodically sending a TCP frame with no data, and the sequence number set to one less than the current sequence number.</span></span> <span data-ttu-id="c7e83-1505">활성 상태의 수신자는 해당 TCP Keepalive 프레임을 수신하면 현재 시퀀스 번호에 대해 ACK로 응답합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1505">On receiving such TCP Keepalive frame, the recipient, if still alive, responses with an ACK for its current sequence number.</span></span> <span data-ttu-id="c7e83-1506">이렇게 하면 keepalive 트랜잭션이 완료됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1506">This completes the keepalive transaction.</span></span>  

<span data-ttu-id="c7e83-1507">기본적으로 keepalive 기능은 사용하도록 설정되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1507">By default the keepalive feature is not enabled.</span></span> <span data-ttu-id="c7e83-1508">이 기능을 사용하려면 \***NX_ENABLE_TCP_KEEPALIVE** _가 정의된 NetX Duo 라이브러리를 빌드해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1508">To use this feature, NetX Duo library must be built with \***NX_ENABLE_TCP_KEEPALIVE** _ defined.</span></span> <span data-ttu-id="c7e83-1509">_ *_NX_TCP_KEEPALIVE_INITIAL_*\* 기호는 keepalive 프레임이 시작되기 전의 비활성 시간(초)을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1509">The symbol _ *_NX_TCP_KEEPALIVE_INITIAL_*\* specifies the number of seconds of inactivity before the keepalive frame is initiated.</span></span>  

### <a name="tcp-packet-receive"></a><span data-ttu-id="c7e83-1510">TCP 패킷 수신</span><span class="sxs-lookup"><span data-stu-id="c7e83-1510">TCP Packet Receive</span></span>   
<span data-ttu-id="c7e83-1511">TCP 수신 패킷 처리(IP 도우미 스레드에서 호출)는 다양한 연결 및 연결 끊기 작업뿐만 아니라 전송 승인 처리도 담당합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1511">The TCP receive packet processing (called from the IP helper thread) is responsible for handling various connection and disconnection actions as well as transmit acknowledge processing.</span></span> <span data-ttu-id="c7e83-1512">또한 TCP 수신 패킷 처리는 수신 데이터가 있는 패킷을 적절한 TCP 소켓의 수신 큐에 배치하거나 패킷을 대기 중인 첫 번째 일시 중단된 스레드에 패킷을 전달하는 역할을 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1512">In addition, the TCP receive packet processing is responsible for placing packets with receive data on the appropriate TCP socket's receive queue or delivering the packet to the first suspended thread waiting for a packet.</span></span>

### <a name="tcp-receive-notify"></a><span data-ttu-id="c7e83-1513">TCP 수신 알림</span><span class="sxs-lookup"><span data-stu-id="c7e83-1513">TCP Receive Notify</span></span>     
<span data-ttu-id="c7e83-1514">애플리케이션 스레드가 둘 이상의 소켓에서 받은 데이터를 처리해야 하는 경우 ***nx_tcp_socket_receive_notify*** 함수를 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1514">If the application thread needs to process received data from more than one socket, the ***nx_tcp_socket_receive_notify*** function should be used.</span></span> <span data-ttu-id="c7e83-1515">이 함수는 소켓에 대한 수신 패킷 콜백 함수를 등록합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1515">This function registers a receive packet callback function for the socket.</span></span> <span data-ttu-id="c7e83-1516">패킷이 소켓에 수신될 때마다 콜백 함수가 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1516">Whenever a packet is received on the socket, the callback function is executed.</span></span>  

<span data-ttu-id="c7e83-1517">콜백 함수의 콘텐츠는 애플리케이션에 따라 다르지만, 그 함수는 해당 소켓에서 패킷을 사용할 수 있다는 것을 처리 스레드에 알리는 논리를 포함할 가능성이 큽니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1517">The contents of the callback function are applicationspecific; however, the function would most likely contain logic to inform the processing thread that a packet is available on the corresponding socket.</span></span> 

### <a name="thread-suspension"></a><span data-ttu-id="c7e83-1518">스레드 일시 중단</span><span class="sxs-lookup"><span data-stu-id="c7e83-1518">Thread Suspension</span></span>      
<span data-ttu-id="c7e83-1519">앞에서 설명한 대로 애플리케이션 스레드는 특정 TCP 포트에서 데이터를 수신하는 동안 일시 중단할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1519">As mentioned previously, application threads can suspend while attempting to receive data from a particular TCP port.</span></span> <span data-ttu-id="c7e83-1520">해당 포트에서 패킷이 수신되면 패킷이 일시 중단된 첫 번째 스레드에 제공되고 해당 스레드가 다시 시작됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1520">After a packet is received on that port, it is given to the first thread suspended and that thread is then resumed.</span></span> <span data-ttu-id="c7e83-1521">대부분의 NetX Duo 서비스에서 사용할 수 있는 기능인 TCP 수신 패킷을 일시 중단할 경우 선택적 시간 제한을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1521">An optional timeout is available when suspending on a TCP receive packet, a feature available for most NetX Duo services.</span></span>  

<span data-ttu-id="c7e83-1522">또한 스레드 일시 중단은 연결(클라이언트 및 서버 모두), 클라이언트 바인딩, 연결 끊기 서비스에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1522">Thread suspension is also available for connection (both client and server), client binding, and disconnection services.</span></span>  

### <a name="tcp-socket-statistics-and-errors"></a><span data-ttu-id="c7e83-1523">TCP 소켓 통계 및 오류</span><span class="sxs-lookup"><span data-stu-id="c7e83-1523">TCP Socket Statistics and Errors</span></span>     
<span data-ttu-id="c7e83-1524">사용하도록 설정된 경우 NetX Duo TCP 소켓 소프트웨어는 애플리케이션에 유용할 수 있는 몇 가지 통계 및 오류를 추적합니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1524">If enabled, the NetX Duo TCP socket software keeps track of several statistics and errors that may be useful to the application.</span></span> <span data-ttu-id="c7e83-1525">각 IP/TCP 인스턴스에 대해 다음 통계 및 오류 보고서가 유지 관리됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1525">The following statistics and error reports are maintained for each IP/TCP instance:</span></span>   

- <span data-ttu-id="c7e83-1526">전송된 총 TCP 패킷</span><span class="sxs-lookup"><span data-stu-id="c7e83-1526">Total TCP Packets Sent</span></span>  
- <span data-ttu-id="c7e83-1527">전송된 총 TCP 바이트</span><span class="sxs-lookup"><span data-stu-id="c7e83-1527">Total TCP Bytes Sent</span></span>  
- <span data-ttu-id="c7e83-1528">수신된 총 TCP 패킷</span><span class="sxs-lookup"><span data-stu-id="c7e83-1528">Total TCP Packets Received</span></span>   
- <span data-ttu-id="c7e83-1529">수신된 총 TCP 바이트</span><span class="sxs-lookup"><span data-stu-id="c7e83-1529">Total TCP Bytes Received</span></span>   
- <span data-ttu-id="c7e83-1530">총 TCP 잘못된 패킷</span><span class="sxs-lookup"><span data-stu-id="c7e83-1530">Total TCP Invalid Packets</span></span>   
- <span data-ttu-id="c7e83-1531">삭제된 총 TCP 수신 패킷</span><span class="sxs-lookup"><span data-stu-id="c7e83-1531">Total TCP Receive Packets Dropped</span></span>    
- <span data-ttu-id="c7e83-1532">총 TCP 수신 체크섬 오류</span><span class="sxs-lookup"><span data-stu-id="c7e83-1532">Total TCP Receive Checksum Errors</span></span>   
- <span data-ttu-id="c7e83-1533">총 TCP 연결</span><span class="sxs-lookup"><span data-stu-id="c7e83-1533">Total TCP Connections</span></span>   
- <span data-ttu-id="c7e83-1534">총 TCP 연결 끊김</span><span class="sxs-lookup"><span data-stu-id="c7e83-1534">Total TCP Disconnections</span></span>   
- <span data-ttu-id="c7e83-1535">삭제된 총 TCP 연결</span><span class="sxs-lookup"><span data-stu-id="c7e83-1535">Total TCP Connections Dropped</span></span>    
- <span data-ttu-id="c7e83-1536">총 TCP 패킷 재전송</span><span class="sxs-lookup"><span data-stu-id="c7e83-1536">Total TCP Packet Retransmits</span></span>   
- <span data-ttu-id="c7e83-1537">전송된 TCP 소켓 패킷</span><span class="sxs-lookup"><span data-stu-id="c7e83-1537">TCP Socket Packets Sent</span></span>   
- <span data-ttu-id="c7e83-1538">전송된 TCP 소켓 바이트</span><span class="sxs-lookup"><span data-stu-id="c7e83-1538">TCP Socket Bytes Sent</span></span>   
- <span data-ttu-id="c7e83-1539">수신된 TCP 소켓 패킷</span><span class="sxs-lookup"><span data-stu-id="c7e83-1539">TCP Socket Packets Received</span></span>   
- <span data-ttu-id="c7e83-1540">수신된 TCP 소켓 바이트</span><span class="sxs-lookup"><span data-stu-id="c7e83-1540">TCP Socket Bytes Received</span></span>   
- <span data-ttu-id="c7e83-1541">TCP 소켓 패킷 재전송</span><span class="sxs-lookup"><span data-stu-id="c7e83-1541">TCP Socket Packet Retransmits</span></span>    
- <span data-ttu-id="c7e83-1542">큐에 있는 TCP 소켓 패킷</span><span class="sxs-lookup"><span data-stu-id="c7e83-1542">TCP Socket Packets Queued</span></span>    
- <span data-ttu-id="c7e83-1543">TCP 소켓 체크섬 오류</span><span class="sxs-lookup"><span data-stu-id="c7e83-1543">TCP Socket Checksum Errors</span></span>    
- <span data-ttu-id="c7e83-1544">TCP 소켓 상태</span><span class="sxs-lookup"><span data-stu-id="c7e83-1544">TCP Socket State</span></span>    
- <span data-ttu-id="c7e83-1545">TCP 소켓 전송 큐 깊이</span><span class="sxs-lookup"><span data-stu-id="c7e83-1545">TCP Socket Transmit Queue Depth</span></span>    
- <span data-ttu-id="c7e83-1546">TCP 소켓 전송 창 크기</span><span class="sxs-lookup"><span data-stu-id="c7e83-1546">TCP Socket Transmit Window Size</span></span>    
- <span data-ttu-id="c7e83-1547">TCP 소켓 수신 창 크기</span><span class="sxs-lookup"><span data-stu-id="c7e83-1547">TCP Socket Receive Window Size</span></span>    

<span data-ttu-id="c7e83-1548">이러한 모든 통계 및 오류 보고서는 총 TCP 통계의 경우 ***nx_tcp_info_get** _ 서비스와 소켓당 TCP 통계의 경우 _ _nx_tcp_socket_info_get_* 서비스가 있는 애플리케이션에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1548">All these statistics and error reports are available to the application with the ***nx_tcp_info_get** _ service for total TCP statistics and the _ *_nx_tcp_socket_info_get_** service for TCP statistics per socket.</span></span>

### <a name="tcp-socket-control-block-nx_tcp_socket"></a><span data-ttu-id="c7e83-1549">TCP 소켓 제어 블록 NX_TCP_SOCKET</span><span class="sxs-lookup"><span data-stu-id="c7e83-1549">TCP Socket Control Block NX_TCP_SOCKET</span></span>      
<span data-ttu-id="c7e83-1550">각 TCP 소켓의 특징은 연결된 *NX_TCP_SOCKET* 제어 블록에서 찾을 수 있습니다. 여기에는 IP 데이터 구조에 대한 링크, 네트워크 연결 인터페이스, 바인딩된 포트, 수신 패킷 큐와 같은 유용한 정보가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1550">The characteristics of each TCP socket are found in the associated *NX_TCP_SOCKET* control block, which contains useful information such as the link to the IP data structure, the network connection interface, the bound port, and the receive packet queue.</span></span> <span data-ttu-id="c7e83-1551">이 구조는 ***nx_api.h*** 파일에서 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="c7e83-1551">This structure is defined in the ***nx_api.h*** file.</span></span>