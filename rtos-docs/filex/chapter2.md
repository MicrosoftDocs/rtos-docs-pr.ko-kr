---
title: 2장 - Azure RTOS FileX 설치 및 사용
description: 이 장에서는 다음을 포함하여 Azure RTOS FileX에 대한 소개와 설치 조건, 절차 및 사용에 대해 설명합니다.
author: philmea
ms.author: philmea
ms.date: 05/19/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 6703b10d8e0895984bb92d74d5dff809dca1a7f8
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/22/2021
ms.locfileid: "104810326"
---
# <a name="chapter-2---installation-and-use-of-azure-rtos-filex"></a><span data-ttu-id="3703d-103">2장 - Azure RTOS FileX 설치 및 사용</span><span class="sxs-lookup"><span data-stu-id="3703d-103">Chapter 2 - Installation and use of Azure RTOS FileX</span></span>

<span data-ttu-id="3703d-104">이 장에서는 Azure RTOS FileX에 대한 소개와 설치 조건, 절차 및 사용에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-104">This chapter contains an introduction to Azure RTOS FileX and a description of installation conditions, procedures, and use.</span></span> 

## <a name="host-considerations"></a><span data-ttu-id="3703d-105">호스트 고려 사항</span><span class="sxs-lookup"><span data-stu-id="3703d-105">Host Considerations</span></span>

### <a name="computer-type"></a><span data-ttu-id="3703d-106">컴퓨터 유형</span><span class="sxs-lookup"><span data-stu-id="3703d-106">Computer Type</span></span>

<span data-ttu-id="3703d-107">임베디드 개발은 일반적으로 Windows 또는 Linux(Unix) 호스트 컴퓨터에서 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-107">Embedded development is usually performed on Windows or Linux (Unix) host computers.</span></span> <span data-ttu-id="3703d-108">애플리케이션이 호스트에서 컴파일, 링크 및 배치된 후 실행할 수 있도록 대상 하드웨어에 다운로드됩니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-108">After the application is compiled, linked, and located on the host, it is downloaded to the target hardware for execution.</span></span>

### <a name="download-interfaces"></a><span data-ttu-id="3703d-109">인터페이스 다운로드</span><span class="sxs-lookup"><span data-stu-id="3703d-109">Download Interfaces</span></span>

<span data-ttu-id="3703d-110">일반적으로 대상 다운로드는 개발 도구의 디버거 내에서 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-110">Usually the target download is done from within the development tool's debugger.</span></span> <span data-ttu-id="3703d-111">다운로드 후 디버거는 대상 실행 제어(이동, 중지, 중단점 등)뿐만 아니라 메모리 및 프로세서 레지스터에 대한 액세스를 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-111">After download, the debugger is responsible for providing target execution control (go, halt, breakpoint, etc.) as well as access to memory and processor registers.</span></span>

### <a name="debugging-tools"></a><span data-ttu-id="3703d-112">디버깅 도구</span><span class="sxs-lookup"><span data-stu-id="3703d-112">Debugging Tools</span></span>

<span data-ttu-id="3703d-113">대부분의 개발 도구 디버거는 JTAG(IEEE 1149.1) 및 BDM(백그라운드 디버그 모드)과 같은 OCD(온칩 디버그) 연결을 통해 대상 하드웨어와 통신합니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-113">Most development tool debuggers communicate with the target hardware via on-chip debug (OCD) connections such as JTAG (IEEE 1149.1) and Background Debug Mode (BDM).</span></span> <span data-ttu-id="3703d-114">디버거는 ICE(회로 내 에뮬레이션) 연결을 통해 대상 하드웨어와 통신하기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-114">Debuggers also communicate with target hardware through In-Circuit Emulation (ICE) connections.</span></span> <span data-ttu-id="3703d-115">OCD 및 ICE 연결 모두 대상 상주 소프트웨어에 대한 침입이 최소화된 강력한 솔루션을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-115">Both OCD and ICE connections provide robust solutions with minimal intrusion on the target resident software.</span></span>

### <a name="required-hard-disk-space"></a><span data-ttu-id="3703d-116">최소 하드 디스크 공간</span><span class="sxs-lookup"><span data-stu-id="3703d-116">Required Hard Disk Space</span></span>

<span data-ttu-id="3703d-117">FileX의 소스 코드는 ASCII 형식으로 제공되며 호스트 컴퓨터의 하드 디스크에 약 500KB의 공간이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-117">The source code for FileX is delivered in ASCII format and requires approximately 500 KBytes of space on the host computer's hard disk</span></span>

## <a name="target-considerations"></a><span data-ttu-id="3703d-118">대상 고려 사항</span><span class="sxs-lookup"><span data-stu-id="3703d-118">Target Considerations</span></span>

<span data-ttu-id="3703d-119">FileX를 사용하려면 대상에 6 ~ 30KB의 ROM(읽기 전용 메모리)이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-119">FileX requires between 6 KBytes and 30 KBytes of  Read-Only Memory (ROM) on the target.</span></span> <span data-ttu-id="3703d-120">또한 FileX 글로벌 데이터 구조에 대상의 100KB RAM(Random Access Memory)이 추가로 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-120">Another  100 bytes of the target's Random Access Memory (RAM) are required for FileX global data structures.</span></span> <span data-ttu-id="3703d-121">또한 열려 있는 각 미디어에는 하나의 섹터(일반적으로 512바이트)의 데이터를 저장하는 RAM 외에도 제어 블록에 1.5KB의 RAM이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-121">Each opened media also requires 1.5 KBytes of RAM for the control block in addition to RAM for storing data for one sector (typically 512 bytes).</span></span>

<span data-ttu-id="3703d-122">날짜/시간 스탬프가 제대로 작동하려면 FileX에서 ThreadX 타이머 기능에 의존합니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-122">For date/time stamping to function properly, FileX relies on ThreadX timer facilities.</span></span> <span data-ttu-id="3703d-123">이는 FileX를 초기화하는 동안 FileX 관련 타이머를 만들어 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-123">This is implemented by creating a FileX-specific timer during FileX initialization.</span></span> <span data-ttu-id="3703d-124">또한 FileX는 다중 스레드 보호 및 I/O 일시 중단에 대해 ThreadX 세마포를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-124">FileX also relies on ThreadX semaphores for multiple thread protection and I/O suspension.</span></span>

## <a name="product-distribution"></a><span data-ttu-id="3703d-125">제품 배포</span><span class="sxs-lookup"><span data-stu-id="3703d-125">Product Distribution</span></span>

<span data-ttu-id="3703d-126">Azure RTOS FileX는 <https://github.com/azure-rtos/filex/>에 있는 공용 소스 코드 리포지토리에서 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-126">Azure RTOS FileX can be obtained from our public source code repository at <https://github.com/azure-rtos/filex/>.</span></span>

<span data-ttu-id="3703d-127">다음은 리포지토리에 있는 몇 가지 중요한 파일 목록입니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-127">The following is a list of several important files in the repository:</span></span>

- <span data-ttu-id="3703d-128">***fx_api.h***: 이 C 헤더 파일에는 모든 시스템 이큐에이트, 데이터 구조 및 서비스 프로토타입이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-128">***fx_api.h*** : This C header file contains all system equates, data structures, and service prototypes.</span></span>
- <span data-ttu-id="3703d-129">***fx_port.h***: 이 C 헤더 파일에는 모든 개발 도구 관련 데이터 정의 및 구조가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-129">***fx_port.h*** : This C header file contains all development-tool-specific data definitions and structures.</span></span>
- <span data-ttu-id="3703d-130">***demo_filex.c***: 이 C 파일에는 작은 데모 애플리케이션이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-130">***demo_filex.c*** : This C file contains a small demo application.</span></span>
- <span data-ttu-id="3703d-131">***fx.a(또는 fx.lib)***: FileX C 라이브러리의 이진 버전입니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-131">***fx.a (or fx.lib)*** : This is the binary version of the FileX C library.</span></span> <span data-ttu-id="3703d-132">표준 패키지로 배포됩니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-132">It is distributed with the standard package.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="3703d-133">*모든 파일 이름은 소문자로 되어 있습니다. 이 명명 규칙을 사용하면 명령을 Linux(Unix) 개발 플랫폼으로 좀 더 쉽게 변환할 수 있습니다.*</span><span class="sxs-lookup"><span data-stu-id="3703d-133">*All file names are in lower-case. This naming convention makes it easier to convert the commands to Linux (Unix) development platforms.*</span></span>

## <a name="filex-installation"></a><span data-ttu-id="3703d-134">FileX 설치</span><span class="sxs-lookup"><span data-stu-id="3703d-134">FileX Installation</span></span>

<span data-ttu-id="3703d-135">FileX는 GitHub 리포지토리를 로컬 컴퓨터에 복제하여 설치됩니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-135">FileX is installed by cloning the GitHub repository to your local machine.</span></span> <span data-ttu-id="3703d-136">다음은 PC에서 FileX 리포지토리의 복제본을 만들기 위한 일반적인 구문입니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-136">The following is typical syntax for creating a clone of the FileX repository on your PC:</span></span>

```c
    git clone https://github.com/azure-rtos/filex
```

<span data-ttu-id="3703d-137">또는 GitHub 기본 페이지의 다운로드 단추를 사용하여 리포지토리의 복사본을 다운로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-137">Alternatively you can download a copy of the repository using the download button on the GitHub main page.</span></span>

<span data-ttu-id="3703d-138">또한 온라인 리포지토리의 프런트 페이지에서 FileX 라이브러리를 빌드하기 위한 지침을 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-138">You will also find instructions for building the FileX library on the front page of the online repository.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="3703d-139">애플리케이션 소프트웨어는 FileX 라이브러리 파일(일반적으로 ***fx.a** _ 또는 _*_fx.lib_*_ 라고 함*)_에 액세스해야 하며 C에는 **fx_api. h** 및 **fx_port.h** 파일이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-139">Application software needs access to the FileX library file (usually called\* usually ***fx.a** _ or _*_fx.lib_\*_) _and the C include files **fx_api.h** and **fx_port.h**.</span></span> <span data-ttu-id="3703d-140">이렇게 하려면 개발 도구에 대한 적절한 경로를 설정하거나 해당 파일을 애플리케이션 개발 영역으로 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-140">This is accomplished either by setting the appropriate path for the development tools or by copying these files into the application development area.</span></span>

## <a name="using-filex"></a><span data-ttu-id="3703d-141">FileX 사용</span><span class="sxs-lookup"><span data-stu-id="3703d-141">Using FileX</span></span>

<span data-ttu-id="3703d-142">FileX는 쉽게 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-142">Using FileX is easy.</span></span> <span data-ttu-id="3703d-143">기본적으로 컴파일하는 동안 애플리케이션 코드가 ***fx_api.h** _를 포함하고 FileX 런타임 라이브러리 _*_tx.a_*_(또는 _*_tx.lib_\*_)와 연결해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-143">Basically, the application code must include ***fx_api.h** _ during compilation and link with the FileX run-time library _*_fx.a_*_ (or _*_fx.lib_\*_).</span></span> <span data-ttu-id="3703d-144">물론 ThreadX 파일, 즉 _*_tx_api.h_*_ 및 _*_tx.a_*_(또는 _*_tx.lib_*_)_\*도 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-144">Of course, the ThreadX files, namely _*_tx_api.h_*_ and _*_tx.a_*_ (or _*_tx.lib_*_)_,\* are also required.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="3703d-145">FileX를 독립 실행형 모드에서 사용하는 경우(**FX_STANDALONE_ENABLE** 을 정의해야 함) ThreadX 파일/라이브러리가 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-145">When using FileX in Standalone mode (**FX_STANDALONE_ENABLE** must be defined), ThreadX files/libraries are not required.</span></span>

<span data-ttu-id="3703d-146">ThreadX를 이미 사용하고 있다고 가정하면 FileX 애플리케이션을 빌드하는 데 필요한 네 가지 단계가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-146">Assuming you are already using ThreadX, there are four steps required to build a FileX application:</span></span>

1. <span data-ttu-id="3703d-147">FileX 서비스 또는 데이터 구조를 사용하는 모든 애플리케이션 파일에 ***fx_api.h*** 파일을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-147">Include the ***fx_api.h*** file in all application files that use FileX services or data structures.</span></span>
1. <span data-ttu-id="3703d-148">_ *_tx_application_define_*\* 함수 또는 애플리케이션 스레드에서 \***fx_system_initialize** _를 호출하여 FileX 시스템을 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-148">Initialize the FileX system by calling ***fx_system_initialize** _ from the _ *_tx_application_define_** function or an application thread.</span></span>

    > [!IMPORTANT]
    > <span data-ttu-id="3703d-149">FileX를 독립 실행형 모드에서 사용하는 경우 ***fx_system_initialize*** 를 애플리케이션 코드에서 직접 호출해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-149">When using FileX in Standalone mode, ***fx_system_initialize*** should be directly called from application code.</span></span>

1. <span data-ttu-id="3703d-150">***fx_media_open*** 에 대한 호출을 하나 이상 추가하여 FileX 미디어를 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-150">Add one or more calls to ***fx_media_open*** to set up the FileX media.</span></span> <span data-ttu-id="3703d-151">애플리케이션 스레드의 컨텍스트에서 이 호출을 수행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-151">This call must be made from the context of an application thread.</span></span>

    > [!IMPORTANT]
    > <span data-ttu-id="3703d-152">***fx_media_open** 호출에는 하나의 섹터에 대한 데이터를 저장하는 데 충분한 RAM이 필요합니다.*</span><span class="sxs-lookup"><span data-stu-id="3703d-152">*Remember that the **fx_media_open** call requires enough RAM to store data for one sector.*</span></span>

1. <span data-ttu-id="3703d-153">애플리케이션 소스를 컴파일하고 FileX 및 ThreadX 런타임 라이브러리, ***fx.a** _(또는 _*_fx.lib_*_) 및 _*_tx.a_*_(또는 _*_tx.lib_\*\*)와 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-153">Compile application source and link with the FileX and ThreadX run-time libraries, ***fx.a** _ (or _*_fx.lib_*_) and _*_tx.a_*_ (or _*_tx.lib_\*\*).</span></span> <span data-ttu-id="3703d-154">결과 이미지를 대상으로 다운로드하여 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-154">The resulting image can be downloaded to the target and executed!</span></span>

## <a name="troubleshooting"></a><span data-ttu-id="3703d-155">문제 해결</span><span class="sxs-lookup"><span data-stu-id="3703d-155">Troubleshooting</span></span>

<span data-ttu-id="3703d-156">각 FileX 포트는 데모 애플리케이션과 함께 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-156">Each FileX port is delivered with a demonstration application.</span></span> <span data-ttu-id="3703d-157">항상 대상 하드웨어 또는 특정 데모 환경에서 데모 시스템을 먼저 실행하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-157">It is always a good idea to get the demonstration system running first—either on the target hardware or a specific demonstration environment.</span></span>

<span data-ttu-id="3703d-158">데모 시스템이 작동하지 않는 경우 다음 작업을 수행하여 문제 범위를 좁힙니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-158">If the demonstration system does not work, try the following things to narrow the problem:</span></span>

1. <span data-ttu-id="3703d-159">데모가 어느 정도 실행되고 있는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-159">Determine how much of the demonstration is running.</span></span>
1. <span data-ttu-id="3703d-160">스택 크기를 늘립니다(데모보다는 실제 애플리케이션 코드에서 더 중요함).</span><span class="sxs-lookup"><span data-stu-id="3703d-160">Increase stack sizes (this is more important in actual application code than it is for the demonstration).</span></span>
1. <span data-ttu-id="3703d-161">32KB 기본 RAM 디스크 크기를 위한 충분한 RAM이 있는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-161">Ensure there is enough RAM for the 32KBytes default RAM disk size.</span></span> <span data-ttu-id="3703d-162">기본 시스템은 훨씬 더 작은 RAM으로 작동합니다. 그러나 더 많은 RAM 디스크를 사용하는 경우 메모리가 충분하지 않으면 문제가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-162">The basic system will operate on much less RAM; however, as more of the RAM disk is used, problems will surface if there is not enough memory.</span></span>
1. <span data-ttu-id="3703d-163">최근 변경 내용을 일시적으로 무시하여 문제가 사라지거나 달라지는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-163">Temporarily bypass any recent changes to see if the problem disappears or changes.</span></span> <span data-ttu-id="3703d-164">이러한 정보는 Microsoft 지원 엔지니어에게 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-164">Such information should prove useful to Microsoft support engineers.</span></span> <span data-ttu-id="3703d-165">"고객 지원 센터"에 설명된 절차에 따라 문제 해결 단계에서 수집한 정보를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-165">Follow the procedures outlined in "Customer Support Center" to send the information gathered from the troubleshooting steps.</span></span>

## <a name="configuration-options"></a><span data-ttu-id="3703d-166">구성 옵션</span><span class="sxs-lookup"><span data-stu-id="3703d-166">Configuration Options</span></span>

<span data-ttu-id="3703d-167">FileX를 사용하여 FileX 라이브러리 및 애플리케이션을 빌드할 때 몇 가지 구성 옵션이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-167">There are several configuration options when building the FileX library and the application using FileX.</span></span> <span data-ttu-id="3703d-168">아래 옵션은 애플리케이션 소스, 명령줄 또는 ***fx_user.h*** 포함 파일 내에서 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-168">The options below can be defined in the application source, on the command line, or within the ***fx_user.h*** include file.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="3703d-169">\***fx_user.h** 에 정의된 옵션은 애플리케이션 및 ThreadX 라이브러리가 정의된 **_FX_INCLUDE_USER_DEFINE_FILE_\*_로 빌드하는 경우에만 적용됩니다._ 독립 실행형 모드에서 FileX를 사용하는 경우(** FX_STANDALONE_ENABLE\*\*을 정의해야 함), ThreadX 파일/라이브러리가 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-169">*Options defined in **fx_user.h** are applied only if the application and ThreadX library are built with **_FX_INCLUDE_USER_DEFINE_FILE_\*_ defined._ When using FileX in Standalone mode (** FX_STANDALONE_ENABLE*\* must be defined), ThreadX files/libraries are not required.</span></span>

<span data-ttu-id="3703d-170">다음 목록은 각 구성 옵션에 대해 자세히 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-170">The following list describes each configuration option in detail:</span></span>

|<span data-ttu-id="3703d-171">정의</span><span class="sxs-lookup"><span data-stu-id="3703d-171">Define</span></span>|<span data-ttu-id="3703d-172">의미</span><span class="sxs-lookup"><span data-stu-id="3703d-172">Meaning</span></span>|
|----------    |-----------|
|<span data-ttu-id="3703d-173">FX_MAX_LAST_NAME_LEN</span><span class="sxs-lookup"><span data-stu-id="3703d-173">FX_MAX_LAST_NAME_LEN</span></span>        |<span data-ttu-id="3703d-174">이 값은 전체 경로 이름을 포함하는 최대 파일 이름 길이를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-174">This value defines the maximum file name length, which includes full path name.</span></span> <span data-ttu-id="3703d-175">기본적으로 이 값은 256입니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-175">By default, this value is 256.</span></span>|
|<span data-ttu-id="3703d-176">FX_DONT_UPDATE_OPEN_FILES</span><span class="sxs-lookup"><span data-stu-id="3703d-176">FX_DONT_UPDATE_OPEN_FILES</span></span>    |<span data-ttu-id="3703d-177">정의된 경우, FileX는 이미 열려 있는 파일을 업데이트하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-177">Defined, FileX does not update already opened files.</span></span>|
|<span data-ttu-id="3703d-178">FX_MEDIA_DISABLE_SEARCH_CACHE</span><span class="sxs-lookup"><span data-stu-id="3703d-178">FX_MEDIA_DISABLE_SEARCH_CACHE</span></span>    |<span data-ttu-id="3703d-179">정의된 경우, 파일 검색 캐시 최적화를 사용하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-179">Defined, the file search cache optimization is disabled.</span></span>|
|<span data-ttu-id="3703d-180">FX_MEDIA_DISABLE_SEARCH_CACHE</span><span class="sxs-lookup"><span data-stu-id="3703d-180">FX_MEDIA_DISABLE_SEARCH_CACHE</span></span>    |<span data-ttu-id="3703d-181">정의된 경우, 파일 검색 캐시 최적화를 사용하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-181">Defined, the file search cache optimization is disabled.</span></span>|
|<span data-ttu-id="3703d-182">FX_DISABLE_DIRECT_DATA_READ_CACHE_FILL</span><span class="sxs-lookup"><span data-stu-id="3703d-182">FX_DISABLE_DIRECT_DATA_READ_CACHE_FILL</span></span> |<span data-ttu-id="3703d-183">정의된 경우, 캐시의 직접 읽기 섹터 업데이트가 사용하지 않도록 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-183">Defined, the direct read sector update of cache is disabled.</span></span>|
|<span data-ttu-id="3703d-184">FX_MEDIA_STATISTICS_DISABLE</span><span class="sxs-lookup"><span data-stu-id="3703d-184">FX_MEDIA_STATISTICS_DISABLE</span></span> |<span data-ttu-id="3703d-185">정의된 경우, 미디어 통계 수집이 사용하지 않도록 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-185">Defined, gathering of media statistics is disabled.</span></span>|
|<span data-ttu-id="3703d-186">FX_SINGLE_OPEN_LEGACY</span><span class="sxs-lookup"><span data-stu-id="3703d-186">FX_SINGLE_OPEN_LEGACY</span></span> |<span data-ttu-id="3703d-187">정의된 경우, 동일한 파일에 대해 레거시 단일 오픈 논리를 사용하도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-187">Defined, legacy single open logic for the same file is enabled.</span></span>|
|<span data-ttu-id="3703d-188">FX_RENAME_PATH_INHERIT</span><span class="sxs-lookup"><span data-stu-id="3703d-188">FX_RENAME_PATH_INHERIT</span></span>    |<span data-ttu-id="3703d-189">정의된 경우, 이름 바꾸기는 경로 정보를 상속합니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-189">Defined, renaming inherits path information.</span></span>|
|<span data-ttu-id="3703d-190">FX_DISABLE_ERROR_CHECKING</span><span class="sxs-lookup"><span data-stu-id="3703d-190">FX_DISABLE_ERROR_CHECKING</span></span>    |<span data-ttu-id="3703d-191">기본 FileX 오류 검사 API를 제거하고 성능이 향상되고(30% 정도) 코드 크기가 더 작아집니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-191">Removes the basic FileX error checking API and results in improved performance (as much as 30%) and smaller code size.</span></span>|
|<span data-ttu-id="3703d-192">FX_MAX_LONG_NAME_LEN</span><span class="sxs-lookup"><span data-stu-id="3703d-192">FX_MAX_LONG_NAME_LEN</span></span>    |<span data-ttu-id="3703d-193">FileX에 대한 최대 파일 이름 크기를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-193">Specifies the maximum file name size for FileX.</span></span> <span data-ttu-id="3703d-194">기본값은 256이지만 명령줄 정의를 사용하여 이 값을 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-194">The default value is 256, but this can be overridden with a command-line define.</span></span> <span data-ttu-id="3703d-195">올바른 값의 범위는 13에서 256 사이입니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-195">Legal values range between 13 and 256.</span></span>|
|<span data-ttu-id="3703d-196">FX_MAX_SECTOR_CACHE</span><span class="sxs-lookup"><span data-stu-id="3703d-196">FX_MAX_SECTOR_CACHE</span></span>|<span data-ttu-id="3703d-197">FileX에서 캐시할 수 있는 최대 논리 섹터 수를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-197">Specifies the maximum number of logical sectors that can be cached by FileX.</span></span> <span data-ttu-id="3703d-198">캐시할 수 있는 실제 섹터 수는 이 상수와 fx_media_open에서 제공되는 메모리 양에 맞출 수 있는 섹터 수입니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-198">The actual number of sectors that can be cached is lesser of this constant and how many sectors can fit in the amount of memory supplied at fx_media_open.</span></span> <span data-ttu-id="3703d-199">기본값은 256입니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-199">The default value is 256.</span></span> <span data-ttu-id="3703d-200">모든 값은 2의 거듭제곱이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-200">All values must be a power of 2.</span></span>|
|<span data-ttu-id="3703d-201">FX_FAT_MAP_SIZE</span><span class="sxs-lookup"><span data-stu-id="3703d-201">FX_FAT_MAP_SIZE</span></span>    |<span data-ttu-id="3703d-202">FAT 업데이트 맵에 표시할 수 있는 섹터 수를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-202">Specifies the number of sectors that can be represented in the FAT update map.</span></span> <span data-ttu-id="3703d-203">기본값은 256이지만 명령줄 정의를 사용하여 이 값을 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-203">The default value is 256, but this can be overridden with a command-line define.</span></span> <span data-ttu-id="3703d-204">값이 클수록 보조 FAT 섹터의 불필요한 업데이트를 줄이는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-204">Larger values help reduce unneeded updates of secondary FAT sectors.</span></span>|
|<span data-ttu-id="3703d-205">FX_MAX_FAT_CACHE</span><span class="sxs-lookup"><span data-stu-id="3703d-205">FX_MAX_FAT_CACHE</span></span>    |<span data-ttu-id="3703d-206">내부 FAT 캐시의 항목 수를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-206">Specifies the number of entries in the internal FAT cache.</span></span> <span data-ttu-id="3703d-207">기본값은 16이지만 명령줄 정의를 사용하여 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-207">The default value is 16, but this can be overridden with a command-line define.</span></span> <span data-ttu-id="3703d-208">모든 값은 2의 거듭제곱이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-208">All values must be a power of 2.</span></span>|
|<span data-ttu-id="3703d-209">FX_FAULT_TOLERANT</span><span class="sxs-lookup"><span data-stu-id="3703d-209">FX_FAULT_TOLERANT</span></span>    |<span data-ttu-id="3703d-210">정의된 경우, FileX는 모든 시스템 섹터(부팅, FAT 및 디렉터리 섹터)의 쓰기 요청을 미디어의 드라이버에 즉시 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-210">When defined, FileX immediately passes write requests of all system sectors (boot, FAT, and directory sectors) to the media's driver.</span></span> <span data-ttu-id="3703d-211">이로 인해 성능이 저하될 수 있지만 손실된 클러스터에 대한 손상을 제한하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-211">This potentially decreases performance, but helps limit corruption to lost clusters.</span></span> <span data-ttu-id="3703d-212">이 기능을 사용하도록 설정해도 FileX 내결함성 모듈이 자동으로 사용하도록 설정되지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-212">Note that enabling this feature does not automatically enable FileX Fault Tolerant Module, which is enabled by defining</span></span>|
|<span data-ttu-id="3703d-213">FX_FAULT_TOLERANT_DATA</span><span class="sxs-lookup"><span data-stu-id="3703d-213">FX_FAULT_TOLERANT_DATA</span></span>    |<span data-ttu-id="3703d-214">정의된 경우, FileX는 모든 파일 데이터 쓰기 요청을 미디어의 드라이버에 즉시 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-214">When defined, FileX immediately passes all file data write requests to the media's driver.</span></span> <span data-ttu-id="3703d-215">이로 인해 성능이 저하될 수 있지만 손실된 파일 데이터를 제한하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-215">This potentially decreases performance, but helps limit lost file data.</span></span> <span data-ttu-id="3703d-216">이 기능을 사용하도록 설정한다고 해서 ***FX_ENABLE_FAULT_TOLERANT*** 를 정의하여 사용하도록 설정되는 FileX 내결함성 모듈이 자동으로 사용하도록 설정되지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-216">Note that enabling this feature does not automatically enable FileX Fault Tolerant Module, which is enabled by defining ***FX_ENABLE_FAULT_TOLERANT***</span></span>|
|<span data-ttu-id="3703d-217">FX_NO_LOCAL_PATH</span><span class="sxs-lookup"><span data-stu-id="3703d-217">FX_NO_LOCAL_PATH</span></span>|<span data-ttu-id="3703d-218">FileX에서 로컬 경로 논리를 제거하여 더 작은 코드 크기를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-218">Removes local path logic from FileX, resulting in smaller code size.</span></span>|
|<span data-ttu-id="3703d-219">FX_NO_TIMER</span><span class="sxs-lookup"><span data-stu-id="3703d-219">FX_NO_TIMER</span></span>|<span data-ttu-id="3703d-220">FileX 시스템 시간 및 날짜를 업데이트하는 ThreadX 타이머 설정을 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-220">Eliminates the ThreadX timer setup to update the FileX system time and date.</span></span> <span data-ttu-id="3703d-221">이렇게 하면 기본 시간 및 날짜가 모든 파일 작업에 배치됩니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-221">Doing so causes default time and date to be placed on all file operations.</span></span>|
|<span data-ttu-id="3703d-222">FX_UPDATE_RATE_IN_SECONDS</span><span class="sxs-lookup"><span data-stu-id="3703d-222">FX_UPDATE_RATE_IN_SECONDS</span></span>    |<span data-ttu-id="3703d-223">FileX에서 시스템 시간을 조정하는 속도를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-223">Specifies rate at which system time in FileX is adjusted.</span></span> <span data-ttu-id="3703d-224">기본적으로 값은 10이며 FileX 시스템 시간이 10초마다 업데이트되도록 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-224">By default, value is 10, specifying that the FileX system time is updated every 10 seconds.</span></span>|
|<span data-ttu-id="3703d-225">FX_ENABLE_EXFAT</span><span class="sxs-lookup"><span data-stu-id="3703d-225">FX_ENABLE_EXFAT</span></span>| <span data-ttu-id="3703d-226">정의된 경우, exFAT 파일 시스템을 처리하는 논리는 FileX에서 사용하도록 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-226">When defined, the logic for handling exFAT file system is enabled in FileX.</span></span> <span data-ttu-id="3703d-227">기본적으로 이 기호는 정의되어 있지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-227">By default this symbol is not defined.</span></span>| 
|<span data-ttu-id="3703d-228">FX_UPDATE_RATE_IN_TICKS</span><span class="sxs-lookup"><span data-stu-id="3703d-228">FX_UPDATE_RATE_IN_TICKS</span></span>| <span data-ttu-id="3703d-229">기본 ThreadX 타이머 빈도를 제외하고 ***FX_UPDATE_RATE_IN_SECONDS***(위 참조)와 동일한 속도로 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-229">Specifies the same rate as ***FX_UPDATE_RATE_IN_SECONDS*** (see above), except in terms of the underlying ThreadX timer frequency.</span></span> <span data-ttu-id="3703d-230">기본값은 1000(10ms ThreadX 타이머 요율 및 10초 간격으로 가정)입니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-230">The default is 1000, which assumes a 10ms ThreadX timer rate and a 10 second interval.</span></span>|
|<span data-ttu-id="3703d-231">FX_SINGLE_THREAD</span><span class="sxs-lookup"><span data-stu-id="3703d-231">FX_SINGLE_THREAD</span></span>|<span data-ttu-id="3703d-232">FileX 원본에서 ThreadX 보호 논리를 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-232">Eliminates ThreadX protection logic from the FileX source.</span></span> <span data-ttu-id="3703d-233">FileX를 하나의 스레드에서만 사용하거나 ThreadX 없이 FileX를 사용하는 경우에 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-233">It should be used if FileX is being used only from one thread or if FileX is being used without ThreadX.</span></span>|
|<span data-ttu-id="3703d-234">FX_DRIVER_USE_64BIT_LBA</span><span class="sxs-lookup"><span data-stu-id="3703d-234">FX_DRIVER_USE_64BIT_LBA</span></span>|<span data-ttu-id="3703d-235">정의된 경우, I/O 드라이버에서 64비트 섹터 주소를 사용하도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-235">When defined, enables 64-bit sector addresses used in I/O driver.</span></span> <span data-ttu-id="3703d-236">기본적으로 이 옵션은 정의되어 있지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-236">By default this option is not defined.</span></span>|
|<span data-ttu-id="3703d-237">FX_ENABLE_FAULT_TOLERANT</span><span class="sxs-lookup"><span data-stu-id="3703d-237">FX_ENABLE_FAULT_TOLERANT</span></span>| <span data-ttu-id="3703d-238">정의된 경우, FileX 내결함성 모듈을 사용하도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-238">When defined, enables FileX Fault Tolerant Module.</span></span> <span data-ttu-id="3703d-239">내결함성을 사용하도록 설정하면 ***FX_FAULT_TOLERANT** _ 및 _*_FX_FAULT_TOLERANT_DATA_\*\* 기호가 자동으로 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-239">Enabling Fault Tolerant automatically defines the symbol ***FX_FAULT_TOLERANT** _ and _*_FX_FAULT_TOLERANT_DATA_\*\*.</span></span> <span data-ttu-id="3703d-240">기본적으로 이 옵션은 정의되어 있지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-240">By default this option is not defined.</span></span>|
|<span data-ttu-id="3703d-241">FX_FAULT_TOLERANT_BOOT_INDEX</span><span class="sxs-lookup"><span data-stu-id="3703d-241">FX_FAULT_TOLERANT_BOOT_INDEX</span></span>|<span data-ttu-id="3703d-242">내결함성 로그에 대한 클러스터가 있는 부팅 섹터의 바이트 오프셋을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-242">Defines byte offset in the boot sector where the cluster for the fault tolerant log is.</span></span> <span data-ttu-id="3703d-243">기본적으로 이 값은 116입니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-243">By default this value is 116.</span></span> <span data-ttu-id="3703d-244">이 필드에는 4바이트가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-244">This field takes 4 bytes.</span></span> <span data-ttu-id="3703d-245">116~119 바이트는 FAT 12/16/32/exFAT 사양에서 예약된 것으로 표시되기 때문에 선택됩니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-245">Bytes 116 through 119 are chosen because they are marked as reserved by FAT 12/16/32/exFAT specification.</span></span>|
|<span data-ttu-id="3703d-246">FX_FAULT_TOLERANT_MINIMAL_CLUSTER</span><span class="sxs-lookup"><span data-stu-id="3703d-246">FX_FAULT_TOLERANT_MINIMAL_CLUSTER</span></span>|<span data-ttu-id="3703d-247">이 기호는 사용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-247">This symbol is deprecated.</span></span> <span data-ttu-id="3703d-248">FileX 내결함성이 더 이상 사용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-248">It is no longer being used by FileX Fault Tolerant.</span></span>|
|<span data-ttu-id="3703d-249">FX_STANDALONE_ENABLE</span><span class="sxs-lookup"><span data-stu-id="3703d-249">FX_STANDALONE_ENABLE</span></span>|<span data-ttu-id="3703d-250">정의된 경우, Azure RTOS 없이 독립 실행형 모드에서 FileX를 사용하도록 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-250">Defined, enables FileX to be used in standalone mode (without Azure RTOS).</span></span> <span data-ttu-id="3703d-251">기본적으로 이 기호는 정의되어 있지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-251">By default this symbol is not defined.</span></span>|

> [!IMPORTANT]
> <span data-ttu-id="3703d-252">**FX_STANDALONE_ENABLE** 이 정의된 경우 로컬 경로 논리와 ThreadX 타이머 설치는 사용하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-252">When **FX_STANDALONE_ENABLE** is defined, Local path logic and ThreadX timer setup are disabled.</span></span>

## <a name="filex-version-id"></a><span data-ttu-id="3703d-253">FileX 버전 ID</span><span class="sxs-lookup"><span data-stu-id="3703d-253">FileX Version ID</span></span>

<span data-ttu-id="3703d-254">FileX의 현재 버전은 런타임 중 사용자 및 애플리케이션 모두에 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-254">The current version of FileX is available both to the user and the application software during run-time.</span></span> <span data-ttu-id="3703d-255">프로그래머는 **fx_port.h** 파일을 조사하여 FileX 버전을 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-255">The programmer can obtain the FileX version from examination of the **fx_port.h** file.</span></span> <span data-ttu-id="3703d-256">또한 이 파일에는 해당 포트의 버전 기록도 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-256">In addition, this file also contains a version history of the corresponding port.</span></span> <span data-ttu-id="3703d-257">애플리케이션 소프트웨어는 전체 문자열 **_ _fx_version_id_** 를 검사하여 FileX 버전을 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3703d-257">Application software can obtain the FileX version by examining the global string **_ _fx_version_id_**.</span></span>
