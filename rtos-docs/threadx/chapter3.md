---
title: 챕터 3 - Azure RTOS ThreadX의 기능 구성 요소
description: 이 챕터에는 기능적 관점의 고성능 Azure RTOS ThreadX 커널에 대한 설명이 포함되어 있습니다.
author: philmea
ms.author: philmea
ms.date: 05/19/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: aa66ad392171958e5d2cc765992fd1a9e41250a6
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/22/2021
ms.locfileid: "104812187"
---
# <a name="chapter-3---functional-components-of-azure-rtos-threadx"></a><span data-ttu-id="13920-103">챕터 3 - Azure RTOS ThreadX의 기능 구성 요소</span><span class="sxs-lookup"><span data-stu-id="13920-103">Chapter 3 - Functional Components of Azure RTOS ThreadX</span></span>

<span data-ttu-id="13920-104">이 챕터에는 기능적 관점의 고성능 Azure RTOS ThreadX 커널에 대한 설명이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-104">This chapter contains a description of the high-performance Azure RTOS ThreadX kernel from a functional perspective.</span></span> <span data-ttu-id="13920-105">각 기능 구성 요소는 이해하기 쉽게 설명되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-105">Each functional component is presented in an easy-to-understand manner.</span></span>

## <a name="execution-overview"></a><span data-ttu-id="13920-106">실행 개요</span><span class="sxs-lookup"><span data-stu-id="13920-106">Execution Overview</span></span>

<span data-ttu-id="13920-107">ThreadX 애플리케이션에는 초기화, 스레드 실행, ISR(인터럽트 서비스 루틴) 및 애플리케이션 타이머라는 네 가지 프로그램 실행 형식이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-107">There are four types of program execution within a ThreadX application: Initialization, Thread Execution, Interrupt Service Routines (ISRs), and Application Timers.</span></span>

<span data-ttu-id="13920-108">그림 2는 각기 다른 프로그램 실행 형식을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="13920-108">Figure 2 shows each different type of program execution.</span></span> <span data-ttu-id="13920-109">이러한 각 형식에 대한 자세한 내용은 이 챕터의 후속 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="13920-109">More detailed information about each of these types is found in subsequent sections of this chapter.</span></span>

### <a name="initialization"></a><span data-ttu-id="13920-110">초기화</span><span class="sxs-lookup"><span data-stu-id="13920-110">Initialization</span></span>

<span data-ttu-id="13920-111">이름에서 알 수 있듯이 이것은 ThreadX 애플리케이션에서 첫 번째 프로그램 실행 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-111">As the name implies, this is the first type of program execution in a ThreadX application.</span></span> <span data-ttu-id="13920-112">초기화에는 프로세서 재설정과 *스레드 예약 루프* 의 진입점 사이에 있는 모든 프로그램 실행이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-112">Initialization includes all program execution between processor reset and the entry point of the *thread scheduling loop.*</span></span>

### <a name="thread-execution"></a><span data-ttu-id="13920-113">스레드 실행</span><span class="sxs-lookup"><span data-stu-id="13920-113">Thread Execution</span></span>

<span data-ttu-id="13920-114">초기화가 완료되면 ThreadX가 스레드 예약 루프를 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-114">After initialization is complete, ThreadX enters its thread scheduling loop.</span></span> <span data-ttu-id="13920-115">예약 루프는 실행할 준비가 된 애플리케이션 스레드를 찾아봅니다.</span><span class="sxs-lookup"><span data-stu-id="13920-115">The scheduling loop looks for an application thread ready for execution.</span></span> <span data-ttu-id="13920-116">준비된 스레드를 찾으면 ThreadX는 이 스레드로 제어권을 이전합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-116">When a ready thread is found, ThreadX transfers control to it.</span></span> <span data-ttu-id="13920-117">스레드가 완료되면(또는 우선 순위가 더 높은 다른 스레드가 준비되면) 준비된 스레드 중 다음으로 우선 순위가 높은 스레드를 찾기 위해 스레드 예약 루프로 실행이 다시 이전됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-117">After the thread is finished (or another higher-priority thread becomes ready), execution transfers back to the thread scheduling loop to find the next highest priority ready thread.</span></span>

<span data-ttu-id="13920-118">스레드를 지속적으로 실행하고 예약하는 이런 프로세스는 ThreadX 애플리케이션에서 가장 일반적인 프로그램 실행 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-118">This process of continually executing and scheduling threads is the most common type of program execution in ThreadX applications.</span></span>

### <a name="interrupt-service-routines-isr"></a><span data-ttu-id="13920-119">ISR(인터럽트 서비스 루틴)</span><span class="sxs-lookup"><span data-stu-id="13920-119">Interrupt Service Routines (ISR)</span></span>

<span data-ttu-id="13920-120">인터럽트는 실시간 시스템의 초석입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-120">Interrupts are the cornerstone of real-time systems.</span></span> <span data-ttu-id="13920-121">인터럽트가 없으면 외부 세계의 변화에 적시에 대응하기가 매우 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-121">Without interrupts it would be extremely difficult to respond to changes in the external world in a timely manner.</span></span> <span data-ttu-id="13920-122">인터럽트가 감지되면 프로세서는 현재 프로그램 실행에 대한 주요 정보를 저장한 다음(일반적으로 스택에), 미리 정의된 프로그램 영역으로 제어권을 이전합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-122">On detection of an interrupt, the processor saves key information about the current program execution (usually on the stack), then transfers control to a predefined program area.</span></span> <span data-ttu-id="13920-123">미리 정의된 프로그램 영역을 일반적으로 인터럽트 서비스 루틴이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-123">This predefined program area is commonly called an Interrupt Service Routine.</span></span> <span data-ttu-id="13920-124">대부분의 경우 인터럽트는 스레드 실행 중에(또는 스레드 예약 루프에서) 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-124">In most cases, interrupts occur during thread execution (or in the thread scheduling loop).</span></span> <span data-ttu-id="13920-125">하지만 실행 중인 ISR 또는 애플리케이션 타이머 내부에서도 인터럽트가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-125">However, interrupts may also occur inside of an executing ISR or an Application Timer.</span></span>

![프로그램 실행 형식](./media/user-guide/types-program-execution.png)

<span data-ttu-id="13920-127">**그림 2. 프로그램 실행 형식**</span><span class="sxs-lookup"><span data-stu-id="13920-127">**FIGURE 2. Types of Program Execution**</span></span>

### <a name="application-timers"></a><span data-ttu-id="13920-128">애플리케이션 타이머</span><span class="sxs-lookup"><span data-stu-id="13920-128">Application Timers</span></span>

<span data-ttu-id="13920-129">애플리케이션 타이머는 하드웨어 구현(일반적으로 정기적인 단일 하드웨어 인터럽트가 사용됨)이 애플리케이션에서 숨겨지는 점을 제외하면 ISR과 유사합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-129">Application Timers are similar to ISRs, except the hardware implementation (usually a single periodic hardware interrupt is used) is hidden from the application.</span></span> <span data-ttu-id="13920-130">이러한 타이머는 애플리케이션에서 시간 제한 서비스, 정기적 서비스 및/또는 감시 서비스를 수행하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-130">Such timers are used by applications to perform time-outs, periodics, and/or watchdog services.</span></span> <span data-ttu-id="13920-131">ISR과 마찬가지로 애플리케이션 타이머는 스레드 실행을 가장 자주 중단합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-131">Just like ISRs, Application Timers most often interrupt thread execution.</span></span> <span data-ttu-id="13920-132">단, ISR과 달리 애플리케이션 타이머는 서로를 인터럽트할 수는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-132">Unlike ISRs, however, Application Timers cannot interrupt each other.</span></span>

## <a name="memory-usage"></a><span data-ttu-id="13920-133">메모리 사용량</span><span class="sxs-lookup"><span data-stu-id="13920-133">Memory Usage</span></span>

<span data-ttu-id="13920-134">ThreadX는 애플리케이션과 함께 상주합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-134">ThreadX resides along with the application program.</span></span> <span data-ttu-id="13920-135">그 결과, ThreadX의 정적 메모리(또는 고정 메모리) 사용량은 개발 도구(예: 컴파일러, 링커 및 로케이터)에 의해 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-135">As a result, the static memory (or fixed memory) usage of ThreadX is determined by the development tools; e.g., the compiler, linker, and locator.</span></span> <span data-ttu-id="13920-136">동적 메모리(또는 런타임 메모리) 사용량은 애플리케이션에서 직접 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-136">Dynamic memory (or run-time memory) usage is under direct control of the application.</span></span>

### <a name="static-memory-usage"></a><span data-ttu-id="13920-137">정적 메모리 사용량</span><span class="sxs-lookup"><span data-stu-id="13920-137">Static Memory Usage</span></span>

<span data-ttu-id="13920-138">대부분의 개발 도구는 애플리케이션 프로그램 이미지를 *명령어*, *상수*, *초기화된 데이터*, *초기화되지 않은 데이터*, *시스템 스택* 이라는 5가지 기본 영역으로 나눕니다.</span><span class="sxs-lookup"><span data-stu-id="13920-138">Most of the development tools divide the application program image into five basic areas: *instruction*, *constant*, *initialized data*, *uninitialized data*, and *system stack*.</span></span> <span data-ttu-id="13920-139">그림 3은 이러한 메모리 영역의 예를 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="13920-139">Figure 3 shows an example of these memory areas.</span></span>

<span data-ttu-id="13920-140">이것은 단지 예일 뿐이라는 것을 이해해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-140">It is important to understand that this is only an example.</span></span> <span data-ttu-id="13920-141">실제 정적 메모리 레이아웃은 프로세서, 개발 도구 및 기본 하드웨어에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="13920-141">The actual static memory layout is specific to the processor, development tools, and the underlying hardware.</span></span>

<span data-ttu-id="13920-142">명령어 영역에는 프로그램의 모든 프로세서 명령이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-142">The instruction area contains all of the program's processor instructions.</span></span> <span data-ttu-id="13920-143">이 영역은 대체로 가장 크며 ROM에 있는 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-143">This area is typically the largest and is often located in ROM.</span></span>

<span data-ttu-id="13920-144">상수 영역에는 프로그램 내에서 정의되거나 참조되는 문자열을 포함하는 다양한 컴파일된 상수가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-144">The constant area contains various compiled constants, including strings defined or referenced within the program.</span></span> <span data-ttu-id="13920-145">또한 이 영역에는 초기화된 데이터 영역의 "초기 복사본"이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-145">In addition, this area contains the "initial copy" of the initialized data area.</span></span> <span data-ttu-id="13920-146">*메모리 사용량* 컴파일러의 초기화 과정에서 상수 영역의 이 부분은 RAM에 초기화된 데이터 영역을 설정하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-146">During the *Memory Usage* compiler's initialization process, this portion of the constant area is used to set up the initialized data area in RAM.</span></span> <span data-ttu-id="13920-147">상수 영역은 일반적으로 명령어 영역 다음에 있고 ROM에 있는 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-147">The constant area usually follows the instruction area and is often located in ROM.</span></span>

<span data-ttu-id="13920-148">초기화된 데이터 영역과 초기화되지 않은 데이터 영역에는 모든 전역 변수와 및 정적 변수가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-148">The initialized data and uninitialized data areas contain all of the global and static variables.</span></span> <span data-ttu-id="13920-149">이러한 영역은 항상 RAM에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-149">These areas are always located in RAM.</span></span>

<span data-ttu-id="13920-150">시스템 스택은 일반적으로 초기화된 데이터 영역과 초기화되지 않은 데이터 영역 바로 다음에 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-150">The system stack is generally set up immediately following the initialized and uninitialized data areas.</span></span>

<span data-ttu-id="13920-151">시스템 스택은 컴파일러에서 초기화 중에 사용된 다음, ThreadX에서 초기화 중에 사용되며 이후에는 ISR 처리에서 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-151">The system stack is used by the compiler during initialization, then by ThreadX during initialization and, subsequently, in ISR processing.</span></span>

![메모리 영역 예](./media/user-guide/memory-area-example.png)

<span data-ttu-id="13920-153">**그림 3. 메모리 영역 예**</span><span class="sxs-lookup"><span data-stu-id="13920-153">**FIGURE 3. Memory Area Example**</span></span>

### <a name="dynamic-memory-usage"></a><span data-ttu-id="13920-154">동적 메모리 사용량</span><span class="sxs-lookup"><span data-stu-id="13920-154">Dynamic Memory Usage</span></span>

<span data-ttu-id="13920-155">앞서 언급했듯이 동적 메모리 사용량은 애플리케이션에서 직접 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-155">As mentioned before, dynamic memory usage is under direct control of the application.</span></span> <span data-ttu-id="13920-156">스택, 큐 및 메모리 풀과 연결된 메모리 영역 및 제어 블록은 대상의 메모리 공간 어디에나 배치할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-156">Control blocks and memory areas associated with stacks, queues, and memory pools can be placed anywhere in the target's memory space.</span></span> <span data-ttu-id="13920-157">이 기능은 다양한 형식의 실제 메모리를 쉽게 활용할 수 있기 때문에 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-157">This is an important feature because it facilitates easy utilization of different types of physical memory.</span></span>

<span data-ttu-id="13920-158">예를 들어 대상 하드웨어 환경에 빠른 메모리와 느린 메모리가 모두 있다고 가정하겠습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-158">For example, suppose a target hardware environment has both fast memory and slow memory.</span></span> <span data-ttu-id="13920-159">애플리케이션에 우선 순위가 높은 스레드에 대한 추가 성능이 필요한 경우 제어 블록(TX_THREAD) 및 스택을 빠른 메모리 영역에 배치할 수 있으며, 따라서 성능이 크게 향상될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-159">If the application needs extra performance for a high-priority thread, its control block (TX_THREAD) and stack can be placed in the fast memory area, which may greatly enhance its performance.</span></span>

## <a name="initialization"></a><span data-ttu-id="13920-160">초기화</span><span class="sxs-lookup"><span data-stu-id="13920-160">Initialization</span></span>

<span data-ttu-id="13920-161">초기화 프로세스를 이해하는 것은 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-161">Understanding the initialization process is important.</span></span> <span data-ttu-id="13920-162">초기 하드웨어 환경이 여기에서 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-162">The initial hardware environment is set up here.</span></span> <span data-ttu-id="13920-163">또한 바로 여기에서 애플리케이션에 초기 특징이 부여됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-163">In addition, this is where the application is given its initial personality.</span></span>

> [!NOTE]
> <span data-ttu-id="13920-164">*ThreadX는(가능한 경우) 전체 개발 도구의 초기화 프로세스를 활용하려고 시도합니다. 이는 나중에 새 버전의 개발 도구로 쉽게 업그레이드할 수 있게 해줍니다.*</span><span class="sxs-lookup"><span data-stu-id="13920-164">*ThreadX attempts to utilize (whenever possible) the complete development tool's initialization process. This makes it easier to upgrade to new versions of the development tools in the future.*</span></span>

### <a name="system-reset-vector"></a><span data-ttu-id="13920-165">시스템 재설정 벡터</span><span class="sxs-lookup"><span data-stu-id="13920-165">System Reset Vector</span></span>

<span data-ttu-id="13920-166">모든 마이크로프로세서에는 재설정 논리가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-166">All microprocessors have reset logic.</span></span> <span data-ttu-id="13920-167">재설정(하드웨어 또는 소프트웨어)이 발생하면 특정 메모리 위치에서 애플리케이션의 진입점 주소가 검색됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-167">When a reset occurs (either hardware or software), the address of the application's entry point is retrieved from a specific memory location.</span></span> <span data-ttu-id="13920-168">진입점이 검색된 후 프로세서는 이 위치로 제어권을 이전합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-168">After the entry point is retrieved, the processor transfers control to that location.</span></span> <span data-ttu-id="13920-169">애플리케이션 진입점은 네이티브 어셈블리 언어로 작성되는 경우가 많으며 일반적으로 개발 도구에서(적어도 템플릿 형태로) 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-169">The application entry point is quite often written in the native assembly language and is usually supplied by the development tools (at least in template form).</span></span> <span data-ttu-id="13920-170">경우에 따라 ThreadX에 특수 버전의 엔트리 프로그램이 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-170">In some cases, a special version of the entry program is supplied with ThreadX.</span></span>

### <a name="development-tool-initialization"></a><span data-ttu-id="13920-171">개발 도구 초기화</span><span class="sxs-lookup"><span data-stu-id="13920-171">Development Tool Initialization</span></span>

<span data-ttu-id="13920-172">하위 수준 초기화가 완료되면 제어권은 개발 도구의 상위 수준 초기화로 이전됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-172">After the low-level initialization is complete, control transfers to the development tool's high-level initialization.</span></span> <span data-ttu-id="13920-173">일반적으로 여기에서 초기화된 전역 변수 및 정적 C 변수가 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-173">This is usually the place where initialized global and static C variables are set up.</span></span> <span data-ttu-id="13920-174">초기 값은 상수 영역에서 검색됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-174">Remember their initial values are retrieved from the constant area.</span></span> <span data-ttu-id="13920-175">정확한 초기화 처리는 개발 도구에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="13920-175">Exact initialization processing is development tool specific.</span></span>

### <a name="main-function"></a><span data-ttu-id="13920-176">main 함수</span><span class="sxs-lookup"><span data-stu-id="13920-176">main Function</span></span>

<span data-ttu-id="13920-177">개발 도구 초기화가 완료되면 제어권은 사용자가 제공한 *main* 함수로 이전됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-177">When the development tool initialization is complete, control transfers to the user-supplied *main* function.</span></span> <span data-ttu-id="13920-178">이 시점에서 애플리케이션은 이후 발생하는 상황을 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-178">At this point, the application controls what happens next.</span></span> <span data-ttu-id="13920-179">대부분의 애플리케이션에서 main 함수는 ThreadX에 대한 엔트리인 *tx_kernel_enter* 를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-179">For most applications, the main function simply calls *tx_kernel_enter*, which is the entry into ThreadX.</span></span> <span data-ttu-id="13920-180">하지만 애플리케이션은 ThreadX에 들어가기 전에 예비 처리(일반적으로 하드웨어 초기화용)를 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-180">However, applications can perform preliminary processing (usually for hardware initialization) prior to entering ThreadX.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="13920-181">*tx_kernel_enter에 대한 호출은 반환되지 않으므로 이 다음에는 처리를 배치하지 마십시오.*</span><span class="sxs-lookup"><span data-stu-id="13920-181">*The call to tx_kernel_enter does not return, so do not place any processing after it.*</span></span>

### <a name="tx_kernel_enter"></a><span data-ttu-id="13920-182">tx_kernel_enter</span><span class="sxs-lookup"><span data-stu-id="13920-182">tx_kernel_enter</span></span>

<span data-ttu-id="13920-183">엔트리 함수는 다양한 내부 ThreadX 데이터 구조의 초기화를 조정한 다음, 애플리케이션의 정의 함수인 ***tx_application_define*** 을 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-183">The entry function coordinates initialization of various internal ThreadX data structures and then calls the application's definition function ***tx_application_define***.</span></span>

<span data-ttu-id="13920-184">***tx_application_define*** 이 반환되면 제어권은 스레드 예약 루프로 이전됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-184">When ***tx_application_define*** returns, control is transferred to the thread scheduling loop.</span></span> <span data-ttu-id="13920-185">그러면 초기화의 끝이 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-185">This marks the end of initialization.</span></span>

### <a name="application-definition-function"></a><span data-ttu-id="13920-186">애플리케이션 정의 함수</span><span class="sxs-lookup"><span data-stu-id="13920-186">Application Definition Function</span></span>

<span data-ttu-id="13920-187">***tx_application_define*** 함수는 모든 초기 애플리케이션 스레드, 큐, 세마포, 뮤텍스, 이벤트 플래그, 메모리 풀, 타이머를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-187">The ***tx_application_define*** function defines all of the initial application threads, queues, semaphores, mutexes, event flags, memory pools, and timers.</span></span> <span data-ttu-id="13920-188">애플리케이션이 정상적으로 작동하는 동안 스레드에서 시스템 리소스를 만들고 삭제할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-188">It is also possible to create and delete system resources from threads during the normal operation of the application.</span></span> <span data-ttu-id="13920-189">하지만 모든 초기 애플리케이션 리소스가 여기에 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-189">However, all initial application resources are defined here.</span></span>

<span data-ttu-id="13920-190">\***tx_application_define** _ 함수에는 단일 입력 매개 변수가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-190">The \***tx_application_define** _ function has a single input parameter and it is certainly worth mentioning.</span></span> <span data-ttu-id="13920-191">_first-available\* RAM 주소는 이 함수에 대한 유일한 입력 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-191">The _first-available\* RAM address is the sole input parameter to this function.</span></span> <span data-ttu-id="13920-192">일반적으로 스레드 스택, 큐, 메모리 풀의 초기 런타임 메모리 할당을 위한 시작점으로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-192">It is typically used as a starting point for initial run-time memory allocations of thread stacks, queues, and memory pools.</span></span>

> [!NOTE]
> <span data-ttu-id="13920-193">*초기화가 완료된 후에는 실행 스레드에서만 다른 스레드를 포함하는 시스템 리소스를 만들고 삭제할 수 있습니다. 따라서 초기화하는 동안 하나 이상의 스레드를 만들어야 합니다.*</span><span class="sxs-lookup"><span data-stu-id="13920-193">*After initialization is complete, only an executing thread can create and delete system resources— including other threads. Therefore, at least one thread must be created during initialization.*</span></span>

### <a name="interrupts"></a><span data-ttu-id="13920-194">인터럽트</span><span class="sxs-lookup"><span data-stu-id="13920-194">Interrupts</span></span>

<span data-ttu-id="13920-195">인터럽트는 전체 초기화 프로세스 동안 사용하지 않도록 설정된 상태로 유지됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-195">Interrupts are left disabled during the entire initialization process.</span></span> <span data-ttu-id="13920-196">애플리케이션에서 인터럽트를 사용하도록 설정하면 예기치 않은 동작이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-196">If the application somehow enables interrupts, unpredictable behavior may occur.</span></span> <span data-ttu-id="13920-197">그림 4는 시스템 재설정부터 애플리케이션별 초기화까지 전체 초기화 프로세스를 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="13920-197">Figure 4 shows the entire initialization process, from system reset through application-specific initialization.</span></span>

## <a name="thread-execution"></a><span data-ttu-id="13920-198">스레드 실행</span><span class="sxs-lookup"><span data-stu-id="13920-198">Thread Execution</span></span>

<span data-ttu-id="13920-199">애플리케이션 스레드 예약 및 실행은 ThreadX의 가장 중요한 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-199">Scheduling and executing application threads is the most important activity of ThreadX.</span></span> <span data-ttu-id="13920-200">스레드는 일반적으로 전용 용도가 있는 반독립적인 프로그램 세그먼트로 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-200">A thread is typically defined as a semi-independent program segment with a dedicated purpose.</span></span> <span data-ttu-id="13920-201">모든 스레드의 처리를 결합하여 애플리케이션이 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="13920-201">The combined processing of all threads makes an application.</span></span>

<span data-ttu-id="13920-202">스레드는 초기화 중에 또는 스레드 실행 중에 \***tx_thread_create** _를 호출하여 동적으로 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-202">Threads are created dynamically by calling \***tx_thread_create** _ during initialization or during thread execution.</span></span> <span data-ttu-id="13920-203">스레드는 준비됨(_ready*) 또는 일시 중단됨(*suspended\*) 상태로 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-203">Threads are created in either a _ready\* or *suspended* state.</span></span>

![초기화 프로세스](./media/user-guide/initialization-process.png)

<span data-ttu-id="13920-205">**그림 4. 초기화 프로세스**</span><span class="sxs-lookup"><span data-stu-id="13920-205">**FIGURE 4. Initialization Process**</span></span>

### <a name="thread-execution-states"></a><span data-ttu-id="13920-206">스레드 실행 상태</span><span class="sxs-lookup"><span data-stu-id="13920-206">Thread Execution States</span></span>

<span data-ttu-id="13920-207">스레드의 다양한 처리 상태를 이해하는 것은 전체 다중 스레드 환경을 이해하는 데 중요한 부분입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-207">Understanding the different processing states of threads is a key ingredient to understanding the entire multithreaded environment.</span></span> <span data-ttu-id="13920-208">ThreadX에는 준비됨(*ready*), 일시 중단됨(*suspended*), 실행 중(*executing*), 종료됨(*terminated*), 완료됨(*completed*)이라는 다섯 가지 개별 스레드 상태가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-208">In ThreadX there are five distinct thread states: *ready*, *suspended*, *executing*, *terminated*, and *completed*.</span></span> <span data-ttu-id="13920-209">그림 5는 ThreadX의 스레드 상태 전환 다이어그램을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="13920-209">Figure 5 shows the thread state transition diagram for ThreadX.</span></span>

![스레드 상태 전환](./media/user-guide/thread-state-transition.png)

<span data-ttu-id="13920-211">**그림 5. 스레드 상태 전환**</span><span class="sxs-lookup"><span data-stu-id="13920-211">**FIGURE 5. Thread State Transition**</span></span>

<span data-ttu-id="13920-212">스레드를 실행할 준비가 되면 준비됨(*ready*) 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-212">A thread is in a *ready* state when it is ready for execution.</span></span> <span data-ttu-id="13920-213">준비된 스레드는 준비됨 상태에서 우선 순위가 가장 높은 스레드가 될 때까지 실행되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-213">A ready thread is not executed until it is the highest priority thread in ready state.</span></span> <span data-ttu-id="13920-214">그렇게 되면 ThreadX는 스레드를 실행한 다음, 스레드의 상태를 실행 중(*executing*)으로 변경합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-214">When this happens, ThreadX executes the thread, which then changes its state to *executing*.</span></span>

<span data-ttu-id="13920-215">우선 순위가 더 높은 스레드가 준비되면 실행 중인 스레드는 다시 준비됨(*ready*) 상태로 돌아갑니다.</span><span class="sxs-lookup"><span data-stu-id="13920-215">If a higher-priority thread becomes ready, the executing thread reverts back to a *ready* state.</span></span> <span data-ttu-id="13920-216">그러면 새로 준비된 우선 순위가 높은 스레드가 실행되고 이 스레드의 논리적 상태는 실행 중(*executing*)으로 변경됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-216">The newly ready high-priority thread is then executed, which changes its logical state to *executing*.</span></span> <span data-ttu-id="13920-217">스레드 선점이 발생할 때마다 이렇게 준비됨(*ready*) 상태와 실행 중(*executing*) 상태가 서로 전환되는 경우가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-217">This transition between *ready* and *executing* states occurs every time thread preemption occurs.</span></span>

<span data-ttu-id="13920-218">언제든 특정 순간에 오직 하나의 스레드만 실행 중(*executing*) 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-218">At any given moment, only one thread is in an *executing* state.</span></span> <span data-ttu-id="13920-219">실행 중(*executing*)인 상태의 스레드가 기본 프로세서에 대한 제어권을 갖기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-219">This is because a thread in the *executing* state has control of the underlying processor.</span></span>

<span data-ttu-id="13920-220">일시 중단됨(*suspended*) 상태인 스레드는 실행하기에 적합하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-220">Threads in a *suspended* state are not eligible for execution.</span></span> <span data-ttu-id="13920-221">일시 중단됨(*suspended*) 상태인 이유에는 시간, 큐 메시지, 세마포, 뮤텍스, 이벤트 플래그, 메모리에 대한 일시 중단 및 기본 스레드 일시 중단이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-221">Reasons for being in a *suspended* state include suspension for time, queue messages, semaphores, mutexes, event flags, memory, and basic thread suspension.</span></span> <span data-ttu-id="13920-222">일시 중단의 원인이 제거되면 스레드는 다시 준비됨(*ready*) 상태로 돌아갑니다.</span><span class="sxs-lookup"><span data-stu-id="13920-222">After the cause for suspension is removed, the thread is placed back in a *ready* state.</span></span>

<span data-ttu-id="13920-223">완료됨(*completed*) 상태인 스레드는 처리가 완료되고 엔트리 함수에서 반환된 스레드입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-223">A thread in a *completed* state is a thread that has completed its processing and returned from its entry function.</span></span> <span data-ttu-id="13920-224">엔트리 함수는 스레드를 만드는 동안 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-224">The entry function is specified during thread creation.</span></span> <span data-ttu-id="13920-225">완료됨(*completed*) 상태인 스레드는 다시 실행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-225">A thread in a *completed* state cannot execute again.</span></span>

<span data-ttu-id="13920-226">스레드가 종료됨(*terminated*) 상태인 이유는 다른 스레드 또는 스레드 자체가 *tx_thread_terminate* 서비스를 호출했기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-226">A thread is in a *terminated* state because another thread or the thread itself called the *tx_thread_terminate* service.</span></span> <span data-ttu-id="13920-227">종료됨(*terminated*) 상태인 스레드는 다시 실행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-227">A thread in a *terminated* state cannot execute again.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="13920-228">*완료되었거나 종료된 스레드를 다시 시작하는 경우 애플리케이션은 먼저 스레드를 삭제해야 합니다. 그런 다음 다시 만들고 다시 시작할 수 있습니다.*</span><span class="sxs-lookup"><span data-stu-id="13920-228">*If re-starting a completed or terminated thread is desired, the application must first delete the thread. It can then be re-created and re-started.*</span></span>

### <a name="thread-entryexit-notification"></a><span data-ttu-id="13920-229">스레드 진입/종료 알림</span><span class="sxs-lookup"><span data-stu-id="13920-229">Thread Entry/Exit Notification</span></span>

<span data-ttu-id="13920-230">일부 애플리케이션은 특정 스레드에 처음 진입하거나, 스레드가 완료되거나 종료될 때 알림을 받는 것이 유리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-230">Some applications may find it advantageous to be notified when a specific thread is entered for the first time, when it completes, or is terminated.</span></span> <span data-ttu-id="13920-231">ThreadX는 ***tx_thread_entry_exit_notify*** 서비스를 통해 이 기능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-231">ThreadX provides this ability through the ***tx_thread_entry_exit_notify*** service.</span></span> <span data-ttu-id="13920-232">이 서비스는 특정 스레드에 대한 애플리케이션 알림 함수(스레드 실행이 시작되거나, 완료되거나 종료될 때마다 ThreadX에 의해 호출됨)를 등록합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-232">This service registers an application notification function for a specific thread, which is called by ThreadX whenever the thread starts running, completes, or is terminated.</span></span> <span data-ttu-id="13920-233">애플리케이션 알림 함수가 호출된 후에는 애플리케이션별 처리를 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-233">After being invoked, the application notification function can perform the application-specific processing.</span></span> <span data-ttu-id="13920-234">여기에는 일반적으로 ThreadX 동기화 기본 형식을 통해 다른 애플리케이션 스레드에 이벤트를 알리는 작업이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-234">This typically involves informing another application thread of the event via a ThreadX synchronization primitive.</span></span>

### <a name="thread-priorities"></a><span data-ttu-id="13920-235">스레드 우선 순위</span><span class="sxs-lookup"><span data-stu-id="13920-235">Thread Priorities</span></span>

<span data-ttu-id="13920-236">앞서 언급했듯이 스레드는 전용 용도가 있는 반독립적인 프로그램 세그먼트입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-236">As mentioned before, a thread is a semi-independent program segment with a dedicated purpose.</span></span> <span data-ttu-id="13920-237">하지만 모든 스레드가 동일하게 생성되는 것은 아닙니다!</span><span class="sxs-lookup"><span data-stu-id="13920-237">However, all threads are not created equal!</span></span> <span data-ttu-id="13920-238">일부 스레드의 전용 용도는 다른 스레드보다 훨씬 더 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-238">The dedicated purpose of some threads is much more important than others.</span></span> <span data-ttu-id="13920-239">이렇게 다른 형식의 스레드 중요도는 내장된 실시간 애플리케이션의 특징입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-239">This heterogeneous type of thread importance is a hallmark of embedded realtime applications.</span></span>

<span data-ttu-id="13920-240">ThreadX는 스레드의 우선 순위(*priority*)를 나타내는 숫자 값을 할당하여 스레드가 생성될 때 스레드의 중요도를 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-240">ThreadX determines a thread's importance when the thread is created by assigning a numerical value representing its *priority*.</span></span> <span data-ttu-id="13920-241">ThreadX 우선 순위의 최대 수는 32에서 1024까지 32씩 증가하도록 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-241">The maximum number of ThreadX priorities is configurable from 32 through 1024 in increments of 32.</span></span> <span data-ttu-id="13920-242">실제 최대 우선 순위 수는 ThreadX 라이브러리를 컴파일하는 동안 **TX_MAX_PRIORITIES** 상수에 의해 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-242">The actual maximum number of priorities is determined by the **TX_MAX_PRIORITIES** constant during compilation of the ThreadX library.</span></span> <span data-ttu-id="13920-243">우선 순위의 수가 더 많다고 해서 처리 오버헤드가 크게 증가하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-243">Having a larger number of priorities does not significantly increase processing overhead.</span></span> <span data-ttu-id="13920-244">하지만 우선 순위 수준이 32개인 각 그룹을 관리하려면 RAM 128바이트가 추가로 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-244">However, for each group of 32 priority levels an additional 128 bytes of RAM is required to manage them.</span></span> <span data-ttu-id="13920-245">예를 들어, 32개의 우선 순위 수준에는 128바이트의 RAM이 필요하고, 64개의 우선 순위 수준에는 256바이트의 RAM이 필요하며, 96개의 우선 순위 수준에는 384바이트의 RAM이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-245">For example, 32 priority levels require 128 bytes of RAM, 64 priority levels require 256 bytes of RAM, and 96 priority levels requires 384 bytes of RAM.</span></span>

<span data-ttu-id="13920-246">기본적으로 ThreadX에는 우선 순위 0부터 우선 순위 31까지 32개의 우선 순위 수준이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-246">By default, ThreadX has 32 priority levels, ranging from priority 0 through priority 31.</span></span> <span data-ttu-id="13920-247">숫자 값이 작을수록 높은 우선 순위를 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-247">Numerically smaller values imply higher priority.</span></span> <span data-ttu-id="13920-248">따라서 우선 순위가 0이면 가장 높은 우선 순위를 나타내고 우선 순위 (**TX_MAX_PRIORITIES**-1)은 가장 낮은 우선 순위를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="13920-248">Hence, priority 0 represents the highest priority, while priority (**TX_MAX_PRIORITIES**-1) represents the lowest priority.</span></span>

<span data-ttu-id="13920-249">협력 예약 또는 시간 조각화에 따라 여러 스레드가 동일한 우선 순위를 가질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-249">Multiple threads can have the same priority relying on cooperative scheduling or time-slicing.</span></span> <span data-ttu-id="13920-250">또한 스레드 우선 순위는 런타임 중에 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-250">In addition, thread priorities can be changed during run-time.</span></span>

### <a name="thread-scheduling"></a><span data-ttu-id="13920-251">스레드 예약</span><span class="sxs-lookup"><span data-stu-id="13920-251">Thread Scheduling</span></span>

<span data-ttu-id="13920-252">ThreadX는 우선 순위에 따라 스레드를 예약합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-252">ThreadX schedules threads based on their priority.</span></span> <span data-ttu-id="13920-253">우선 순위가 가장 높은 준비된 스레드가 먼저 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-253">The ready thread with the highest priority is executed first.</span></span> <span data-ttu-id="13920-254">우선 순위가 같은 여러 스레드가 준비되면 *FIFO(선입 선출)* 방식으로 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-254">If multiple threads of the same priority are ready, they are executed in a *first-in-first-out* (FIFO) manner.</span></span>

### <a name="round-robin-scheduling"></a><span data-ttu-id="13920-255">라운드 로빈 예약</span><span class="sxs-lookup"><span data-stu-id="13920-255">Round-robin Scheduling</span></span>

<span data-ttu-id="13920-256">ThreadX는 우선 순위가 같은 여러 스레드의 *라운드 로빈* 예약을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-256">ThreadX supports *round-robin* scheduling of multiple threads having the same priority.</span></span> <span data-ttu-id="13920-257">이것은 \***tx_thread_relinquish** _에 대한 협력 호출을 통해 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-257">This is accomplished through cooperative calls to \***tx_thread_relinquish** _.</span></span> <span data-ttu-id="13920-258">이 서비스는 _ *_tx_thread_relinquish_*\* 호출자가 다시 실행되기 전에 우선 순위가 같은 다른 모든 준비된 스레드가 실행될 수 있는 기회를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-258">This service gives all other ready threads of the same priority a chance to execute before the _ *_tx_thread_relinquish_*\* caller executes again.</span></span>

### <a name="time-slicing"></a><span data-ttu-id="13920-259">시간 조각화</span><span class="sxs-lookup"><span data-stu-id="13920-259">Time-Slicing</span></span>

<span data-ttu-id="13920-260">시간 조각화(*Time-slicing*)는 라운드 로빈 예약의 또 다른 형태입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-260">*Time-slicing* is another form of round-robin scheduling.</span></span> <span data-ttu-id="13920-261">시간 조각은 스레드가 프로세서를 포기하지 않고 실행될 수 있는 최대 타이머 틱(타이머 인터럽트) 수를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-261">A time-slice specifies the maximum number of timer ticks (timer interrupts) that a thread can execute without giving up the processor.</span></span> <span data-ttu-id="13920-262">ThreadX에서 시간 조각화는 스레드별로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-262">In ThreadX, time-slicing is available on a per-thread basis.</span></span> <span data-ttu-id="13920-263">스레드의 시간 조각은 생성 중에 할당되고 런타임 중에 수정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-263">The thread's time-slice is assigned during creation and can be modified during run-time.</span></span> <span data-ttu-id="13920-264">시간 조각이 만료되면 시간이 조각화된 스레드가 다시 실행되기 전에 우선 순위 수준이 같은 다른 모든 준비된 스레드를 실행할 기회가 주어집니다.</span><span class="sxs-lookup"><span data-stu-id="13920-264">When a time-slice expires, all other ready threads of the same priority level are given a chance to execute before the time-sliced thread executes again.</span></span>

<span data-ttu-id="13920-265">일시 중단되거나, 포기되거나, 선점을 유발하는 ThreadX 서비스 호출이 수행되거나 자체적으로 시간이 조각화된 후에 새로운 스레드 시간 조각이 스레드에 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-265">A fresh thread time-slice is given to a thread after it suspends, relinquishes, makes a ThreadX service call that causes preemption, or is itself time-sliced.</span></span>

<span data-ttu-id="13920-266">시간이 조각화된 스레드가 선점되면 나머지 시간 조각에 대해 우선 순위가 동일한 다른 준비된 스레드보다 먼저 재개됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-266">When a time-sliced thread is preempted, it will resume before other ready threads of equal priority for the remainder of its time-slice.</span></span>

> [!NOTE]
> <span data-ttu-id="13920-267">*시간 조각화를 사용하면 약간의 시스템 오버헤드가 발생합니다. 시간 조각화는 여러 스레드가 동일한 우선 순위를 공유하는 경우에만 유용하므로 고유한 우선 순위가 있는 스레드에는 시간 조각이 할당되면 안 됩니다.*</span><span class="sxs-lookup"><span data-stu-id="13920-267">*Using time-slicing results in a slight amount of system overhead. Because time-slicing is only useful in cases in which multiple threads share the same priority, threads having a unique priority should not be assigned a time-slice.*</span></span>

### <a name="preemption"></a><span data-ttu-id="13920-268">선점</span><span class="sxs-lookup"><span data-stu-id="13920-268">Preemption</span></span>

<span data-ttu-id="13920-269">선점은 우선 순위가 더 높은 스레드를 위해 실행 중인 스레드를 일시적으로 중단하는 프로세스입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-269">Preemption is the process of temporarily interrupting an executing thread in favor of a higher-priority thread.</span></span> <span data-ttu-id="13920-270">이 프로세스는 실행 중인 스레드에 표시되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-270">This process is invisible to the executing thread.</span></span> <span data-ttu-id="13920-271">우선 순위가 더 높은 스레드가 완료되면 선점이 발생한 정확한 위치로 제어권이 다시 이전됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-271">When the higher-priority thread is finished, control is transferred back to the exact place where the preemption took place.</span></span> <span data-ttu-id="13920-272">이것은 실시간 시스템에서 매우 중요한 기능입니다. 중요한 애플리케이션 이벤트에 신속하게 대응할 수 있기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-272">This is a very important feature in real-time systems because it facilitates fast response to important application events.</span></span> <span data-ttu-id="13920-273">선점은 매우 중요한 기능이지만 고갈, 과도한 오버헤드, 우선 순위 반전을 비롯한 다양한 문제의 원인이 될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-273">Although a very important feature, preemption can also be a source of a variety of problems, including starvation, excessive overhead, and priority inversion.</span></span>

### <a name="preemption-thresholdtrade"></a><span data-ttu-id="13920-274">선점 임계값&trade;</span><span class="sxs-lookup"><span data-stu-id="13920-274">Preemption Threshold&trade;</span></span>

<span data-ttu-id="13920-275">선점에 내재된 문제를 완화하기 위해 ThreadX는 선점 임계값(*preemption-threshold*)이라는 고유한 고급 기능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-275">To ease some of the inherent problems of preemption, ThreadX provides a unique and advanced feature called *preemption-threshold*.</span></span>

<span data-ttu-id="13920-276">선점 임계값을 사용하면 스레드에서 선점을 비활성화하기 위한 우선 순위 상한(*ceiling*)을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-276">A preemption-threshold allows a thread to specify a priority *ceiling* for disabling preemption.</span></span> <span data-ttu-id="13920-277">상한보다 우선 순위가 높은 스레드는 여전히 선점이 가능하지만 상한보다 낮은 스레드는 선점이 불가능합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-277">Threads that have higher priorities than the ceiling are still allowed to preempt, while those less than the ceiling are not allowed to preempt.</span></span>

<span data-ttu-id="13920-278">예를 들어 우선 순위가 20인 스레드가 우선 순위가 15에서 20 사이인 스레드 그룹과만 상호 작용한다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-278">For example, suppose a thread of priority 20 only interacts with a group of threads that have priorities between 15 and 20.</span></span> <span data-ttu-id="13920-279">임계 영역 중에 우선 순위가 20인 스레드는 선점 임계값을 15로 설정하여 상호 작용하는 모든 스레드에서 선점을 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-279">During its critical sections, the thread of priority 20 can set its preemption-threshold to 15, thereby preventing preemption from all of the threads that it interacts with.</span></span> <span data-ttu-id="13920-280">이렇게 해도 매우 중요한 스레드(우선 순위가 0에서 14 사이)는 중요한 섹션 처리 중에 이 스레드를 선점할 수 있으며 따라서 응답성이 훨씬 더 향상된 처리가 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-280">This still permits really important threads (priorities between 0 and 14) to preempt this thread during its critical section processing, which results in much more responsive processing.</span></span>

<span data-ttu-id="13920-281">물론 선점 임계값을 0으로 설정하여 스레드가 모든 선점을 비활성화하는 것도 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-281">Of course, it is still possible for a thread to disable all preemption by setting its preemption-threshold to 0.</span></span> <span data-ttu-id="13920-282">런타임 중에 선점 임계값을 변경할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-282">In addition, preemption-threshold can be changed during run-time.</span></span>

> [!NOTE]
> <span data-ttu-id="13920-283">*선점 임계값을 사용하면 지정된 스레드에 대한 시간 조각화가 비활성화됩니다.*</span><span class="sxs-lookup"><span data-stu-id="13920-283">*Using preemption-threshold disables time-slicing for the specified thread.*</span></span>

### <a name="priority-inheritance"></a><span data-ttu-id="13920-284">우선 순위 상속</span><span class="sxs-lookup"><span data-stu-id="13920-284">Priority Inheritance</span></span>

<span data-ttu-id="13920-285">ThreadX는 뮤텍스(이 챕터의 뒷부분에 설명되어 있음) 서비스 내에서 선택적 우선 순위 상속도 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-285">ThreadX also supports optional priority inheritance within its mutex services described later in this chapter.</span></span> <span data-ttu-id="13920-286">우선 순위 상속을 사용하면 우선 순위가 낮은 스레드가 소유한 뮤텍스를 기다리는 우선 순위가 높은 스레드의 우선 순위를 우선 순위가 낮은 스레드가 임시로 가정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-286">Priority inheritance allows a lower priority thread to temporarily assume the priority of a high priority thread that is waiting for a mutex owned by the lower priority thread.</span></span> <span data-ttu-id="13920-287">이 기능은 중간 스레드 우선 순위의 선점을 제거하여 애플리케이션이 비결정적 우선 순위 반전을 방지하는 데 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-287">This capability helps the application to avoid nondeterministic priority inversion by eliminating preemption of intermediate thread priorities.</span></span> <span data-ttu-id="13920-288">물론, *선점 임계값* 을 사용하여 유사한 결과를 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-288">Of course, *preemption-threshold* may be used to achieve a similar result.</span></span>

### <a name="thread-creation"></a><span data-ttu-id="13920-289">스레드 만들기</span><span class="sxs-lookup"><span data-stu-id="13920-289">Thread Creation</span></span>

<span data-ttu-id="13920-290">애플리케이션 스레드는 초기화 중에 또는 다른 애플리케이션 스레드를 실행하는 동안 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="13920-290">Application threads are created during initialization or during the execution of other application threads.</span></span> <span data-ttu-id="13920-291">애플리케이션에서 만들 수 있는 스레드 수에는 제한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-291">There is no limit on the number of threads that can be created by an application.</span></span>

### <a name="thread-control-block-tx_thread"></a><span data-ttu-id="13920-292">스레드 제어 블록 TX_THREAD</span><span class="sxs-lookup"><span data-stu-id="13920-292">Thread Control Block TX_THREAD</span></span>

<span data-ttu-id="13920-293">각 스레드의 특징은 해당 제어 블록에 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-293">The characteristics of each thread are contained in its control block.</span></span> <span data-ttu-id="13920-294">이 구조는 ***tx_api.h*** 파일에 정의되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-294">This structure is defined in the ***tx_api.h*** file.</span></span>

<span data-ttu-id="13920-295">스레드의 제어 블록은 메모리의 어디에나 위치할 수 있지만 제어 블록을 모든 함수의 범위 밖에 정의하여 전역 구조로 만드는 것이 가장 일반적입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-295">A thread's control block can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

<span data-ttu-id="13920-296">제어 블록을 다른 영역에서 두려면 모든 동적 할당 메모리와 마찬가지로 조금 더 주의가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-296">Locating the control block in other areas requires a bit more care, just like all dynamically-allocated memory.</span></span> <span data-ttu-id="13920-297">제어 블록이 C 함수 내에 할당된 경우 이것과 연결된 메모리는 호출 스레드 스택의 일부입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-297">If a control block is allocated within a C function, the memory associated with it is part of the calling thread's stack.</span></span> <span data-ttu-id="13920-298">일반적으로 제어 블록에 로컬 스토리지를 사용하지 마십시오. 함수가 반환된 후에는 다른 스레드가 로컬 스토리지를 제어 블록에 사용하고 있는지 여부에 관계없이 모든 로컬 변수 스택 공간이 해제되기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-298">In general, avoid using local storage for control blocks because after the function returns, all of its local variable stack space is released—regardless of whether another thread is using it for a control block.</span></span>

<span data-ttu-id="13920-299">대부분의 경우 애플리케이션은 스레드 제어 블록의 콘텐츠를 인식하지 못합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-299">In most cases, the application is oblivious to the contents of the thread's control block.</span></span> <span data-ttu-id="13920-300">하지만 특정 멤버를 확인하는 것이 유용한 상황이 있습니다(특히 디버그 중에).</span><span class="sxs-lookup"><span data-stu-id="13920-300">However, there are some situations, especially during debug, in which looking at certain members is useful.</span></span> <span data-ttu-id="13920-301">다음은 몇 가지 유용한 제어 블록 멤버 중 일부입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-301">The following are some of the more useful control block members.</span></span>

<span data-ttu-id="13920-302">**tx_thread_run_count** 에는 스레드가 예약된 횟수 카운터가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-302">**tx_thread_run_count** contains a counter of the number of many times the thread has been scheduled.</span></span> <span data-ttu-id="13920-303">카운터가 증가하면 스레드가 예약되고 실행되고 있음을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="13920-303">An increasing counter indicates the thread is being scheduled and executed.</span></span>

<span data-ttu-id="13920-304">**tx_thread_state** 에는 연결된 스레드의 상태가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-304">**tx_thread_state** contains the state of the associated thread.</span></span> <span data-ttu-id="13920-305">가능한 스레드 상태는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-305">The following lists the possible thread states.</span></span>

|  <span data-ttu-id="13920-306">스레드 상태</span><span class="sxs-lookup"><span data-stu-id="13920-306">Thread state</span></span>   | <span data-ttu-id="13920-307">값</span><span class="sxs-lookup"><span data-stu-id="13920-307">Value</span></span> |
| --------------- | ------ |
| <span data-ttu-id="13920-308">TX_READY</span><span class="sxs-lookup"><span data-stu-id="13920-308">TX_READY</span></span>       | <span data-ttu-id="13920-309">(0x00)</span><span class="sxs-lookup"><span data-stu-id="13920-309">(0x00)</span></span> |
| <span data-ttu-id="13920-310">TX_COMPLETED</span><span class="sxs-lookup"><span data-stu-id="13920-310">TX_COMPLETED</span></span>   | <span data-ttu-id="13920-311">(0x01)</span><span class="sxs-lookup"><span data-stu-id="13920-311">(0x01)</span></span> |
| <span data-ttu-id="13920-312">TX_TERMINATED</span><span class="sxs-lookup"><span data-stu-id="13920-312">TX_TERMINATED</span></span>  | <span data-ttu-id="13920-313">(0x02)</span><span class="sxs-lookup"><span data-stu-id="13920-313">(0x02)</span></span> |
| <span data-ttu-id="13920-314">TX_SUSPENDED</span><span class="sxs-lookup"><span data-stu-id="13920-314">TX_SUSPENDED</span></span>   | <span data-ttu-id="13920-315">(0x03)</span><span class="sxs-lookup"><span data-stu-id="13920-315">(0x03)</span></span> |
| <span data-ttu-id="13920-316">TX_SLEEP</span><span class="sxs-lookup"><span data-stu-id="13920-316">TX_SLEEP</span></span>       | <span data-ttu-id="13920-317">(0x04)</span><span class="sxs-lookup"><span data-stu-id="13920-317">(0x04)</span></span> |
| <span data-ttu-id="13920-318">TX_QUEUE_SUSP</span><span class="sxs-lookup"><span data-stu-id="13920-318">TX_QUEUE_SUSP</span></span> | <span data-ttu-id="13920-319">(0x05)</span><span class="sxs-lookup"><span data-stu-id="13920-319">(0x05)</span></span> |
| <span data-ttu-id="13920-320">TX_SEMAPHORE_SUSP</span><span class="sxs-lookup"><span data-stu-id="13920-320">TX_SEMAPHORE_SUSP</span></span> | <span data-ttu-id="13920-321">(0x06)</span><span class="sxs-lookup"><span data-stu-id="13920-321">(0x06)</span></span> |
| <span data-ttu-id="13920-322">TX_EVENT_FLAG</span><span class="sxs-lookup"><span data-stu-id="13920-322">TX_EVENT_FLAG</span></span>   | <span data-ttu-id="13920-323">(0x07)</span><span class="sxs-lookup"><span data-stu-id="13920-323">(0x07)</span></span> |
| <span data-ttu-id="13920-324">TX_BLOCK_MEMORY</span><span class="sxs-lookup"><span data-stu-id="13920-324">TX_BLOCK_MEMORY</span></span> | <span data-ttu-id="13920-325">(0x08)</span><span class="sxs-lookup"><span data-stu-id="13920-325">(0x08)</span></span> |
| <span data-ttu-id="13920-326">TX_BYTE_MEMORY</span><span class="sxs-lookup"><span data-stu-id="13920-326">TX_BYTE_MEMORY</span></span>  | <span data-ttu-id="13920-327">(0x09)</span><span class="sxs-lookup"><span data-stu-id="13920-327">(0x09)</span></span> |
| <span data-ttu-id="13920-328">TX_MUTEX_SUSP</span><span class="sxs-lookup"><span data-stu-id="13920-328">TX_MUTEX_SUSP</span></span>   | <span data-ttu-id="13920-329">(0x0D)</span><span class="sxs-lookup"><span data-stu-id="13920-329">(0x0D)</span></span> |

> [!NOTE]
> <span data-ttu-id="13920-330">*물론, 스레드 제어 블록에는 다른 흥미로운 필드(스택 포인터, 시간 조각 값, 우선 순위 등)가 많이 있습니다. 사용자는 제어 블록 멤버를 검토할 수 있지만 수정은 엄격히 금지됩니다!*</span><span class="sxs-lookup"><span data-stu-id="13920-330">*Of course there are many other interesting fields in the thread control block, including the stack pointer, time-slice value, priorities, etc. Users are welcome to review control block members, but modifications are strictly prohibited!*</span></span>

> [!IMPORTANT]
> <span data-ttu-id="13920-331">*이는 이 섹션 앞부분에서 언급한 "실행 중" 상태와는 다릅니다. 주어진 시간에 실행되는 스레드가 하나뿐이기 때문에 실행 중 상태는 필요하지 않습니다. 또한 실행 중인 스레드의 상태도* **TX_READY** 입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-331">*There is no equate for the "executing" state mentioned earlier in this section. It is not necessary because there is only one executing thread at a given time. The state of an executing thread is also* **TX_READY**.</span></span>

### <a name="currently-executing-thread"></a><span data-ttu-id="13920-332">현재 실행 중인 스레드</span><span class="sxs-lookup"><span data-stu-id="13920-332">Currently Executing Thread</span></span>

<span data-ttu-id="13920-333">전에 언급했듯이 주어진 시간에 스레드는 하나만 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-333">As mentioned before, there is only one thread executing at any given time.</span></span> <span data-ttu-id="13920-334">실행 중인 스레드를 식별하는 방법은 요청을 수행하는 스레드에 따라 여러 가지가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-334">There are several ways to identify the executing thread, depending on which thread is making the request.</span></span>
<span data-ttu-id="13920-335">프로그램 세그먼트는 ***tx_thread_identify*** 를 호출하여 실행 중인 스레드의 제어 블록 주소를 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-335">A program segment can get the control block address of the executing thread by calling ***tx_thread_identify***.</span></span> <span data-ttu-id="13920-336">이것은 여러 스레드에서 실행되는 애플리케이션 코드의 공유 부분에서 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-336">This is useful in shared portions of application code that are executed from multiple threads.</span></span>

<span data-ttu-id="13920-337">디버그 세션에서 사용자는 내부 ThreadX 포인터인 ***_tx_thread_current_ptr*** 을 검사할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-337">In debug sessions, users can examine the internal ThreadX pointer ***_tx_thread_current_ptr***.</span></span> <span data-ttu-id="13920-338">여기에는 현재 실행 중인 스레드의 제어 블록 주소가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-338">It contains the control block address of the currently executing thread.</span></span> <span data-ttu-id="13920-339">이 포인터가 NULL이면 애플리케이션 스레드는 실행되지 않습니다. 즉, ThreadX는 스레드가 준비될 때까지 예약 루프에서 대기하고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-339">If this pointer is NULL, no application thread is executing; i.e., ThreadX is waiting in its scheduling loop for a thread to become ready.</span></span>

### <a name="thread-stack-area"></a><span data-ttu-id="13920-340">스레드 스택 영역</span><span class="sxs-lookup"><span data-stu-id="13920-340">Thread Stack Area</span></span>

<span data-ttu-id="13920-341">각 스레드에는 마지막 실행 및 컴파일러 사용의 컨텍스트를 저장하기 위한 자체 스택이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-341">Each thread must have its own stack for saving the context of its last execution and compiler use.</span></span> <span data-ttu-id="13920-342">대부분의 C 컴파일러는 이 스택을 사용하여 함수 호출을 수행하고 임시로 로컬 변수를 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-342">Most C compilers use the stack for making function calls and for temporarily allocating local variables.</span></span> <span data-ttu-id="13920-343">그림 6은 일반적인 스레드 스택을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="13920-343">Figure 6 shows a typical thread's stack.</span></span>

<span data-ttu-id="13920-344">메모리에서 스레드 스택이 어디에 위치할지는 애플리케이션에 달려 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-344">Where a thread stack is located in memory is up to the application.</span></span> <span data-ttu-id="13920-345">스택 영역은 스레드 생성 중에 지정되며 대상 주소 공간의 어디에나 위치할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-345">The stack area is specified during thread creation and can be located anywhere in the target's address space.</span></span> <span data-ttu-id="13920-346">이 기능을 사용하면 애플리케이션이 고속 RAM에 스택을 배치하여 중요한 스레드의 성능을 향상시킬 수 있기 때문에 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-346">This is an important feature because it allows applications to improve performance of important threads by placing their stack in high-speed RAM.</span></span>

<span data-ttu-id="13920-347">**스택 메모리 영역**(예)</span><span class="sxs-lookup"><span data-stu-id="13920-347">**Stack Memory Area** (example)</span></span>

![일반적인 스레드 스택](./media/user-guide/typical-thread-stack.png)

<span data-ttu-id="13920-349">**그림 6. 일반적인 스레드 스택**</span><span class="sxs-lookup"><span data-stu-id="13920-349">**FIGURE 6. Typical Thread Stack**</span></span>

<span data-ttu-id="13920-350">스택에 필요한 크기는 스레드에 대해 가장 자주 묻는 질문 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-350">How big a stack should be is one of the most frequently asked questions about threads.</span></span> <span data-ttu-id="13920-351">스레드의 스택 영역은 최악의 경우 함수 호출 중첩, 로컬 변수 할당 및 마지막 실행 컨텍스트 저장을 수용할 수 있을 만큼 충분히 커야 합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-351">A thread's stack area must be large enough to accommodate worst-case function call nesting, local variable allocation, and saving its last execution context.</span></span>

<span data-ttu-id="13920-352">최소 스택 크기 **TX_MINIMUM_STACK** 은 ThreadX에 의해 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-352">The minimum stack size, **TX_MINIMUM_STACK**, is defined by ThreadX.</span></span> <span data-ttu-id="13920-353">이 크기의 스택은 스레드의 컨텍스트 저장 및 최소한의 함수 호출 그리고 로컬 변수 할당을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-353">A stack of this size supports saving a thread's context and minimum amount of function calls and local variable allocation.</span></span>

<span data-ttu-id="13920-354">하지만 대부분의 스레드는 최소 스택 크기가 너무 작기 때문에 사용자가 함수 호출 중첩 및 로컬 변수 할당을 검사하여 최악의 경우 크기 요구 사항을 확인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-354">For most threads, however, the minimum stack size is too small, and the user must ascertain the worst-case size requirement by examining function-call nesting and local variable allocation.</span></span> <span data-ttu-id="13920-355">물론, 시작하는 스택 영역이 클수록 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-355">Of course, it is always better to start with a larger stack area.</span></span>

<span data-ttu-id="13920-356">애플리케이션을 디버깅한 후 메모리가 부족하면 스레드 스택 크기를 조정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-356">After the application is debugged, it is possible to tune the thread stack sizes if memory is scarce.</span></span> <span data-ttu-id="13920-357">자주 사용하는 트릭은 스레드를 만들기 전에 쉽게 식별할 수 있는 (0xEFEF)와 같은 데이터 패턴으로 모든 스택 영역을 미리 설정하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-357">A favorite trick is to preset all stack areas with an easily identifiable data pattern like (0xEFEF) prior to creating the threads.</span></span> <span data-ttu-id="13920-358">애플리케이션이 얼마나 잘 작동하는지 철저히 시험해 본 후 스택 영역을 검사하여 데이터 패턴이 아직 온전한 스택 영역을 찾아서 실제로 얼마나 많은 스택이 사용되었는지 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-358">After the application has been thoroughly put through its paces, the stack areas can be examined to see how much stack was actually used by finding the area of the stack where the data pattern is still intact.</span></span> <span data-ttu-id="13920-359">그림 7은 철저한 스레드 실행 후 0xEFEF로 사전 설정된 스택을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="13920-359">Figure 7 shows a stack preset to 0xEFEF after thorough thread execution.</span></span>

<span data-ttu-id="13920-360">**스택 메모리 영역**(다른 예)</span><span class="sxs-lookup"><span data-stu-id="13920-360">**Stack Memory Area** (another example)</span></span>

![0xEFEF로 스택 사전 설정\*](./media/user-guide/stack-preset.png)

<span data-ttu-id="13920-362">**그림 7. 0xEFEF로 스택 사전 설정**</span><span class="sxs-lookup"><span data-stu-id="13920-362">**FIGURE 7. Stack Preset to 0xEFEF**</span></span>

> [!IMPORTANT]
> <span data-ttu-id="13920-363">*기본적으로 ThreadX는 각 스레드 스택의 모든 바이트를 0xEF 값으로 초기화합니다.*</span><span class="sxs-lookup"><span data-stu-id="13920-363">*By default, ThreadX initializes every byte of each thread stack with a value of 0xEF.*</span></span>

### <a name="memory-pitfalls"></a><span data-ttu-id="13920-364">메모리 관련 문제</span><span class="sxs-lookup"><span data-stu-id="13920-364">Memory Pitfalls</span></span>

<span data-ttu-id="13920-365">스레드에 대한 스택 요구 사항은 클 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-365">The stack requirements for threads can be large.</span></span> <span data-ttu-id="13920-366">따라서, 애플리케이션이 적절한 수의 스레드를 갖도록 디자인하는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-366">Therefore, it is important to design the application to have a reasonable number of threads.</span></span> <span data-ttu-id="13920-367">또한 스레드 내에서 과도한 스택 사용을 방지하기 위해 약간의 주의를 기울여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-367">Furthermore, some care must be taken to avoid excessive stack usage within threads.</span></span> <span data-ttu-id="13920-368">재귀 알고리즘과 대규모 로컬 데이터 구조는 피해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-368">Recursive algorithms and large local data structures should be avoided.</span></span>

<span data-ttu-id="13920-369">대부분의 경우 스택이 오버플로되면 스레드 실행으로 인해 스택 영역에 인접한(일반적으로 이전) 메모리가 손상됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-369">In most cases, an overflowed stack causes thread execution to corrupt memory adjacent (usually before) its stack area.</span></span> <span data-ttu-id="13920-370">결과는 예측할 수 없지만 대부분의 경우 프로그램 카운터가 부자연스럽게 변경됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-370">The results are unpredictable, but most often result in an unnatural change in the program counter.</span></span> <span data-ttu-id="13920-371">이를 흔히 "잡초에 뛰어들기(jumping into the weeds)"라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-371">This is often called "jumping into the weeds."</span></span> <span data-ttu-id="13920-372">물론 이것을 방지하는 유일한 방법은 모든 스레드 스택이 충분히 큰지 확인하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-372">Of course, the only way to prevent this is to ensure all thread stacks are large enough.</span></span>

### <a name="optional-run-time-stack-checking"></a><span data-ttu-id="13920-373">선택적 런타임 스택 검사</span><span class="sxs-lookup"><span data-stu-id="13920-373">Optional Run-time Stack Checking</span></span>

<span data-ttu-id="13920-374">ThreadX는 런타임 중에 각 스레드의 스택이 손상되었는지 확인하는 기능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-374">ThreadX provides the ability to check each thread's stack for corruption during run-time.</span></span> <span data-ttu-id="13920-375">기본적으로 ThreadX는 생성하는 동안 스레드 스택의 모든 바이트를 0xEF 데이터 패턴으로 채웁니다.</span><span class="sxs-lookup"><span data-stu-id="13920-375">By default, ThreadX fills every byte of thread stacks with a 0xEF data pattern during creation.</span></span> <span data-ttu-id="13920-376">애플리케이션이 **TX_ENABLE_STACK_CHECKING** 이 정의된 ThreadX 라이브러리를 빌드하는 경우 ThreadX는 일시 중단되거나 재개될 때 각 스레드의 스택이 손상되었는지 검사합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-376">If the application builds the ThreadX library with **TX_ENABLE_STACK_CHECKING** defined, ThreadX will examine each thread's stack for corruption as it is suspended or resumed.</span></span> <span data-ttu-id="13920-377">스택 손상이 감지되면 **_tx_thread_stack_error_notify_ *_ 호출에 지정된 대로 애플리케이션의 스택 오류 처리 루틴을 호출합니다. 스택 오류 처리기가 지정되지 않은 경우 ThreadX는 내부 _* _ _tx_thread_stack_error_handler_** 루틴을 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-377">If stack corruption is detected, ThreadX will call the application's stack error handling routine as specified by the call to **_tx_thread_stack_error_notify_*_. Otherwise, if no stack error handler was specified, ThreadX will call the internal _\* _ _tx_thread_stack_error_handler_*\* routine.</span></span>

### <a name="reentrancy"></a><span data-ttu-id="13920-378">다시 표시</span><span class="sxs-lookup"><span data-stu-id="13920-378">Reentrancy</span></span>

<span data-ttu-id="13920-379">다중 스레딩의 정말 좋은 점 중 하나는 동일한 C 함수를 여러 스레드에서 호출할 수 있다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-379">One of the real beauties of multithreading is that the same C function can be called from multiple threads.</span></span> <span data-ttu-id="13920-380">이를 통해 강력한 성능을 제공하고 코드 공간을 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-380">This provides great power and also helps reduce code space.</span></span> <span data-ttu-id="13920-381">하지만 다중 스레드에서 호출된 C 함수가 재진입(*reentrant*) 함수여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-381">However, it does require that C functions called from multiple threads are *reentrant*.</span></span>

<span data-ttu-id="13920-382">기본적으로 재진입 함수는 호출자의 반환 주소를 현재 스택에 저장하고 이전에 설정한 전역 또는 정적 C 변수에 의존하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-382">Basically, a reentrant function stores the caller's return address on the current stack and does not rely on global or static C variables that it previously set up.</span></span> <span data-ttu-id="13920-383">대부분의 컴파일러는 스택에 반환 주소를 배치합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-383">Most compilers place the return address on the stack.</span></span> <span data-ttu-id="13920-384">따라서 애플리케이션 개발자는 전역(*globals*) 및 정적(*statics*) 사용에 대해서만 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-384">Hence, application developers must only worry about the use of *globals* and *statics*.</span></span>

<span data-ttu-id="13920-385">재진입이 아닌 함수의 예는 표준 C 라이브러리에 있는 문자열 토큰 함수 ***strtok*** 입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-385">An example of a non-reentrant function is the string token function ***strtok*** found in the standard C library.</span></span> <span data-ttu-id="13920-386">이 함수는 후속 호출에서 이전 문자열 포인터를 "기억"합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-386">This function "remembers" the previous string pointer on subsequent calls.</span></span> <span data-ttu-id="13920-387">이 작업은 정적 문자열 포인터를 사용하여 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-387">It does this with a static string pointer.</span></span> <span data-ttu-id="13920-388">이 함수를 여러 스레드에서 호출하면 잘못된 포인터를 반환할 가능성이 높습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-388">If this function is called from multiple threads, it would most likely return an invalid pointer.</span></span>

### <a name="thread-priority-pitfalls"></a><span data-ttu-id="13920-389">스레드 우선 순위 관련 문제</span><span class="sxs-lookup"><span data-stu-id="13920-389">Thread Priority Pitfalls</span></span>

<span data-ttu-id="13920-390">스레드 우선 순위 선택은 다중 스레딩의 가장 중요한 측면 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-390">Selecting thread priorities is one of the most important aspects of multithreading.</span></span> <span data-ttu-id="13920-391">런타임에 정확히 무엇이 필요한지 결정하기 보다는 스레드 중요도에 대해 인식된 개념을 기반으로 우선 순위를 할당하려고 하는 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-391">It is sometimes very tempting to assign priorities based on a perceived notion of thread importance rather than determining what is exactly required during run-time.</span></span> <span data-ttu-id="13920-392">스레드 우선 순위를 잘못 사용하면 다른 스레드가 고갈되고 우선 순위 반전이 생성되며 처리 대역폭이 줄어들고 애플리케이션의 런타임 동작을 이해하기 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-392">Misuse of thread priorities can starve other threads, create priority inversion, reduce processing bandwidth, and make the application's run-time behavior difficult to understand.</span></span>

<span data-ttu-id="13920-393">앞서 언급했듯이 ThreadX는 우선 순위에 기반한 선점형 예약 알고리즘을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-393">As mentioned before, ThreadX provides a priority-based, preemptive scheduling algorithm.</span></span> <span data-ttu-id="13920-394">우선 순위가 낮은 스레드는 실행할 준비가 된 우선 순위가 더 높은 스레드가 없을 때까지 실행되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-394">Lower priority threads do not execute until there are no higher priority threads ready for execution.</span></span> <span data-ttu-id="13920-395">우선 순위가 더 높은 스레드가 항상 준비되어 있으면 우선 순위가 낮은 스레드는 실행되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-395">If a higher priority thread is always ready, the lower priority threads never execute.</span></span> <span data-ttu-id="13920-396">이러한 상황을 스레드 고갈(*thread starvation*)이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-396">This condition is called *thread starvation*.</span></span>

<span data-ttu-id="13920-397">대부분의 스레드 고갈 문제는 디버그 초기에 감지되며 우선 순위가 더 높은 스레드가 지속적으로 실행되지 않도록 하여 문제를 해결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-397">Most thread starvation problems are detected early in debug and can be solved by ensuring that higher priority threads don't execute continuously.</span></span> <span data-ttu-id="13920-398">또는 고갈된 스레드가 실행 기회를 얻을 때까지 우선 순위를 점진적으로 올리는 논리를 애플리케이션에 추가할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-398">Alternatively, logic can be added to the application that gradually raises the priority of starved threads until they get a chance to execute.</span></span>

<span data-ttu-id="13920-399">스레드 우선 순위와 관련된 또 다른 문제는 우선 순위 반전(*priority inversion*)입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-399">Another pitfall associated with thread priorities is *priority inversion*.</span></span> <span data-ttu-id="13920-400">우선 순위 반전은 우선 순위가 낮은 스레드에 필요한 리소스가 있기 때문에 우선 순위가 높은 스레드가 일시 중단되는 경우 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-400">Priority inversion takes place when a higher priority thread is suspended because a lower priority thread has a needed resource.</span></span> <span data-ttu-id="13920-401">물론, 우선 순위가 서로 다른 두 스레드가 공용 리소스를 공유해야 하는 경우도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-401">Of course, in some instances it is necessary for two threads of different priority to share a common resource.</span></span> <span data-ttu-id="13920-402">이 스레드가 유일한 활성 스레드인 경우 우선 순위가 낮은 스레드가 리소스를 보유하는 시간에 의해 우선 순위 반전 시간이 제한됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-402">If these threads are the only ones active, the priority inversion time is bounded by the time the lower priority thread holds the resource.</span></span> <span data-ttu-id="13920-403">이 조건은 결정적이며 매우 정상적입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-403">This condition is both deterministic and quite normal.</span></span> <span data-ttu-id="13920-404">하지만 이 우선 순위 반전 조건 중에 중간 우선 순위의 스레드가 활성 상태가 되면 우선 순위 반전 시간은 더 이상 결정적이지 않고 애플리케이션 오류를 유발할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-404">However, if threads of intermediate priority become active during this priority inversion condition, the priority inversion time is no longer deterministic and could cause an application failure.</span></span>

<span data-ttu-id="13920-405">ThreadX에서 비결정적 우선 순위 반전을 방지하는 세 가지 다른 메서드가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-405">There are principally three distinct methods of preventing nondeterministic priority inversion in ThreadX.</span></span> <span data-ttu-id="13920-406">첫째, 애플리케이션 우선 순위 선택 및 런타임 동작을 우선 순위 반전 문제를 방지하는 방식으로 설계할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-406">First, the application priority selections and run-time behavior can be designed in a manner that prevents the priority inversion problem.</span></span> <span data-ttu-id="13920-407">둘째, 우선 순위가 낮은 스레드는 *선점 임계값* 을 활용하여 우선 순위가 더 높은 스레드와 리소스를 공유하는 동안 중간 스레드의 선점을 차단할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-407">Second, lower priority threads can utilize *preemption threshold* to block preemption from intermediate threads while they share resources with higher priority threads.</span></span> <span data-ttu-id="13920-408">마지막으로 ThreadX 뮤텍스 개체를 사용하여 시스템 리소스를 보호하는 스레드는 선택적 뮤텍스 *우선 순위 상속* 을 활용하여 비결정적 우선 순위 반전을 제거할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-408">Finally, threads using ThreadX mutex objects to protect system resources may utilize the optional mutex *priority inheritance* to eliminate nondeterministic priority inversion.</span></span>

### <a name="priority-overhead"></a><span data-ttu-id="13920-409">우선 순위 오버 헤드</span><span class="sxs-lookup"><span data-stu-id="13920-409">Priority Overhead</span></span>

<span data-ttu-id="13920-410">다중 스레딩에서 오버헤드를 줄이는 데 가장 간과되는 방법 중 하나는 컨텍스트 전환 수를 줄이는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-410">One of the most overlooked ways to reduce overhead in multithreading is to reduce the number of context switches.</span></span> <span data-ttu-id="13920-411">앞서 언급했듯이 컨텍스트 전환은 실행 중인 스레드보다 우선 순위가 더 높은 스레드 실행을 선호하는 경우에 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-411">As previously mentioned, a context switch occurs when execution of a higher priority thread is favored over that of the executing thread.</span></span> <span data-ttu-id="13920-412">우선 순위가 더 높은 스레드는 외부 이벤트(예: 인터럽트) 및 실행 중인 스레드가 만든 서비스 호출의 결과로 준비될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-412">It is worthwhile to mention that higher priority threads can become ready as a result of both external events (like interrupts) and from service calls made by the executing thread.</span></span>

<span data-ttu-id="13920-413">스레드 우선 순위가 컨텍스트 전환 오버헤드에 미치는 영향을 설명하기 위해 *thread_1*, *thread_2*, *thread_3* 이라는 스레드로 3개 스레드 환경을 가정하겠습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-413">To illustrate the effects thread priorities have on context switch overhead, assume a three thread environment with threads named *thread_1*, *thread_2*, and *thread_3*.</span></span> <span data-ttu-id="13920-414">모든 스레드가 메시지를 기다리는 일시 중단 상태에 있다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-414">Assume further that all of the threads are in a state of suspension waiting for a message.</span></span> <span data-ttu-id="13920-415">thread_1이 메시지를 받으면 thread_2에 즉시 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-415">When thread_1 receives a message, it immediately forwards it to thread_2.</span></span> <span data-ttu-id="13920-416">그러면 thread_2는 thread_3에 메시지를 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-416">Thread_2 then forwards the message to thread_3.</span></span> <span data-ttu-id="13920-417">thread_3은 메시지를 버립니다.</span><span class="sxs-lookup"><span data-stu-id="13920-417">Thread_3 just discards the message.</span></span> <span data-ttu-id="13920-418">각 스레드는 메시지를 처리한 후 돌아가서 또 다른 메시지를 기다립니다.</span><span class="sxs-lookup"><span data-stu-id="13920-418">After each thread processes its message, it goes back and waits for another message.</span></span>

<span data-ttu-id="13920-419">3개 스레드를 실행하는 데 필요한 처리는 우선 순위에 따라 크게 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="13920-419">The processing required to execute these three threads varies greatly depending on their priorities.</span></span> <span data-ttu-id="13920-420">모든 스레드의 우선 순위가 동일하면 각 스레드를 실행하기 전에 단일 컨텍스트 전환이 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-420">If all of the threads have the same priority, a single context switch occurs before the execution of each thread.</span></span> <span data-ttu-id="13920-421">컨텍스트 전환은 각 스레드가 빈 메시지 큐에서 일시 중단될 때 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-421">The context switch occurs when each thread suspends on an empty message queue.</span></span>

<span data-ttu-id="13920-422">하지만 thread_2가 thread_1보다 우선 순위가 높고 thread_3이 thread_2보다 우선 순위가 높으면 컨텍스트 전환 수는 두 배가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-422">However, if thread_2 is higher priority than thread_1 and thread_3 is higher priority than thread_2, the number of context switches doubles.</span></span> <span data-ttu-id="13920-423">우선 순위가 더 높은 스레드가 준비된 것을 감지하면 *tx_queue_send* 서비스 내부에서 다른 컨텍스트 전환이 발생하기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-423">This is because another context switch occurs inside of the *tx_queue_send* service when it detects that a higher priority thread is now ready.</span></span>

<span data-ttu-id="13920-424">ThreadX 선점 임계값 메커니즘은 이러한 추가 컨텍스트 전환을 방지하면서 앞서 언급한 우선 순위 선택을 허용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-424">The ThreadX preemption-threshold mechanism can avoid these extra context switches and still allow the previously mentioned priority selections.</span></span> <span data-ttu-id="13920-425">이 기능을 사용하면 예약 중에 여러 스레드 우선 순위가 허용되는 동시에 스레드 실행 중에 원치 않는 컨텍스트 전환을 제거할 수 있기 때문에 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-425">This is an important feature because it allows several thread priorities during scheduling, while at the same time eliminating some of the unwanted context switching between them during thread execution.</span></span>

### <a name="run-time-thread-performance-information"></a><span data-ttu-id="13920-426">런타임 스레드 성능 정보</span><span class="sxs-lookup"><span data-stu-id="13920-426">Run-time Thread Performance Information</span></span>

<span data-ttu-id="13920-427">ThreadX는 선택적 런타임 스레드 성능 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-427">ThreadX provides optional run-time thread performance information.</span></span> <span data-ttu-id="13920-428">ThreadX 라이브러리 및 애플리케이션이 **TX_THREAD_ENABLE_PERFORMANCE_INFO** 가 정의된 상태로 빌드되면 ThreadX는 다음 정보를 누적합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-428">If the ThreadX library and application is built with **TX_THREAD_ENABLE_PERFORMANCE_INFO** defined, ThreadX accumulates the following information.</span></span>

<span data-ttu-id="13920-429">전체 시스템의 다음에 대한 총 수:</span><span class="sxs-lookup"><span data-stu-id="13920-429">Total number for the overall system:</span></span>

  - <span data-ttu-id="13920-430">스레드 재개</span><span class="sxs-lookup"><span data-stu-id="13920-430">thread resumptions</span></span>

  - <span data-ttu-id="13920-431">스레드 일시 중단</span><span class="sxs-lookup"><span data-stu-id="13920-431">thread suspensions</span></span>

  - <span data-ttu-id="13920-432">서비스 호출 선점</span><span class="sxs-lookup"><span data-stu-id="13920-432">service call preemptions</span></span>

  - <span data-ttu-id="13920-433">인터럽트 선점</span><span class="sxs-lookup"><span data-stu-id="13920-433">interrupt preemptions</span></span>

  - <span data-ttu-id="13920-434">우선 순위 반전</span><span class="sxs-lookup"><span data-stu-id="13920-434">priority inversions</span></span>

  - <span data-ttu-id="13920-435">시간 조각</span><span class="sxs-lookup"><span data-stu-id="13920-435">time-slices</span></span>

  - <span data-ttu-id="13920-436">포기</span><span class="sxs-lookup"><span data-stu-id="13920-436">relinquishes</span></span>

  - <span data-ttu-id="13920-437">스레드 시간 제한</span><span class="sxs-lookup"><span data-stu-id="13920-437">thread timeouts</span></span>

  - <span data-ttu-id="13920-438">일시 중단을 중단</span><span class="sxs-lookup"><span data-stu-id="13920-438">suspension aborts</span></span>

  - <span data-ttu-id="13920-439">유휴 시스템 반환</span><span class="sxs-lookup"><span data-stu-id="13920-439">idle system returns</span></span>

  - <span data-ttu-id="13920-440">비유휴 시스템 반환</span><span class="sxs-lookup"><span data-stu-id="13920-440">non-idle system returns</span></span>

<span data-ttu-id="13920-441">각 스레드의 총 수:</span><span class="sxs-lookup"><span data-stu-id="13920-441">Total number for each thread:</span></span>

  - <span data-ttu-id="13920-442">재개</span><span class="sxs-lookup"><span data-stu-id="13920-442">resumptions</span></span>

  - <span data-ttu-id="13920-443">일시 중단</span><span class="sxs-lookup"><span data-stu-id="13920-443">suspensions</span></span>

  - <span data-ttu-id="13920-444">서비스 호출 선점</span><span class="sxs-lookup"><span data-stu-id="13920-444">service call preemptions</span></span>

  - <span data-ttu-id="13920-445">인터럽트 선점</span><span class="sxs-lookup"><span data-stu-id="13920-445">interrupt preemptions</span></span>

  - <span data-ttu-id="13920-446">우선 순위 반전</span><span class="sxs-lookup"><span data-stu-id="13920-446">priority inversions</span></span>

  - <span data-ttu-id="13920-447">시간 조각</span><span class="sxs-lookup"><span data-stu-id="13920-447">time-slices</span></span>

  - <span data-ttu-id="13920-448">스레드 포기</span><span class="sxs-lookup"><span data-stu-id="13920-448">thread relinquishes</span></span>

  - <span data-ttu-id="13920-449">스레드 시간 제한</span><span class="sxs-lookup"><span data-stu-id="13920-449">thread timeouts</span></span>

  - <span data-ttu-id="13920-450">일시 중단을 중단</span><span class="sxs-lookup"><span data-stu-id="13920-450">suspension aborts</span></span>

<span data-ttu-id="13920-451">이 정보는 ***tx_thread_performance_info_get** _ 및 _*_tx_thread_performance_system_info_get_\*\* 서비스를 통해 런타임에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-451">This information is available at run-time through the services ***tx_thread_performance_info_get** _ and _*_tx_thread_performance_system_info_get_\*\*.</span></span> <span data-ttu-id="13920-452">스레드 성능 정보는 애플리케이션이 제대로 작동하는지 확인하는 데 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-452">Thread performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="13920-453">애플리케이션을 최적화하는데도 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-453">It is also useful in optimizing the application.</span></span> <span data-ttu-id="13920-454">예를 들어 서비스 호출 선점의 수가 상대적으로 높으면 스레드의 우선 순위 및/또는 선점 임계값이 너무 낮다는 표시일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-454">For example, a relatively high number of service call preemptions might suggest the thread's priority and/or preemption-threshold is too low.</span></span> <span data-ttu-id="13920-455">또한 유휴 시스템 반환 수가 상대적으로 적으면 우선 순위가 낮은 스레드가 충분히 일시 중단되지 않음을 의미할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-455">Furthermore, a relatively low number of idle system returns might suggest that lower priority threads are not suspending enough.</span></span>

### <a name="debugging-pitfalls"></a><span data-ttu-id="13920-456">디버깅 관련 문제</span><span class="sxs-lookup"><span data-stu-id="13920-456">Debugging Pitfalls</span></span>

<span data-ttu-id="13920-457">다중 스레드 애플리케이션을 디버깅하는 것은 동일한 프로그램 코드가 여러 스레드에서 실행될 수 있기 때문에 더 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-457">Debugging multithreaded applications is a little more difficult because the same program code can be executed from multiple threads.</span></span> <span data-ttu-id="13920-458">이러한 경우 중단점만으로는 부족할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-458">In such cases, a break-point alone may not be enough.</span></span> <span data-ttu-id="13920-459">디버거는 조건부 중단점을 사용하여 현재 스레드 포인터 **_tx_thread_current_ptr** 도 살펴보고 호출 스레드가 디버깅할 스레드가 맞는지 확인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-459">The debugger must also view the current thread pointer **_tx_thread_current_ptr** using a conditional breakpoint to see if the calling thread is the one to debug.</span></span>

<span data-ttu-id="13920-460">이 중 대부분은 다양한 개발 도구 공급업체를 통해 제공되는 다중 스레딩 지원 패키지에서 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-460">Much of this is being handled in multithreading support packages offered through various development tool vendors.</span></span> <span data-ttu-id="13920-461">디자인이 단순하기 때문에 ThreadX를 다른 개발 도구와 통합하는 것이 비교적 쉽습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-461">Because of its simple design, integrating ThreadX with different development tools is relatively easy.</span></span>

<span data-ttu-id="13920-462">스택 크기는 다중 스레딩에서 항상 중요한 디버그 항목입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-462">Stack size is always an important debug topic in multithreading.</span></span> <span data-ttu-id="13920-463">설명할 수 없는 동작이 보일 때마다 모든 스레드의 스택 크기(특히 마지막으로 실행할 스레드의 스택 크기)를 늘리는 것이 좋습니다!</span><span class="sxs-lookup"><span data-stu-id="13920-463">Whenever unexplained behavior is observed, it is usually a good first guess to increase stack sizes for all threads—especially the stack size of the last thread to execute!</span></span>

> [!TIP]
> <span data-ttu-id="13920-464">***TX_ENABLE_STACK_CHECKING** 으로 정의된 threadx 라이브러리를 빌드하는 것도 좋은 방법입니다. 이를 통해 가능한 한 처리 초기에 스택 손상 문제를 격리할 수 있습니다.*</span><span class="sxs-lookup"><span data-stu-id="13920-464">*It is also a good idea to build the ThreadX library with **TX_ENABLE_STACK_CHECKING** defined. This will help isolate stack corruption problems as early in the processing as possible.*</span></span>

## <a name="message-queues"></a><span data-ttu-id="13920-465">메시지 큐</span><span class="sxs-lookup"><span data-stu-id="13920-465">Message Queues</span></span>

<span data-ttu-id="13920-466">메시지 큐는 ThreadX에서 스레드 간 통신의 기본 수단입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-466">Message queues are the primary means of inter-thread communication in ThreadX.</span></span> <span data-ttu-id="13920-467">메시지 큐에는 하나 이상의 메시지가 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-467">One or more messages can reside in a message queue.</span></span> <span data-ttu-id="13920-468">단일 메시지를 보유하는 메시지 큐를 일반적으로 사서함(*mailbox*)이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-468">A message queue that holds a single message is commonly called a *mailbox*.</span></span>

<span data-ttu-id="13920-469">메시지는 ***tx_queue_send** _에 의해 큐로 복사되고 _*_tx_queue_receive_\*\*에 의해 큐에서 복사됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-469">Messages are copied to a queue by ***tx_queue_send** _ and are copied from a queue by _*_tx_queue_receive_\*\*.</span></span> <span data-ttu-id="13920-470">이에 대한 유일한 예외는 빈 큐에서 메시지를 기다리는 동안 스레드가 일시 중단되는 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-470">The only exception to this is when a thread is suspended while waiting for a message on an empty queue.</span></span> <span data-ttu-id="13920-471">이 경우 큐에 전송된 다음 메시지는 스레드의 대상 영역에 직접 배치됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-471">In this case, the next message sent to the queue is placed directly into the thread's destination area.</span></span>

<span data-ttu-id="13920-472">각 메시지 큐는 공용 리소스입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-472">Each message queue is a public resource.</span></span> <span data-ttu-id="13920-473">ThreadX는 메시지 큐가 사용되는 방식에 제약 조건을 두지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-473">ThreadX places no constraints on how message queues are used.</span></span>

### <a name="creating-message-queues"></a><span data-ttu-id="13920-474">메시지 큐 만들기</span><span class="sxs-lookup"><span data-stu-id="13920-474">Creating Message Queues</span></span>

<span data-ttu-id="13920-475">메시지 큐는 초기화 중에 또는 애플리케이션 스레드에서 런타임 중에 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-475">Message queues are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="13920-476">애플리케이션의 메시지 큐 수에는 제한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-476">There is no limit on the number of message queues in an application.</span></span>

### <a name="message-size"></a><span data-ttu-id="13920-477">메시지 크기</span><span class="sxs-lookup"><span data-stu-id="13920-477">Message Size</span></span>

<span data-ttu-id="13920-478">각 메시지 큐는 여러 가지 고정 크기 메시지를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-478">Each message queue supports a number of fixed-sized messages.</span></span> <span data-ttu-id="13920-479">사용 가능한 메시지 크기는 32비트 1~16단어입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-479">The available message sizes are 1 through 16 32-bit words inclusive.</span></span> <span data-ttu-id="13920-480">메시지 크기는 큐를 만들 때 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-480">The message size is specified when the queue is created.</span></span> <span data-ttu-id="13920-481">16단어 보다 큰 애플리케이션 메시지는 포인터로 전달되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-481">Application messages greater than 16 words must be passed by pointer.</span></span> <span data-ttu-id="13920-482">이 작업은 메시지 크기가 1단어(포인터를 보유하기에 충분함)인 큐를 만든 다음, 전체 메시지 대신 메시지 포인터를 보내고 받는 방식으로 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-482">This is accomplished by creating a queue with a message size of 1 word (enough to hold a pointer) and then sending and receiving message pointers instead of the entire message.</span></span>

### <a name="message-queue-capacity"></a><span data-ttu-id="13920-483">메시지 큐 용량</span><span class="sxs-lookup"><span data-stu-id="13920-483">Message Queue Capacity</span></span>

<span data-ttu-id="13920-484">큐가 보유할 수 있는 메시지 수는 메시지 크기 및 생성 중에 제공된 메모리 영역의 크기의 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-484">The number of messages a queue can hold is a function of its message size and the size of the memory area supplied during creation.</span></span> <span data-ttu-id="13920-485">큐의 총 메시지 용량은 각 메시지의 바이트 수를 제공된 메모리 영역의 총 바이트 수로 나누어 계산합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-485">The total message capacity of the queue is calculated by dividing the number of bytes in each message into the total number of bytes in the supplied memory area.</span></span>

<span data-ttu-id="13920-486">예를 들어, 메시지 크기로 32비트 1단어(4바이트)를 지원하는 메시지 큐가 100바이트 메모리 영역으로 생성되는 경우 용량은 25개 메시지입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-486">For example, if a message queue that supports a message size of 1 32-bit word (4 bytes) is created with a 100-byte memory area, its capacity is 25 messages.</span></span>

### <a name="queue-memory-area"></a><span data-ttu-id="13920-487">큐 메모리 영역</span><span class="sxs-lookup"><span data-stu-id="13920-487">Queue Memory Area</span></span>

<span data-ttu-id="13920-488">앞서 언급했듯이 메시지 버퍼링을 위한 메모리 영역은 큐를 만드는 동안 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-488">As mentioned previously, the memory area for buffering messages is specified during queue creation.</span></span> <span data-ttu-id="13920-489">ThreadX의 다른 메모리 영역과 마찬가지로 대상 주소 공간의 어디에나 위치할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-489">Like other memory areas in ThreadX, it can be located anywhere in the target's address space.</span></span>

<span data-ttu-id="13920-490">애플리케이션에 상당한 유연성을 제공하기 때문에 중요한 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-490">This is an important feature because it gives the application considerable flexibility.</span></span> <span data-ttu-id="13920-491">예를 들어 애플리케이션은 성능 향상을 위해 중요한 큐의 메모리 영역을 고속 RAM에 배치할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-491">For example, an application might locate the memory area of an important queue in high-speed RAM to improve performance.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="13920-492">스레드 일시 중단</span><span class="sxs-lookup"><span data-stu-id="13920-492">Thread Suspension</span></span>

<span data-ttu-id="13920-493">애플리케이션 스레드는 큐에서 메시지를 받거나 보내는 동안 일시 중단될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-493">Application threads can suspend while attempting to send or receive a message from a queue.</span></span> <span data-ttu-id="13920-494">일반적으로 스레드 일시 중단에는 빈 큐에서 메시지를 기다리는 작업이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-494">Typically, thread suspension involves waiting for a message from an empty queue.</span></span> <span data-ttu-id="13920-495">하지만 꽉 찬 큐에 메시지를 보내려는 시도를 스레드가 일시 중단하는 것도 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-495">However, it is also possible for a thread to suspend trying to send a message to a full queue.</span></span>

<span data-ttu-id="13920-496">일시 중단 조건이 확인되면 요청된 서비스가 완료되고 대기 중인 스레드가 재개됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-496">After the condition for suspension is resolved, the service requested is completed and the waiting thread is resumed.</span></span> <span data-ttu-id="13920-497">여러 스레드가 동일한 큐에서 일시 중단되면 일시 중단된 순서대로(FIFO) 재개됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-497">If multiple threads are suspended on the same queue, they are resumed in the order they were suspended (FIFO).</span></span>

<span data-ttu-id="13920-498">하지만 스레드 일시 중단을 해제하는 큐 서비스 이전에 애플리케이션이 ***tx_queue_prioritize*** 를 호출하는 경우에도 우선 순위 재개가 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-498">However, priority resumption is also possible if the application calls ***tx_queue_prioritize*** prior to the queue service that lifts thread suspension.</span></span> <span data-ttu-id="13920-499">큐 우선 순위 지정 서비스는 우선 순위가 가장 높은 스레드를 일시 중단 목록의 맨 앞에 배치하고 다른 모든 일시 중단된 스레드는 동일한 FIFO 순서를 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-499">The queue prioritize service places the highest priority thread at the front of the suspension list, while leaving all other suspended threads in the same FIFO order.</span></span>

<span data-ttu-id="13920-500">시간 제한은 모든 큐 일시 중단에도 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-500">Time-outs are also available for all queue suspensions.</span></span> <span data-ttu-id="13920-501">기본적으로 시간 제한은 스레드가 일시 중단된 상태로 유지되는 최대 타이머 틱 수를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-501">Basically, a time-out specifies the maximum number of timer ticks the thread will stay suspended.</span></span> <span data-ttu-id="13920-502">시간 제한이 발생하면 스레드가 재개되고 서비스가 적절한 오류 코드와 함께 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-502">If a time-out occurs, the thread is resumed and the service returns with the appropriate error code.</span></span>

### <a name="queue-send-notification"></a><span data-ttu-id="13920-503">큐 알림 보내기</span><span class="sxs-lookup"><span data-stu-id="13920-503">Queue Send Notification</span></span>

<span data-ttu-id="13920-504">일부 애플리케이션은 메시지가 큐에 배치될 때마다 알림을 받는 것이 유리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-504">Some applications may find it advantageous to be notified whenever a message is placed on a queue.</span></span> <span data-ttu-id="13920-505">ThreadX는 ***tx_queue_send_notify*** 서비스를 통해 이 기능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-505">ThreadX provides this ability through the ***tx_queue_send_notify*** service.</span></span> <span data-ttu-id="13920-506">이 서비스는 제공된 애플리케이션 알림 함수를 지정된 큐에 등록합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-506">This service registers the supplied application notification function with the specified queue.</span></span> <span data-ttu-id="13920-507">ThreadX는 메시지를 큐에 보낼 때마다 이 애플리케이션 알림 함수를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-507">ThreadX will subsequently invoke this application notification function whenever a message is sent to the queue.</span></span> <span data-ttu-id="13920-508">애플리케이션 알림 함수 내에서 정확한 처리는 애플리케이션에 의해 결정됩니다. 하지만 일반적으로 새 메시지를 처리하기 위한 적절한 스레드를 재개하는 것으로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-508">The exact processing within the application notification function is determined by the application; however, it typically consists of resuming the appropriate thread for processing the new message.</span></span>

### <a name="queue-event-chainingtrade"></a><span data-ttu-id="13920-509">Queue Event chaining&trade;</span><span class="sxs-lookup"><span data-stu-id="13920-509">Queue Event chaining&trade;</span></span>

<span data-ttu-id="13920-510">ThreadX의 알림 기능을 사용하여 다양한 동기화 이벤트를 함께 연결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-510">The notification capabilities in ThreadX can be used to chain various synchronization events together.</span></span> <span data-ttu-id="13920-511">일반적으로 단일 스레드가 여러 동기화 이벤트를 처리해야 하는 경우에 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-511">This is typically useful when a single thread must process multiple synchronization events.</span></span>

<span data-ttu-id="13920-512">예를 들어, 단일 스레드가 5개의 서로 다른 큐에서 메시지 처리를 담당하고 사용 가능한 메시지가 없을 때도 일시 중지해야 한다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-512">For example, suppose a single thread is responsible for processing messages from five different queues and must also suspend when no messages are available.</span></span> <span data-ttu-id="13920-513">이 작업은 각 큐에 대한 애플리케이션 알림 함수를 등록하고 추가 카운팅 세마포를 도입하여 쉽게 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-513">This is easily accomplished by registering an application notification function for each queue and introducing an additional counting semaphore.</span></span> <span data-ttu-id="13920-514">특히, 애플리케이션 알림 함수는 호출될 때마다 *tx_semaphore_put* 을 수행합니다. (세마포 수는 5개 큐 모두의 총 메시지 수를 나타냅니다.)</span><span class="sxs-lookup"><span data-stu-id="13920-514">Specifically, the application notification function performs a *tx_semaphore_put* whenever it is called (the semaphore count represents the total number of messages in all five queues).</span></span> <span data-ttu-id="13920-515">처리 스레드는 *tx_semaphore_get* 서비스를 통해 이 세마포에서 일시 중단됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-515">The processing thread suspends on this semaphore via the *tx_semaphore_get* service.</span></span> <span data-ttu-id="13920-516">세마포를 사용할 수 있으면(여기서는 메시지를 사용할 수 있는 경우) 처리 스레드가 재개됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-516">When the semaphore is available (in this case, when a message is available!), the processing thread is resumed.</span></span> <span data-ttu-id="13920-517">그런 다음, 각 큐에 메시지가 있는지 조사하여, 발견된 메시지를 처리하고, 또 다른 ***tx_semaphore_get*** 을 수행하여 다음 메시지를 기다립니다.</span><span class="sxs-lookup"><span data-stu-id="13920-517">It then interrogates each queue for a message, processes the found message, and performs another ***tx_semaphore_get*** to wait for the next message.</span></span> <span data-ttu-id="13920-518">이것을 이벤트 연결 없이 구현하려면 매우 어렵고 더 많은 스레드 및/또는 추가 애플리케이션 코드가 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-518">Accomplishing this without event-chaining is quite difficult and likely would require more threads and/or additional application code.</span></span>

<span data-ttu-id="13920-519">일반적으로 이벤트 연결(*event-chaining*)은 스레드 수, 오버헤드, RAM 요구 사항을 줄입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-519">In general, *event-chaining* results in fewer threads, less overhead, and smaller RAM requirements.</span></span> <span data-ttu-id="13920-520">또한 복잡한 시스템의 동기화 요구 사항을 처리할 수 있는 매우 유연한 메커니즘을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-520">It also provides a highly flexible mechanism to handle synchronization requirements of more complex systems.</span></span>

### <a name="run-time-queue-performance-information"></a><span data-ttu-id="13920-521">런타임 큐 성능 정보</span><span class="sxs-lookup"><span data-stu-id="13920-521">Run-time Queue Performance Information</span></span>
<span data-ttu-id="13920-522">ThreadX는 선택적 런타임 큐 성능 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-522">ThreadX provides optional run-time queue performance information.</span></span> <span data-ttu-id="13920-523">ThreadX 라이브러리 및 애플리케이션이 ***TX_QUEUE_ENABLE_PERFORMANCE_INFO*** 가 정의된 상태로 빌드되면 ThreadX는 다음 정보를 누적합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-523">If the ThreadX library and application is built with ***TX_QUEUE_ENABLE_PERFORMANCE_INFO*** defined, ThreadX accumulates the following information.</span></span>

<span data-ttu-id="13920-524">전체 시스템의 다음에 대한 총 수:</span><span class="sxs-lookup"><span data-stu-id="13920-524">Total number for the overall system:</span></span>

  - <span data-ttu-id="13920-525">전송된 메시지</span><span class="sxs-lookup"><span data-stu-id="13920-525">messages sent</span></span>

  - <span data-ttu-id="13920-526">수신된 메시지</span><span class="sxs-lookup"><span data-stu-id="13920-526">messages received</span></span>

  - <span data-ttu-id="13920-527">큐 비어 있음 일시 중단</span><span class="sxs-lookup"><span data-stu-id="13920-527">queue empty suspensions</span></span>

  - <span data-ttu-id="13920-528">큐 가득 참 일시 중단</span><span class="sxs-lookup"><span data-stu-id="13920-528">queue full suspensions</span></span>

  - <span data-ttu-id="13920-529">큐 가득 참 오류 반환(일시 중단이 지정되지 않음)</span><span class="sxs-lookup"><span data-stu-id="13920-529">queue full error returns (suspension not specified)</span></span>

  - <span data-ttu-id="13920-530">큐 시간 제한</span><span class="sxs-lookup"><span data-stu-id="13920-530">queue timeouts</span></span>

<span data-ttu-id="13920-531">각 큐의 다음에 대한 총 수:</span><span class="sxs-lookup"><span data-stu-id="13920-531">Total number for each queue:</span></span>

  - <span data-ttu-id="13920-532">전송된 메시지</span><span class="sxs-lookup"><span data-stu-id="13920-532">messages sent</span></span>

  - <span data-ttu-id="13920-533">수신된 메시지</span><span class="sxs-lookup"><span data-stu-id="13920-533">messages received</span></span>

  - <span data-ttu-id="13920-534">큐 비어 있음 일시 중단</span><span class="sxs-lookup"><span data-stu-id="13920-534">queue empty suspensions</span></span>

  - <span data-ttu-id="13920-535">큐 가득 참 일시 중단</span><span class="sxs-lookup"><span data-stu-id="13920-535">queue full suspensions</span></span>

  - <span data-ttu-id="13920-536">큐 가득 참 오류 반환(일시 중단이 지정되지 않음)</span><span class="sxs-lookup"><span data-stu-id="13920-536">queue full error returns (suspension not specified)</span></span>

  - <span data-ttu-id="13920-537">큐 시간 제한</span><span class="sxs-lookup"><span data-stu-id="13920-537">queue timeouts</span></span>

<span data-ttu-id="13920-538">이 정보는 ***tx_queue_performance_info_get** _ 및 _*_tx_queue_performance_system_info_get_\*\* 서비스를 통해 런타임에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-538">This information is available at run-time through the services ***tx_queue_performance_info_get** _ and _*_tx_queue_performance_system_info_get_\*\*.</span></span> <span data-ttu-id="13920-539">큐 성능 정보는 애플리케이션이 제대로 작동하는지 확인하는 데 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-539">Queue performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="13920-540">애플리케이션을 최적화하는데도 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-540">It is also useful in optimizing the application.</span></span> <span data-ttu-id="13920-541">예를 들어 "큐 가득 참 일시 중단"의 수가 상대적으로 높으면 큐 크기를 늘리는 것이 유용하다는 표시일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-541">For example, a relatively high number of "queue full suspensions" suggests an increase in the queue size might be beneficial.</span></span>

### <a name="queue-control-block-tx_queue"></a><span data-ttu-id="13920-542">큐 제어 블록 TX_QUEUE</span><span class="sxs-lookup"><span data-stu-id="13920-542">Queue Control Block TX_QUEUE</span></span>

<span data-ttu-id="13920-543">각 메시지 큐의 특징은 해당 제어 블록에서 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-543">The characteristics of each message queue are found in its control block.</span></span> <span data-ttu-id="13920-544">여기에는 큐에 있는 메시지의 수와 같은 흥미로운 정보가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-544">It contains interesting information such as the number of messages in the queue.</span></span> <span data-ttu-id="13920-545">이 구조는 ***tx_api.h*** 파일에 정의되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-545">This structure is defined in the ***tx_api.h*** file.</span></span>

<span data-ttu-id="13920-546">메시지 큐 제어 블록은 메모리의 어디에나 위치할 수 있지만 제어 블록을 모든 함수의 범위 밖에 정의하여 전역 구조로 만드는 것이 가장 일반적입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-546">Message queue control blocks can also be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="message-destination-pitfall"></a><span data-ttu-id="13920-547">메시지 대상 관련 문제</span><span class="sxs-lookup"><span data-stu-id="13920-547">Message Destination Pitfall</span></span>

<span data-ttu-id="13920-548">앞서 언급했듯이 메시지는 큐 영역과 애플리케이션 데이터 영역 간에 복사됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-548">As mentioned previously, messages are copied between the queue area and application data areas.</span></span> <span data-ttu-id="13920-549">받은 메시지의 대상이 전체 메시지를 보관할 수 있을 정도로 큰지 확인하는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-549">It is important to ensure the destination for a received message is large enough to hold the entire message.</span></span> <span data-ttu-id="13920-550">그렇지 않으면 메시지 대상 다음의 메모리가 손상될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-550">If not, the memory following the message destination will likely be corrupted.</span></span>

> [!NOTE]
> <span data-ttu-id="13920-551">*스택에 너무 작은 메시지 대상이 있는 경우 특히 치명적이며, 함수의 반환 주소를 손상시키는 것과는 전혀 다릅니다!*</span><span class="sxs-lookup"><span data-stu-id="13920-551">*This is especially lethal when a too-small message destination is on the stack—nothing like corrupting the return address of a function!*</span></span>

## <a name="counting-semaphores"></a><span data-ttu-id="13920-552">세마포 수 계산</span><span class="sxs-lookup"><span data-stu-id="13920-552">Counting Semaphores</span></span>

<span data-ttu-id="13920-553">ThreadX는 32비트 카운팅 세마포를 제공하며 이 값의 범위는 0에서 4,294,967,295 사이입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-553">ThreadX provides 32-bit counting semaphores that range in value between 0 and 4,294,967,295.</span></span> <span data-ttu-id="13920-554">카운팅 세마포에는 *tx_semaphore_get* 및 *tx_semaphore_put* 이라는 두 가지 연산이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-554">There are two operations for counting semaphores: *tx_semaphore_get* and *tx_semaphore_put*.</span></span> <span data-ttu-id="13920-555">get 연산은 세마포를 하나씩 줄입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-555">The get operation decreases the semaphore by one.</span></span> <span data-ttu-id="13920-556">세마포가 0이면 get 연산이 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-556">If the semaphore is 0, the get operation is not successful.</span></span> <span data-ttu-id="13920-557">get 연산의 반대는 put 연산입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-557">The inverse of the get operation is the put operation.</span></span>
<span data-ttu-id="13920-558">세마포를 하나씩 증가시킵니다.</span><span class="sxs-lookup"><span data-stu-id="13920-558">It increases the semaphore by one.</span></span>

<span data-ttu-id="13920-559">각 카운팅 세마포는 공용 리소스입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-559">Each counting semaphore is a public resource.</span></span> <span data-ttu-id="13920-560">ThreadX는 카운팅 세마포가 사용되는 방식에 대한 제약 조건을 두지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-560">ThreadX places no constraints on how counting semaphores are used.</span></span>

<span data-ttu-id="13920-561">카운팅 세마포는 일반적으로 상호 배제(*mutual exclusion*)에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-561">Counting semaphores are typically used for *mutual exclusion*.</span></span> <span data-ttu-id="13920-562">하지만 카운팅 세마포는 이벤트 알림을 위한 메서드로도 사용될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-562">However, counting semaphores can also be used as a method for event notification.</span></span>

### <a name="mutual-exclusion"></a><span data-ttu-id="13920-563">상호 배제</span><span class="sxs-lookup"><span data-stu-id="13920-563">Mutual Exclusion</span></span>

 <span data-ttu-id="13920-564">상호 배제는 특정 애플리케이션 영역(*임계 영역* 또는 *애플리케이션 리소스* 라고도 함)에 대한 스레드 액세스 제어와 관련이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-564">Mutual exclusion pertains to controlling the access of threads to certain application areas (also called *critical sections* or *application resources*).</span></span> <span data-ttu-id="13920-565">상호 배제에 사용되는 경우 세마포의 "현재 개수"는 액세스가 허용된 총 스레드 수를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="13920-565">When used for mutual exclusion, the "current count" of a semaphore represents the total number of threads that are allowed access.</span></span> <span data-ttu-id="13920-566">대부분의 경우 상호 배제에 사용되는 카운팅 세마포의 초기 값은 1이며, 이것은 연결된 리소스에 스레드가 한 번에 하나만 액세스할 수 있다는 의미입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-566">In most cases, counting semaphores used for mutual exclusion will have an initial value of 1, meaning that only one thread can access the associated resource at a time.</span></span> <span data-ttu-id="13920-567">값이 0 또는 1인 카운팅 세마포를 일반적으로 이진 세마포(*binary semaphores*)라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-567">Counting semaphores that only have values of 0 or 1 are commonly called *binary semaphores*.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="13920-568">*이진 세마포가 사용되는 경우 사용자는 이미 소유하고 있는 세마포에 대해 동일한 스레드가 get 작업을 수행할 수 없도록 해야 합니다. 두 번째 get은 실패하고 호출 스레드를 무기한으로 일시 중단하고 리소스를 영구적으로 사용할 수 없도록 할 수 있습니다.*</span><span class="sxs-lookup"><span data-stu-id="13920-568">*If a binary semaphore is being used, the user must prevent the same thread from performing a get operation on a semaphore it already owns. A second get would be unsuccessful and could cause indefinite suspension of the calling thread and permanent unavailability of the resource.*</span></span>

### <a name="event-notification"></a><span data-ttu-id="13920-569">이벤트 알림</span><span class="sxs-lookup"><span data-stu-id="13920-569">Event Notification</span></span>

<span data-ttu-id="13920-570">카운팅 세마포를 생산자-소비자 방식의 이벤트 알림으로 사용할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-570">It is also possible to use counting semaphores as event notification, in a producer-consumer fashion.</span></span> <span data-ttu-id="13920-571">소비자는 카운팅 세마포를 가져오려고 시도하는 반면 생산자는 사용 가능한 항목이 있을 때마다 세마포를 증가시킵니다.</span><span class="sxs-lookup"><span data-stu-id="13920-571">The consumer attempts to get the counting semaphore while the producer increases the semaphore whenever something is available.</span></span> <span data-ttu-id="13920-572">이러한 세마포는 일반적으로 초기 값이 0이며 생산자가 소비자에 대해 준비될 때까지 증가하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-572">Such semaphores usually have an initial value of 0 and will not increase until the producer has something ready for the consumer.</span></span> <span data-ttu-id="13920-573">이벤트 알림에 사용되는 세마포가 ***tx_semaphore_ceiling_put*** 서비스 호출을 사용하면 유용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-573">Semaphores used for event notification may also benefit from use of the ***tx_semaphore_ceiling_put*** service call.</span></span> <span data-ttu-id="13920-574">이 서비스는 세마포 수가 호출에 제공된 값을 절대 초과하지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-574">This service ensures that the semaphore count never exceeds the value supplied in the call.</span></span>

### <a name="creating-counting-semaphores"></a><span data-ttu-id="13920-575">카운팅 세마포 만들기</span><span class="sxs-lookup"><span data-stu-id="13920-575">Creating Counting Semaphores</span></span>

<span data-ttu-id="13920-576">카운팅 세마포는 초기화 중에 또는 애플리케이션 스레드에서 런타임 중에 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-576">Counting semaphores are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="13920-577">세마포의 초기 개수는 생성 중에 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-577">The initial count of the semaphore is specified during creation.</span></span> <span data-ttu-id="13920-578">애플리케이션의 카운팅 세마포 수에는 제한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-578">There is no limit on the number of counting semaphores in an application.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="13920-579">스레드 일시 중단</span><span class="sxs-lookup"><span data-stu-id="13920-579">Thread Suspension</span></span>

<span data-ttu-id="13920-580">현재 개수가 0인 세마포에서 get 연산을 수행하는 동안 애플리케이션 스레드가 일시 중단될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-580">Application threads can suspend while attempting to perform a get operation on a semaphore with a current count of 0.</span></span>

<span data-ttu-id="13920-581">put 연산이 수행된 후 일시 중단된 스레드의 get 연산이 수행되고 스레드가 재개됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-581">After a put operation is performed, the suspended thread's get operation is performed and the thread is resumed.</span></span> <span data-ttu-id="13920-582">동일한 카운팅 세마포에서 여러 스레드가 일시 중단되면 일시 중단된 순서 대로(FIFO) 재개됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-582">If multiple threads are suspended on the same counting semaphore, they are resumed in the same order they were suspended (FIFO).</span></span>

<span data-ttu-id="13920-583">하지만 스레드 일시 중단을 해제하는 세마포 put 호출 전에 애플리케이션이 ***tx_semaphore_prioritize*** 를 호출하는 경우에도 우선 순위 재개가 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-583">However, priority resumption is also possible if the application calls ***tx_semaphore_prioritize*** prior to the semaphore put call that lifts thread suspension.</span></span> <span data-ttu-id="13920-584">세마포 우선 순위 지정 서비스는 우선 순위가 가장 높은 스레드를 일시 중단 목록의 맨 앞에 배치하고 다른 모든 일시 중단된 스레드는 동일한 FIFO 순서를 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-584">The semaphore prioritize service places the highest priority thread at the front of the suspension list, while leaving all other suspended threads in the same FIFO order.</span></span>

### <a name="semaphore-put-notification"></a><span data-ttu-id="13920-585">세마포 Put 알림</span><span class="sxs-lookup"><span data-stu-id="13920-585">Semaphore Put Notification</span></span>

<span data-ttu-id="13920-586">일부 애플리케이션은 세마포를 put할 때마다 알림을 받는 것이 유리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-586">Some applications may find it advantageous to be notified whenever a semaphore is put.</span></span> <span data-ttu-id="13920-587">ThreadX는 ***tx_semaphore_put_notify*** 서비스를 통해 이 기능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-587">ThreadX provides this ability through the ***tx_semaphore_put_notify*** service.</span></span> <span data-ttu-id="13920-588">이 서비스는 제공된 애플리케이션 알림 함수를 지정된 세마포에 등록합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-588">This service registers the supplied application notification function with the specified semaphore.</span></span> <span data-ttu-id="13920-589">ThreadX는 이후에 세마포를 put할 때마다 이 애플리케이션 알림 함수를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-589">ThreadX will subsequently invoke this application notification function whenever the semaphore is put.</span></span> <span data-ttu-id="13920-590">애플리케이션 알림 함수 내에서 정확한 처리는 애플리케이션에 의해 결정됩니다. 하지만 일반적으로 새 세마포 put 이벤트를 처리하기 위한 적절한 스레드를 재개하는 것으로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-590">The exact processing within the application notification function is determined by the application; however, it typically consists of resuming the appropriate thread for processing the new semaphore put event.</span></span>

### <a name="semaphore-event-chainingtrade"></a><span data-ttu-id="13920-591">Semaphore Event chaining&trade;</span><span class="sxs-lookup"><span data-stu-id="13920-591">Semaphore Event chaining&trade;</span></span>

<span data-ttu-id="13920-592">ThreadX의 알림 기능을 사용하여 다양한 동기화 이벤트를 함께 연결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-592">The notification capabilities in ThreadX can be used to chain various synchronization events together.</span></span> <span data-ttu-id="13920-593">일반적으로 단일 스레드가 여러 동기화 이벤트를 처리해야 하는 경우에 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-593">This is typically useful when a single thread must process multiple synchronization events.</span></span>

<span data-ttu-id="13920-594">예를 들어 큐 메시지, 이벤트 플래그, 세마포에 대한 개별 스레드를 일시 중단하는 대신 애플리케이션은 각 개체에 대한 알림 루틴을 등록할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-594">For example, instead of having separate threads suspend for a queue message, event flags, and a semaphore, the application can register a notification routine for each object.</span></span> <span data-ttu-id="13920-595">호출되면 애플리케이션 알림 루틴은 단일 스레드를 재개할 수 있습니다. 그러면 각 개체를 조사하여 새 이벤트를 찾아서 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-595">When invoked, the application notification routine can then resume a single thread, which can interrogate each object to find and process the new event.</span></span>

<span data-ttu-id="13920-596">일반적으로 이벤트 연결(*event-chaining*)은 스레드 수, 오버헤드, RAM 요구 사항을 줄입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-596">In general, *event-chaining* results in fewer threads, less overhead, and smaller RAM requirements.</span></span> <span data-ttu-id="13920-597">또한 복잡한 시스템의 동기화 요구 사항을 처리할 수 있는 매우 유연한 메커니즘을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-597">It also provides a highly flexible mechanism to handle synchronization requirements of more complex systems.</span></span>

### <a name="run-time-semaphore-performance-information"></a><span data-ttu-id="13920-598">런타임 세마포 성능 정보</span><span class="sxs-lookup"><span data-stu-id="13920-598">Run-time Semaphore Performance Information</span></span>

<span data-ttu-id="13920-599">ThreadX는 선택적 런타임 세마포 성능 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-599">ThreadX provides optional run-time semaphore performance information.</span></span> <span data-ttu-id="13920-600">ThreadX 라이브러리 및 애플리케이션이 **TX_SEMAPHORE_ENABLE_PERFORMANCE_INFO** 가 정의된 상태로 빌드되면 ThreadX는 다음 정보를 누적합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-600">If the ThreadX library and application is built with **TX_SEMAPHORE_ENABLE_PERFORMANCE_INFO** defined, ThreadX accumulates the following information.</span></span>

<span data-ttu-id="13920-601">전체 시스템의 다음에 대한 총 수:</span><span class="sxs-lookup"><span data-stu-id="13920-601">Total number for the overall system:</span></span>

  - <span data-ttu-id="13920-602">세마포 put</span><span class="sxs-lookup"><span data-stu-id="13920-602">semaphore puts</span></span>

  - <span data-ttu-id="13920-603">세마포 get</span><span class="sxs-lookup"><span data-stu-id="13920-603">semaphore gets</span></span>

  - <span data-ttu-id="13920-604">세마포 get 일시 중단</span><span class="sxs-lookup"><span data-stu-id="13920-604">semaphore get suspensions</span></span>

  - <span data-ttu-id="13920-605">세마포 get 시간 제한</span><span class="sxs-lookup"><span data-stu-id="13920-605">semaphore get timeouts</span></span>

<span data-ttu-id="13920-606">각 세마포의 다음에 대한 총 수:</span><span class="sxs-lookup"><span data-stu-id="13920-606">Total number for each semaphore:</span></span>

  - <span data-ttu-id="13920-607">세마포 put</span><span class="sxs-lookup"><span data-stu-id="13920-607">semaphore puts</span></span>

  - <span data-ttu-id="13920-608">세마포 get</span><span class="sxs-lookup"><span data-stu-id="13920-608">semaphore gets</span></span>

  - <span data-ttu-id="13920-609">세마포 get 일시 중단</span><span class="sxs-lookup"><span data-stu-id="13920-609">semaphore get suspensions</span></span>

  - <span data-ttu-id="13920-610">세마포 get 시간 제한</span><span class="sxs-lookup"><span data-stu-id="13920-610">semaphore get timeouts</span></span>

<span data-ttu-id="13920-611">이 정보는 ***tx_semaphore_performance_info_get** _ 및 _*_tx_semaphore_performance_system_info_get_\*\* 서비스를 통해 런타임에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-611">This information is available at run-time through the services ***tx_semaphore_performance_info_get** _ and _*_tx_semaphore_performance_system_info_get_\*\*.</span></span> <span data-ttu-id="13920-612">세마포 성능 정보는 애플리케이션이 제대로 작동하는지 확인하는 데 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-612">Semaphore performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="13920-613">애플리케이션을 최적화하는데도 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-613">It is also useful in optimizing the application.</span></span> <span data-ttu-id="13920-614">예를 들어 "세마포 get 시간 제한"의 수가 상대적으로 높으면 다른 스레드가 리소스를 너무 오래 보유하고 있다는 표시일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-614">For example, a relatively high number of "semaphore get timeouts" might suggest that other threads are holding resources too long.</span></span>

### <a name="semaphore-control-block-tx_semaphore"></a><span data-ttu-id="13920-615">세마포 제어 블록 TX_SEMAPHORE</span><span class="sxs-lookup"><span data-stu-id="13920-615">Semaphore Control Block TX_SEMAPHORE</span></span>

<span data-ttu-id="13920-616">각 카운팅 세마포의 특징은 해당 제어 블록에서 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-616">The characteristics of each counting semaphore are found in its control block.</span></span> <span data-ttu-id="13920-617">현재 세마포 수와 같은 정보를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-617">It contains information such as the current semaphore count.</span></span> <span data-ttu-id="13920-618">이 구조는 ***tx_api.h*** 파일에 정의되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-618">This structure is defined in the ***tx_api.h*** file.</span></span>

<span data-ttu-id="13920-619">세마포 제어 블록은 메모리의 어디에나 위치할 수 있지만 제어 블록을 모든 함수의 범위 밖에 정의하여 전역 구조로 만드는 것이 가장 일반적입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-619">Semaphore control blocks can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="deadly-embrace"></a><span data-ttu-id="13920-620">치명적인 수용</span><span class="sxs-lookup"><span data-stu-id="13920-620">Deadly Embrace</span></span>

<span data-ttu-id="13920-621">상호 배제에 사용되는 세마포와 관련하여 가장 흥미롭고 위험한 문제 중 하나는 치명적인 수용(*deadly embrace*)입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-621">One of the most interesting and dangerous pitfalls associated with semaphores used for mutual exclusion is the *deadly embrace*.</span></span> <span data-ttu-id="13920-622">치명적인 수용 또는 *교착* 상태는 이미 서로를 소유하고 있는 세마포를 get하려고 시도하는 동안 둘 이상의 스레드가 무기한 일시 중단되는 조건입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-622">A deadly embrace, or *deadlock*, is a condition in which two or more threads are suspended indefinitely while attempting to get semaphores already owned by each other.</span></span>

<span data-ttu-id="13920-623">이 조건은 두 개의 스레드, 두 개의 세마포 예제로 가장 잘 설명됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-623">This condition is best illustrated by a two thread, two semaphore example.</span></span> <span data-ttu-id="13920-624">첫 번째 스레드가 첫 번째 세마포를 소유하고 두 번째 스레드가 두 번째 세마포를 소유한다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-624">Suppose the first thread owns the first semaphore and the second thread owns the second semaphore.</span></span> <span data-ttu-id="13920-625">첫 번째 스레드가 두 번째 세마포를 get하려고 시도하는 동시에 두 번째 스레드가 첫 번째 세마포를 get하려고 시도하면 두 스레드 모두 교착 상태가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-625">If the first thread attempts to get the second semaphore and at the same time the second thread attempts to get the first semaphore, both threads enter a deadlock condition.</span></span> <span data-ttu-id="13920-626">또한 이 스레드가 일시 중단된 상태로 영원히 유지되면 연결된 리소스 역시 영원히 잠깁니다.</span><span class="sxs-lookup"><span data-stu-id="13920-626">In addition, if these threads stay suspended forever, their associated resources are locked-out forever as well.</span></span> <span data-ttu-id="13920-627">그림 8에서는 이 예를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="13920-627">Figure 8 illustrates this example.</span></span>

<span data-ttu-id="13920-628">**치명적인 수용**(예)</span><span class="sxs-lookup"><span data-stu-id="13920-628">**Deadly Embrace** (example)</span></span>

![일시 중단된 스레드의 예](./media/user-guide/example-suspended-threads.png)

<span data-ttu-id="13920-630">**그림 8. 일시 중단된 스레드의 예**</span><span class="sxs-lookup"><span data-stu-id="13920-630">**FIGURE 8. Example of Suspended Threads**</span></span>

<span data-ttu-id="13920-631">실시간 시스템의 경우 스레드가 세마포를 확보하는 방법에 특정 제한을 설정하여 치명적인 수용을 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-631">For real-time systems, deadly embraces can be prevented by placing certain restrictions on how threads obtain semaphores.</span></span> <span data-ttu-id="13920-632">스레드는 세마포를 한 번에 하나만 가질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-632">Threads can only have one semaphore at a time.</span></span> <span data-ttu-id="13920-633">또는, 스레드와 세마포가 동일한 순서로 모이면 여러 스레드가 여러 세마포를 소유할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-633">Alternatively, threads can own multiple semaphores if they gather them in the same order.</span></span> <span data-ttu-id="13920-634">앞의 예에서 첫 번째와 두 번째 스레드가 첫 번째와 두 번째 세마포를 순서대로 확보하면 치명적인 수용이 방지됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-634">In the previous example, if the first and second thread obtain the first and second semaphore in order, the deadly embrace is prevented.</span></span>

> [!TIP]
> <span data-ttu-id="13920-635">*get 연산과 관련된 중단 시간 제한을 사용하여 치명적인 수용에서 복구할 수도 있습니다.*</span><span class="sxs-lookup"><span data-stu-id="13920-635">*It is also possible to use the suspension time-out associated with the get operation to recover from a deadly embrace.*</span></span>

### <a name="priority-inversion"></a><span data-ttu-id="13920-636">우선 순위 반전</span><span class="sxs-lookup"><span data-stu-id="13920-636">Priority Inversion</span></span>

<span data-ttu-id="13920-637">상호 배제 세마포와 관련된 또 다른 문제는 우선 순위 반전입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-637">Another pitfall associated with mutual exclusion semaphores is priority inversion.</span></span> <span data-ttu-id="13920-638">이 항목은 "[스레드 우선 순위 관련 문제](#thread-priority-pitfalls)"에서 자세히 설명되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-638">This topic is discussed more fully in "[Thread Priority Pitfalls](#thread-priority-pitfalls)".</span></span>

<span data-ttu-id="13920-639">기본적인 문제는 우선 순위가 높은 스레드에 필요한 세마포가 우선 순위가 낮은 스레드에 있는 상황에서 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-639">The basic problem results from a situation in which a lower-priority thread has a semaphore that a higher priority thread needs.</span></span> <span data-ttu-id="13920-640">이것 자체로는 정상입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-640">This in itself is normal.</span></span> <span data-ttu-id="13920-641">하지만 스레드의 우선 순위가 그 사이이면 우선 순위 반전이 비결정적 시간 동안 지속될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-641">However, threads with priorities in between them may cause the priority inversion to last a nondeterministic amount of time.</span></span> <span data-ttu-id="13920-642">이런 문제는 스레드 우선 순위를 신중하게 선택하고, 선점 임계값을 사용하고, 리소스를 소유한 스레드의 우선 순위를 우선 순위가 높은 스레드의 우선 순위로 일시적으로 높여서 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-642">This can be handled through careful selection of thread priorities, using preemption-threshold, and temporarily raising the priority of the thread that owns the resource to that of the high priority thread.</span></span>

## <a name="mutexes"></a><span data-ttu-id="13920-643">뮤텍스</span><span class="sxs-lookup"><span data-stu-id="13920-643">Mutexes</span></span>

<span data-ttu-id="13920-644">ThreadX는 세마포 외에 뮤텍스 개체도 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-644">In addition to semaphores, ThreadX also provides a mutex object.</span></span> <span data-ttu-id="13920-645">뮤텍스는 기본적으로 이진 세마포입니다. 즉, 한 번에 하나의 스레드만 뮤텍스를 소유할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-645">A mutex is basically a binary semaphore, which means that only one thread can own a mutex at a time.</span></span> <span data-ttu-id="13920-646">또한 동일한 스레드는 소유한 뮤텍스에서 성공적인 뮤텍스 get 연산을 여러 번(정확히 4,294,967,295번) 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-646">In addition, the same thread may perform a successful mutex get operation on an owned mutex multiple times, 4,294,967,295 to be exact.</span></span> <span data-ttu-id="13920-647">뮤텍스 개체에는 ***tx_mutex_get** _ 및 _*_tx_mutex_put_\*\*이라는 두 가지 연산이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-647">There are two operations on the mutex object: ***tx_mutex_get** _ and _*_tx_mutex_put_\*\*.</span></span> <span data-ttu-id="13920-648">get 연산은 다른 스레드가 소유하지 않은 뮤텍스를 확보하는 반면, put 연산은 이전에 확보한 뮤텍스를 해제합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-648">The get operation obtains a mutex not owned by another thread, while the put operation releases a previously obtained mutex.</span></span> <span data-ttu-id="13920-649">스레드가 뮤텍스를 해제하려면 put 연산의 수가 이전 get 연산의 수와 같아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-649">For a thread to release a mutex, the number of put operations must equal the number of prior get operations.</span></span>

<span data-ttu-id="13920-650">각 뮤텍스는 공용 리소스입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-650">Each mutex is a public resource.</span></span> <span data-ttu-id="13920-651">ThreadX는 뮤텍스가 사용되는 방식에 제약 조건을 두지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-651">ThreadX places no constraints on how mutexes are used.</span></span>

<span data-ttu-id="13920-652">ThreadX 뮤텍스는 *상호 배제* 에만 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-652">ThreadX mutexes are used solely for *mutual exclusion*.</span></span> <span data-ttu-id="13920-653">카운팅 세마포와 달리, 뮤텍스는 이벤트 알림을 위한 메서드로 사용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-653">Unlike counting semaphores, mutexes have no use as a method for event notification.</span></span>

### <a name="mutex-mutual-exclusion"></a><span data-ttu-id="13920-654">뮤텍스 상호 배제</span><span class="sxs-lookup"><span data-stu-id="13920-654">Mutex Mutual Exclusion</span></span>

<span data-ttu-id="13920-655">카운팅 세마포 섹션의 설명과 마찬가지로, 상호 배제는 특정 애플리케이션 영역(*임계 영역* 또는 *애플리케이션 리소스* 라고도 함)에 대한 스레드 액세스 제어와 관련이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-655">Similar to the discussion in the counting semaphore section, mutual exclusion pertains to controlling the access of threads to certain application areas (also called *critical sections* or *application resources*).</span></span> <span data-ttu-id="13920-656">사용 가능한 경우 ThreadX 뮤텍스의 소유권 개수는 0입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-656">When available, a ThreadX mutex will have an ownership count of 0.</span></span> <span data-ttu-id="13920-657">스레드가 뮤텍스를 확보한 후 소유권 개수는 뮤텍스에서 수행한 get 연산이 성공할 때마다 한 번씩 증가하고 put 연산이 성공할 때마다 한 번씩 감소합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-657">After the mutex is obtained by a thread, the ownership count is incremented once for every successful get operation performed on the mutex and decremented for every successful put operation.</span></span>

### <a name="creating-mutexes"></a><span data-ttu-id="13920-658">뮤텍스 만들기</span><span class="sxs-lookup"><span data-stu-id="13920-658">Creating Mutexes</span></span>

<span data-ttu-id="13920-659">ThreadX 뮤텍스는 초기화 중에 또는 애플리케이션 스레드에서 런타임 중에 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-659">ThreadX mutexes are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="13920-660">뮤텍스의 초기 조건은 항상 "사용 가능"입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-660">The initial condition of a mutex is always "available."</span></span> <span data-ttu-id="13920-661">*우선 순위 상속* 을 선택한 상태에서 뮤텍스를 만들 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-661">A mutex may also be created with *priority inheritance* selected.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="13920-662">스레드 일시 중단</span><span class="sxs-lookup"><span data-stu-id="13920-662">Thread Suspension</span></span>

<span data-ttu-id="13920-663">다른 스레드가 이미 소유하고 있는 뮤텍스에 대해 get 연산을 수행하는 동안 애플리케이션 스레드가 일시 중단될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-663">Application threads can suspend while attempting to perform a get operation on a mutex already owned by another thread.</span></span>

<span data-ttu-id="13920-664">소유하는 스레드가 동일한 수의 put 연산을 수행한 후 일시 중단된 스레드의 get 연산이 수행되어 뮤텍스의 소유권을 부여하고 스레드가 재개됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-664">After the same number of put operations are performed by the owning thread, the suspended thread's get operation is performed, giving it ownership of the mutex, and the thread is resumed.</span></span> <span data-ttu-id="13920-665">여러 스레드가 동일한 뮤텍스에서 일시 중단되면 일시 중단된 순서대로(FIFO) 재개됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-665">If multiple threads are suspended on the same mutex, they are resumed in the same order they were suspended (FIFO).</span></span>

<span data-ttu-id="13920-666">단, 생성 중에 뮤텍스 우선 순위 상속을 선택했으면 우선 순위 재개가 자동으로 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-666">However, priority resumption is done automatically if the mutex priority inheritance was selected during creation.</span></span> <span data-ttu-id="13920-667">스레드 일시 중단을 해제하는 뮤텍스 put 호출 전에 애플리케이션이 ***tx_mutex_prioritize*** 를 호출하는 경우에도 우선 순위 재개가 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-667">Priority resumption is also possible if the application calls ***tx_mutex_prioritize*** prior to the mutex put call that lifts thread suspension.</span></span> <span data-ttu-id="13920-668">뮤텍스 우선 순위 지정 서비스는 우선 순위가 가장 높은 스레드를 일시 중단 목록의 맨 앞에 배치하고 다른 모든 일시 중단된 스레드는 동일한 FIFO 순서를 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-668">The mutex prioritize service places the highest priority thread at the front of the suspension list, while leaving all other suspended threads in the same FIFO order.</span></span>

### <a name="run-time-mutex-performance-information"></a><span data-ttu-id="13920-669">런타임 뮤텍스 성능 정보</span><span class="sxs-lookup"><span data-stu-id="13920-669">Run-time Mutex Performance Information</span></span>

<span data-ttu-id="13920-670">ThreadX는 선택적 런타임 뮤텍스 성능 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-670">ThreadX provides optional run-time mutex performance information.</span></span> <span data-ttu-id="13920-671">ThreadX 라이브러리 및 애플리케이션이 **TX_MUTEX_ENABLE_PERFORMANCE_INFO** 가 정의된 상태로 빌드되면 ThreadX는 다음 정보를 누적합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-671">If the ThreadX library and application is built with **TX_MUTEX_ENABLE_PERFORMANCE_INFO** defined, ThreadX accumulates the following information.</span></span>

<span data-ttu-id="13920-672">전체 시스템의 다음에 대한 총 수:</span><span class="sxs-lookup"><span data-stu-id="13920-672">Total number for the overall system:</span></span>

- <span data-ttu-id="13920-673">뮤텍스 put</span><span class="sxs-lookup"><span data-stu-id="13920-673">mutex puts</span></span>

- <span data-ttu-id="13920-674">뮤텍스 get</span><span class="sxs-lookup"><span data-stu-id="13920-674">mutex gets</span></span>

- <span data-ttu-id="13920-675">뮤텍스 get 일시 중단</span><span class="sxs-lookup"><span data-stu-id="13920-675">mutex get suspensions</span></span>

- <span data-ttu-id="13920-676">뮤텍스 get 시간 제한</span><span class="sxs-lookup"><span data-stu-id="13920-676">mutex get timeouts</span></span>

- <span data-ttu-id="13920-677">뮤텍스 우선 순위 반전</span><span class="sxs-lookup"><span data-stu-id="13920-677">mutex priority inversions</span></span>

- <span data-ttu-id="13920-678">뮤텍스 우선 순위 상속</span><span class="sxs-lookup"><span data-stu-id="13920-678">mutex priority inheritances</span></span>

<span data-ttu-id="13920-679">각 뮤텍스의 다음에 대한 총 수:</span><span class="sxs-lookup"><span data-stu-id="13920-679">Total number for each mutex:</span></span>

  - <span data-ttu-id="13920-680">뮤텍스 put</span><span class="sxs-lookup"><span data-stu-id="13920-680">mutex puts</span></span>

  - <span data-ttu-id="13920-681">뮤텍스 get</span><span class="sxs-lookup"><span data-stu-id="13920-681">mutex gets</span></span>

  - <span data-ttu-id="13920-682">뮤텍스 get 일시 중단</span><span class="sxs-lookup"><span data-stu-id="13920-682">mutex get suspensions</span></span>

  - <span data-ttu-id="13920-683">뮤텍스 get 시간 제한</span><span class="sxs-lookup"><span data-stu-id="13920-683">mutex get timeouts</span></span>

  - <span data-ttu-id="13920-684">뮤텍스 우선 순위 반전</span><span class="sxs-lookup"><span data-stu-id="13920-684">mutex priority inversions</span></span>

  - <span data-ttu-id="13920-685">뮤텍스 우선 순위 상속</span><span class="sxs-lookup"><span data-stu-id="13920-685">mutex priority inheritances</span></span>

<span data-ttu-id="13920-686">이 정보는 ***tx_mutex_performance_info_get** _ 및 _*_tx_mutex_performance_system_info_get_\*\* 서비스를 통해 런타임에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-686">This information is available at run-time through the services ***tx_mutex_performance_info_get** _ and _*_tx_mutex_performance_system_info_get_\*\*.</span></span> <span data-ttu-id="13920-687">뮤텍스 성능 정보는 애플리케이션이 제대로 작동하는지 확인하는 데 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-687">Mutex performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="13920-688">애플리케이션을 최적화하는데도 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-688">It is also useful in optimizing the application.</span></span> <span data-ttu-id="13920-689">예를 들어 "뮤텍스 get 시간 제한"의 수가 상대적으로 높으면 다른 스레드가 리소스를 너무 오래 보유하고 있다는 표시일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-689">For example, a relatively high number of "mutex get timeouts" might suggest that other threads are holding resources too long.</span></span>

### <a name="mutex-control-block-tx_mutex"></a><span data-ttu-id="13920-690">뮤텍스 제어 블록 TX_MUTEX</span><span class="sxs-lookup"><span data-stu-id="13920-690">Mutex Control Block TX_MUTEX</span></span>

<span data-ttu-id="13920-691">각 뮤텍스의 특징은 해당 제어 블록에서 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-691">The characteristics of each mutex are found in its control block.</span></span> <span data-ttu-id="13920-692">여기에는 뮤텍스를 소유한 스레드의 포인터와 함께 현재 뮤텍스 소유권 수와 같은 정보가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-692">It contains information such as the current mutex ownership count along with the pointer of the thread that owns the mutex.</span></span> <span data-ttu-id="13920-693">이 구조는 ***tx_api.h*** 파일에 정의되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-693">This structure is defined in the ***tx_api.h*** file.</span></span> <span data-ttu-id="13920-694">뮤텍스 제어 블록은 메모리의 어디에나 위치할 수 있지만 제어 블록을 모든 함수의 범위 밖에 정의하여 전역 구조로 만드는 것이 가장 일반적입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-694">Mutex control blocks can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="deadly-embrace"></a><span data-ttu-id="13920-695">치명적인 수용</span><span class="sxs-lookup"><span data-stu-id="13920-695">Deadly Embrace</span></span>

<span data-ttu-id="13920-696">뮤텍스 소유권과 관련된 가장 흥미롭고 위험한 문제 중 하나는 치명적인 수용(*deadly embrace*)입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-696">One of the most interesting and dangerous pitfalls associated with mutex ownership is the *deadly embrace*.</span></span> <span data-ttu-id="13920-697">치명적인 수용 또는 *교착* 상태는 이미 서로를 소유하고 있는 뮤텍스를 get하려고 시도하는 동안 둘 이상의 스레드가 무기한 일시 중단되는 조건입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-697">A deadly embrace, or *deadlock*, is a condition where two or more threads are suspended indefinitely while attempting to get a mutex already owned by the other threads.</span></span> <span data-ttu-id="13920-698">*치명적인 수용* 과 그 해결책에 대한 설명은 뮤텍스 개체에도 완전히 유효합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-698">The discussion of *deadly embrace* and its remedies are completely valid for the mutex object as well.</span></span>

### <a name="priority-inversion"></a><span data-ttu-id="13920-699">우선 순위 반전</span><span class="sxs-lookup"><span data-stu-id="13920-699">Priority Inversion</span></span>

<span data-ttu-id="13920-700">앞서 언급했듯이 상호 배제와 관련된 주요 문제는 우선 순위 반전입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-700">As mentioned previously, a major pitfall associated with mutual exclusion is priority inversion.</span></span> <span data-ttu-id="13920-701">이 항목은 "[스레드 우선 순위 관련 문제](#thread-priority-pitfalls)"에서 자세히 설명되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-701">This topic is discussed more fully in "[Thread Priority Pitfalls](#thread-priority-pitfalls)".</span></span>

<span data-ttu-id="13920-702">기본적인 문제는 우선 순위가 높은 스레드에 필요한 세마포가 우선 순위가 낮은 스레드에 있는 상황에서 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-702">The basic problem results from a situation in which a lower priority thread has a semaphore that a higher priority thread needs.</span></span> <span data-ttu-id="13920-703">이것 자체로는 정상입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-703">This in itself is normal.</span></span> <span data-ttu-id="13920-704">하지만 스레드의 우선 순위가 그 사이이면 우선 순위 반전이 비결정적 시간 동안 지속될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-704">However, threads with priorities in between them may cause the priority inversion to last a nondeterministic amount of time.</span></span> <span data-ttu-id="13920-705">앞서 언급한 세마포와 달리 ThreadX 뮤텍스 개체에는 선택적 *우선 순위 상속* 이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-705">Unlike semaphores discussed previously, the ThreadX mutex object has optional *priority inheritance*.</span></span> <span data-ttu-id="13920-706">우선 순위 상속의 기본 개념은 우선 순위가 낮은 스레드의 우선 순위가 우선 순위가 낮은 스레드가 소유한 것과 동일한 뮤텍스를 원하는 우선 순위가 높은 스레드의 우선 순위로 일시적으로 높아지는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-706">The basic idea behind priority inheritance is that a lower priority thread has its priority raised temporarily to the priority of a high priority thread that wants the same mutex owned by the lower priority thread.</span></span> <span data-ttu-id="13920-707">우선 순위가 낮은 스레드가 뮤텍스를 해제하면 원래 우선 순위가 복원되고 우선 순위가 높은 스레드에 뮤텍스의 소유권이 부여됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-707">When the lower priority thread releases the mutex, its original priority is then restored and the higher priority thread is given ownership of the mutex.</span></span> <span data-ttu-id="13920-708">이 기능은 반전의 크기를 우선 순위가 낮은 스레드가 뮤텍스를 보유하는 시간으로 제한하여 비결정적 우선 순위 반전을 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-708">This feature eliminates nondeterministic priority inversion by bounding the amount of inversion to the time the lower priority thread holds the mutex.</span></span> <span data-ttu-id="13920-709">물론 이 챕터의 앞부분에서 언급한 비결정적 우선 순위 반전을 처리하는 내용은 뮤텍스에서도 유효합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-709">Of course, the techniques discussed earlier in this chapter to handle nondeterministic priority inversion are also valid with mutexes as well.</span></span>

## <a name="event-flags"></a><span data-ttu-id="13920-710">이벤트 플래그</span><span class="sxs-lookup"><span data-stu-id="13920-710">Event Flags</span></span>

<span data-ttu-id="13920-711">이벤트 플래그는 스레드 동기화를 위한 강력한 도구를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-711">Event flags provide a powerful tool for thread synchronization.</span></span> <span data-ttu-id="13920-712">각 이벤트 플래그는 단일 비트로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-712">Each event flag is represented by a single bit.</span></span> <span data-ttu-id="13920-713">이벤트 플래그는 32개의 그룹으로 정렬됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-713">Event flags are arranged in groups of 32.</span></span> <span data-ttu-id="13920-714">한 그룹의 32개 이벤트 플래그 모두에서 스레드가 동시에 작동할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-714">Threads can operate on all 32 event flags in a group at the same time.</span></span> <span data-ttu-id="13920-715">이벤트는 ***tx_event_flags_set** _에 의해 설정되고 _*_tx_event_flags_get_\*\*에 의해 검색됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-715">Events are set by ***tx_event_flags_set** _ and are retrieved by _*_tx_event_flags_get_\*\*.</span></span>

<span data-ttu-id="13920-716">이벤트 플래그 설정은 현재 이벤트 플래그와 새 이벤트 플래그 사이의 논리적 AND/OR 연산을 사용하여 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-716">Setting event flags is done with a logical AND/OR operation between the current event flags and the new event flags.</span></span> <span data-ttu-id="13920-717">논리 연산 유형(AND 또는 OR)은 ***tx_event_flags_set*** 호출에 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-717">The type of logical operation (either an AND or OR) is specified in the ***tx_event_flags_set*** call.</span></span>

<span data-ttu-id="13920-718">이벤트 플래그 검색을 위한 유사한 논리적 옵션이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-718">There are similar logical options for retrieval of event flags.</span></span> <span data-ttu-id="13920-719">get 요청은 지정된 모든 이벤트 플래그가 필요하도록 지정할 수 있습니다(논리적 AND).</span><span class="sxs-lookup"><span data-stu-id="13920-719">A get request can specify that all specified event flags are required (a logical AND).</span></span>

<span data-ttu-id="13920-720">또는 get 요청은 지정된 이벤트 플래그 중 하나가 요청을 충족하도록 지정할 수 있습니다(논리적 OR).</span><span class="sxs-lookup"><span data-stu-id="13920-720">Alternatively, a get request can specify that any of the specified event flags will satisfy the request (a logical OR).</span></span> <span data-ttu-id="13920-721">이벤트 플래그 검색과 관련된 논리 연산 유형은 ***tx_event_flags_get*** 호출에 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-721">The type of logical operation associated with event flags retrieval is specified in the ***tx_event_flags_get*** call.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="13920-722">*get 요청을 충족하는 이벤트 플래그가 사용됩니다. 즉,* \**TX_OR_CLEAR***또는***TX_AND_CLEAR\*\*\*가 요청에 의해 지정된 경우 0으로 설정됩니다.*</span><span class="sxs-lookup"><span data-stu-id="13920-722">*Event flags that satisfy a get request are consumed, i.e., set to zero, if* **TX_OR_CLEAR** *or* **TX_AND_CLEAR** *are specified by the request.*</span></span>

<span data-ttu-id="13920-723">각 이벤트 플래그 그룹은 공용 리소스입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-723">Each event flags group is a public resource.</span></span> <span data-ttu-id="13920-724">ThreadX는 이벤트 플래그 그룹이 사용되는 방식에 제약 조건을 두지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-724">ThreadX places no constraints on how event flags groups are used.</span></span>

### <a name="creating-event-flags-groups"></a><span data-ttu-id="13920-725">이벤트 플래그 그룹 만들기</span><span class="sxs-lookup"><span data-stu-id="13920-725">Creating Event Flags Groups</span></span>

<span data-ttu-id="13920-726">이벤트 플래그 그룹은 초기화 중에 또는 애플리케이션 스레드에서 런타임 중에 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-726">Event flags groups are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="13920-727">생성 시 그룹의 모든 이벤트 플래그는 0으로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-727">At the time of their creation, all event flags in the group are set to zero.</span></span> <span data-ttu-id="13920-728">애플리케이션의 이벤트 플래그 그룹 수에는 제한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-728">There is no limit on the number of event flags groups in an application.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="13920-729">스레드 일시 중단</span><span class="sxs-lookup"><span data-stu-id="13920-729">Thread Suspension</span></span>

<span data-ttu-id="13920-730">그룹에서 이벤트 플래그의 논리적 조합을 가져오려 시도하는 동안 애플리케이션 스레드가 일시 중단될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-730">Application threads can suspend while attempting to get any logical combination of event flags from a group.</span></span> <span data-ttu-id="13920-731">이벤트 플래그가 설정되면 일시 중단된 모든 스레드의 get 요청이 검토됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-731">After an event flag is set, the get requests of all suspended threads are reviewed.</span></span> <span data-ttu-id="13920-732">이제 필요한 이벤트 플래그가 있는 모든 스레드가 재개됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-732">All the threads that now have the required event flags are resumed.</span></span>

> [!NOTE]
> <span data-ttu-id="13920-733">*이벤트 플래그 그룹에서 일시 중단된 모든 스레드는 해당 이벤트 플래그가 설정될 때 검토됩니다. 물론 추가 오버 헤드가 발생합니다. 따라서 동일한 이벤트 플래그 그룹을 사용하는 스레드 수를 적절한 수로 제한하는 것이 좋습니다.*</span><span class="sxs-lookup"><span data-stu-id="13920-733">*All suspended threads on an event flag group are reviewed when its event flags are set. This, of course, introduces additional overhead. Therefore, it is good practice to limit the number of threads using the same event flag group to a reasonable number.*</span></span>

### <a name="event-flags-set-notification"></a><span data-ttu-id="13920-734">이벤트 플래그 설정 알림</span><span class="sxs-lookup"><span data-stu-id="13920-734">Event Flags Set Notification</span></span>

<span data-ttu-id="13920-735">일부 애플리케이션은 이벤트 플래그가 설정될 때마다 알림을 받는 것이 유리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-735">Some applications may find it advantageous to be notified whenever an event flag is set.</span></span> <span data-ttu-id="13920-736">ThreadX는 ***tx_event_flags_set_notify*** 서비스를 통해 이 기능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-736">ThreadX provides this ability through the ***tx_event_flags_set_notify*** service.</span></span> <span data-ttu-id="13920-737">이 서비스는 제공된 애플리케이션 알림 함수를 지정된 이벤트 플래그 그룹에 등록합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-737">This service registers the supplied application notification function with the specified event flags group.</span></span> <span data-ttu-id="13920-738">ThreadX는 그룹의 이벤트 플래그가 설정될 때마다 애플리케이션 알림 함수를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-738">ThreadX will subsequently invoke this application notification function whenever an event flag in the group is set.</span></span> <span data-ttu-id="13920-739">애플리케이션 알림 함수 내에서 정확한 처리는 애플리케이션에 의해 결정됩니다. 하지만 일반적으로 새 이벤트 플래그를 처리하기 위한 적절한 스레드를 재개하는 것으로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-739">The exact processing within the application notification function is determined by the application, but it typically consists of resuming the appropriate thread for processing the new event flag.</span></span>

### <a name="event-flags-event-chainingtrade"></a><span data-ttu-id="13920-740">Event Flags Event chaining&trade;</span><span class="sxs-lookup"><span data-stu-id="13920-740">Event Flags Event chaining&trade;</span></span>

<span data-ttu-id="13920-741">ThreadX의 알림 기능을 사용하여 다양한 동기화 이벤트를 함께 "연결"할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-741">The notification capabilities in ThreadX can be used to "chain" various synchronization events together.</span></span> <span data-ttu-id="13920-742">일반적으로 단일 스레드가 여러 동기화 이벤트를 처리해야 하는 경우에 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-742">This is typically useful when a single thread must process multiple synchronization events.</span></span>

<span data-ttu-id="13920-743">예를 들어 큐 메시지, 이벤트 플래그, 세마포에 대한 개별 스레드를 일시 중단하는 대신 애플리케이션은 각 개체에 대한 알림 루틴을 등록할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-743">For example, instead of having separate threads suspend for a queue message, event flags, and a semaphore, the application can register a notification routine for each object.</span></span> <span data-ttu-id="13920-744">호출되면 애플리케이션 알림 루틴은 단일 스레드를 재개할 수 있습니다. 그러면 각 개체를 조사하여 새 이벤트를 찾아서 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-744">When invoked, the application notification routine can then resume a single thread, which can interrogate each object to find and process the new event.</span></span>

<span data-ttu-id="13920-745">일반적으로 이벤트 연결(*event-chaining*)은 스레드 수, 오버헤드, RAM 요구 사항을 줄입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-745">In general, *event-chaining* results in fewer threads, less overhead, and smaller RAM requirements.</span></span> <span data-ttu-id="13920-746">또한 복잡한 시스템의 동기화 요구 사항을 처리할 수 있는 매우 유연한 메커니즘을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-746">It also provides a highly flexible mechanism to handle synchronization requirements of more complex systems.</span></span>

### <a name="run-time-event-flags-performance-information"></a><span data-ttu-id="13920-747">런타임 이벤트 플래그 성능 정보</span><span class="sxs-lookup"><span data-stu-id="13920-747">Run-time Event Flags Performance Information</span></span>

<span data-ttu-id="13920-748">ThreadX는 선택적 런타임 이벤트 플래그 성능 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-748">ThreadX provides optional run-time event flags performance information.</span></span> <span data-ttu-id="13920-749">ThreadX 라이브러리 및 애플리케이션이 **TX_EVENT_FLAGS_ENABLE_PERFORMANCE_INFO** 가 정의된 상태로 빌드되면 ThreadX는 다음 정보를 누적합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-749">If the ThreadX library and application is built with **TX_EVENT_FLAGS_ENABLE_PERFORMANCE_INFO** defined, ThreadX accumulates the following information.</span></span>

<span data-ttu-id="13920-750">전체 시스템의 다음에 대한 총 수:</span><span class="sxs-lookup"><span data-stu-id="13920-750">Total number for the overall system:</span></span>

  - <span data-ttu-id="13920-751">이벤트 플래그 설정</span><span class="sxs-lookup"><span data-stu-id="13920-751">event flags sets</span></span>

  - <span data-ttu-id="13920-752">이벤트 플래그 get</span><span class="sxs-lookup"><span data-stu-id="13920-752">event flags gets</span></span>

  - <span data-ttu-id="13920-753">이벤트 플래그 get 일시 중단</span><span class="sxs-lookup"><span data-stu-id="13920-753">event flags get suspensions</span></span>

  - <span data-ttu-id="13920-754">이벤트 플래그 get 시간 제한</span><span class="sxs-lookup"><span data-stu-id="13920-754">event flags get timeouts</span></span>

<span data-ttu-id="13920-755">각 이벤트 플래그 그룹의 다음에 대한 총 수:</span><span class="sxs-lookup"><span data-stu-id="13920-755">Total number for each event flags group:</span></span>

  - <span data-ttu-id="13920-756">이벤트 플래그 설정</span><span class="sxs-lookup"><span data-stu-id="13920-756">event flags sets</span></span>

  - <span data-ttu-id="13920-757">이벤트 플래그 get</span><span class="sxs-lookup"><span data-stu-id="13920-757">event flags gets</span></span>

  - <span data-ttu-id="13920-758">이벤트 플래그 get 일시 중단</span><span class="sxs-lookup"><span data-stu-id="13920-758">event flags get suspensions</span></span>

  - <span data-ttu-id="13920-759">이벤트 플래그 get 시간 제한</span><span class="sxs-lookup"><span data-stu-id="13920-759">event flags get timeouts</span></span>

<span data-ttu-id="13920-760">이 정보는 ***tx_event_flags_performance_info_get** _ 및 _*_tx_event_flags_performance_system_info_get_\*_ 서비스를 통해 런타임에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-760">This information is available at run-time through the services ***tx_event_flags_performance_info_get** _ and _*_tx_event_flags_performance_system_info_get_\*_.</span></span> <span data-ttu-id="13920-761">이벤트 플래그 성능 정보는 애플리케이션이 제대로 작동하는지 확인하는 데 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-761">The performance information of event flags is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="13920-762">애플리케이션을 최적화하는데도 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-762">It is also useful in optimizing the application.</span></span> <span data-ttu-id="13920-763">예를 들어 _ *_tx_event_flags_get_*\* 서비스의 시간 제한 수가 상대적으로 높으면 이벤트 플래그 일시 중단 제한 시간이 너무 짧다는 표시일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-763">For example, a relatively high number of timeouts on the _ *_tx_event_flags_get_*\* service might suggest that the event flags suspension timeout is too short.</span></span>

### <a name="event-flags-group-control-block-tx_event_flags_group"></a><span data-ttu-id="13920-764">이벤트 플래그 그룹 제어 블록 TX_EVENT_FLAGS_GROUP</span><span class="sxs-lookup"><span data-stu-id="13920-764">Event Flags Group Control Block TX_EVENT_FLAGS_GROUP</span></span>

<span data-ttu-id="13920-765">각 이벤트 플래그 그룹의 특징은 해당 제어 블록에서 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-765">The characteristics of each event flags group are found in its control block.</span></span> <span data-ttu-id="13920-766">여기에는 현재 이벤트 플래그 설정 및 이벤트에 대해 일시 중단된 스레드 수와 같은 정보가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-766">It contains information such as the current event flags settings and the number of threads suspended for events.</span></span> <span data-ttu-id="13920-767">이 구조는 ***tx_api.h*** 파일에 정의되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-767">This structure is defined in the ***tx_api.h*** file.</span></span>

<span data-ttu-id="13920-768">이벤트 그룹 제어 블록은 메모리의 어디에나 위치할 수 있지만 제어 블록을 모든 함수의 범위 밖에 정의하여 전역 구조로 만드는 것이 가장 일반적입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-768">Event group control blocks can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="memory-block-pools"></a><span data-ttu-id="13920-769">메모리 블록 풀</span><span class="sxs-lookup"><span data-stu-id="13920-769">Memory Block Pools</span></span>

<span data-ttu-id="13920-770">실시간 애플리케이션에서 빠르고 결정적인 방식으로 메모리를 할당하는 것은 항상 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-770">Allocating memory in a fast and deterministic manner is always a challenge in real-time applications.</span></span> <span data-ttu-id="13920-771">이 점을 고려하여, ThreadX는 다수의 고정 크기 메모리 블록 풀을 만들고 관리하는 기능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-771">With this in mind, ThreadX provides the ability to create and manage multiple pools of fixed-size memory blocks.</span></span>

<span data-ttu-id="13920-772">메모리 블록 풀은 고정 크기 블록으로 구성되기 때문에 조각화 문제가 전혀 없습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-772">Because memory block pools consist of fixed-size blocks, there are never any fragmentation problems.</span></span> <span data-ttu-id="13920-773">물론, 조각화는 본질적으로 비결정적 동작을 유발합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-773">Of course, fragmentation causes behavior that is inherently nondeterministic.</span></span> <span data-ttu-id="13920-774">또한 고정 크기의 메모리 블록을 할당하고 해제하는 데 필요한 시간은 간단한 연결된 목록을 조작하는 시간과 유사 합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-774">In addition, the time required to allocate and free a fixed-size memory block is comparable to that of simple linked-list manipulation.</span></span> <span data-ttu-id="13920-775">또한 메모리 블록 할당 및 할당 취소는 사용 가능한 목록의 헤드에서 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-775">Furthermore, memory block allocation and de-allocation is done at the head of the available list.</span></span> <span data-ttu-id="13920-776">이렇게 하면 가능한 가장 빠른 연결된 목록 처리가 제공되며 실제 메모리 블록을 캐시에 유지하는 데 유용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-776">This provides the fastest possible linked list processing and might help keep the actual memory block in cache.</span></span>

<span data-ttu-id="13920-777">유연성 부족은 고정 크기 메모리 풀의 주요 단점입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-777">Lack of flexibility is the main drawback of fixed-size memory pools.</span></span> <span data-ttu-id="13920-778">풀의 블록 크기는 사용자에 대한 최악의 경우 메모리 요구 사항을 처리할 수 있을 만큼 충분히 커야 합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-778">The block size of a pool must be large enough to handle the worst case memory requirements of its users.</span></span> <span data-ttu-id="13920-779">물론 동일한 풀에 서로 다른 크기의 메모리 요청이 많이 발생하면 메모리가 낭비될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-779">Of course, memory may be wasted if many different size memory requests are made to the same pool.</span></span> <span data-ttu-id="13920-780">가능한 해결 방법은 서로 다른 크기의 메모리 블록을 포함하는 몇 가지 다른 메모리 블록 풀을 만드는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-780">A possible solution is to make several different memory block pools that contain different sized memory blocks.</span></span>

<span data-ttu-id="13920-781">각 메모리 블록 풀은 공용 리소스입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-781">Each memory block pool is a public resource.</span></span> <span data-ttu-id="13920-782">ThreadX는 풀이 사용되는 방식에 제약 조건을 두지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-782">ThreadX places no constraints on how pools are used.</span></span>

### <a name="creating-memory-block-pools"></a><span data-ttu-id="13920-783">메모리 블록 풀 만들기</span><span class="sxs-lookup"><span data-stu-id="13920-783">Creating Memory Block Pools</span></span>

<span data-ttu-id="13920-784">메모리 블록 풀은 초기화 중에 또는 애플리케이션 스레드에서 런타임 중에 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-784">Memory block pools are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="13920-785">애플리케이션의 메모리 블록 풀 수에는 제한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-785">There is no limit on the number of memory block pools in an application.</span></span>

### <a name="memory-block-size"></a><span data-ttu-id="13920-786">메모리 블록 크기</span><span class="sxs-lookup"><span data-stu-id="13920-786">Memory Block Size</span></span>

<span data-ttu-id="13920-787">앞서 언급했듯이 메모리 블록 풀에는 여러 고정 크기 블록이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-787">As mentioned earlier, memory block pools contain a number of fixed-size blocks.</span></span> <span data-ttu-id="13920-788">블록 크기(바이트 단위)는 풀을 만드는 동안 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-788">The block size, in bytes, is specified during creation of the pool.</span></span>

> [!NOTE]
> <span data-ttu-id="13920-789">*ThreadX는 풀의 각 메모리 블록에 적은 양의 오버헤드(C 포인터의 크기)를 추가합니다. 또한 ThreadX는 각 메모리 블록의 시작을 적절한 정렬로 유지하기 위해 블록 크기를 채워야 할 수 있습니다.*</span><span class="sxs-lookup"><span data-stu-id="13920-789">*ThreadX adds a small amount of overhead—the size of a C pointer—to each memory block in the pool. In addition, ThreadX might have to pad the block size to keep the beginning of each memory block on proper alignment.*</span></span>

### <a name="pool-capacity"></a><span data-ttu-id="13920-790">풀 용량</span><span class="sxs-lookup"><span data-stu-id="13920-790">Pool Capacity</span></span>

<span data-ttu-id="13920-791">풀의 메모리 블록 수는 블록 크기 및 생성 중에 제공된 메모리 영역의 총 바이트 수의 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-791">The number of memory blocks in a pool is a function of the block size and the total number of bytes in the memory area supplied during creation.</span></span> <span data-ttu-id="13920-792">풀 용량은 블록 크기(패딩 및 포인터 오버헤드 바이트 포함)를 제공된 메모리 영역의 총 바이트 수로 나누어 계산합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-792">The capacity of a pool is calculated by dividing the block size (including padding and the pointer overhead bytes) into the total number of bytes in the supplied memory area.</span></span>

### <a name="pools-memory-area"></a><span data-ttu-id="13920-793">풀의 메모리 영역</span><span class="sxs-lookup"><span data-stu-id="13920-793">Pool's Memory Area</span></span>

<span data-ttu-id="13920-794">앞서 언급했듯이 블록 풀의 메모리 영역은 생성 중에 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-794">As mentioned before, the memory area for the block pool is specified during creation.</span></span> <span data-ttu-id="13920-795">ThreadX의 다른 메모리 영역과 마찬가지로 대상 주소 공간의 어디에나 위치할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-795">Like other memory areas in ThreadX, it can be located anywhere in the target's address space.</span></span>

<span data-ttu-id="13920-796">이것은 상당한 유연성을 제공하기 때문에 중요한 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-796">This is an important feature because of the considerable flexibility it provides.</span></span> <span data-ttu-id="13920-797">예를 들어, 통신 제품에 I/O를 위한 고속 메모리 영역이 있다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-797">For example, suppose that a communication product has a highspeed memory area for I/O.</span></span> <span data-ttu-id="13920-798">이 메모리 영역을 ThreadX 메모리 블록 풀로 만들어서 쉽게 관리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-798">This memory area is easily managed by making it into a ThreadX memory block pool.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="13920-799">스레드 일시 중단</span><span class="sxs-lookup"><span data-stu-id="13920-799">Thread Suspension</span></span>

<span data-ttu-id="13920-800">빈 풀에서 메모리 블록을 기다리는 동안 애플리케이션 스레드가 일시 중단될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-800">Application threads can suspend while waiting for a memory block from an empty pool.</span></span> <span data-ttu-id="13920-801">블록이 풀로 반환되면 일시 중단된 스레드에 이 블록이 주어지고 스레드가 재개됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-801">When a block is returned to the pool, the suspended thread is given this block and the thread is resumed.</span></span>

<span data-ttu-id="13920-802">여러 스레드가 동일한 메모리 블록 풀에서 일시 중단되면 일시 중단된 순서대로(FIFO) 재개됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-802">If multiple threads are suspended on the same memory block pool, they are resumed in the order they were suspended (FIFO).</span></span>

<span data-ttu-id="13920-803">하지만 스레드 일시 중단을 해제하는 블록 릴리스 호출 전에 애플리케이션이 ***tx_block_pool_prioritize*** 를 호출하는 경우에도 우선 순위 재개가 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-803">However, priority resumption is also possible if the application calls ***tx_block_pool_prioritize*** prior to the block release call that lifts thread suspension.</span></span> <span data-ttu-id="13920-804">블록 풀 우선 순위 지정 서비스는 우선 순위가 가장 높은 스레드를 일시 중단 목록의 맨 앞에 배치하고 다른 모든 일시 중단된 스레드는 동일한 FIFO 순서를 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-804">The block pool prioritize service places the highest priority thread at the front of the suspension list, while leaving all other suspended threads in the same FIFO order.</span></span>

### <a name="run-time-block-pool-performance-information"></a><span data-ttu-id="13920-805">런타임 블록 풀 성능 정보</span><span class="sxs-lookup"><span data-stu-id="13920-805">Run-time Block Pool Performance Information</span></span>

<span data-ttu-id="13920-806">ThreadX는 선택적 런타임 블록 풀 성능 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-806">ThreadX provides optional run-time block pool performance information.</span></span> <span data-ttu-id="13920-807">ThreadX 라이브러리 및 애플리케이션이 **TX_BLOCK_POOL_ENABLE_PERFORMANCE_INFO** 가 정의된 상태로 빌드되면 ThreadX는 다음 정보를 누적합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-807">If the ThreadX library and application is built with **TX_BLOCK_POOL_ENABLE_PERFORMANCE_INFO** defined, ThreadX accumulates the following information.</span></span>

<span data-ttu-id="13920-808">전체 시스템의 다음에 대한 총 수:</span><span class="sxs-lookup"><span data-stu-id="13920-808">Total number for the overall system:</span></span>

  - <span data-ttu-id="13920-809">할당된 블록</span><span class="sxs-lookup"><span data-stu-id="13920-809">blocks allocated</span></span>

  - <span data-ttu-id="13920-810">해제된 블록</span><span class="sxs-lookup"><span data-stu-id="13920-810">blocks released</span></span>

  - <span data-ttu-id="13920-811">할당 일시 중단</span><span class="sxs-lookup"><span data-stu-id="13920-811">allocation suspensions</span></span>

  - <span data-ttu-id="13920-812">할당 시간 제한</span><span class="sxs-lookup"><span data-stu-id="13920-812">allocation timeouts</span></span>

<span data-ttu-id="13920-813">각 블록 풀의 다음에 대한 총 수:</span><span class="sxs-lookup"><span data-stu-id="13920-813">Total number for each block pool:</span></span>

  - <span data-ttu-id="13920-814">할당된 블록</span><span class="sxs-lookup"><span data-stu-id="13920-814">blocks allocated</span></span>

  - <span data-ttu-id="13920-815">해제된 블록</span><span class="sxs-lookup"><span data-stu-id="13920-815">blocks released</span></span>

  - <span data-ttu-id="13920-816">할당 일시 중단</span><span class="sxs-lookup"><span data-stu-id="13920-816">allocation suspensions</span></span>

  - <span data-ttu-id="13920-817">할당 시간 제한</span><span class="sxs-lookup"><span data-stu-id="13920-817">allocation timeouts</span></span>

<span data-ttu-id="13920-818">이 정보는 ***tx_block_pool_performance_info_get** _ 및 _*_tx_block_pool_performance_system_info_get_\*\* 서비스를 통해 런타임에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-818">This information is available at run-time through the services ***tx_block_pool_performance_info_get** _ and _*_tx_block_pool_performance_system_info_get_\*\*.</span></span> <span data-ttu-id="13920-819">블록 풀 성능 정보는 애플리케이션이 제대로 작동하는지 확인하는 데 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-819">Block pool performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="13920-820">애플리케이션을 최적화하는데도 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-820">It is also useful in optimizing the application.</span></span> <span data-ttu-id="13920-821">예를 들어 "할당 일시 중단"의 수가 상대적으로 높으면 블록 풀이 너무 작다는 표시일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-821">For example, a relatively high number of "allocation suspensions" might suggest that the block pool is too small.</span></span>

### <a name="memory-block-pool-control-block-tx_block_pool"></a><span data-ttu-id="13920-822">메모리 블록 풀 제어 블록 TX_BLOCK_POOL</span><span class="sxs-lookup"><span data-stu-id="13920-822">Memory Block Pool Control Block TX_BLOCK_POOL</span></span>

<span data-ttu-id="13920-823">각 메모리 블록 풀의 특징은 해당 제어 블록에서 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-823">The characteristics of each memory block pool are found in its control block.</span></span> <span data-ttu-id="13920-824">여기에는 사용 가능한 메모리 블록 수 및 메모리 풀 블록 크기와 같은 정보가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-824">It contains information such as the number of memory blocks available and the memory pool block size.</span></span> <span data-ttu-id="13920-825">이 구조는 ***tx_api.h*** 파일에 정의되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-825">This structure is defined in the ***tx_api.h*** file.</span></span>

<span data-ttu-id="13920-826">풀 제어 블록은 메모리의 어디에나 위치할 수 있지만 제어 블록을 모든 함수의 범위 밖에 정의하여 전역 구조로 만드는 것이 가장 일반적입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-826">Pool control blocks can also be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="overwriting-memory-blocks"></a><span data-ttu-id="13920-827">메모리 블록 덮어쓰기</span><span class="sxs-lookup"><span data-stu-id="13920-827">Overwriting Memory Blocks</span></span>

<span data-ttu-id="13920-828">할당된 메모리 블록의 사용자가 경계 외부에 쓰지 않도록 하는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-828">It is important to ensure that the user of an allocated memory block does not write outside its boundaries.</span></span> <span data-ttu-id="13920-829">만약 그렇게 되면 인접한(일반적으로 후속) 메모리 영역에서 손상이 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-829">If this happens, corruption occurs in an adjacent (usually subsequent) memory area.</span></span> <span data-ttu-id="13920-830">결과는 예측할 수 없으며, 애플리케이션에 치명적인 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-830">The results are unpredictable and often fatal to the application.</span></span>

## <a name="memory-byte-pools"></a><span data-ttu-id="13920-831">메모리 바이트 풀</span><span class="sxs-lookup"><span data-stu-id="13920-831">Memory Byte Pools</span></span>

<span data-ttu-id="13920-832">ThreadX 메모리 바이트 풀은 표준 C 힙과 비슷합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-832">ThreadX memory byte pools are similar to a standard C heap.</span></span> <span data-ttu-id="13920-833">표준 C 힙과 달리 여러 메모리 바이트 풀을 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-833">Unlike the standard C heap, it is possible to have multiple memory byte pools.</span></span> <span data-ttu-id="13920-834">또한 요청된 메모리를 사용할 수 있을 때까지 스레드가 풀에서 일시 중단될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-834">In addition, threads can suspend on a pool until the requested memory is available.</span></span>

<span data-ttu-id="13920-835">메모리 바이트 풀의 할당은 기존 \***malloc** _ 호출과 유사하며 여기에는 원하는 메모리 크기(바이트)가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-835">Allocations from memory byte pools are similar to traditional \***malloc** _ calls, which include the amount of memory desired (in bytes).</span></span> <span data-ttu-id="13920-836">메모리는 최초 적합(_first-fit\*) 방식으로 풀에서 할당됩니다. 즉, 요청을 충족하는 첫 번째 사용 가능 메모리 블록이 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-836">Memory is allocated from the pool in a _first-fit\* manner; i.e., the first free memory block that satisfies the request is used.</span></span> <span data-ttu-id="13920-837">이 블록에서 초과하는 메모리는 새 블록으로 변환되어 사용 가능한 메모리 목록에 다시 배치됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-837">Excess memory from this block is converted into a new block and placed back in the free memory list.</span></span> <span data-ttu-id="13920-838">이 프로세스를 조각화(*fragmentation*)라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-838">This process is called *fragmentation*.</span></span>

<span data-ttu-id="13920-839">사용 가능한 인접 메모리 블록은 충분히 큰 여유 메모리 블록에 대한 후속 할당 검색 중에 함께 *병합* 됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-839">Adjacent free memory blocks are *merged* together during a subsequent allocation search for a large enough free memory block.</span></span> <span data-ttu-id="13920-840">이 프로세스를 조각 모음(*defragmentation*)이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-840">This process is called *defragmentation*.</span></span>

<span data-ttu-id="13920-841">각 메모리 바이트 풀은 공용 리소스입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-841">Each memory byte pool is a public resource.</span></span> <span data-ttu-id="13920-842">ThreadX는 ISR에서 메모리 바이트 서비스를 호출할 수 없다는 점을 제외하고, 풀이 사용되는 방식에 제약 조건을 두지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-842">ThreadX places no constraints on how pools are used, except that memory byte services cannot be called from ISRs.</span></span>

### <a name="creating-memory-byte-pools"></a><span data-ttu-id="13920-843">메모리 바이트 풀 만들기</span><span class="sxs-lookup"><span data-stu-id="13920-843">Creating Memory Byte Pools</span></span>

<span data-ttu-id="13920-844">메모리 바이트 풀은 초기화 중에 또는 애플리케이션 스레드에서 런타임 중에 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-844">Memory byte pools are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="13920-845">애플리케이션의 메모리 바이트 풀 수에는 제한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-845">There is no limit on the number of memory byte pools in an application.</span></span>

### <a name="pool-capacity"></a><span data-ttu-id="13920-846">풀 용량</span><span class="sxs-lookup"><span data-stu-id="13920-846">Pool Capacity</span></span>

<span data-ttu-id="13920-847">메모리 바이트 풀에서 할당 가능한 바이트 수는 생성 중에 지정된 것보다 약간 적습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-847">The number of allocatable bytes in a memory byte pool is slightly less than what was specified during creation.</span></span> <span data-ttu-id="13920-848">여유 메모리 영역을 관리하면 약간의 오버헤드가 발생하기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-848">This is because management of the free memory area introduces some overhead.</span></span> <span data-ttu-id="13920-849">풀의 사용 가능한 각 메모리 블록에는 오버헤드의 두 C 포인터에 해당하는 것이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-849">Each free memory block in the pool requires the equivalent of two C pointers of overhead.</span></span> <span data-ttu-id="13920-850">또한 풀은 두 개의 블록, 즉 큰 여유 블록과 메모리 영역 끝에 영구 할당된 작은 블록으로 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="13920-850">In addition, the pool is created with two blocks, a large free block and a small permanently allocated block at the end of the memory area.</span></span> <span data-ttu-id="13920-851">이렇게 할당된 블록은 할당 알고리즘의 성능을 높이는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-851">This allocated block is used to improve performance of the allocation algorithm.</span></span> <span data-ttu-id="13920-852">병합하는 동안 풀 영역의 끝을 지속적으로 확인하지 않아도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-852">It eliminates the need to continuously check for the end of the pool area during merging.</span></span>

<span data-ttu-id="13920-853">런타임 중에는 풀의 오버헤드 크기가 일반적으로 증가합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-853">During run-time, the amount of overhead in the pool typically increases.</span></span> <span data-ttu-id="13920-854">다음 메모리 블록의 적절한 정렬을 보장하기 위해 홀수 바이트 할당이 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="13920-854">Allocations of an odd number of bytes are padded to ensure proper alignment of the next memory block.</span></span> <span data-ttu-id="13920-855">또한 풀 조각화가 더 진행될수록 오버헤드는 증가합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-855">In addition, overhead increases as the pool becomes more fragmented.</span></span>

### <a name="pools-memory-area"></a><span data-ttu-id="13920-856">풀의 메모리 영역</span><span class="sxs-lookup"><span data-stu-id="13920-856">Pool's Memory Area</span></span>

<span data-ttu-id="13920-857">메모리 바이트 풀의 메모리 영역은 생성 중에 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-857">The memory area for a memory byte pool is specified during creation.</span></span> <span data-ttu-id="13920-858">ThreadX의 다른 메모리 영역과 마찬가지로 대상 주소 공간의 어디에나 위치할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-858">Like other memory areas in ThreadX, it can be located anywhere in the target's address space.</span></span> <span data-ttu-id="13920-859">이것은 상당한 유연성을 제공하기 때문에 중요한 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-859">This is an important feature because of the considerable flexibility it provides.</span></span> <span data-ttu-id="13920-860">예를 들어 대상 하드웨어에 고속 메모리 영역과 저속 메모리 영역이 있는 경우 사용자는 각 영역에 풀을 생성하여 두 영역에 대한 메모리 할당을 관리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-860">For example, if the target hardware has a high-speed memory area and a low-speed memory area, the user can manage memory allocation for both areas by creating a pool in each of them.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="13920-861">스레드 일시 중단</span><span class="sxs-lookup"><span data-stu-id="13920-861">Thread Suspension</span></span>

<span data-ttu-id="13920-862">풀의 메모리 바이트를 기다리는 동안 애플리케이션 스레드가 일시 중단될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-862">Application threads can suspend while waiting for memory bytes from a pool.</span></span> <span data-ttu-id="13920-863">충분한 연속 메모리를 사용할 수 있게 되면 일시 중단된 스레드에 요청된 메모리가 제공되고 스레드가 재개됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-863">When sufficient contiguous memory becomes available, the suspended threads are given their requested memory and the threads are resumed.</span></span>

<span data-ttu-id="13920-864">여러 스레드가 동일한 메모리 바이트 풀에서 일시 중단되면 일시 중단된 순서대로(FIFO) 메모리가 주어집니다.</span><span class="sxs-lookup"><span data-stu-id="13920-864">If multiple threads are suspended on the same memory byte pool, they are given memory (resumed) in the order they were suspended (FIFO).</span></span>

<span data-ttu-id="13920-865">하지만 스레드 일시 중단을 해제하는 바이트 릴리스 호출 전에 애플리케이션이 ***tx_byte_pool_prioritize*** 를 호출하는 경우에도 우선 순위 재개가 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-865">However, priority resumption is also possible if the application calls ***tx_byte_pool_prioritize*** prior to the byte release call that lifts thread suspension.</span></span> <span data-ttu-id="13920-866">바이트 풀 우선 순위 지정 서비스는 우선 순위가 가장 높은 스레드를 일시 중단 목록의 맨 앞에 배치하고 다른 모든 일시 중단된 스레드는 동일한 FIFO 순서를 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-866">The byte pool prioritize service places the highest priority thread at the front of the suspension list, while leaving all other suspended threads in the same FIFO order.</span></span>

### <a name="run-time-byte-pool-performance-information"></a><span data-ttu-id="13920-867">런타임 바이트 풀 성능 정보</span><span class="sxs-lookup"><span data-stu-id="13920-867">Run-time Byte Pool Performance Information</span></span>

<span data-ttu-id="13920-868">ThreadX는 선택적 런타임 바이트 풀 성능 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-868">ThreadX provides optional run-time byte pool performance information.</span></span> <span data-ttu-id="13920-869">ThreadX 라이브러리 및 애플리케이션이 ***TX_BYTE_POOL_ENABLE_PERFORMANCE_INFO*** 가 정의된 상태로 빌드되면 ThreadX는 다음 정보를 누적합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-869">If the ThreadX library and application is built with ***TX_BYTE_POOL_ENABLE_PERFORMANCE_INFO*** defined, ThreadX accumulates the following information.</span></span>

<span data-ttu-id="13920-870">전체 시스템의 다음에 대한 총 수:</span><span class="sxs-lookup"><span data-stu-id="13920-870">Total number for the overall system:</span></span>

  - <span data-ttu-id="13920-871">할당</span><span class="sxs-lookup"><span data-stu-id="13920-871">allocations</span></span>

  - <span data-ttu-id="13920-872">릴리스</span><span class="sxs-lookup"><span data-stu-id="13920-872">releases</span></span>

  - <span data-ttu-id="13920-873">검색된 조각</span><span class="sxs-lookup"><span data-stu-id="13920-873">fragments searched</span></span>

  - <span data-ttu-id="13920-874">병합된 조각</span><span class="sxs-lookup"><span data-stu-id="13920-874">fragments merged</span></span>

  - <span data-ttu-id="13920-875">생성된 조각</span><span class="sxs-lookup"><span data-stu-id="13920-875">fragments created</span></span>

  - <span data-ttu-id="13920-876">할당 일시 중단</span><span class="sxs-lookup"><span data-stu-id="13920-876">allocation suspensions</span></span>

  - <span data-ttu-id="13920-877">할당 시간 제한</span><span class="sxs-lookup"><span data-stu-id="13920-877">allocation timeouts</span></span>

<span data-ttu-id="13920-878">각 바이트 풀의 다음에 대한 총 수:</span><span class="sxs-lookup"><span data-stu-id="13920-878">Total number for each byte pool:</span></span>

  - <span data-ttu-id="13920-879">할당</span><span class="sxs-lookup"><span data-stu-id="13920-879">allocations</span></span>

  - <span data-ttu-id="13920-880">릴리스</span><span class="sxs-lookup"><span data-stu-id="13920-880">releases</span></span>

  - <span data-ttu-id="13920-881">검색된 조각</span><span class="sxs-lookup"><span data-stu-id="13920-881">fragments searched</span></span>

  - <span data-ttu-id="13920-882">병합된 조각</span><span class="sxs-lookup"><span data-stu-id="13920-882">fragments merged</span></span>

  - <span data-ttu-id="13920-883">생성된 조각</span><span class="sxs-lookup"><span data-stu-id="13920-883">fragments created</span></span>

  - <span data-ttu-id="13920-884">할당 일시 중단</span><span class="sxs-lookup"><span data-stu-id="13920-884">allocation suspensions</span></span>

  - <span data-ttu-id="13920-885">할당 시간 제한</span><span class="sxs-lookup"><span data-stu-id="13920-885">allocation timeouts</span></span>

<span data-ttu-id="13920-886">이 정보는 ***tx_byte_pool_performance_info_get** _ 및 _*_tx_byte_pool_performance_system_info_get_\*\* 서비스를 통해 런타임에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-886">This information is available at run-time through the services ***tx_byte_pool_performance_info_get** _ and _*_tx_byte_pool_performance_system_info_get_\*\*.</span></span> <span data-ttu-id="13920-887">바이트 풀 성능 정보는 애플리케이션이 제대로 작동하는지 확인하는 데 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-887">Byte pool performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="13920-888">애플리케이션을 최적화하는데도 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-888">It is also useful in optimizing the application.</span></span> <span data-ttu-id="13920-889">예를 들어 "할당 일시 중단"의 수가 상대적으로 높으면 바이트 풀이 너무 작다는 표시일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-889">For example, a relatively high number of "allocation suspensions" might suggest that the byte pool is too small.</span></span>

### <a name="memory-byte-pool-control-block-tx_byte_pool"></a><span data-ttu-id="13920-890">메모리 바이트 풀 제어 블록 TX_BYTE_POOL</span><span class="sxs-lookup"><span data-stu-id="13920-890">Memory Byte Pool Control Block TX_BYTE_POOL</span></span>

<span data-ttu-id="13920-891">각 메모리 바이트 풀의 특징은 해당 제어 블록에서 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-891">The characteristics of each memory byte pool are found in its control block.</span></span> <span data-ttu-id="13920-892">여기에는 풀에서 사용 가능한 바이트 수와 같은 유용한 정보가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-892">It contains useful information such as the number of available bytes in the pool.</span></span> <span data-ttu-id="13920-893">이 구조는 ***tx_api.h*** 파일에 정의되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-893">This structure is defined in the ***tx_api.h*** file.</span></span>

<span data-ttu-id="13920-894">풀 제어 블록은 메모리의 어디에나 위치할 수 있지만 제어 블록을 모든 함수의 범위 밖에 정의하여 전역 구조로 만드는 것이 가장 일반적입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-894">Pool control blocks can also be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="nondeterministic-behavior"></a><span data-ttu-id="13920-895">비결정적 동작</span><span class="sxs-lookup"><span data-stu-id="13920-895">Nondeterministic Behavior</span></span>

<span data-ttu-id="13920-896">메모리 바이트 풀은 가장 유연한 메모리 할당을 제공하지만 다소 비결정적 동작으로 인해 어려움이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-896">Although memory byte pools provide the most flexible memory allocation, they also suffer from somewhat nondeterministic behavior.</span></span> <span data-ttu-id="13920-897">예를 들어, 메모리 바이트 풀은 2,000바이트의 사용 가능 메모리를 가질 수 있지만 1,000 바이트의 할당 요청을 충족하지 못할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-897">For example, a memory byte pool may have 2,000 bytes of memory available but may not be able to satisfy an allocation request of 1,000 bytes.</span></span> <span data-ttu-id="13920-898">사용 가능한 바이트 중 얼마나 많은 바이트가 연속 바이트인지에 대한 보장이 없기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-898">This is because there are no guarantees on how many of the free bytes are contiguous.</span></span> <span data-ttu-id="13920-899">1,000바이트의 여유 블록이 있어도 블록을 찾는 데 시간이 얼마나 걸릴지에 대한 보장은 없습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-899">Even if a 1,000 byte free block exists, there are no guarantees on how long it might take to find the block.</span></span> <span data-ttu-id="13920-900">1,000바이트 블록을 찾기 위해 전체 메모리 풀을 검색해야 할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-900">It is completely possible that the entire memory pool would need to be searched to find the 1,000 byte block.</span></span>

> [!TIP]
> <span data-ttu-id="13920-901">*메모리 바이트 풀의 비결정적 동작의 결과로, 일반적으로 결정적이며 실시간 동작이 필요한 영역에서는 메모리 바이트 서비스를 사용하지 않는 것이 좋습니다. 많은 애플리케이션이 초기화 또는 런타임 구성 중에 필요한 메모리를 미리 할당합니다.*</span><span class="sxs-lookup"><span data-stu-id="13920-901">*As a result of the nondeterministic behavior of memory byte pools, it is generally good practice to avoid using memory byte services in areas where deterministic, real-time behavior is required. Many applications pre-allocate their required memory during initialization or run-time configuration.*</span></span>

### <a name="overwriting-memory-blocks"></a><span data-ttu-id="13920-902">메모리 블록 덮어쓰기</span><span class="sxs-lookup"><span data-stu-id="13920-902">Overwriting Memory Blocks</span></span>

<span data-ttu-id="13920-903">할당된 메모리의 사용자가 경계 외부에 쓰지 않도록 하는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-903">It is important to ensure that the user of allocated memory does not write outside its boundaries.</span></span> <span data-ttu-id="13920-904">만약 그렇게 되면 인접한(일반적으로 후속) 메모리 영역에서 손상이 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-904">If this happens, corruption occurs in an adjacent (usually subsequent) memory area.</span></span> <span data-ttu-id="13920-905">결과는 예측할 수 없으며, 프로그램 실행에 치명적인 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-905">The results are unpredictable and often catastrophic for program execution.</span></span>

## <a name="application-timers"></a><span data-ttu-id="13920-906">애플리케이션 타이머</span><span class="sxs-lookup"><span data-stu-id="13920-906">Application Timers</span></span>

<span data-ttu-id="13920-907">비동기 외부 이벤트에 대한 빠른 응답은 내장된 실시간 애플리케이션의 가장 중요한 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-907">Fast response to asynchronous external events is the most important function of real-time, embedded applications.</span></span> <span data-ttu-id="13920-908">하지만 이러한 애플리케이션은 대부분 미리 결정된 시간 간격으로 특정 작업을 수행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-908">However, many of these applications must also perform certain activities at predetermined intervals of time.</span></span>

<span data-ttu-id="13920-909">ThreadX 애플리케이션 타이머는 애플리케이션에 특정 시간 간격으로 애플리케이션 C 함수를 실행할 수 있는 기능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-909">ThreadX application timers provide applications with the ability to execute application C functions at specific intervals of time.</span></span> <span data-ttu-id="13920-910">애플리케이션 타이머가 한 번만 만료될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-910">It is also possible for an application timer to expire only once.</span></span> <span data-ttu-id="13920-911">이러한 형식의 타이머를 원샷 타이머(*one-shot timer*)라고 하고 반복 간격 타이머는 주기적 타이머(*periodic timers*)라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-911">This type of timer is called a *one-shot timer*, while repeating interval timers are called *periodic timers*.</span></span>

<span data-ttu-id="13920-912">각 애플리케이션 타이머는 공용 리소스입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-912">Each application timer is a public resource.</span></span> <span data-ttu-id="13920-913">ThreadX는 애플리케이션 타이머가 사용되는 방식에 제약 조건을 두지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-913">ThreadX places no constraints on how application timers are used.</span></span>

### <a name="timer-intervals"></a><span data-ttu-id="13920-914">타이머 간격</span><span class="sxs-lookup"><span data-stu-id="13920-914">Timer Intervals</span></span>

<span data-ttu-id="13920-915">ThreadX에서 시간 간격은 주기적인 타이머 인터럽트로 측정됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-915">In ThreadX time intervals are measured by periodic timer interrupts.</span></span> <span data-ttu-id="13920-916">각 타이머 인터럽트를 타이머 *틱* 이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-916">Each timer interrupt is called a timer *tick*.</span></span> <span data-ttu-id="13920-917">타이머 틱 사이의 실제 시간은 애플리케이션에서 지정되지만 대부분의 구현에서는 10ms입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-917">The actual time between timer ticks is specified by the application, but 10ms is the norm for most implementations.</span></span> <span data-ttu-id="13920-918">주기적 타이머 설정은 일반적으로 ***tx_initialize_low_level*** 어셈블리 파일에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-918">The periodic timer setup is typically found in the ***tx_initialize_low_level*** assembly file.</span></span>

<span data-ttu-id="13920-919">기본 하드웨어는 애플리케이션 타이머가 작동하기 위해 주기적인 인터럽트를 생성할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-919">It is worth mentioning that the underlying hardware must have the ability to generate periodic interrupts for application timers to function.</span></span> <span data-ttu-id="13920-920">프로세서에 주기적인 인터럽트 기능이 기본 제공되는 경우가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-920">In some cases, the processor has a built-in periodic interrupt capability.</span></span> <span data-ttu-id="13920-921">프로세서에 이 기능이 없으면 사용자 보드에 주기적인 인터럽트를 생성할 수 있는 주변 장치가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-921">If the processor doesn't have this ability, the user's board must have a peripheral device that can generate periodic interrupts.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="13920-922">*ThreadX는 주기적인 인터럽트 원본 없이도 계속 작동할 수 있습니다. 그러나 모든 타이머 관련 처리는 사용 하지 않도록 설정됩니다. 여기에는 시간 조각화, 일시 중단 시간 제한 및 타이머 서비스가 포함됩니다.*</span><span class="sxs-lookup"><span data-stu-id="13920-922">*ThreadX can still function even without a periodic interrupt source. However, all timer-related processing is then disabled. This includes timeslicing, suspension time-outs, and timer services.*</span></span>

### <a name="timer-accuracy"></a><span data-ttu-id="13920-923">타이머 정확도</span><span class="sxs-lookup"><span data-stu-id="13920-923">Timer Accuracy</span></span>

<span data-ttu-id="13920-924">타이머 만료는 틱 단위로 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-924">Timer expirations are specified in terms of ticks.</span></span> <span data-ttu-id="13920-925">지정된 만료 값은 타이머 틱마다 1씩 감소합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-925">The specified expiration value is decreased by one on each timer tick.</span></span> <span data-ttu-id="13920-926">타이머 인터럽트(또는 타이머 틱) 직전에 애플리케이션 타이머를 사용하도록 설정할 수 있기 때문에 실제 만료 시간은 최대 1틱이 빠를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-926">Because an application timer could be enabled just prior to a timer interrupt (or timer tick), the actual expiration time could be up to one tick early.</span></span>

<span data-ttu-id="13920-927">타이머 틱 속도가 10ms이면 애플리케이션 타이머는 최대 10ms 일찍 만료될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-927">If the timer tick rate is 10ms, application timers may expire up to 10ms early.</span></span> <span data-ttu-id="13920-928">이것은 1초 타이머보다는 10ms 타이머에서 더 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-928">This is more significant for 10ms timers than 1 second timers.</span></span> <span data-ttu-id="13920-929">물론 타이머 인터럽트 빈도를 높이면 이러한 오차 범위가 줄어듭니다.</span><span class="sxs-lookup"><span data-stu-id="13920-929">Of course, increasing the timer interrupt frequency decreases this margin of error.</span></span>

### <a name="timer-execution"></a><span data-ttu-id="13920-930">타이머 실행</span><span class="sxs-lookup"><span data-stu-id="13920-930">Timer Execution</span></span>

<span data-ttu-id="13920-931">애플리케이션 타이머는 활성 상태가 되는 순서대로 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-931">Application timers execute in the order they become active.</span></span> <span data-ttu-id="13920-932">예를 들어 동일한 만료 값으로 세 개의 타이머를 생성하고 활성화하면 해당 만료 함수는 활성화된 순서대로 실행되도록 보장됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-932">For example, if three timers are created with the same expiration value and activated, their corresponding expiration functions are guaranteed to execute in the order they were activated.</span></span>

### <a name="creating-application-timers"></a><span data-ttu-id="13920-933">애플리케이션 타이머 만들기</span><span class="sxs-lookup"><span data-stu-id="13920-933">Creating Application Timers</span></span>

<span data-ttu-id="13920-934">애플리케이션 타이머는 초기화 중에 또는 애플리케이션 스레드에서 런타임 중에 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-934">Application timers are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="13920-935">애플리케이션의 애플리케이션 타이머 수에는 제한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-935">There is no limit on the number of application timers in an application.</span></span>

### <a name="run-time-application-timer-performance-information"></a><span data-ttu-id="13920-936">런타임 애플리케이션 타이머 성능 정보</span><span class="sxs-lookup"><span data-stu-id="13920-936">Run-time Application Timer Performance Information</span></span>

<span data-ttu-id="13920-937">ThreadX는 선택적 런타임 애플리케이션 타이머 성능 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-937">ThreadX provides optional run-time application timer performance information.</span></span> <span data-ttu-id="13920-938">ThreadX 라이브러리 및 애플리케이션이 **TX_TIMER_ENABLE_PERFORMANCE_INFO** 가 정의된 상태로 빌드되면 ThreadX는 다음 정보를 누적합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-938">If the ThreadX library and application are built with **TX_TIMER_ENABLE_PERFORMANCE_INFO** defined, ThreadX accumulates the following information.</span></span>

<span data-ttu-id="13920-939">전체 시스템의 다음에 대한 총 수:</span><span class="sxs-lookup"><span data-stu-id="13920-939">Total number for the overall system:</span></span>

- <span data-ttu-id="13920-940">활성화</span><span class="sxs-lookup"><span data-stu-id="13920-940">activations</span></span>

- <span data-ttu-id="13920-941">비활성화</span><span class="sxs-lookup"><span data-stu-id="13920-941">deactivations</span></span>

- <span data-ttu-id="13920-942">재활성화(주기적 타이머)</span><span class="sxs-lookup"><span data-stu-id="13920-942">reactivations (periodic timers)</span></span>

- <span data-ttu-id="13920-943">만료</span><span class="sxs-lookup"><span data-stu-id="13920-943">expirations</span></span>

- <span data-ttu-id="13920-944">만료 조정</span><span class="sxs-lookup"><span data-stu-id="13920-944">expiration adjustments</span></span>

<span data-ttu-id="13920-945">각 애플리케이션 타이머의 다음에 대한 총 수:</span><span class="sxs-lookup"><span data-stu-id="13920-945">Total number for each application timer:</span></span>

- <span data-ttu-id="13920-946">활성화</span><span class="sxs-lookup"><span data-stu-id="13920-946">activations</span></span>

- <span data-ttu-id="13920-947">비활성화</span><span class="sxs-lookup"><span data-stu-id="13920-947">deactivations</span></span>

- <span data-ttu-id="13920-948">재활성화(주기적 타이머)</span><span class="sxs-lookup"><span data-stu-id="13920-948">reactivations (periodic timers)</span></span>

- <span data-ttu-id="13920-949">만료</span><span class="sxs-lookup"><span data-stu-id="13920-949">expirations</span></span>

- <span data-ttu-id="13920-950">만료 조정</span><span class="sxs-lookup"><span data-stu-id="13920-950">expiration adjustments</span></span>

<span data-ttu-id="13920-951">이 정보는 ***tx_timer_performance_info_get** _ 및 _*_tx_timer_performance_system_info_get_\*\* 서비스를 통해 런타임에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-951">This information is available at run-time through the services ***tx_timer_performance_info_get** _ and _*_tx_timer_performance_system_info_get_\*\*.</span></span> <span data-ttu-id="13920-952">애플리케이션 타이머 성능 정보는 애플리케이션이 제대로 작동하는지 확인하는 데 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-952">Application Timer performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="13920-953">애플리케이션을 최적화하는데도 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-953">It is also useful in optimizing the application.</span></span>

### <a name="application-timer-control-block-tx_timer"></a><span data-ttu-id="13920-954">애플리케이션 타이머 제어 블록 TX_TIMER</span><span class="sxs-lookup"><span data-stu-id="13920-954">Application Timer Control Block TX_TIMER</span></span>

<span data-ttu-id="13920-955">각 애플리케이션 타이머의 특징은 해당 제어 블록에서 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-955">The characteristics of each application timer are found in its control block.</span></span> <span data-ttu-id="13920-956">여기에는 32비트 만료 식별 값과 같은 유용한 정보가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-956">It contains useful information such as the 32-bit expiration identification value.</span></span> <span data-ttu-id="13920-957">이 구조는 ***tx_api.h*** 파일에 정의되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-957">This structure is defined in the ***tx_api.h*** file.</span></span>

<span data-ttu-id="13920-958">애플리케이션 타이머 제어 블록은 메모리의 어디에나 위치할 수 있지만 제어 블록을 모든 함수의 범위 밖에 정의하여 전역 구조로 만드는 것이 가장 일반적입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-958">Application timer control blocks can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="excessive-timers"></a><span data-ttu-id="13920-959">과도한 타이머</span><span class="sxs-lookup"><span data-stu-id="13920-959">Excessive Timers</span></span>

<span data-ttu-id="13920-960">기본적으로 애플리케이션 타이머는 우선 순위 0에서 실행되는 숨겨진 시스템 스레드 내에서 실행되며, 이것은 일반적으로 애플리케이션 스레드보다 높습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-960">By default, application timers execute from within a hidden system thread that runs at priority zero, which is typically higher than any application thread.</span></span> <span data-ttu-id="13920-961">따라서 애플리케이션 타이머 내부 처리는 최소한으로 유지되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-961">Because of this, processing inside application timers should be kept to a minimum.</span></span>

<span data-ttu-id="13920-962">모든 타이머 틱이 만료되는 타이머를 가능하면 피하는 것도 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-962">It is also important to avoid, whenever possible, timers that expire every timer tick.</span></span> <span data-ttu-id="13920-963">이러한 상황은 애플리케이션에서 과도한 오버헤드를 유발할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-963">Such a situation might induce excessive overhead in the application.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="13920-964">*앞서 언급했듯이 애플리케이션 타이머는 숨겨진 시스템 스레드에서 실행됩니다. 따라서 애플리케이션 타이머의 만료 함수 내에서 만들어진 ThreadX 서비스 호출에서는 일시 중단을 선택하지 않는 것이 중요합니다.*</span><span class="sxs-lookup"><span data-stu-id="13920-964">*As mentioned previously, application timers are executed from a hidden system thread. It is, therefore, important not to select suspension on any ThreadX service calls made from within the application timer's expiration function.*</span></span>

## <a name="relative-time"></a><span data-ttu-id="13920-965">상대 시간</span><span class="sxs-lookup"><span data-stu-id="13920-965">Relative Time</span></span>

<span data-ttu-id="13920-966">앞서 언급한 애플리케이션 타이머 외에도 ThreadX는 지속적으로 증가하는 단일 32비트 틱 카운터를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-966">In addition to the application timers mentioned previously, ThreadX provides a single continuously incrementing 32-bit tick counter.</span></span> <span data-ttu-id="13920-967">틱 카운터 또는 *시간* 은 각 타이머 인터럽트마다 1씩 증가합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-967">The tick counter or *time* is increased by one on each timer interrupt.</span></span>

<span data-ttu-id="13920-968">애플리케이션은 각각 ***tx_time_get** _ 및 _*_tx_time_set_\*\*에 대한 호출을 통해 32비트 카운터를 읽거나 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-968">The application can read or set this 32-bit counter through calls to ***tx_time_get** _ and _*_tx_time_set_\*\*, respectively.</span></span> <span data-ttu-id="13920-969">틱 카운터 사용은 완전히 애플리케이션에 의해 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-969">The use of this tick counter is determined completely by the application.</span></span> <span data-ttu-id="13920-970">ThreadX에서 내부적으로 사용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-970">It is not used internally by ThreadX.</span></span>

## <a name="interrupts"></a><span data-ttu-id="13920-971">인터럽트</span><span class="sxs-lookup"><span data-stu-id="13920-971">Interrupts</span></span>

<span data-ttu-id="13920-972">비동기 이벤트에 대한 빠른 응답은 내장된 실시간 애플리케이션의 주요 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-972">Fast response to asynchronous events is the principal function of real-time, embedded applications.</span></span> <span data-ttu-id="13920-973">애플리케이션은 하드웨어 인터럽트를 통해 이러한 이벤트가 있다는 것을 알고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-973">The application knows such an event is present through hardware interrupts.</span></span>

<span data-ttu-id="13920-974">인터럽트는 프로세서 실행의 비동기 변경입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-974">An interrupt is an asynchronous change in processor execution.</span></span> <span data-ttu-id="13920-975">일반적으로 *인터럽트* 가 발생하면 프로세서는 현재 실행의 작은 부분을 스택에 저장하고 적절한 인터럽트 벡터로 제어권을 이전합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-975">Typically, when an interrupt occurs, the *Interrupts* processor saves a small portion of the current execution on the stack and transfers control to the appropriate interrupt vector.</span></span> <span data-ttu-id="13920-976">인터럽트 벡터는 기본적으로 특정 형식 인터럽트를 처리하는 루틴의 주소일 뿐입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-976">The interrupt vector is basically just the address of the routine responsible for handling the specific type interrupt.</span></span> <span data-ttu-id="13920-977">정확한 인터럽트 처리 절차는 프로세서마다 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="13920-977">The exact interrupt handling procedure is processor specific.</span></span>

### <a name="interrupt-control"></a><span data-ttu-id="13920-978">인터럽트 제어</span><span class="sxs-lookup"><span data-stu-id="13920-978">Interrupt Control</span></span>

<span data-ttu-id="13920-979">***tx_interrupt_control*** 서비스를 사용하면 애플리케이션에서 인터럽트를 사용하거나 사용하지 않도록 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-979">The ***tx_interrupt_control*** service allows applications to enable and disable interrupts.</span></span> <span data-ttu-id="13920-980">이 서비스는 이전 인터럽트 사용/사용 안 함 상태를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-980">The previous interrupt enable/disable posture is returned by this service.</span></span> <span data-ttu-id="13920-981">인터럽트 제어는 현재 실행 중인 프로그램 세그먼트에만 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="13920-981">It is important to mention that interrupt control only affects the currently executing program segment.</span></span> <span data-ttu-id="13920-982">예를 들어 스레드가 인터럽트를 사용하지 않도록 설정하면 해당 스레드가 실행되는 동안만 사용하지 않도록 설정된 상태로 유지됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-982">For example, if a thread disables interrupts, they only remain disabled during execution of that thread.</span></span>

> [!NOTE]
> <span data-ttu-id="13920-983">*마스크 불가능 인터럽트(NMI)는 하드웨어에서 비활성화할 수 없는 인터럽트입니다. 이러한 인터럽트는 ThreadX 애플리케이션에서 사용될 수 있습니다. 그러나 애플리케이션의 NMI 처리 루틴은 ThreadX 컨텍스트 관리 또는 API 서비스를 사용할 수 없습니다.*</span><span class="sxs-lookup"><span data-stu-id="13920-983">*A Non-Maskable Interrupt (NMI) is an interrupt that cannot be disabled by the hardware. Such an interrupt may be used by ThreadX applications. However, the application's NMI handling routine is not allowed to use ThreadX context management or any API services.*</span></span>

### <a name="threadx-managed-interrupts"></a><span data-ttu-id="13920-984">ThreadX 관리형 인터럽트</span><span class="sxs-lookup"><span data-stu-id="13920-984">ThreadX Managed Interrupts</span></span>

<span data-ttu-id="13920-985">ThreadX는 애플리케이션에 완전한 인터럽트 관리를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-985">ThreadX provides applications with complete interrupt management.</span></span> <span data-ttu-id="13920-986">이러한 관리에는 중단된 실행의 컨텍스트를 저장하고 복원하는 작업이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-986">This management includes saving and restoring the context of the interrupted execution.</span></span> <span data-ttu-id="13920-987">또한 ThreadX를 사용하면 ISR(인터럽트 서비스 루틴) 내에서 특정 서비스를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-987">In addition, ThreadX allows certain services to be called from within Interrupt Service Routines (ISRs).</span></span> <span data-ttu-id="13920-988">다음은 애플리케이션 ISR에서 허용되는 ThreadX 서비스 목록입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-988">The following is a list of ThreadX services allowed from application ISRs.</span></span>

```c
tx_block_allocate
tx_block_pool_info_get tx_block_pool_prioritize
tx_block_pool_performance_info_get
tx_block_pool_performance_system_info_get tx_block_release
tx_byte_pool_info_get tx_byte_pool_performance_info_get
tx_byte_pool_performance_system_info_get
tx_byte_pool_prioritize tx_event_flags_info_get
tx_event_flags_get tx_event_flags_set
tx_event_flags_performance_info_get
tx_event_flags_performance_system_info_get
tx_event_flags_set_notify tx_interrupt_control
tx_mutex_performance_info_get
tx_mutex_performance_system_info_get tx_queue_front_send
tx_queue_info_get tx_queue_performance_info_get
tx_queue_performance_system_info_get tx_queue_prioritize
tx_queue_receive tx_queue_send tx_semaphore_get
tx_queue_send_notify tx_semaphore_ceiling_put
tx_semaphore_info_get tx_semaphore_performance_info_get
tx_semaphore_performance_system_info_get
tx_semaphore_prioritize tx_semaphore_put tx_thread_identify
tx_semaphore_put_notify tx_thread_entry_exit_notify
tx_thread_info_get tx_thread_resume
tx_thread_performance_info_get
tx_thread_performance_system_info_get
tx_thread_stack_error_notify tx_thread_wait_abort tx_time_get
tx_time_set tx_timer_activate tx_timer_change
tx_timer_deactivate tx_timer_info_get
tx_timer_performance_info_get
tx_timer_performance_system_info_get
```

> [!IMPORTANT]
> <span data-ttu-id="13920-989">*ISR에서는 일시 중단이 허용되지 않습니다. 따라서 ISR에서 수행된 모든 ThreadX 서비스 호출에 대한 **wait_option** 매개 변수를 **TX_NO_WAIT** 로 설정해야 합니다.*</span><span class="sxs-lookup"><span data-stu-id="13920-989">*Suspension is not allowed from ISRs. Therefore, the **wait_option** parameter for all ThreadX service calls made from an ISR must be set to **TX_NO_WAIT**.*</span></span>

### <a name="isr-template"></a><span data-ttu-id="13920-990">ISR 템플릿</span><span class="sxs-lookup"><span data-stu-id="13920-990">ISR Template</span></span>

<span data-ttu-id="13920-991">애플리케이션 인터럽트를 관리하려면 애플리케이션 ISR의 시작과 끝에서 몇 개의 ThreadX 유틸리티를 호출해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="13920-991">To manage application interrupts, several ThreadX utilities must be called in the beginning and end of application ISRs.</span></span> <span data-ttu-id="13920-992">인터럽트 처리의 정확한 형식은 포트마다 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="13920-992">The exact format for interrupt handling varies between ports.</span></span>

<span data-ttu-id="13920-993">다음 작은 코드 세그먼트는 대부분의 ThreadX 관리형 ISR에서 일반적입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-993">The following small code segment is typical of most ThreadX managed ISRs.</span></span> <span data-ttu-id="13920-994">대부분의 경우 이러한 처리는 어셈블리 언어로 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-994">In most cases, this processing is in assembly language.</span></span>

```c
_application_ISR_vector_entry:

; Save context and prepare for

; ThreadX use by calling the ISR

; entry function.

CALL _tx_thread_context_save

; The ISR can now call ThreadX

; services and its own C functions

; When the ISR is finished, context

; is restored (or thread preemption)

; by calling the context restore ; function. Control does not return!

JUMP _tx_thread_context_restore
```

### <a name="high-frequency-interrupts"></a><span data-ttu-id="13920-995">빈도가 높은 인터럽트</span><span class="sxs-lookup"><span data-stu-id="13920-995">High-frequency Interrupts</span></span>

<span data-ttu-id="13920-996">일부 인터럽트는 매우 높은 빈도로 발생하여 인터럽트가 발생할 때마다 전체 컨텍스트를 저장하고 복원하면 과도한 처리 대역폭이 소비됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-996">Some interrupts occur at such a high frequency that saving and restoring full context upon each interrupt would consume excessive processing bandwidth.</span></span> <span data-ttu-id="13920-997">이런 경우 빈도가 높은 인터럽트의 대부분에 대해 제한된 크기의 처리를 수행하는 작은 어셈블리 언어 ISR을 애플리케이션에 두는 것이 일반적입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-997">In such cases, it is common for the application to have a small assembly language ISR that does a limited amount of processing for a majority of these high-frequency interrupts.</span></span>

<span data-ttu-id="13920-998">특정 시점이 지나면 작은 ISR이 ThreadX와 상호 작용해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13920-998">After a certain point in time, the small ISR may need to interact with ThreadX.</span></span> <span data-ttu-id="13920-999">이 작업은 위의 템플릿에 설명된 엔트리 및 종료 함수를 호출하여 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="13920-999">This is accomplished by calling the entry and exit functions described in the above template.</span></span>

### <a name="interrupt-latency"></a><span data-ttu-id="13920-1000">인터럽트 대기 시간</span><span class="sxs-lookup"><span data-stu-id="13920-1000">Interrupt Latency</span></span>

<span data-ttu-id="13920-1001">ThreadX는 짧은 시간 동안 인터럽트를 잠급니다.</span><span class="sxs-lookup"><span data-stu-id="13920-1001">ThreadX locks out interrupts over brief periods of time.</span></span> <span data-ttu-id="13920-1002">인터럽트를 사용하지 않도록 설정되는 최대 시간은 스레드의 컨텍스트를 저장하거나 복원하는 데 필요한 시간 순서입니다.</span><span class="sxs-lookup"><span data-stu-id="13920-1002">The maximum amount of time interrupts are disabled is on the order of the time required to save or restore a thread's context.</span></span>
