---
title: 3장 - Azure RTOS NetX Secure의 기능 설명
description: 이 챕터에는 NetX Secure TLS에 대한 기능 설명이 포함되어 있습니다.
author: philmea
ms.author: philmea
ms.date: 06/04/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 711195e60771ebd467c69df49ef7665f32e13a17c21ca839404e829449cf1401
ms.sourcegitcommit: 93d716cf7e3d735b18246d659ec9ec7f82c336de
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/07/2021
ms.locfileid: "116797982"
---
# <a name="chapter-3---functional-description-of-azure-rtos-netx-secure"></a>3장 - Azure RTOS NetX Secure의 기능 설명

## <a name="execution-overview"></a>실행 개요

이 챕터에는 Azure RTOS NetX Secure TLS에 대한 기능 설명이 포함되어 있습니다. NetX Secure TLS 애플리케이션에는 초기화 및 애플리케이션 인터페이스 호출이라는 두 가지 주요 프로그램 실행 형식이 있습니다. 

NetX Secure는 ThreadX 및 NetX/NetXDuo가 있다고 가정합니다. ThreadX에서는 스레드 실행, 일시 중단, 주기적 타이머, 상호 배제 기능이 필요합니다. NetX/NetXDuo에서는 TCP/IP 네트워킹 기능과 드라이버가 필요합니다.

## <a name="transport-layer-security-tls-and-secure-sockets-layer-ssl"></a>TLS(전송 계층 보안) 및 SSL(Secure Sockets Layer)

NetX Secure의 보안 네트워크 프로토콜 구성 요소는 RFC 2246(버전 1.0), 4346(버전 1.1), 5246(버전 1.2), 8446(버전 1.3)에 설명되어 있는 TLS(전송 계층 보안) 프로토콜을 구현한 것입니다. 기본 X.509(RFC 5280)에 대한 지원 루틴도 포함되어 있습니다.

NetX Secure TLS는 TLS 버전 1.2 및 1.3을 지원합니다. 현재 더 이상 사용되지 않는 TLS 1.0 및 TLS 1.1에 대한 구현이 제공되지만 명시적으로 초기화해야 하며 새 제품에는 사용하지 않는 것이 좋습니다.

SSL(*Secure Sockets Layer*)은 RFC 2246에서 표준이 되기 전 TLS의 원래 이름이며 "SSL"이 TLS 프로토콜의 일반적인 이름으로 사용되는 경우가 많습니다. SSL의 마지막 버전은 3.0이고 TLS 1.0을 SSL 버전 3.1이라고 하는 경우도 있습니다. 공식 "SSL" 프로토콜의 모든 버전은 더 이상 사용되지 않고 안전하지 않은 것으로 간주되며 현재 NetX Secure는 SSL 구현을 제공하지 않습니다.

TLS는 TLS 클라이언트와 서버 간의 TLS 핸드셰이크 중에 만들어지는 세션 키를 생성하는 프로토콜을 지정하며, 이러한 키는 TLS 세션 중에 애플리케이션에서 보낸 데이터를 암호화하는 데 사용됩니다.  

TLS 데이터는 개념상 TCP 패킷과 동일한 레코드로 나뉩니다. 모든 TLS 레코드에는 헤더가 있고 TLS 암호화 레코드에는 바닥글(체크섬 해시)도 있습니다. TLS 핸드셰이크 레코드에는 더 큰 TLS 레코드 내에 캡슐화된 추가 헤더가 있습니다. TLS 레코드는 TCP 패킷이 IP 패킷에 의해 캡슐화되는 것과 같은 방식으로 전송 계층 네트워크 프로토콜에 의해 캡슐화됩니다.

### <a name="tls-13"></a>TLS 1.3

2018년 8월에 TLS 1.3 사양이 완성되었습니다. 새 버전의 프로토콜은 TLS의 기본 보안 및 성능에 대한 몇 가지 기본적인 측면을 변경하는 상당히 중요한 업데이트입니다. 하지만 이러한 변화는 주로 TLS 핸드셰이크 상태 시스템 및 세션 키 생성에 적용되기 때문에 일반적인 TLS 사용자에게는 거의 보이지 않습니다. 몇 가지 선택적 기능과 확장도 추가되었습니다. 다음은 변경 내용 및 TLS 기능에 미치는 영향에 대한 요약입니다.

- 서버에 의한 전체 메시지 교환을 제거하여 핸드셰이크 상태 시스템이 최적화되었습니다.
- 키 생성이 HKDF(HMAC-based Key Derivation Function)라는 표준화된 루틴을 사용하고 세션 키를 모든 핸드셰이크 메시지(몇 가지 select 매개 변수 대신)에 연결하도록 업데이트되었습니다.
- 모든 TLS 1.2 및 이전 ciphersuite는 더 이상 사용되지 않으며 TLS 1.3과 호환되지 않습니다. 마찬가지로 모든 TLS 1.3 ciphersuite는 이전 버전에서 사용할 수 없습니다.
- 모든 TLS 1.3 ciphersuite는 사용 후 삭제(ephemeral) 키<sup>6</sup>를 사용하여 PFS(Perfect Forward Secrecy)를 제공합니다. 
- TLS 1.3은 AEAD<sup>7</sup> 암호화를 사용하기 위해 각 레코드에서 "MAC"(메시지 인증 코드)를 제거합니다.
- 핸드셰이크 중에 애플리케이션 데이터를 보낼 수 있는 0-RTT(제로 왕복 시간)를 비롯한 몇 가지 선택적 기능이 더 추가되었습니다. 0-RTT는 전적으로 선택 사항이며 현재 Azure RTOS TLS에서 지원되지 않습니다.

TLS 1.3은 사용자 애플리케이션에 크게 영향을 주지 않습니다. API는 버전 간에 정확히 동일하게 유지되며, ciphersuite가 표시되므로 단일 ciphersuite 테이블을 사용할 수 있습니다.

TLS 1.3을 사용하려면 NX_SECURE_TLS_ENABLE_TLS_1_3 매크로를 전역적으로 정의해야 합니다. TLS 1.3은 Azure RTOS TLS에서 기본적으로 비활성화되어 있습니다.

6. "사용 후 삭제(ephemeral)" 키는 TLS 핸드셰이크 중에 생성되고 해당 세션의 비밀 교환에만 사용되는 비대칭 키 쌍입니다. 이 키 쌍은 사용 후 삭제됩니다. 이렇게 하면 나중에 인증서 프라이빗 키가 손상되더라도 기록된 TLS 세션의 암호화된 데이터에 공격자가 액세스할 수 없기 때문에 “PFS(Perfect Forward Secrecy)”라고 합니다.

7. 관련 데이터를 사용하여 인증된 암호화 – 암호화와 무결성 검사를 단일 작업으로 결합하여 무결성 검사를 위한 별도의 데이터 해시가 필요하지 않은 AES와 같은 암호용 모드입니다.

### <a name="tls-record-header"></a>TLS 레코드 헤더

유효한 TLS 레코드에는 TLS 헤더가 있어야 합니다. 자세한 내용은 오류! 참조 소스를 찾을 수 없습니다. 섹션을 참조하세요.

![TLS 레코드 헤더의 다이어그램](media/image2.png)

그림 1 - TLS 레코드 헤더

TLS 레코드 헤더의 필드는 다음과 같이 정의됩니다.

| TLS 헤더 필드 | 용도     |
| ---------------- | ------------- |
| **8비트 메시지 유형** | 이 필드에는 전송되는 TLS 레코드 형식이 포함됩니다. 유효한 형식은 다음과 같습니다.<br />- ChangeCipherSpec<sup>8</sup>: 0x14<br />- 경고: 0x15<br />- 핸드셰이크: 0x16<br />- 애플리케이션 데이터: 0x17 |
| **16비트 프로토콜 버전** | 이 필드에는 TLS 프로토콜 버전이 포함됩니다. 유효한 값은 다음과 같습니다.<br />- SSL 3.0: 0x0300<br />- TLS 1.0: 0x0301<br />- TLS 1.1: 0x0302<br />- TLS 1.2: 0x0303<br />- **TLS 1.3 <sup>9</sup>** : **0x0303** |
| **16비트 길이** | 이 필드에는 TLS 레코드에 캡슐화된 데이터의 길이가 포함됩니다. |

8. TLS 1.3에서 ChangeCipherSpec 메시지는 더 이상 사용되지 않지만 호환성을 위해 아직 보낼 수 있으며, 이런 경우 메시지는 무시됩니다.

9. 이 스키마가 계속 사용되었다면 TLS 1.3은 기술적으로 0x0304 값을 갖게 되지만 프로토콜이 확장의 실제 프로토콜 버전을 갖도록 변경되었기 때문에 모든 TLS 1.3 레코드는 이전 버전과의 호환성을 위해 프로토콜 버전 필드에 0x0303을 사용합니다.

### <a name="tls-handshake-record-header"></a>TLS 핸드셰이크 레코드 헤더

그림 2와 같이, 유효한 모든 TLS 핸드셰이크 레코드에는 TLS 핸드셰이크 헤더가 있어야 합니다.

![TLS 핸드셰이크 레코드 헤더의 다이어그램입니다.](media/image3.png)

그림 2 - TLS 핸드셰이크 레코드 헤더

TLS 핸드셰이크 레코드 헤더의 필드는 다음과 같이 정의됩니다.

| TLS 헤더 필드 | 용도 |
| ---------------- |----------------------- |
| **8비트 메시지 유형** | 이 필드에는 전송되는 TLS 레코드 형식이 포함됩니다. 유효한 형식은 다음과 같습니다.<br />- ChangeCipherSpec<sup>10</sup>: 0x14<br />- 경고: 0x15<br />- 핸드셰이크: 0x16<br />- 애플리케이션 데이터: 0x17 |
| **16비트 프로토콜 버전** | 이 필드에는 TLS 프로토콜 버전이 포함됩니다. 유효한 값은 다음과 같습니다.<br />- SSL 3.0: 0x0300<br />- TLS 1.0: 0x0301<br />- TLS 1.1: 0x0302<br />- TLS 1.2: 0x0303<br />- **TLS 1.3 <sup>11</sup>** : **0x0303** |
| **16비트 길이**    | 이 필드에는 TLS 레코드에 캡슐화된 데이터의 길이가 포함됩니다. |
| **8비트 핸드셰이크 유형** | 이 필드는 핸드셰이크 메시지 유형을 포함합니다. 유효한 값은 다음과 같습니다(***굵게 표시** 된 메시지는 TLS 1.3에 추가됨).<br />- HelloRequest: 0x00<br />- ClientHello: 0x01<br />- ServerHello: 0x02<br />- **HelloVerifyRequest**: **0x03**<br />- **NewSessionTicket**: **0x04**<br />- **EndOfEarlyData**: **0x05**<br />- **EncryptedExtensions**: **0x08**<br />- Certificate: 0x0B<br />- ServerKeyExchange: 0x0C<br />- CertificateRequest: 0x0D<br />- ServerHelloDone: 0x0E<br />- CertificateVerify: 0x0F<br />- ClientKeyExchange: 0x10<br />- Finished: 0x14<br />- **KeyUpdate**: **0x18**<br />- **MessageHash**: **0xFE** |
| **24비트 길이**    | 이 필드는 핸드셰이크 메시지 데이터의 길이를 포함합니다. |

10. TLS 1.3에서 ChangeCipherSpec 메시지는 더 이상 사용되지 않지만 호환성을 위해 아직 보낼 수 있으며, 이런 경우 메시지는 무시됩니다.

11. 이 스키마가 계속 사용되었다면 TLS 1.3은 기술적으로 0x0304 값을 갖게 되지만 프로토콜이 확장의 실제 프로토콜 버전을 갖도록 변경되었기 때문에 모든 TLS 1.3 레코드는 이전 버전과의 호환성을 위해 프로토콜 버전 필드에 0x0303을 사용합니다.

### <a name="the-tls-handshake-and-tls-session"></a>TLS 핸드셰이크 및 TLS 세션

일반적인 TLS 핸드셰이크(버전 1.0-1.2)는 그림 3에 나와 있습니다. TLS 핸드셰이크는 TLS 클라이언트가 TLS 서버에 *ClientHello* 메시지(TLS 세션을 시작하려는 의도를 나타냄)를 보낼 때 시작됩니다. 이 메시지에는 클라이언트가 세션에 사용할 암호화에 대한 정보와 함께 나중에 핸드셰이크에서 세션 키를 생성하는 데 사용되는 정보가 포함됩니다. 세션 키가 생성될 때까지 TLS 핸드셰이크의 모든 메시지는 암호화되지 않습니다. TLS 1.3은 핸드셰이크를 다소 변경합니다. – 자세한 내용은 다음 섹션에 나와 있습니다.

TLS 서버는 ClientHello에 ServerHello 메시지(클라이언트가 제공한 암호화 옵션의 선택 항목을 나타냄)로 응답합니다. ServerHello 뒤에는 Certificate 메시지가 오며, 여기에는 클라이언트에서 서버의 ID를 인증하기 위해 서버가 제공하는 디지털 인증서가 포함됩니다. 마지막으로 서버는 ServerHelloDone 메시지를 보내서 더 이상 보낼 메시지가 없음을 나타냅니다. 서버는 ServerHello 다음에 다른 메시지를 보낼 수 있고 경우에 따라 Certificate 메시지를 보내지 않을 수도 있기 때문에 ServerHelloDone 메시지가 필요합니다.

클라이언트가 서버의 모든 메시지를 수신하면 세션 키를 생성하기에 충분한 정보를 갖게 됩니다. TLS는 고정 크기이며 암호화가 활성화되면 필요한 모든 키를 생성하기 위해 시드로 사용되는 *Pre-Master Secret* 이라는 임의 데이터의 공유 비트를 생성하여 이 작업을 수행합니다. Pre-Master Secret은 Hello 메시지에 지정된 공개 키 알고리즘(예: RSA)(공개 키 알고리즘에 대한 자세한 내용은 아래 참조) 및 서버가 인증서에서 제공한 공개 키를 사용하여 암호화됩니다. PSK(미리 공유한 키)라는 선택적 TLS 기능을 사용하면 인증서를 사용하는 대신 호스트 간에 공유되는 비밀 값(일반적으로 물리적 전송 또는 기타 보안 방법을 통해)을 사용하는 ciphersuite를 사용할 수 있습니다. 공유 비밀은 암호화된 메시지를 사용하여 Pre-Master Secret을 보내는 대신 Pre-Master Secret을 생성하는 데 사용됩니다. 아래에서 미리 공유한 키 섹션을 참조하세요.

암호화된 Pre-Master Secret은 ClientKeyExchange 메시지에 포함되어 서버로 전송됩니다. 서버가 ClientKeyExchange 메시지를 받으면 자체 프라이빗 키를 사용하여 Pre-Master Secret을 해독하고 TLS 클라이언트와 병렬로 세션 키 생성을 진행합니다.

세션 키가 생성되면 Hello 메시지에서 선택한 프라이빗 키 알고리즘(예: AES)을 사용하여 모든 추가 메시지를 암호화할 수 있습니다. 클라이언트와 서버 모두에서 ChangeCipherSpec이라는 암호화되지 않은 마지막 메시지 하나를 보내서 모든 추가 메시지가 암호화된다는 것을 나타냅니다.

클라이언트와 서버 모두에서 보낸 첫 번째 암호화된 메시지는 Finished라는 최종 TLS 핸드셰이크 메시지이기도 합니다. 이 메시지는 송수신한 모든 핸드셰이크 메시지의 해시를 포함합니다. 이 해시는 핸드셰이크의 어떤 메시지도 변조되거나 손상(보안 위반 가능성을 나타냄)되지 않았다는 것을 확인하는 데 사용됩니다.

Finished 메시지를 받고 핸드셰이크 해시가 확인되면, TLS 세션이 시작되고 애플리케이션은 데이터 송수신을 시작합니다. TLS 세션 중에 양쪽에서 전송된 모든 데이터는 먼저 Hello 메시지에서 선택한 해시 알고리즘을 사용하여 해시되고(메시지 무결성을 제공하기 위해) 생성된 세션 키와 함께 선택한 프라이빗 키 알고리즘을 사용하여 암호화됩니다.

마지막으로, TLS 세션은 클라이언트나 서버에서 종료하기로 선택하는 경우에만 성공적으로 종료될 수 있습니다. 잘린 세션은 보안 위반으로 간주되며(모든 송신 데이터가 수신되는 것을 공격자가 막으려고 시도할 수 있기 때문에) 따라서 둘 중 한쪽에서 세션을 종료하려고 하면 CloseNotify 경고라는 특별한 알림이 전송됩니다. 세션 종료에 성공하려면 클라이언트와 서버 모두 CloseNotify 경고를 보내고 처리해야 합니다.

![일반적인 TLS 핸드셰이크의 다이어그램](media/image4.png)

그림 3- 일반적인 TLS 핸드셰이크

### <a name="tls-13-handshake"></a>TLS 1.3 핸드셰이크

TLS 1.3은 TLS 프로토콜에서 상당히 많이 재정비되었습니다. 대부분의 변화는 보안과 성능을 높이기 위해 핸드셰이크에 적용되었습니다. 일반적인 TLS 1.3 핸드셰이크는 그림 4에 나와 있습니다. 주요 차이는 서버와 클라이언트 사이의 교환 수에서 볼 수 있습니다.

TLS 1.2 및 이전 버전에서는 서버가 메시지 플라이트<sup>12</sup>를 2개 보냅니다. – 먼저 ServerHello를 보낸 다음, ChangeCipherSpec 메시지를 보낸 후 핸드셰이크를 종료하는 암호화된 Finished 메시지를 보냅니다. TLS 1.3에서는 서버가 모든 것을(ServerHello, Extensions, Certificate 및 Finished) 첫 번째 플라이트에 포함하여 보냅니다. ChangeCipherSpec 메시지는 제거되었으며 서버가 세션 키를 생성하고 ServerHello 직후에 핸드셰이크 메시지 암호화를 시작합니다.

새로운 방식은 암호화를 통해 TLS 핸드셰이크를 더 많이 보호하여 공격자가 액세스할 수 있는 일반 텍스트의 양을 제한하는 것을 의미합니다. 또한 두 번째 서버 플라이트(ChangeCipherSpec 다음에 Finished가 있음)를 제거하면 TLS 클라이언트는 애플리케이션 데이터 전송을 시작할 때까지 더 이상 기다릴 필요가 없으며 클라이언트가 자체 Finished 메시지를 보내는 즉시 세션이 시작됩니다.

12. 플라이트는 한 그룹에 포함되어 동시에 전송되는 TLS 메시지의 모음입니다.

![TLS 1.3 핸드셰이크 다이어그램](media/image5.png)

그림 4 - TLS 1.3 핸드셰이크

> [!NOTE]
> TLS 1.3에는 "Early data" 및 0-RTT(제로 왕복 시간)라는 개념도 도입되었습니다. 일부 애플리케이션 데이터를 메시지의 첫 번째 플라이트에 포함하여 보낼 수 있다는 의미입니다. 이 선택적 기능은 주로 웹 브라우저 응답성을 위한 최적화(예: 페이지 렌더링을 시작하기 위해 이른(early) HTTP 헤더 보내기)로 추가되었습니다. Azure RTOS 6.0부터는 이 기능이 지원되지 않습니다.

### <a name="initialization"></a>초기화

NetX 또는 NetXDuo TCP/IP 스택은 NetX Secure TLS를 사용하기 전에 초기화해야 합니다. TCP/IP 스택을 제대로 초기화하는 방법에 대한 자세한 내용은 NetX 또는 NetXDuo 사용자 가이드를 참조하세요.

NetX TCP/IP 스택이 초기화되면 TLS를 활성화할 수 있습니다. 내부적으로 모든 TLS 네트워크 트래픽 및 처리는 사용자의 개입 없이도 NetX/NetXDuo 스택에 의해 처리됩니다. 단, TLS에는 기본 네트워크 스택과 별개로 처리해야 하는 특정 요구 사항이 있습니다. 이러한 매개 변수는_ *_nx_secure_tls_session_create_** 서비스를 사용하여 ***NX_SECURE_TLS_SESSION** _이라는 TLS 제어 블록에 할당됩니다.

TLS에는 서버 및 클라이언트라는 두 가지 모드가 있으며, 애플리케이션에서 둘 중 하나를 활성화할 수 있고(단, NetX 소켓당 한 가지 모드) 각각 고유한 요구 사항(아래에 자세히 설명되어 있음)이 있습니다.

어느 모드에서든 NetX Secure TLS는 원격 호스트와의 TCP 통신을 위해 TCP 소켓(***NX_TCP_SOCKET** _)을 만들고 설정해야 합니다. TCP 소켓은 _ *_nx_secure_tls_session_start_** 서비스(아래에 자세히 설명되어 있음)를 사용하여 TLS 세션 인스턴스에 할당됩니다.

### <a name="initialization--tls-server"></a>초기화 – TLS 서버

TCP 소켓 외에도 NetX Secure TLS 서버 모드에는 디지털 인증서(연결하는 TLS 클라이언트에 TLS 서버를 식별하는 데 사용되는 문서)와 프라이빗 키에 해당하는 인증서(일반적으로 RSA 암호화 알고리즘에 사용됨)가 필요합니다.  International Telecommunications Union X.509 표준은 TLS에서 사용하는 인증서 형식을 지정하며 X.509 디지털 인증서를 만들 수 있는 다양한 유틸리티가 있습니다.

NetX Secure TLS의 경우 X.509 인증서는 DER(Distinguished Encoding Rules) 형식인 ASN.1을 사용하여 이진으로 인코딩해야 합니다. DER은 인증서에 사용되는 표준 TLS 네트워크 이진 형식입니다.

제공된 인증서와 연결된 프라이빗 키는 DER 인코딩 PKCS#1 형식이어야 합니다. 프라이빗 키는 디바이스에서만 사용되며 네트워크를 통해 전송되지 않습니다. 프라이빗 키는 TLS 통신 보안에 중요하므로 안전하게 보관해야 합니다.

TLS 서버 인증서를 초기화하려면 애플리케이션에서 ***nx_secure_x509_certificate_intialize** _ 서비스를 사용하여 DER 인코딩 X.509 인증서 및 선택적 DER 인코딩 PKCS#1 RSA 프라이빗 키 데이터를 포함하는 버퍼에 대한 포인터를 제공해야 합니다. 이 서비스는 _ *NX_SECURE_X509_CERT** 구조를 TLS에서 사용할 적절한 인증서 데이터로 채우는 서비스입니다.

서버 인증서가 초기화되면 ***nx_secure_tls_local_certificate_add*** 서비스를 사용하여 TLS 제어 블록에 인증서를 추가해야 합니다.

서버 인증서가 TLS 제어 블록에 추가되면 소켓을 사용하여 보안 TLS 서버 연결을 설정할 수 있습니다.

### <a name="initialization--tls-client"></a>초기화 – TLS 클라이언트

NetX Secure TLS 클라이언트 모드에는 신뢰할 수 있는 인증서 저장소가 필요합니다. 이것은 신뢰할 수 있는 CA(인증 기관)의 X.509 인코딩 디지털 인증서의 모음입니다. 이러한 인증서는 TLS 프로토콜에서 "신뢰할 수 있는" 것으로 간주되며 TLS 서버 엔터티가 NetX Secure TLS 클라이언트에 제공하는 인증서를 인증하기 위한 기반으로 사용됩니다.

신뢰할 수 있는 CA 인증서는 자체 서명되거나 다른 CA에서 서명될 수 있으며, 이 경우 해당 인증서를 ICA(중간 CA)라고 합니다.  일반적인 TLS 애플리케이션에서 서버는 자체 서버 인증서와 함께 ICA 인증서를 제공하지만, 인증이 성공하기 위해서는 발급자 체인(다른 인증서에 서명하는 데 사용되는 인증서)을 서버 인증서에서 신뢰할 수 있는 인증서 저장소의 신뢰할 수 있는 CA 인증서로 다시 추적할 수 있어야 하며, 이것이 유일한 요구 사항입니다. 이 체인을 신뢰 체인 또는 인증서 체인이라고 합니다. 

신뢰할 수 있는 CA 또는 ICA 인증서를 초기화하려면 애플리케이션에서 ***nx_secure_x509_certificate_intialize** _ 서비스를 사용하여 DER로 인코딩된 X.509 인증서를 포함하는 버퍼에 대한 포인터를 제공해야 합니다. 이 서비스는 _ *NX_SECURE_X509_CERT** 구조를 TLS에서 사용할 적절한 인증서 데이터로 채우는 서비스입니다.

그러면 초기화된 신뢰할 수 있는 인증서는 ***nx_secure_tls_trusted_certificate_add*** 서비스를 사용하여 TLS 제어 블록에 추가됩니다. 인증서를 추가하지 못하면 TLS 프로토콜이 원격 TLS 서버 호스트를 인증할 방법이 없기 때문에 TLS 클라이언트 세션이 실패합니다.

TLS 클라이언트에는 수신 서버 인증서를 할당할 공간도 필요합니다(미리 공유한 키 모드가 사용되지 않는다고 가정). NetX Secure TLS 5.12부터는 애플리케이션이 더 이상 원격 인증서를 위한 공간을 할당할 필요가 없습니다. 단, 서버 인증서를 위한 공간을 할당하는 레거시 옵션을 계속 사용할 수 있으며 내부 인증서 버퍼 최적화 <sup>13</sup> 전에는 사용자가 할당한 인증서가 사용됩니다. 자세한 내용은 ***nx_secure_tls_remote_certificate_allocate*** 서비스를 참조하세요.

신뢰할 수 있는 인증서 저장소가 생성되고 서버 인증서를 위한 공간이 할당되면 소켓을 사용하여 보안 TLS 클라이언트 연결을 설정할 수 있습니다.

13. 최적화는 이전 버전의 NetX Secure TLS에서 사용된 사용자 제공 구조를 사용하는 대신 *nx_secure_tls_session_packet_buffer_set* 을 사용하여 사용자 애플리케이션이 TLS 세션에 제공한 "패킷 버퍼"를 활용하여 X.509 구문 분석 구조를 할당합니다. 패킷 버퍼의 크기를 초과하는 인증서 체인이 발생할 가능성은 거의 없으며, 만약 발생하면 패킷 버퍼 크기를 늘리거나 *nx_secure_tls _remote_certificate_allocate* 를 사용하여 인증서 체인에 더 많은 공간을 할당할 수 있습니다.

### <a name="application-interface-calls"></a>애플리케이션 인터페이스 호출

NetX Secure TLS 애플리케이션은 일반적으로 ThreadX RTOS에서 실행되는 애플리케이션 스레드 내에서 함수 호출을 수행합니다. 일부 초기화, 특히 기본 네트워크 통신 프로토콜(예: TCP 및 IP)에 대한 초기화는 ***tx_application_define*** 에서 호출할 수 있습니다. 네트워크 통신 초기화에 대한 자세한 내용은 NetX/NetXDuo 사용자 가이드를 참조하세요.

TLS는 프로세서 사용량이 많은 작업인 암호화 루틴을 많이 사용합니다. 일반적으로 이러한 작업은 호출 스레드의 컨텍스트 내에서 수행됩니다.

### <a name="tls-session-start"></a>TLS 세션 시작

TLS가 작동하려면 기본 전송 계층 네트워크 프로토콜이 필요합니다. 일반적으로 사용되는 프로토콜은 TCP입니다. NetX Secure TLS 세션을 설정하려면 NetX/NetXDuo TCP API를 사용하여 TCP 연결을 설정해야 합니다. **NX_TCP_SOCKET** 을 생성해야 하고 **_nx_tcp_server_socket_listen_ *_ 및 _* _nx_tcp_server_socket_accept_ *_ 서비스(TLS 서버용) 또는 _* _nx_tcp_client_socket_connect_** 서비스(TLS 클라이언트 용)를 사용하여 연결을 설정해야 합니다.

TCP 연결이 설정되면 TCP 소켓이 ***nx_secure_tls_session_start*** 서비스에 전달됩니다.

### <a name="tls-packet-allocation"></a>TLS 패킷 할당

NetX Secure TLS는 NetX/NetXDuo TCP(***NX_PACKET** _)와 동일한 패킷 구조를 사용합니다. 단, _*_nx_packet_allocate_*_ 서비스를 호출하는 대신 _ *_nx_secure_tls_packet_allocate_** 서비스를 호출해야 TLS 헤더를 위한 공간이 제대로 할당될 수 있습니다.

### <a name="tls-session-send"></a>TLS 세션 보내기

TLS 세션이 시작되면 애플리케이션은 ***nx_secure_tls_session_send** _ 서비스를 사용하여 데이터를 보낼 수 있습니다. 보내기 서비스는 _*_nx_tcp_socket_send_*_ 서비스와 동일하며 송신되는 데이터가 포함된 _*_NX_PACKET_*_ 데이터 구조를 사용합니다. 이 데이터만 송신되기 전에 NX Secure TLS 스택에 의해 암호화되며 _*_nx_secure_tls_packet_allocate_**를 사용하여 패킷이 할당되어야 합니다.

### <a name="tls-session-receive"></a>TLS 세션 받기

TLS 세션이 시작되면 애플리케이션은 ***nx_secure_tls_session_receive** _ 서비스를 사용하여 데이터를 받기 시작할 수 있습니다. TLS 세션 보내기와 마찬가지로 이 서비스는 동일하게 _*_nx_tcp_socket_receive_**를 사용합니다. 단, 수신 데이터는 패킷 구조로 반환되기 전에 TLS 스택에 의해 해독되고 확인됩니다.

### <a name="tls-session-close"></a>TLS 세션 닫기

TLS 세션이 완료되면 TLS 클라이언트와 서버는 서로에 CloseNotify 경고를 보내서 세션을 종료해야 합니다. 양쪽 모두 경고를 수신하고 처리해야만 세션이 성공적으로 종료됩니다.

원격 호스트가 CloseNotify 경고를 보내면 ***nx_secure_tls_session_receive** _ 서비스에 대한 호출은 경고를 처리하고 해당 경고를 원격 호스트에 돌려보내고 _*_NX_SECURE_TLS_SESSION_CLOSED_** 값을 반환합니다. 세션이 닫힌 후에는 이 TLS 세션을 사용하여 데이터를 보내거나 받으려는 시도가 실패합니다.

애플리케이션이 TLS 세션을 닫으려면 ***nx_secure_tls_session_end** _ 서비스를 호출해야 합니다. 서비스는 CloseNotify 경고를 보내고 응답 CloseNotify를 처리합니다. 응답을 받지 못하면 오류 값 _ *_NX_SECURE_TLS_SESSION_CLOSE_FAIL_**이 반환되어 TLS 세션이 완전히 종료되지 않았음을 나타냅니다. 이것은 보안 위반 가능성을 나타냅니다.

### <a name="tls-alerts"></a>TLS 경고

TLS는 최대 보안을 제공하도록 설계되었기 때문에 프로토콜에 이상 동작이 있으면 잠재적 보안 위반으로 간주됩니다. 이러한 이유로 인해 메시지 처리 또는 암호화/암호 해독에 오류가 있으면 치명적인 오류로 간주되어 핸드셰이크 또는 세션이 즉시 종료됩니다.

로컬 애플리케이션에서 오류를 처리하는 것은 비교적 간단하지만, 원격 호스트는 상황을 올바르게 처리하고 추가로 발생할 수 있는 보안 위반을 방지하려면 오류가 발생한 사실을 알아야 합니다. 이러한 이유로 TLS는 오류 발생 시 원격 호스트에 경고(*Alert*) 메시지를 보냅니다.

경고는 다른 TLS 메시지와 동일한 방식으로 처리되며 세션 중에 암호화되어 제공된 유형의 경고에서 공격자가 정보를 수집하지 못하도록 방지합니다. 핸드셰이크 중에 전송되는 경고는 잠재적인 공격자가 얻을 수 있는 정보의 양을 제한하기 위해 범위가 제한됩니다.

TLS 세션을 닫는 데 사용되는 CloseNotify 경고는 유일하게 치명적이지 않은 경고입니다. CloseNotify는 경고로 간주되고 경고 메시지의 형태로 송신되지만, 오류가 발생했음을 알리지 않는다는 점에서 다른 경고와는 다릅니다.

경고 값과 "수준"(수준은 "경고(warning)" 및 "치명적(fatal)"이며 대부분의 TLS 경고는 "치명적"임)은 TLS RFC에 정의되어 있으며 발생한 오류 유형을 나타냅니다. CloseNotify 이외의 대부분의 TLS 경고는 잠재적인 보안 문제를 나타내는 것으로 간주될 수 있으며, 이로 인해 TLS 세션 또는 핸드셰이크가 중단됩니다. TLS API 호출이 **NX_SECURE_TLS_ALERT_RECEIVED** (0x114)를 반환하면 API 서비스 **_nx_secure_tls_session_alert_value_get_**(NetX Secure TLS 버전 5.12의 신규 서비스)을 사용하여 애플리케이션이 보안 문제에 대한 응답과 관련된 결정에 사용할 TLS 경고 값 및 수준을 검색할 수 있습니다. 대부분의 경우 원격 호스트에서 받은 모든 경고는 CloseNotify를 제외하고 치명적인 오류로 간주되어야 합니다. 단, 일부 예외가 있으며 자세한 내용은 TLS RFC를 참조하세요.

### <a name="tls-session-renegotiation"></a>TLS 세션 재협상

TLS는 기존 TLS 세션의 컨텍스트 내에서 TLS 세션 매개 변수를 재협상하는 "재협상"이라는 개념을 지원합니다. 즉, 새로운 핸드셰이크 메시지가 기존 세션을 사용하여 암호화되고 인증된다는 의미입니다. 재협상은 TLS 호스트가 기존 세션을 완료하지 않고도 새 세션 매개 변수를 생성(예: 새 TLS 세션 키를 생성)하려고 할 때 사용됩니다. 예를 들어, 애플리케이션에 대한 보안 정책에 따라 제한된 시간 동안만 세션 키가 사용되는데 그 시간 이후에도 TLS 세션이 활성 상태로 유지되는 경우에는 재협상이 바람직할 수 있습니다.

세션 재협상과 관련된 한 가지 문제는 TLS를 특정 중간자(man-in-the-middle) 공격에 취약하게 만든다는 것입니다. 이것은 서버가 새로운 매개 변수로 재협상을 시작하도록 유도하여 공격자가 TLS 세션을 가로챌 수 있도록 하는 공격입니다. 이 문제를 완화하기 위해 보안 재협상 표시 확장이 도입되었습니다(**오류! 참조 소스를 찾을 수 없습니다.** 섹션 참조).

NetX Secure TLS는 세션 재협상 및 보안 재협상 표시 확장을 완벽하게 지원합니다.

원격 호스트에서 데이터를 받을 때 재협상(및 확장)은 애플리케이션 상호 작용 없이 자동으로 처리됩니다. 세션 재협상에 대한 알림이 필요한 경우 *nx_secure_tls_session_renegotiate_callback_set* 서비스를 통해 재협상 콜백을 제공할 수 있습니다. 원격 호스트가 재협상을 요청할 때마다 콜백이 호출되고 필요한 경우 애플리케이션이 조치를 취할 수 있도록 합니다.

활성 TLS 세션에서 재협상을 시작하려면 필요한 TLS 세션에서 *nx_secure_tls_session_renegotiate* 서비스를 호출하면 됩니다.

### <a name="tls-session-resumption"></a>TLS 세션 재개

TLS 세션 재개는 세션 재협상과 비슷한 점이 있지만 혼동해서는 안 됩니다. 세션 재협상은 기존 TLS 세션 내에서 새 핸드셰이크를 시작하는 반면, 세션 재개는 TLS 핸드셰이크를 완전히 수행하지 않고 닫힌 TLS 세션을 다시 시작하며 전적으로 선택적 기능입니다.  이를 위해 TLS 구현은 세션 매개 변수 및 키를 캐시하여 원래 핸드셰이크에서 제공된 고유 식별자인 세션 ID와 연결합니다. TLS 서버에 세션 ID를 제공함으로써 클라이언트는 호스트 간의 이전 TLS 세션이 존재했고 과거에 완료되었으며 핸드셰이크가 줄어든 세션을 다시 설정할 수 있는 상태를 클라이언트가 여전히 보유하고 있음을 나타냅니다. 세션 키는 이론적으로 아직 비밀이고 통신 중인 두 호스트만 알고 있기 때문에 서버는 새 TLS 세션을 시작하면서 대부분의 정상적인 핸드셰이크를 우회할 수 있습니다.

세션 재개는 키 생성 마스터 비밀을 공유하고 인증서 서명을 확인하는 데 사용하는 잠재적으로 비용이 많이 드는 공개 키 작업을 방지하는 데 유용할 수 있지만, 가능한 모든 세션에 대해(적어도 구성 가능 기간 동안) 세션 매개 변수, 키, 암호화 상태가 메모리에 유지되어야 합니다.

현재 버전의 NetX Secure TLS는 세션 재개를 지원하지 않습니다. 세션 ID는 TLS 서버에서 간단히 무시되며 TLS 클라이언트는 항상 NULL 세션 ID를 제공하여 서버가 완전한 핸드셰이크를 수행하도록 요청합니다. 세션 재개가 부족해도 상호 운용성 문제는 발생하지 않습니다. 전적으로 선택적인 기능이기 때문입니다. 세션 ID가 NULL이거나 인식되지 않으면 모든 TLS 구현이 기본적으로 완전한 핸드셰이크로 설정되어야 합니다.

### <a name="protocol-layering"></a>프로토콜 계층화

TLS 프로토콜은 전송 계층(예: TCP)과 애플리케이션 계층 사이의 네트워킹 스택에 적합합니다. TLS는 경우에 따라 전송 계층 프로토콜(따라서 *전송 계층* 보안)로 간주되지만, 기본 네트워크 프로토콜(예: TCP)과 관련하여 애플리케이션으로 작동하기 때문에 애플리케이션 계층으로 그룹화되는 경우도 있습니다.

TLS에는 순차적 전달 및 무손실 전달을 지원하는 전송 계층 프로토콜(예: TCP)이 필요합니다. 이러한 요구 사항 때문에 TLS는 UDP 위에서 실행할 수 없습니다. UDP는 데이터그램 전달을 보장하지 않기 때문입니다. TLS의 수정 버전인 *DTLS* 라는 별도의 프로토콜은 UDP와 같은 데이터그램 프로토콜을 통해 TLS 보안이 필요한 애플리케이션에 사용됩니다. NetX Secure는 DTLS를 지원하지만 DTLS에 대한 설명서는 이 문서와는 별개입니다.

![TCP/IP 및 TLS 프로토콜 계층의 다이어그램입니다.](media/image6.png)

그림 5- TCP/IP 및 TLS 프로토콜 계층

## <a name="network-communications-security"></a>네트워크 통신 보안

공용 네트워크와 인터넷을 통한 통신 보안은 매우 중요한 토픽이며 다수의 서적, 기사 및 솔루션의 주제입니다. 이 토픽은 매우 복잡하지만, 의도한 대상만 정보에 액세스하거나 정보를 변경할 수 있도록 네트워크를 통해 정보 보내기라는 간단한 개념으로 정리할 수 있습니다. 이 개념은 다시 비밀 유지, 무결성 및 인증이라는 세 가지 중요한 개념으로 나뉩니다. TLS 프로토콜은 세 가지 모두에 대한 솔루션을 제공합니다.

### <a name="secrecy"></a>비밀 유지

네트워크를 통해 데이터를 전송하는 경우 악의적인 엔터티가 데이터를 손에 넣을 수 없도록 하는 것이 중요한 경우가 많습니다. TCP/IP 연결을 통해 데이터를 전송하는 경우에는 네트워크에 액세스할 수 있는 사람이라면 누구나 쉽게 사용 가능한 네트워킹 도구를 사용하여 해당 데이터를 읽을 수 있습니다. 해당 데이터를 손에 넣지 못하도록 하려면 의도한 대상을 제외하고 아무도 읽을 수 없도록 인코딩해야 합니다. 이것이 비밀 유지입니다. TLS에서는 RSA, AES와 같은 암호화 알고리즘이 보안을 제공합니다.

### <a name="integrity"></a>무결성

때로는 비밀 유지만으로는 네트워크를 통해 이동하는 데이터를 보호하기가 충분하지 않습니다. 경우에 따라 악의적인 엔터티가 패킷에 포함된 내용을 몰라도 TCP 패킷의 콘텐츠를 변경할 수 있습니다. 암호화된 데이터를 변경하여 해독을 무효화하거나 메시지 매개 변수를 변경하여 공격자가 원하는 결과를 얻을 수 있습니다. 네트워크에서 전송 중인 데이터를 공격자가 변경하는 것을 막을 수는 없어도 데이터가 변경되었는지 여부를 알 수 있는 메커니즘은 제공할 수 있습니다. 전송 중에 데이터가 변경되면 알 수 있고 데이터를 거부할 수 있습니다. 이 개념이 무결성입니다. TLS에서 무결성은 해시 함수라고 알려진 암호화 루틴 클래스에 의해 제공됩니다. 해시 함수의 예는 MD5 및 SHA-1입니다.

### <a name="authentication"></a>인증

네트워크 통신 보안에서 세 번째로 중요한 개념은, 의도한 대상에게만 데이터가 전달되어야 한다는 것입니다. 공격자는 다른 호스트를 대상으로 하는 데이터를 수신하기 위해 진짜 엔터티로 가장하려고 할 수 있습니다. 비밀 유지 및 무결성 메커니즘을 사용하여 데이터가 전송되더라도, 공격자는 이러한 속임수를 통해 원하는 결과(보안 통신의 손상)를 달성할 수 있습니다. 이를 방지하려면 중요한 데이터를 보내기 전에 원격 호스트의 ID를 증명하는 메커니즘이 필요합니다. 원격 호스트의 ID를 증명하는 프로세스가 인증입니다. TLS에서 인증은 디지털 인증서, 해시 함수 및 공개 키 암호화 속성을 활용하는 디지털 서명이라는 메커니즘을 사용하여 제공됩니다(아래 설명 참조). 제한적이지만 유용한 인증 형식은 PSK(미리 공유한 키)를 통해 제공될 수도 있습니다.

## <a name="tls-encryption"></a>TLS 암호화

TLS 프로토콜은 암호화를 사용하여 인터넷을 통해 보안 네트워크 통신을 제공하기 위한 프레임워크입니다. 암호화는 일반적으로 키 없이는 원래 데이터(또는 해당 데이터에 대한 정보)를 얻는 것이 매우 어렵도록 데이터를 인코딩하는 프로세스로 정의됩니다. 컴퓨터 시스템에서 암호화는 유한 필드와 같은 복잡한 수학을 기반으로 하며 프라이빗 키(또는 대칭 암호화)와 공개 키(또는 비대칭 암호화)라는 두 가지 유형으로 분류될 수 있습니다.    프라이빗 키 암호화의 예로는 AES(Advanced Encryption Standard)와 RC4(Rivest Cipher 4)가 있습니다. 공개 키 암호화의 예로는 RSA(Rivest, Shamir, Adleson) 및 Diffie-Hellman 암호가 있습니다.

TLS 프로토콜은 성능, 보안 및 유연성의 균형을 유지하기 위해 프라이빗 키와 공개 키 암호화 루틴을 모두 사용합니다.

### <a name="private-key-encryption"></a>프라이빗 키 암호화

프라이빗 키 암호화는 수천 년간 사용되어 왔습니다. 기본 대체 암호(문자나 단어가 관련 없는 다른 문자나 단어로 대체됨)는 가장 먼저 알려진 암호화의 예이지만 정보화 시대의 도래로 인해 프라이빗 키 암호화가 크게 향상되었습니다.

프라이빗 키 암호는 "키"를 사용합니다. 이 키는 데이터를 인코딩하는 데 사용되는 값(일반적으로 단어, 문구 또는 숫자일 수 있음)이며, 이 키에 액세스할 수 있는 엔터티만 의미 있는 방식으로 데이터를 디코딩할 수 있습니다. 이 키는 데이터 암호화 및 암호 해독 모두에 사용되기 때문에 대칭 암호화라는 다른 이름이 있습니다.

프라이빗 키 암호는 포함된 수학이 매우 복잡하더라도 일반적으로 빠르고 간단하게 구현할 수 있습니다. 그래서 TLS는 보안 통신의 대부분에 프라이빗 키 암호를 사용합니다.

하지만 프라이빗 키 암호화를 일반 컴퓨터 네트워크 통신에 적용하려고 할 때는 문제가 있습니다. 통신하려는 두 컴퓨터 사이에 키를 공유해야 한다는 점입니다. 인터넷 상의 두 컴퓨터 사이에 프라이빗 키를 안전하게 주고받는 것은 일반적으로 비현실적이며 불가능한 경우가 많습니다. 네트워크 트래픽이 인터넷을 통해 라우팅될 때 데이터가 거치는 다양한 곳에서 여러 엔터티가 데이터를 손에 넣는 것이 가능하다고 생각할 수 있기 때문입니다. 악의적인 엔터티가 키를 확보하면 이 키를 사용하여 암호화된 모든 데이터는 손상됩니다. 인터넷 상의 대부분의 컴퓨터에는 네트워크 연결만 있고 통신을 위한 다른 보안 채널이 없기 때문에 네트워크를 통해 키를 보내는 것은 암호화되지 않은 데이터를 보내는 것과 마찬가지이며 보안이 제공되지 않습니다.

따라서, 프라이빗 키 암호화는 범용 네트워크 통신 보안 프로토콜을 구현하기에 충분하지 않습니다. 이 경우 공개 키 암호화가 도움이 될 수 있습니다.

NetX Secure TLS는 AES 프라이빗 키 암호화를 지원합니다.

### <a name="public-key-encryption"></a>공개 키 암호화

프라이빗 키 암호화와 달리 공개 키 암호화는 상당히 새로운 개념으로, 1970년에 개발되었습니다. 수학의 "트랩 도어 함수"라는 개념을 사용하여, 암호화된 데이터의 보안을 손상시키지 않으면서 네트워크를 통해 키를 공유할 수 있는 방법이 있음을 발견했습니다.

공개 키 암호화가 작동하는 방식은 키(위에 설명된 프라이빗 키 암호화에서의 의미)가 프라이빗 키와 공개 키라는 두 부분으로 분할되고, 공개 키 암호화가 이름을 가져오는 것입니다.  이러한 키 중 하나(일반적으로 공개 키)가 암호화에 사용되고 다른 하나는 암호 해독에 사용된다는 개념입니다. 키의 비대칭으로 인해 공개 키 암호화의 다른 이름은 비대칭 암호화입니다.

공개 키 암호화 이면의 수학은 상당히 복잡하지만, 그 개념은 공개 키는 암호화에만 사용될 수 있고 이 키를 확보해도 암호화된 데이터를 확보할 수는 없다는 것입니다. 공개 키를 사용하여 암호화된 데이터를 해독하는 유일한 방법은 프라이빗 키입니다. 따라서 프라이빗 키를 비밀로 유지하면, 프라이빗 키의 소유자와 안전하게 통신하려는 사람은 프라이빗 키를 소유한 사람만 보안 데이터를 확보할 수 있다는 것을 알고 해당 공개 키로 데이터를 암호화하기만 하면 됩니다.

NetX Secure TLS는 RSA 공개 키 암호화를 지원합니다.

> [!IMPORTANT] 
> 소프트웨어 RSA 구현이 사용되는 경우 RSA는 프로세서 사용량이 매우 많은 작업입니다. 키 크기가 클수록 필요한 처리 능력이 제곱 비율로 증가합니다. 즉, 키 크기가 2배 증가하면 속도는 4배 느려집니다.

### <a name="public-key-authentication"></a>공개 키 인증

공개 키 암호화 개념의 흥미로운 부작용은 반대로(프라이빗 키를 사용하여 암호화하고 공개 키를 사용하여 해독) 작업을 수행하여 인증은 물론 암호화를 제공하는 데 사용할 수 있다는 것입니다.  이 작업을 수행하는 실제 메커니즘은 사용되는 공개 키 알고리즘에 따라 달라지지만 개념은 동일합니다.

공개 키 인증을 사용하여 인증하기 위해 프라이빗 키 소유자는 프라이빗 키를 사용하여 일부 데이터(일반적으로 인증 받을 데이터의 암호화 해시)를 암호화합니다. 그런 다음, 데이터가 프라이빗 키 소유자로부터 왔음을 인증하려는 사람은 연결된 공개 키를 사용하여 데이터를 해독합니다. 해독에 성공하면(이 사용자가 공개 키의 유효성을 신뢰했다고 가정하고) 이 사용자는 데이터가 프라이빗 키 소유자로부터 왔다는 것을 확신할 수 있습니다.

TLS에서 공개 키 인증은 신뢰할 수 있는 인증서 저장소의 공개 키를 사용하여 TLS 서버(및 선택적으로 TLS 클라이언트)가 제공한 디지털 인증서의 유효성을 확인하는 데 사용됩니다. 인증서는 저장소의 공개 키와 비교하여 확인되며 인증서의 데이터는 서버의 ID를 확인하는 데 사용됩니다.

NetX Secure TLS는 RSA 인증을 지원합니다.

### <a name="cryptographic-hashing"></a>암호화 해시

암호화(encryption)는 TLS에서 사용되는 유일한 암호화(cryptographic) 작업이 아닙니다. TLS 세션 중에 메시지 무결성을 제공하려면 메시지 내용이 변조되지 않았는지 확인하는 체크섬이 필요합니다. 하지만 간단한 체크섬(TCP에서 사용됨)만으로는 적합한 수준의 무결성을 보장할 수 없습니다. 지식이 풍부한 공격자가 쉽게 손상시킬 수 있기 때문입니다. TLS에서 메시지 무결성을 제공하는 데 사용하는 메커니즘을 암호화 해시라고 합니다.

암호화는 1:1 인코딩입니다. 즉, 암호화된 데이터에서 원본 데이터 전체를 얻을 수 있습니다. 하지만 해시는 임의의 크기인 데이터를 체크섬처럼 고정된 크기 값에 매핑합니다. 간단한 체크섬과 달리 해시는 다른 입력 데이터가 동일한 출력을 생성하는 충돌을 줄이기 위해 특별히 설계되었습니다. 간단한 체크섬에서 비트가 1에서 0으로, 또 다른 비트가 0에서 1로 바뀌면 체크섬은 동일합니다. 암호화 해시를 사용하면 출력이 상당히 달라지기 때문에 공격자가 해시된 데이터를 변경하고 변경된 데이터에 해시 작업을 수행하여 여전히 동일한 값을 얻기(따라서 해당 데이터의 무결성을 거짓으로 확인하기)가 어렵습니다.

TLS는 다양한 해시 알고리즘을 사용하여 메시지(애플리케이션 메시지와 TLS 제어 메시지 모두)의 무결성을 제공합니다. 여기에는 MD5, SHA-1 및 SHA-256이 포함됩니다.

NetX Secure TLS는 MD5, SHA-1 및 SHA-256 해시를 지원합니다.

## <a name="tls-extensions"></a>TLS 확장

TLS는 특정 애플리케이션에 대한 추가 기능이 포함된 여러 확장을 제공합니다. 이러한 확장은 일반적으로 ClientHello 또는 ServerHello 메시지의 일부로 전송되며, 확장을 사용해야 한다고 원격 호스트에 알리거나 보안 TLS 세션을 설정하는 데 사용할 추가 세부 정보를 원격 호스트에 제공합니다.

일반적으로 확장은 진행 작업을 안내하는 핸드셰이크 시작 부분에서 TLS에 선택적 매개 변수를 제공합니다. 일부 확장에는 애플리케이션 입력 또는 의사 결정이 필요하고 다른 확장은 자동으로 처리됩니다.

다음 표에서는 현재 NetX Secure TLS에서 지원하는 TLS 확장에 대해 설명합니다.

| **Extension Name**              | **설명**              |
| ------------------------------- |----------------------------- |
| 보안 재협상 표시 | 이 확장은 재협상 핸드셰이크 중에 발생할 수 있는 중간자(man-in-the-middle) 공격 취약점을 완화합니다.|
| 서버 이름 표시          | 이 확장을 통해 TLS 클라이언트는 특정 DNS 이름을 TLS 서버에 제공하여 서버가 올바른 자격 증명을 선택할 수 있습니다(서버에 여러 ID 인증서와 네트워크 진입점이 있다고 가정). |
| 서명 알고리즘            | 이 확장을 통해 TLS 클라이언트는 허용되는 서명 및 해시 알고리즘 목록을 TLS 서버에 제공할 수 있습니다. |

지원되는 TLS 확장 개요

### <a name="secure-renegotiation-indication"></a>보안 재협상 표시

TLS는 기존 TLS 세션 내에서 핸드셰이크를 수행하는 개념을 지원하므로 설정된 세션을 사용하여 핸드셰이크 메시지를 암호화합니다. 이 프로세스를 통해 TLS 세션을 종료하지 않고 암호화 세션 키를 다시 설정할 수 있습니다("TLS 세션 재협상" 섹션 참조).

유감스럽게도 TLS가 한동안 재협상을 사용한 후, 재협상 기능을 악용한 중간자(man-in-the-middle) 공격에 대한 취약성이 있다는 것을 알게 되었습니다. 이러한 취약성을 해소하기 위해 보안 재협상 표시라는 확장이 도입되었습니다. 기본적으로 보안 재협상 확장은 설정된 연결의 Finished 메시지 해시를 사용하여 원래 호스트가 재협상 핸드셰이크에 참여 중인지 확인합니다. 기본적으로 해시는 공격자가 해시를 위조할 수 없다는 가정 하에 확인 토큰으로 사용됩니다(세션 키에 대한 액세스가 필요함).

NetX Secure TLS는 재협상을 자동으로 처리하며 기본적으로 보안 재협상 확장을 사용합니다. 애플리케이션 상호 작용이 필요하지 않습니다.

### <a name="server-name-indication"></a>서버 이름 표시

TLS 핸드셰이크 중에 TLS 클라이언트는 클라이언트가 서버를 인증할 수 있도록 원격 서버가 ID 인증서를 제공할 것으로 예상합니다. 하지만 한 서버가 각각 고유한 ID를 가진 서로 다른 "가상" 서버로 여러 가지 서비스를 제공하는 경우가 있을 수 있습니다. 여러 ID가 있는 단일 서버의 경우 TLS 클라이언트는 서버가 적절한 자격 증명을 선택하는 데 사용할 특정 DNS 이름을 제공할 수 있습니다. 이 이름을 제공하는 메커니즘이 SNI(서버 이름 표시) 확장입니다.

SNI 확장을 사용하는 애플리케이션에는 몇 가지 상호 작용이 필요합니다. TLS 클라이언트의 경우 애플리케이션은 원격 서버에 보낼 DNS 이름을 제공해야 합니다. TLS 서버의 경우 애플리케이션은 확장에서 DNS 이름을 읽고 클라이언트에 돌려보낼 적절한 인증서를 선택해야 합니다.

다음 섹션에는 NetX Secure TLS에서 SNI 확장을 사용하는 방법에 대한 자세한 내용이 있습니다.

### <a name="sni-extension--tls-client"></a>SNI 확장 – TLS 클라이언트

SNI 확장을 사용하려는 NetX Secure TLS 클라이언트는 핸드셰이크 중에 제공할 DNS 이름을 TLS에 제공해야 합니다. 이 이름은 TLS 세션을 시작하기 전에 초기화되고 제공되어 야합니다. 확장은 핸드셰이크 프로세스를 시작하는 ClientHello 메시지에 포함되어 전송되기 때문입니다.

다음 코드 조각은 확장을 사용하는 방법을 보여줍니다. 먼저 NX_SECURE_X509_DNS_NAME 개체가 원하는 서버 이름으로 초기화됩니다. 그런 다음, TLS 세션을 시작하기 전에 SNI 확장 API를 사용하여 TLS에 이름이 제공됩니다. 이름이 설정되면 추가 작업이 필요하지 않습니다. 챕터 4의 API 참조를 확인하세요.  
  
개별 함수에 대한 자세한 내용은 NetX Secure 서비스에 대한 설명을 참조하세요.

```C
/* The dns_name variable will contain our desired server name. */
UINT status;
NX_SECURE_X509_DNS_NAME dns_name;

/* Initialize the server DNS name. */
status = nx_secure_x509_dns_name_initialize(&dns_name, "www.example.com", 
                                            strlen("www.example.com"));


/* Initialize SNI extension in previously-initialized TLS Session. */
status = nx_secure_tls_session_sni_extension_set(&client_tls_session, &dns_name);

/* Now start the TLS session, starting with establishing the TCP connection – if 
   TLS is started before initializing the SNI extension, the extension will not be 
   sent in the ClientHello message! */
status = nx_tcp_client_socket_connect(&client_socket, IP_ADDRESS(1, 2, 3, 4), 443, 
                                      5 * NX_IP_PERIODIC_RATE);

status = nx_secure_tls_session_start(&client_tls_session, &client_socket, 
                                     NX_WAIT_FOREVER);
```
### <a name="sni-extension--tls-server"></a>SNI 확장 – TLS 서버

TLS 서버 측에서 SNI 확장은 핸드셰이크 중에 원격 클라이언트에 제공할 적절한 자격 증명(예 : 인증서)을 선택하기 위해 애플리케이션에서 처리될 수 있습니다. 그러려면 애플리케이션은 ClientHello 메시지 수신 후 호출되는 세션 콜백을 제공해야 합니다.

nx_secure_tls_session_server_callback_set API(122 페이지 참조)에 대한 예제 코드는 서버 콜백을 사용한 수신 SNI 확장의 구문 분석을 보여줍니다. 기본적으로 TLS 서버는 ClientHello를 수신하고 콜백을 호출합니다. 그런 다음, 애플리케이션은 *nx_secure_tls_session_sni_extension_parse* API를 사용하여 콜백에 제공된 확장 데이터를 구문 분석하여 SNI 확장을 찾고 제공된 DNS 이름을 반환합니다(확장은 단일 DNS 이름만 지원함). 이름을 얻으면 애플리케이션은 그 이름을 사용하여 적절한 서버 ID 인증서(및 해당되는 경우 발급자 체인)를 찾아서 보냅니다.

### <a name="signature-algorithms-extension"></a>서명 알고리즘 확장

이 확장은 TLS 1.2에만 해당되며 TLS 클라이언트가 디지털 서명을 생성 및 확인하는 데 사용할 수 있는 허용되는 서명 및 해시 알고리즘 쌍 목록을 제공할 수 있도록 합니다. 이 목록은 *nx_secure_tls_session_create* 에 제공된 암호 테이블을 사용하여 TLS 클라이언트용 NetX Secure TLS에 의해 자동으로 생성됩니다. 애플리케이션 상호 작용이 필요하지 않습니다.

## <a name="authentication-methods"></a>인증 방법

TLS는 안전하지 않은 네트워크를 통해 두 디바이스 간에 보안 연결을 설정할 수 있는 프레임워크를 제공하지만, 해당 연결의 반대쪽 끝에 있는 디바이스 ID를 알아야 한다는 문제가 있습니다. 원격 호스트의 ID를 인증하는 메커니즘이 없으면 공격자는 신뢰할 수 있는 디바이스로 손쉽게 가장할 수 있습니다.

처음에는 IP 주소, 하드웨어 MAC 주소 또는 DNS를 사용하면 네트워크에서 호스트를 식별하는 데 비교적 높은 수준의 신뢰도를 제공하는 것처럼 보일 수 있지만, TCP/IP 기술의 특성과 주소를 쉽게 스푸핑할 수 있고 DNS 항목이 손상(예: DNS 캐시 손상을 통해)될 수 있다는 점을 고려할 때 TLS에는 사기성 ID를 차단하기 위한 추가 보호 계층이 필요합니다.

TLS에 이와 같은 추가 인증 계층을 제공할 수 있는 다양한 메커니즘이 있지만, 가장 일반적인 방법은 *디지털 인증서* 입니다. 기타 메커니즘으로는 PSK(미리 공유한 키) 및 암호 체계가 있습니다.

### <a name="digital-cerificates"></a>디지털 인증서

디지털 인증서는 TLS에서 원격 호스트를 인증하는 가장 일반적인 방법입니다. 기본적으로 디지털 인증서는 컴퓨터 네트워크 상의 디바이스에 대한 ID 정보를 제공하는 특정 형식을 포함하고 있는 문서입니다.

TLS는 일반적으로 International Telecommunication Union에서 개발한 표준인 X.509 형식을 사용하지만, 사용하려는 형식을 TLS 호스트에서 동의할 수 있다면 다른 형식의 인증서를 사용해도 됩니다. X.509는 디지털 문서를 작성하는 데 사용할 수 있는 다양한 인코딩 및 인증서의 형식을 정의합니다. TLS에 사용되는 대부분의 X.509 인증서는 다른 통신 표준의 변형인 ASN.1을 사용하여 인코딩됩니다. ASN.1에는 다양한 디지털 인코딩이 포함되어 있지만, TLS 인증서에 사용되는 가장 일반적인 인코딩은 DER(Distinguished Encoding Rules) 표준입니다. DER은 구문 분석을 쉽게 수행할 수 있도록 분명하게 설계된 ASN.1 BER(Basic Encoding Rules)의 간소화된 하위 세트입니다. 네트워크를 통해 TLS 인증서는 일반적으로 이진 DER로 인코딩되며, 이 형식은 NetX Secure에서 X.509 인증서에 요구하는 형식입니다.

DER 형식의 이진 인증서는 실제 TLS 프로토콜에 사용되지만 .pem, .crt, .p12 등의 파일 확장명을 사용하여 다양한 인코딩으로 생성하고 저장할 수 있습니다. 여러 제조업체의 다양한 애플리케이션에서 다양한 변형이 사용되지만, 일반적으로 널리 제공되는 도구를 사용하여 DER로 변환할 수 있습니다.

가장 일반적인 대체 인증서 인코딩은 PEM입니다. Privacy Enhanced Mail의 PEM 형식은 base-64로 인코딩된 DER 인코딩 버전으로, 인코딩 결과가 이메일 또는 웹 기반 프로토콜을 사용하여 쉽게 보낼 수 있는 인쇄 가능한 텍스트로 생성되기 때문에 자주 사용됩니다.

NetX Secure 애플리케이션의 인증서 생성은 일반적으로 이 설명서의 범위를 벗어나지만, OpenSSL 명령줄 도구([www.openssl.org](http://www.openssl.org))는 광범위하게 사용할 수 있으며 대부분의 형식을 변환할 수 있습니다.

애플리케이션에 따라 사용자 고유의 인증서를 생성할 수도 있고, 제조업체 또는 정부 기관에서 인증서를 제공할 수도 있고, 상용 인증 기관에서 인증서를 구매할 수도 있습니다.

NetX Secure 애플리케이션에서 디지털 인증서를 사용하려면 먼저 인증서를 이진 DER 형식으로 변환하고, 필요에 따라 연결된 프라이빗 키(예: RSA의 경우 "프라이빗 지수")를 이진 형식(일반적으로 PKCS#1 형식의 DER로 인코딩된 RSA 키 또는 DER로 인코딩된 ECC 키)으로 변환해야 합니다. 변환이 완료되면 디바이스에 인증서 및 프라이빗 키를 로드해야 합니다. 선택 가능한 옵션으로는 플래시 기반 파일 시스템을 사용하거나, 데이터에서 C 배열을 생성하고(Linux의 "xxd" 같은 도구를 사용하여) 인증서와 키를 애플리케이션에 상수 데이터로 컴파일하는 방법이 있습니다.

인증서가 디바이스에 로드되면 TLS API를 사용하여 인증서를 TLS 세션과 연결할 수 있습니다.

NetX Secure TLS에서 X.509 인증서를 사용하는 방법에 대한 자세한 내용과 예제는 "NetX Secure로 X.509 인증서 가져오기" 섹션을 참조하세요.

자세한 내용은 API 참조에서 다음 TLS 서비스를 확인하세요.

- nx_secure_x509_certificate_initialize
- nx_secure_tls_local_certificate_add
- nx_secure_tls_local_certificate_remove
- nx_secure_tls_remote_certificate_allocate
- nx_secure_tls_trusted_certificate_add
- nx_secure_trusted_certificate_remove

### <a name="tls-client-certificate-specifics"></a>TLS 클라이언트 인증서 세부 정보

일반적으로 TLS 클라이언트를 구현할 때 "로컬" 인증서<sup>14</sup>를 디바이스에 로드하지 않아도 됩니다. 클라이언트 인증서 인증을 사용하도록 설정된 경우에는 예외지만, 전혀 일반적인 상황은 아닙니다.

TLS 클라이언트를 사용하려면 "신뢰할 수 있는" 인증서<sup>15</sup>를 하나 이상 로드해야 하며(필요한 경우 더 많이 로드할 수 있음) "원격" 인증서<sup>16</sup>를 할당할 공간이 필요합니다.

신뢰할 수 있는 인증서를 추가하고 원격 인증서의 공간을 할당하는 방법에 대한 자세한 내용은 nx_secure_tls_remote_certificate_allocate, nx_secure_tls_trusted_certificate_add 서비스의 TLS API 참조를 확인하세요.

14. "로컬" 인증서는 로컬 디바이스를 식별하는 인증서입니다. 즉, TLS 애플리케이션이 로드되는 디바이스에 대한 ID 정보를 제공합니다.

15. "신뢰할 수 있는" 인증서는 직접 또는 PKI(공개 키 인프라)를 통해 원격 디바이스의 신뢰와 인증을 위한 기반을 제공하는 인증서입니다. 신뢰 체인의 루트를 일반적으로 “인증 기관” 또는 CA 인증서라고 합니다.

16. "원격" 인증서는 TLS 핸드셰이크 중에 원격 호스트가 보낸 인증서를 말합니다. 해당 원격 호스트의 ID를 제공하며, 로컬 디바이스의 "신뢰할 수 있는" 인증서와 비교하여 인증됩니다.

### <a name="tls-server-certificate-specifics"></a>TLS 서버 인증서 세부 정보

일반적으로 TLS 서버를 구현할 때 "신뢰할 수 있는" 인증서를 디바이스에 로드하거나 원격 인증서를 할당할 필요가 없습니다. 클라이언트 인증서 인증을 사용하도록 설정된 경우에는 예외입니다(일반적이지 않음).

TLS 서버의 경우 TLS 핸드셰이크 중에 원격 클라이언트에 인증서를 제공하여 서버를 클라이언트에 인증할 수 있도록 "로컬"(또는 "ID") 인증서를 로드해야 합니다.

NetX TLS 서버 애플리케이션에 사용할 로컬 인증서를 로드하는 방법에 대한 자세한 내용은 API 참조에서 다음 서비스를 확인하세요. 
- nx_secure_tls_local_certificate_add, 
- nx_secure_tls_local_certificate_remove.

### <a name="pre-shared-keys-psk"></a>PSK(미리 공유한 키)

TLS에서 식별 인증을 제공하는 또 다른 메커니즘은 PSK(미리 공유한 키)라는 개념입니다. PSK ciphersuite를 사용하면 프로세서 사용량이 많은 공개 키 암호화 작업을 수행할 필요가 없으므로 리소스가 제한적인 임베디드 디바이스에 요긴합니다. PSK는 TLS 핸드셰이크의 인증서를 대체하며 TLS 세션 키 생성을 위해 암호화된 Pre-Master Secret 대신 사용됩니다.

PSK ciphersuite는 TLS 세션을 설정하려면 두 디바이스 모두에 공유 비밀이 있어야 한다는 점에서 제한적입니다. 즉, TLS PSK 연결이 아닌 다른 안전한 방법으로 해당 비밀을 디바이스에 로드해야 합니다. PSK는 TLS PSK 연결을 통해 업데이트할 수 있지만, 디바이스는 반드시 다른 메커니즘을 통해 로드된 PSK를 사용하여 시작해야 합니다. 예를 들어 출하 전에 공장에서 PSK를 사용하여 센서 디바이스와 게이트웨이 디바이스를 로드하거나, 표준 TLS 연결(인증서 포함)을 사용하여 PSK를 로드할 수 있습니다.

PSK ciphersuite는 RFC 4279에 설명된 여러 가지 형식으로 제공됩니다. 첫 번째 형식은 표준 TLS 핸드셰이크에서 인증서에 전송된 공개 키와 동일한 방식으로 사용되는 RSA 또는 Diffie-Hellman 키를 사용합니다. 리소스가 제한적인 환경에서 더 많이 사용되는 두 번째 형식은 세션 키(AES에서 사용할)를 직접 생성하는 데 사용되는 PSK를 사용하며, 비용이 많이 드는 RSA 또는 Diffie-Hellman 작업의 사용을 방지합니다.

NetX Secure는 애플리케이션에서 모든 공개 키 암호화 코드 및 메모리를 사용하지 않도록 두 번째 PSK ciphersuite 형식을 지원합니다. PSK 자체는 AES 키가 아니지만 실제 키가 생성되는 암호와 비슷한 것으로 간주할 수 있습니다. PSK 값에는 몇 가지 제한 사항이 있지만, 암호와 마찬가지로 값이 길수록 강력한 보안을 제공합니다.

NetX Secure 애플리케이션에서 PSK를 사용하려면 먼저 글로벌 매크로 **NX_SECURE_ENABLE_PSK_CIPHERSUITES** 를 정의해야 합니다. 이 작업은 일반적으로 컴파일러 설정을 통해 수행되지만 nx_secure_tls.h 헤더 파일에 정의를 배치할 수도 있습니다. 매크로가 정의되면 PSK ciphersuite 지원이 NetX Secure TLS 애플리케이션으로 컴파일됩니다.

PSK 지원을 사용하도록 설정한 후에는 TLS API를 사용하여 애플리케이션에 대한 PSK를 설정할 수 있습니다. 각 PSK에는 PSK 값(실제 비밀 "키" – 안전하게 보관해야 함), 특정 PSK를 식별하는 데 사용되는 "ID" 값, 그리고 TLS 서버에서 특정 PSK 값을 선택하는 데 사용하는 "ID 힌트"가 필요합니다.

PSK 자체는 네트워크 연결을 통해 전송되지 않으므로 임의의 이진 값일 수 있습니다. PSK의 최대 길이는 64바이트입니다.

ID 및 힌트는 UTF-8을 사용하여 서식이 지정된 인쇄 가능한 문자열이어야 합니다. ID 및 힌트 값의 최대 길이는 128바이트입니다.

ID 및 PSK는 서로 통신해야 하는 네트워크 상의 모든 디바이스에 로드되는 고유한 쌍을 형성합니다.

"힌트"는 PSK를 함수 또는 서비스별로 그룹화하는 애플리케이션 프로필을 정의하는 데 주로 사용됩니다. 이러한 값은 미리 합의해야 하며 애플리케이션에 따라 달라집니다. 예를 들어 PSK를 사용하도록 설정된 OpenSSL 명령줄 서버 애플리케이션은 TLS 핸드셰이크를 계속하려면 TLS 클라이언트에서 제공해야 하는 기본 문자열인 "Client_identity"를 사용합니다.

PSK에 대한 자세한 내용은 nx_secure_tls_client_psk_set, nx_secure_tls_psk_add 서비스에 대한 NetX Secure API 참조를 확인하세요.

## <a name="importing-x509-certificates-into-netx-secure"></a>NetX Secure로 X.509 인증서 가져오기

디지털 인증서는 인터넷에서 이루어지는 대부분의 TLS 연결에 필요합니다. 인증서는 일반적으로 *CA(인증 기관)* 라고 하는 신뢰할 수 있는 중개자를 사용하여 인터넷을 통해 이전에는 알 수 없었던 호스트를 인증하는 방법을 제공합니다. NetX Secure 디바이스를 상용 클라우드 서비스(예: Amazon Web Services)와 연결하려면 인증서를 디바이스에 로드하여 인증서를 애플리케이션으로 가져와야 합니다.

인증서와 함께 인증서와 연결된 *프라이빗 키* 가 필요할 수도 있습니다. 일부 애플리케이션(예: 클라이언트 인증서 인증을 사용하지 않는 경우 TLS 클라이언트)에서는 인증서 하나로 충분하지만, 인증서를 사용하여 디바이스를 식별하는 경우에는 프라이빗 키가 필요합니다. 프라이빗 키는 일반적으로 인증서를 만들 때 생성되고 별도의 파일에 저장되며, 이러한 파일은 종종 암호로 암호화됩니다.

### <a name="certificate-types"></a>인증서 종류

디지털 인증서는 일반적으로 네트워크의 엔터티를 식별하는 데 사용되지만 애플리케이션에 따라 약간 다른 속성을 갖습니다.

### <a name="local-certificates"></a>로컬 인증서

이 문서에서는 "로컬 인증서"를 로컬 디바이스에 대한 ID를 제공하는 인증서라고 합니다(다른 가능한 이름은 "디바이스 인증서"일 수 있음). 이러한 인증서는 원격 호스트가 로컬 디바이스를 인증하려고 할 때 원격 호스트에 제공됩니다.

### <a name="remote-certificates"></a>원격 인증서

이 설명서에서 "원격 인증서"는 해당하는 경우 TLS 핸드셰이크 중 원격 호스트가 제공한 인증서를 말합니다. 이러한 인증서를 위한 공간을 할당해야 합니다. 그렇지 않으면 NetX Secure는 인증서를 구문 분석할 수 없고 TLS 핸드셰이크를 완료할 수 없습니다.

### <a name="signing-certificates"></a>서명 인증서

"서명 인증서"는 인증을 위해 다른 인증서 또는 데이터에 디지털 서명하는 데 사용됩니다. 이러한 인증서는 PKI(공개 키 인프라) 내의 중간 또는 루트 인증서일 수 있으며 일반적으로 개별 디바이스나 호스트를 식별하는 데 사용되지 않습니다.

### <a name="root-ca-certificates"></a>루트 CA 인증서

"루트 CA 인증서"는 PKI의 기반을 제공하고 다른 서명 인증서로 서명되지 않고 자체 서명된 서명 인증서입니다. TLS 클라이언트가 원격 서버를 확인하려면 일반적으로 하나 이상의 루트 CA 인증서가 필요합니다.

### <a name="certificate-formats"></a>인증서 형식

디지털 인증서는 ASN.1 구문을 사용하여 인코딩된 정형 데이터를 포함하는 간단한 파일입니다. 하지만, 인증서를 저장할 수 있는 다양한 형식이 있으며 NetX Secure 애플리케이션에 인증서를 로드하기 전에 올바른 형식을 갖는 것이 중요합니다.

인증서에 가장 일반적인 형식은 DER 및 PEM입니다. DER(*Distinguished Encoding Rules* 의 경우 ASN.1 형식)은 초기 핸드셰이크를 수행할 때 TLS에서 사용하는 이진 형식입니다. PEM(*Privacy Enhanced Mail*)은 웹에서 HTTP를 통해 보내거나 이메일을 보내는 데 적합한 DER 형식의 Base-64 인코딩 버전입니다. 공급 업체마다 인증서에 대해 다른 파일 이름 확장명을 사용합니다. PEM 인증서의 경우 ".pem" 또는 ".crt", DER 인증서의 경우 ".der"입니다. 인증서가 있고 사용되는 형식이 명확하지 않은 경우에는 텍스트 편집기에서 파일을 열면 유형을 확인할 수 있습니다. DER 파일은 인코딩된 이진 파일이고 PEM 파일은 "----- BEGIN CERTIFICATE -----" 헤더로 시작하는 일반 ASCII 텍스트이기 때문입니다.

NetX Secure에서는 인증서가 이진 DER 형식이어야 하므로 인증서를 가져오기 전에 DER 형식으로 변환해야 합니다. 이 작업은 OpenSSL과 같이 쉽게 사용할 수 있는 도구로 수행할 수 있습니다.

애플리케이션에 프라이빗 키가 필요한 경우 키 파일은 특정 형식(RSA의 경우 PKCS # 1, ECC의 경우 RFC 5915)의 PEM 또는 DER을 사용하여 인코딩됩니다. 프라이빗 키 파일은 가져오기 전에 DER로 변환해야 합니다.

다음 OpenSSL 명령은 인증서 및 RSA 키 파일을 NetX Secure에 필요한 DER 형식으로 변환하는 예입니다(ECC는 유사함 - OpenSSL 설명서 참조).

```C
openssl x509 -inform PEM -in <certificate> -outform DER -out cert.der
openssl x509 -inform PEM -in <root CA cert> -outform DER -out CA_cert.der
openssl rsa -inform PEM -in <private key> -outform DER -out private.key
```
### <a name="private-keys-and-certificates"></a>프라이빗 키 및 인증서

디바이스를 식별하는 인증서의 경우, 연결된 프라이빗 키는 인증서와 함께 로드되어야 합니다. 프라이빗 키(RSA, Diffie-Hellman 또는 Elliptic-Curve Cryptography와 같은 공개 키 알고리즘 중 하나일 수 있음)는 TLS 서버가 TLS 클라이언트에서 들어오는 키 자료("pre-master secret")를 해독하는 데 사용되어 클라이언트에 대해 자신을 인증합니다. TLS 클라이언트의 경우 ID 인증서(연결된 프라이빗 키가 있는 인증서)가 제공되고 서버가 클라이언트 인증서를 요청하면 프라이빗 키가 클라이언트를 인증하는 데 사용됩니다. RSA의 경우 클라이언트는 프라이빗 키를 사용하여 토큰을 암호화한 다음, 서버가 클라이언트 인증서에 제공된 클라이언트의 공개 키를 사용하여 해독합니다.(Diffie-Hellman 및 ECC 인증은 비슷한 방식으로 발생하지만 세부 사항은 약간 다릅니다.)

NetX Secure 에서 *nx_secure_x509_certificate_initialize* 서비스는 X.509 인증서를 초기화하고(자세한 내용은 "디바이스에 인증서 로드" 섹션 참조) 선택적으로 이 인증서와 프라이빗 키를 연결하는 데 사용됩니다.

프라이빗 키가 제공되면 인증서는 디바이스를 식별하는 데 사용되는 "ID" 인증서로 표시됩니다. 키는 연속 이진 Blob 및 길이로 전달되며 연결된 키 형식이 사용됩니다. 키 유형은 키의 유형(예: RSA, ECC 등) 및 형식(예: PKCS#1 DER)에 따라 달라집니다. 키가 제공되지 않으면 NX_SECURE_X509_KEY_TYPE_NONE(값 0x0) 값을 전달하여 키가 제공되지 않은 것을 나타낼 수 있습니다.(길이 0 및 데이터 매개 변수에 대한 NX_NULL 포인터는 동일한 효과를 냅니다.)

다음 표는 NetX Secure에 알려진 키 유형과 *nx_secure_x509_certificate_initialize* 에 전달될 연결된 유형 식별자를 보여줍니다. NetX Secure에 암호화 알고리즘이 더 많이 추가되면 키 유형이 더 추가될 예정입니다.

| ID                              | 알고리즘 | 서식   | Encoding | 값 |
| --------------------------------------- | --------- | -------- | -------- | ----- |
| NX_SECURE_X509_KEY_TYPE_NONE            | None      | 해당 없음      | N/A      | 0x0   |
| NX_SECURE_X509_KEY_TYPE_RSA_PKCS1_DER   | RSA       | PKCS#1   | DER      | 0x1   |
| NX_SECURE_X509_KEY_TYPE_EC_DER          | ECDSA     | RFC 5915 | DER      | 0x2   |

### <a name="user-defined-private-key-types"></a>사용자 정의 프라이빗 키 유형

*nx_secure_x509_certificate_initialize* 서비스의 키 유형 식별자 값은 프라이빗 키가 제공될 때 수행되는 작업을 제어합니다. 알려진 유형의 경우 값은 0x0000 0000 – 0x0000 FFFF(부호 없는 32비트 정수의 맨 아래 16비트) 범위에 있습니다. 사용자 지정 키 유형<sup>17</sup>인(일부 하드웨어 기반 암호화 엔진의 경우와 마찬가지로) 플랫폼의 경우 0x0000 1000-0xFFFF FFFF(상위 16비트 0이 아님) 범위의 사용자 정의 키 유형이 키 유형으로 전달될 수 있습니다. 키 유형의 상위 16비트 중 하나가 설정되면 프라이빗 키 데이터는 TLS ciphersuite 테이블에 제공된 적절한 암호화 루틴(예: RSA)으로 직접 전달됩니다. 사용자 정의 키 유형은 암호화 루틴으로 전달되기 전에 구문 분석되거나 달리 처리되지 않습니다. 또한 사용자 정의 키 유형도 해당 수준에서 적절한 처리가 가능하도록 암호화 루틴으로 전달됩니다.

사용자 정의 키 유형은 일반적으로 사용자 지정(암호화되었을 수 있음) 키 데이터를 활용하는 특정 하드웨어 플랫폼에 사용됩니다. 일반적으로 이것은 하드웨어 공급업체에 해당하는 특정 메커니즘(또는 PKCS#11과 같은 표준의 경우 특정 표준)을 사용하여 키 데이터가 생성되거나 인코딩된다는 의미입니다. 자세한 내용은 하드웨어 플랫폼 설명서를 참조하세요.

17. 사용자 정의 키 유형에는 사용자 지정 키 형식을 처리하기 위한 해당 사용자 지정 암호화 루틴이 필요합니다. 암호화 루틴에는 일치하는 알고리즘(예: RSA)이 있어야 하며 ciphersuite 테이블의 TLS로 전달되어야 합니다. 

### <a name="loading-certificates-onto-your-device"></a>디바이스에 인증서 로드

디바이스에 파일을 로드하는 방법이면 인증서를 가져오는 데 충분합니다.

인증서를 로드하는 가장 간단한 방법은 이진 DER로 인코딩된 데이터를 C 배열로 변환하고 이것을 애플리케이션에 상수로 컴파일하는 것입니다. Linux에서 "xxd"와 같은 도구를 사용하면("-i" 옵션 사용) 쉽게 수행할 수 있습니다.

또는 인증서 데이터에 대한 포인터를 NetX Secure API에 전달할 수 있기만 하면, 인증서를 플래시 파일 시스템이나 기타 스토리지 옵션에 로드할 수 있습니다.

### <a name="certificate-files-needed-for-netx-secure"></a>NetX Secure에 필요한 인증서 파일

가져와야 하는 인증서 파일은 애플리케이션에 따라 다릅니다. 일반적으로 TLS 서버는 디바이스를 식별하는 인증서가 필요하고 TLS 클라이언트는 원격 서버를 인증하기 위한 신뢰할 수 있는 인증서가 하나 이상 필요합니다. 다음 표에서는 몇 가지 다른 TLS 애플리케이션에 필요한 인증서를 보여줍니다.

| **TLS 기능/옵션**                     | **필요한 인증서/키(최소)**              |
| ------------------------------------------------- | --------------------------------------------------- |
| TLS 클라이언트                                        | 루트 CA 인증서                                 |
| TLS 서버                                        | 로컬 인증서, 이 인증서의 프라이빗 키 |
| 클라이언트 인증서 인증을 사용하는 TLS 서버 | 로컬 인증서, 프라이빗 키, 루트 CA             |
| 클라이언트 인증서 인증을 사용하는 TLS 클라이언트 | 로컬 인증서, 프라이빗 키, 루트 CA             |
| 미리 공유한 키만 있는 TLS 클라이언트 또는 서버    | 없음(인증서 대신 PSK가 사용됨)             |

인증서 로드와 관련된 서비스는 다음과 같습니다.

| **API 이름**                                   | **용도**                                            |
| ---------------------------------------------- |------------------------------------------------------- |
| nx_secure_x509_certificate_initialize      | NX_SECURE_X509_CERT 구조를 인증서 데이터 및 프라이빗 키로 채우려면 모든 인증서에 대해 호출해야 합니다. |
| nx_secure_tls_local_certificate_add       | 디바이스를 식별하기 위해 TLS 세션에 로컬 인증서를 추가합니다.                                                                |
| nx_secure_tls_local_certificate_remove    | TLS 세션에서 로컬 인증서를 제거합니다.                                                                                   |
| nx_secure_tls_remote_certificate_allocate | 원격 인증서를 위한 공간을 할당합니다(초기화되지 않은 NX_SECURE_X509_CERT를 사용하여 호출됨).                                   |
| nx_secure_tls_trusted_certificate_add     | 인증서를 TLS 세션에 원격 호스트를 인증하는 신뢰할 수 있는 인증서로 추가합니다.                                     |
| nx_secure_tls_trusted_certificate_remove  | 신뢰할 수 있는 인증서를 TLS 세션에서 제거합니다.                                                                                 |

### <a name="working-with-aws-iot-certificates"></a>AWS IoT 인증서 작업

Amazon Web Services IoT 인터페이스의 사이드바 메뉴에서 "보안"을 선택하고 "인증서"를 선택합니다. 새 인증서를 만들고 지침에 따라 새 디바이스 인증서를 다운로드합니다.

인증서를 다운로드한 후에는 OpenSSL 또는 유사한 유틸리티를 사용하여 DER 형식으로 변환해야 합니다.

참고: AWS는 공개 키 파일도 제공합니다. 로컬 디바이스 인증서에 공개 키가 포함되어 있으므로 애플리케이션으로 가져올 필요가 없습니다.

예를 들어 로컬 디바이스 인증서와 해당 프라이빗 키를 NetX Secure에서 사용하기 위해 DER 형식으로 변환하는 명령은 다음과 같습니다.

```C
openssl x509 -inform PEM -in <certificate> -outform DER -out cert.der
openssl x509 -inform PEM -in <root CA cert> -outform DER -out CA_cert.der
openssl rsa -inform PEM -in <private key> -outform DER -out private.key
```
위의 지침에 따라 변환된 파일을 애플리케이션으로 가져올 수 있습니다.

## <a name="x509-certificate-validation-in-netx-secure"></a>NetX Secure에서 X.509 인증서 유효성 검사 

호스트 식별 및 확인을 위해 X.509 인증서에 TLS를 사용하는 경우 해당 인증서가 실제로 검증되는 방식을 이해하는 것이 중요합니다. TLS 사양은 인증서 유효성 검사 방법에 대한 자세한 지침을 제공하지 않지만 X.509 사양(RFC 5280)을 참조합니다. 일반적으로 TLS는 들어오는 인증서(TLS 핸드셰이크 중 원격 호스트가 제공한 인증서)에 대해 최소한 기본 유효성 검사를 수행해야 하며 NetX Secure TLS도 다르지 않습니다.

### <a name="basic-x509-validation"></a>기본 X.509 유효성 검사

들어오는 인증서에 대해 NetX Secure TLS는 기본 X.509 경로 유효성 검사를 수행합니다. 이 프로세스에는 각 인증서의 디지털 서명을 원격 호스트가 제공하거나 신뢰할 수 있는 인증서 저장소에 있는 발급자 인증서와 대조하여 검사하는 작업이 포함됩니다.(신뢰할 수 있는 인증서 가져오기에 대한 자세한 내용은 "NetX Secure로 X.509 인증서 가져오기"를 참조하세요.) 유효성 검사 프로세스는 신뢰할 수 있는 인증서에 도달하거나 체인이 끝날 때까지(자체 서명된 인증서 또는 누락된 발급자 인증서로) 발급자 인증서에서 재귀적으로 반복됩니다. 신뢰할 수 있는 인증서에 도달하면 인증서가 확인되고 그렇지 않으면 거부됩니다. 또한 확인 프로세스의 각 단계에서 각 인증서의 만료 날짜를 애플리케이션 타임스탬프 함수가 제공한 시간과 대조하여 확인합니다.(자세한 내용은 "nx_secure_tls_session_time_function_set" 서비스를 참조하세요.)

X.509 사양은 경로 유효성 검사 중에 확인할 수 있는 X.509 확장에 있는 식별자인 "정책"을 지원하는 알고리즘도 제공합니다. NetX Secure는 현재 X.509 인증서를 "anyPolicy" 옵션이 정의된 것처럼 처리합니다. 즉, 모든 정책이 허용되고 선택적 정책 검사가 수행되지 않습니다. NetX Secure X.509 구현은 향후 릴리스에서 이 기능으로 보강될 수 있습니다. 현재는 *nx_secure_x509_extension_find* API를 사용하여 인증서에서 정책 확장을 얻을 수 있습니다.

기본 경로 유효성 검사가 완료되면 TLS는 *nx_secure_tls_session_certificate_callback_set* API를 사용하여 애플리케이션이 제공하는 인증서 확인 콜백을 호출합니다. 콜백이 제공되지 않으면 인증서는 성공적인 경로 유효성 검사에 따라 신뢰할 수 있는 것으로 간주됩니다. 콜백이 제공되면 콜백은 애플리케이션에 필요한 인증서에 대해 추가 유효성 검사를 수행합니다. 콜백의 반환 값은 TLS 핸드셰이크를 계속할지 아니면 유효성 검사 실패로 인해 핸드셰이크를 중단할지 결정하는 데 사용됩니다.

콜백은 관련 TLS 세션에 대한 포인터 및 유효성을 검사할 인증서에 대한 NX_SECURE_X509_CERT 포인터를 사용하여 호출됩니다. TLS 세션과 인증서 사이에는 애플리케이션이 추가 확인 검사를 수행하기 위해 TLS에서 필요한 모든 데이터가 있습니다.

추가 유효성 검사에 도움이 되도록, NetX Secure는 DNS 유효성 검사 및 인증서 해지 목록 검사를 비롯한 몇 가지 일반적인 유효성 검사 작업에 대한 X.509 루틴을 제공합니다. 이러한 모든 루틴은 인증서 확인 콜백 내에서 사용하기에 적합하지만 X.509 인증서의 오프라인 검사를 수행하는데 사용할 수도 있습니다.

다음 표에는 X.509 인증서 처리에 사용할 수 있는 도우미 함수가 요약되어 있습니다. 작업에 대한 자세한 설명은 다음 섹션과 챕터 4의 API 참조에서 찾을 수 있습니다.  
  
NetX Secure 서비스에 대한 설명에는 특정 루틴에 대한 추가 세부 정보가 제공됩니다.

| **API 이름**                             | **설명**                               |
| ---------------------------------------- | -------------------------------------- |
| nx_secure_x509_common_name_dns_check               | X.509 주체 일반 이름 및 SubjectAltName을 예상되는 DNS 이름과 대조하여 확인 |
| nx_secure_x509_crl_revocation_check                 | X.509 CRL(인증서 해지 목록)에서 해지된 인증서 확인       |
| nx_secure_x509_extended_key_usage_extension_parse | 인증서의 특정 확장 키 사용 OID를 구문 분석 및 찾기                   |
| nx_secure_x509_key_usage_extension_parse           | 인증서의 키 사용 비트 필드를 구문 분석 및 반환                            |
| nx_secure_x509_extension_find                        | 특정 확장에 대한 DER로 인코딩된 원시 ASN.1 데이터를 찾아서 반환            |

인증서 확인 콜백에 사용할 X.509 도우미 함수

### <a name="x509-extensions"></a>X.509 확장

X.509 사양에는 인증서를 확인하는 데 사용 가능한 추가 정보를 제공하는 데 사용할 수 있는 여러 가지 "확장"이 설명되어 있습니다. 대부분의 경우 이러한 확장은 선택 사항이며 신뢰할 수 있는 루트 인증서와 대조하여 디지털 인증서의 보안 유효성을 검사하는 데 필요하지 않습니다. 하지만 NetX Secure는 몇 가지 기본 확장을 지원합니다. 추가 확장에 대한 지원은 이후 릴리스에서 추가될 수 있습니다.

현재 지원되는 확장은 다음 표에 나와 있습니다.

| 확장 이름           | Description                                                                   | 관련 API                                             |
| ------------------------ | ----------------------------------------------------------------------------- | -------------------------------------------------------- |
| 키 사용                | 비트 필드의 인증서 공개 키에 대해 허용되는 사용 제공         | nx_secure_x509_key_usage_extension_parse           |
| 확장 키 사용       | OID를 사용하는 인증서의 공개 키에 추가로 허용되는 사용 제공 | nx_secure_x509_extended_key_usage_extension_parse |
| 주체 대체 이름 | 인증서로도 표시되는 대체 DNS 이름 제공   | nx_secure_x509_common_name_dns_check               |

### <a name="unsupported-x509-extensions"></a>지원되지 않는 X.509 확장

NetX Secure의 X.509 구현은 지원되지 않는 확장을 추출하는 서비스도 제공합니다(*nx_secure_x509_extension_find*). 이 API는 고급 사용자용입니다. 반환된 데이터를 구문 분석하려면 DER로 인코딩된 ASN.1에 대한 지식이 필요하기 때문입니다. 내부적으로 지원되는 확장을 추출하는 데 사용되지만, X.509 확장에 대한 사용자 지정 지원을 개발하는 편의를 위해 제공됩니다.

nx_secure_x509_extension_find를 사용하기 위해 알려진 확장 유형에 대한 가변 길이 OID 문자열의 정수 표현인 확장 ID 및 인증서와 함께 NX_SECURE_X509_EXTENSION이 전달됩니다. X.509 확장에 대해 지원되는 OID의 전체 목록은 nx_secure_x509_extension_find에 대한 API 참조에 제공됩니다(178 페이지).

NX_SECURE_X509_EXTENSION 구조는 다음과 같이 정의됩니다.

```C
typedef struct NX_SECURE_X509_EXTENSION_STRUCT
{
    /* Identifier (maps to OID) for this extension. */
    USHORT nx_secure_x509_extension_id;

    /* Critical flag - boolean value. */
    USHORT nx_secure_x509_extension_critical;

    /* Pointer to DER-encoded extension data. */
    const UCHAR *nx_secure_x509_extension_data;
    ULONG        nx_secure_x509_extension_data_length;
} NX_SECURE_X509_EXTENSION;
```
서비스가 성공적으로 반환되면 구조는 인증서의 관련 데이터로 채워집니다. nx_secure_x509_extension_id 필드는 일반적으로 내부 용도로 사용되지만 관련 OID 정수 표현으로 채워집니다. nx_secure_x509_extension_critical 필드는 X.509 중요 확장 플래그 값(Boolean)을 노출합니다. nx_secure_x509_extension_data 및 nx_secure_x509_extension_data_length 필드에는 확장의 DER로 인코딩된 ASN.1 데이터에 대한 포인터와 이 데이터의 길이가 각각 포함됩니다.

확장 ASN.1 데이터의 실제 구문 분석은 이 문서에서 다루지 않지만 NetX Secure TLS 소스에 대한 액세스 권한이 있으면 지원되는 확장에 대해 nx_secure_x509_extension_find가 호출될 때마다 구문 분석이 수행되는 방식을 볼 수 있습니다.

### <a name="x509-dns-validation"></a>X.509 DNS 유효성 검사

TLS의 일반적인 인증서 유효성 검사 작업에는 원격 호스트의 TLD(최상위 도메인) 이름을 TLS 핸드셰이크 중에 호스트가 제공한 X.509 인증서와 대조하여 확인하는 작업이 포함됩니다. 이 작업은 DNS 조회를 신뢰할 수 있다는 가정하에 인증서가 인증서를 제공한 호스트 서버와 실제로 일치하는지 확인하는 데 유용합니다. NetX Secure TLS에서 이 기능은 **nx_secure_x509_common_name_dns_check** 서비스가 제공합니다. 이 서비스는 호스트에 액세스하는 데 사용되는 URL의 TLD 부분을 포함하는 문자열과 인증서를 가져옵니다. TLD는 인증서의 일반 이름 필드와 비교되며 일치하면 NX_SUCCESS가 반환됩니다. 일반 이름이 일치하지 않으면 루틴은 X.509 인증서 확장 *subjectAltName* 이 있는지도 확인합니다. subjectAltName이 있으면 확장의 모든 DNSName 항목도 제공된 TLD와 대조하여 확인됩니다. 마찬가지로, 일치하는 항목이 있으면 NX_SUCCESS가 반환됩니다. 일치하는 항목이 없으면 인증서 유효성 검사 콜백에서 반환하기 적합한 오류가 반환됩니다.

### <a name="x509-key-usage-and-extended-key-usage-extensions"></a>X.509 키 사용 및 EKU(확장 키 사용) 확장

X.509 키 사용 및 EKU(확장 키 사용) 확장은 인증서를 인증할 때 인증서의 공개 키를 사용할 수 있는 방법에 대한 정보를 제공합니다. 키 사용은 인증서가 서명되고 발급될 때 인증서 발급자가 제공합니다. 키 사용은 원격 TLS 호스트를 인증하고 다른 작업을 수행하는 데 인증서를 사용할 권한이 있는지 확인하기 위해 TLS 호스트가 사용할 수 있습니다.

키 사용 확장은 각 비트가 특정 키 사용을 나타내는 간단한 비트 필드로 구성됩니다. 이러한 값의 전체 목록은 *nx_secure_x509_key_usage_extension_parse* 에 대한 API 참조에 제공됩니다(183 페이지). 키 사용 비트와 그 의미에 대한 자세한 내용은 RFC 5280의 4.2.1.3 섹션을 참조하세요.

EKU(확장 키 사용) 확장은 키 사용 확장과 마찬가지로 허용되는 키 사용 정보를 제공합니다. 하지만 임의 사용을 지원하기 위해 EKU(확장 키 사용) 확장은 비트 필드 대신 OID를 활용합니다. NetX Secure X.509에서 EKU(확장 키 사용) 확장을 구문 분석할 때 OID를 나타내는 정수가 애플리케이션에서 제공됩니다. 그런 다음, *nx_secure_x509_extended_key_usage_extension_parse* 서비스는 해당 OID가 있는지 여부를 반환합니다. EKU(확장 키 사용)에 지원되는 OID의 전체 목록은 *nx_secure_x509_extended_key_usage_extension_parse* 에 대한 API 참조에 제공됩니다(175 페이지). OID 및 그 의미에 대한 자세한 설명은 RFC 5280에서 4.2.1.12 섹션을 참조하세요.

### <a name="x509-crl-revocation-status-checking"></a>X.509 CRL 해지 상태 확인

X.509는 디지털 인증서 서명 기관이 서명한 인증서의 유효성을 취소할 수 있는 CRL(인증서 해지 목록)이라는 메커니즘을 제공합니다. 서명 기관의 인증서를 확인해야 하는 애플리케이션은 CRL을 확보하고 해당 기관(발급자)이 서명한 인증서를 CRL과 비교하여 어떤 이유로든(예: 프라이빗 키 손상) 상태가 해지되었는지 확인할 수 있습니다. 이러한 방식으로 애플리케이션은 다른 인증서 유효성 검사를 통과한 잠재적으로 위험한 인증서를 사용하지 않을 수 있습니다.

CRL 확보는 애플리케이션에서 수행됩니다. 미리 정의된 서버에서 또는 다른 수단을 통해 DER로 인코딩된 목록을 다운로드하여 수행합니다. 실제 설정은 발급자마다 다르기 때문에 NetX Secure는 CRL을 확보하는 메커니즘은 제공하지 않고 CRL과 대조하여 인증서를 확인하는 루틴(**nx_secure_x509_crl_revocation_check**)을 제공합니다.

API는 DER로 인코딩된 CRL, 확인 시 대조할 인증서 저장소(예: TLS 세션의 저장소) 및 확인할 인증서를 사용합니다. 루틴은 먼저 신뢰할 수 있는 저장소(애플리케이션이 제공하는 인증서 저장소의 일부)와 대조하여 CRL 자체의 유효성을 검사합니다. 이 작업은 서비스 거부 공격에 사용되는 사기성 CRL로부터 보호하고 CRL이 실제로 적절한 발급자로부터 온 것인지를 입증하는 데 중요합니다. CRL 유효성 검사 후에는 발급자가 확인됩니다. CRL 발급자가 인증서 발급자와 일치하지 않으면 해당 인증서에 대해 CRL이 유효하지 않으며 오류가 반환됩니다. 이 시점에서 TLS 핸드셰이크를 계속할 수 있을지 여부는 애플리케이션에 달려 있습니다. 발급자가 일치하면 유효성이 검사되는 인증서의 일련 번호를 CRL에서 검색합니다. 목록에 일련 번호가 있으면 인증서가 해지되었음을 나타내는 오류가 반환됩니다. 일치 항목이 없으면 NX_SUCCESS가 반환됩니다.

## <a name="client-certificate-authentication-in-netx-secure-tls"></a>NetX Secure TLS의 클라이언트 인증서 인증

X.509 인증서 인증을 사용하는 경우 TLS 프로토콜을 사용하려면 TLS 서버 인스턴스에서 식별용 인증서를 제공해야 하지만, 기본적으로 TLS 클라이언트 인스턴스는 다른 형태의 인증(예: 사용자 이름/암호 조합)을 사용하여 인증용 인증서를 제공할 필요가 없습니다. 따라서 인터넷의 웹 사이트에서 가장 일반적으로 사용되는 TLS에 적합합니다. 예를 들어 온라인 소매점 사이트는 웹 브라우저를 사용하는 잠재 고객에게 서버가 합법적이라는 것을 증명해야 하지만 사용자는 로그인/암호를 사용하여 특정 계정에 액세스합니다.

그러나 기본 사례가 항상 바람직한 것은 아니므로 TLS는 상황에 따라 TLS 서버 인스턴스가 원격 클라이언트의 인증서를 요청하는 것을 허용합니다. 이 기능을 사용하면 TLS 서버는 핸드셰이크 중에 CertificateRequest 메시지를 TLS 클라이언트에 보냅니다. 클라이언트는 자체 인증서 및 이 인증서와 연결된 일치하는 프라이빗 키를 소유하고 있음을 증명하는 암호화 토큰이 포함된 CertificateVerify 메시지로 응답해야 합니다. 확인이 실패하거나 인증서가 서버의 신뢰할 수 있는 인증서에 연결되지 않은 경우 TLS 핸드셰이크가 실패합니다.

TLS의 클라이언트 인증서 인증에는 두 가지 경우가 있으며, 다음 섹션에 두 경우가 모두 설명되어 있습니다.

### <a name="client-certificate-authentication-for-tls-clients"></a>TLS 클라이언트용 클라이언트 인증서 인증

TLS 클라이언트는 클라이언트 인증을 위해 인증서를 요청하는 서버에 연결을 시도할 수 있습니다. 이 경우 클라이언트는 서버에 인증서를 제공하고 인증서와 일치하는 프라이빗 키를 소유하고 있는지 확인해야 합니다. 그렇지 않으면 서버가 TLS 핸드셰이크를 종료합니다.

NetX Secure TLS에는 이 기능을 지원하는 특별한 구성이 없지만 애플리케이션에서 *nx_secure_tls_local_certificate_add* 서비스를 사용하여 TLS 클라이언트 인스턴스에 대한 로컬 식별 인증서를 제공해야 합니다. 애플리케이션이 인증서를 제공하지 않았는데 원격 서버가 클라이언트 인증서 인증을 사용 중이고 인증서를 요청하면 TLS 핸드셰이크가 실패합니다. TLS 핸드셰이크를 완료하려면 *nx_secure_tls_local_certificate_add* 를 사용하여 TLS 세션에 제공된 인증서를 원격 서버에서 인식해야 합니다.

### <a name="client-certificate-authentication-for-tls-servers"></a>TLS 서버용 클라이언트 인증서 인증

클라이언트 인증서 인증을 위한 TLS 서버 사례는 기능이 선택 사항이기 때문에 TLS 클라이언트 사례보다 약간 더 복잡합니다. 이 경우 TLS 서버는 원격 TLS 클라이언트에서 인증서를 구체적으로 요청한 다음, CertificateVerify 메시지를 처리하여 원격 클라이언트가 일치하는 프라이빗 키를 소유하고 있는지 확인해야 합니다. 그 후 서버에서는 클라이언트가 제공한 인증서를 신뢰할 수 있는 로컬 인증서 저장소의 인증서까지 추적할 수 있는지 확인해야 합니다.

NetX Secure TLS 서버 인스턴스에서 클라이언트 인증서 인증은 <br>
*nx <span class="underline"> _</span>secure <span class="underline">_</span>tls <span class="underline"> _</span>session <span class="underline">_</span>client <span class="underline"> _</span>verify <span class="underline">_</span>enable* 및<br>
*nx <span class="underline"> _</span>secure <span class="underline">_</span>tls <span class="underline"> _</span>session <span class="underline">_</span>client <span class="underline"> _</span>verify <span class="underline">_</span>disable* 서비스에 의해 제어됩니다.

클라이언트 인증서 인증을 활성화하려면 애플리케이션이<br>
*nx_secure_tls_session_start* 를 호출하기 전에 TLS 서버 세션 인스턴스를 사용하여 *nx <span class="underline"> _</span>secure <span class="underline">_</span>tls <span class="underline"> _</span>session <span class="underline">_</span>client <span class="underline"> _</span>verify <span class="underline">_</span>enable* 을 호출해야 합니다. TLS 클라이언트 연결에 사용되는 TLS 세션에서 이 서비스를 호출해도 아무런 영향을 주지 않습니다.

클라이언트 인증서 인증을 사용하면 TLS 서버는 TLS 핸드셰이크 중에 원격 TLS 클라이언트의 인증서를 요청합니다. NetX Secure TLS 서버에서 클라이언트 인증서는 X.509 발급자 체인 후 *nx <span class="underline"> _</span>secure_tls <span class="underline">_</span>trusted <span class="underline"> _</span>certificate <span class="underline">_</span>add* 를 사용하여 생성된 신뢰할 수 있는 인증서의 저장소와 대조하여 확인됩니다. 원격 클라이언트는 자체 ID 인증서를 신뢰할 수 있는 저장소의 인증서에 연결하는 체인을 제공해야 합니다. 그렇지 않으면 TLS 핸드셰이크가 실패합니다. 또한 CertificateVerify 메시지 처리가 실패하면 TLS 핸드셰이크도 실패합니다.

CertificateVerify 메서드에 사용되는 서명 메서드는 TLS 버전 1.0 및 TLS 버전 1.1용으로 수정되었으며, TLS 버전 1.2의 TLS 서버에서 지정합니다. TLS 1.2의 경우 지원되는 서명 메서드는 일반적으로 암호화 메서드 테이블에 제공된 관련 메서드를 따르지만, 일반적으로 SHA-256과 함께 RSA를 사용합니다. 암호화 메서드로 TLS를 초기화하는 방법에 대한 자세한 내용은 "NetX Secure TLS의 암호화" 섹션을 참조하세요.

## <a name="cryptography-in-netx-secure-tls"></a>NetX Secure TLS의 암호화

TLS는 암호화를 사용하여 네트워크 통신을 보호할 수 있는 프로토콜을 정의합니다. 따라서 실제 암호화를 TLS 사용자에게 매우 광범위하게 사용할 수 있습니다. 이 사양에서는 단일 ciphersuite를 구현하기만 하면 됩니다. TLS 1.2의 경우에는 해당 ciphersuite는 TLS_RSA_WITH_AES_128_CBC_SHA입니다. 즉, 공개 키 작업에는 RSA를 사용하고, 세션 암호화에는 128비트 키를 사용하여 AES를 CBC 모드로 사용하고, 메시지 인증 해시에는 SHA-1을 사용합니다.

TLS 1.2 규격을 준수하는 NetX Secure는 기본적으로 필수 TLS_RSA_WITH_AES_128_CBC_SHA ciphersuite를 활성화하지만, 하드웨어 기능과 기타 고려 사항으로 인해 각 암호화 메서드에 대해 가능한 구현 수를 고려하여 NetX Secure는 사용자가 TLS에서 사용할 암호화 메서드를 지정할 수 있는 일반 암호화 API를 제공합니다.

참고: 일반 암호화 API 메커니즘을 사용하면 사용자가 자체 ciphersuite를 구현할 수 있지만, TLS ciphersuite 및 확장에 익숙한 고급 사용자만 이 메커니즘을 사용하는 것이 좋습니다. 자체 ciphersuite를 지원하려면 Express Logic 담당자에게 문의하세요.

### <a name="cryptographic-methods"></a>암호화 메서드

NetX Secure TLS는 특정 하드웨어 플랫폼용 하드웨어 드라이버가 있는 소프트웨어에서 DES, 3DES, AES, MD5, HMAC-MD5, SHA-1, HMAC-SHA1, SHA-256, HMAC-SHA256, RSA 및 ECC(선택된 곡선)를 구현합니다. 애플리케이션은 NetX Secure와 함께 제공되는 암호화 루틴을 사용하거나 최종 사용자 또는 제3자가 제공한 사용자 지정 루틴을 사용할 수 있습니다.

*NX_CRYPTO_METHOD* 는 애플리케이션이 NetX Secure TLS에 사용할 암호화 알고리즘의 특정 구현을 설명하도록 설계된 제어 블록입니다. *NX_CRYPTO_METHOD* 를 통해 애플리케이션은 자체 암호화 구현을 NetX Secure에 쉽게 통합할 수 있습니다. *NX_CRYPTO_METHOD* 구조체는 다음과 같이 선언됩니다.

```C
typedef struct NX_CRYPTO_METHOD_STRUCT
{
    /* Symbolic name of the algorithm. */
    USHORT nx_crypto_algorithm;

    /* Size of the key, in bits. */
    USHORT nx_crypto_key_size_in_bits;

    /* Size of the IV block, in bits, used for encryption. */
    USHORT nx_crypto_IV_size_in_bits;

    /* Size of the ICV block, in bits, used for authentication. */
    USHORT nx_crypto_ICV_size_in_bits;

    /* Size of the crypto block, in bytes. */
    ULONG nx_crypto_block_size_in_bytes;

    /* Size of the metadata area. */
    ULONG nx_crypto_metadata_size;

    /* nx_crypto_init function initializes the crypto method with the
        "secret key" or other state  information. The initialization 
        routine should return a handle to the caller.  This handle is 
        used in subsequent crypto operations to identify the session.  
        */

    UINT (*nx_crypto_init) (NX_CRYPTO_METHOD     *method,
                            UCHAR               *key, 
                            NX_CRYPTO_KEY_SIZE   key_size_in_bits,
                            VOID               **handler,
                            VOID                *crypto_metadata,
                            VOID                 crypto_metadata_size);

    /* NetX Secure calls the nx_crypto_cleanup routine when a TLS
       session is to be deleted (or updated).  Resources allocated 
       during the crypto operation should be released in this routine.  
       */
    UINT (*nx_crypto_cleanup) (VOID *handler);

    /* nx_crypto_operation is the actual crypto or hash operation. Note 
       that both input and output buffers are prepared by the caller. 
       For encryption or decryption operations, the crypto operation 
       routine uses the output buffer for encrypted or decrypted data. 
       For authentication operations, the authentication routine shall 
       use the output buffer for the digest. */
    UINT (*nx_crypto_operation)(UINT  op, 
                  VOID              *handler, 
                  NX_CRYPTO_METHOD  *method,
                  UCHAR             *key,
                  NX_CRYPTO_KEY_SIZE key_size_in_bits,
                  UCHAR             *input,
                  ULONG              input_length_in_byte,
                  UCHAR             *iv_ptr,
                  UCHAR             *output,
                  ULONG              output_length_in_byte,
                  VOID              *crypto_metadata,
                  VOID               crypto_metadata_size,
                  NX_PACKET*         packet_ptr,
                  VOID (*nx_crypto_hw_process_callback(NX_PACKET 
                                                       *packet_ptr, 
                                                        UINT status);
} NX_CRYPTO_METHOD;
```

다음은 *NX_CRYPTO_METHOD* 구조체에 있는 각 요소에 대한 설명입니다.

- nx_crypto_algorithm: 이 필드는 변수 메서드에 설명된 알고리즘을 식별합니다. NetX Secure TLS의 일부 유효한 값은 다음과 같습니다(특정 값은 nx_crypto_const.h 참조).
    
  - NX_CRYPTO_NONE    
  - NX_CRYPTO_ENCRYPTION_NULL    
  - NX_CRYPTO_ENCRYPTION_AES_CBC    
  - NX_CRYPTO_AUTHENTICATION_NONE    
  - TLS_HASH_SHA_1    
  - TLS_HASH_SHA_256    
  - TLS_HASH_MD5    
  - TLS_CIPHER_RSA    
  - TLS_CIPHER_NULL

- nx_crypto_key_size_in_bits: 이 필드는 메서드에 사용되는 비밀 키의 크기를 지정합니다.

- nx_crypto_IV_size_in_bits: 이 필드는 IV(Initialization Vector)의 크기를 지정합니다. 대부분의 경우 IV 블록은 암호화/암호 해독 알고리즘에만 사용됩니다. 인증 및 확인 알고리즘은 이 필드를 거의 사용하지 않습니다.

- nx_crypto_ICV_size_in_bits: 이 필드는 ICV(무결성 검사 값) 블록의 크기를 지정합니다. 참고: 이 블록은 IPsec 사용을 위한 것이며 TLS에서 사용되지 않습니다. 자세한 내용은 NetX Duo IPsec을 참조하세요.

- nx_crypto_block_size_in_bytes: 이 필드는 블록 기반 암호에 대한 암호화 알고리즘 블록의 크기(바이트)를 지정합니다. 대부분의 경우 암호화 루틴에서 사용되며 인증 루틴에서는 거의 사용되지 않습니다.

- nx_crypto_metadata_area_size: 이 필드는 이 메서드에 필요한 메타데이터 영역의 크기를 지정합니다. 각 구현에는 상태 정보를 저장하거나 중간 데이터(예: 키 변환 자료)를 저장하거나 스크래치 영역으로 사용하기 위한 특정 메모리가 필요할 수 있습니다. 구현에 필요한 공간이 이 필드에 지정됩니다. 애플리케이션은 TLS 세션을 만들 때 메모리 공간을 제공합니다. 암호화 함수는 이 메타데이터 영역을 관리하는 일을 담당합니다.

- nx_crypto_init: 암호화 알고리즘에 대한 초기화 함수입니다. 초기화 루틴이 필요하지 않은 구현의 경우 이 필드를 NX_NULL로 설정할 수 있습니다. 초기화 함수는 일반적으로 알고리즘의 내부 데이터 구조를 초기화하는 데 사용됩니다. NetX Secure TLS는 내부적으로 이 함수를 호출하여 암호화 루틴의 초기화를 처리합니다.

초기화 함수의 프로토타입은 다음과 같습니다.

```C
UINT crypto_init_function(NX_CRYPTO_METHOD *method, 
                          UCHAR *key, 
                          UINT  key_size_in_bits, 
                          VOID  **handle, 
                          VOID  *crypto_metadata_area, 
                          ULONG crypto_metadata_area_size);
```

  - method는 암호화 메서드 제어 블록에 대한 포인터입니다.

  - key는 데이터 패킷을 처리하는 비밀 키 문자열입니다.

  - key_size_in_bits는 비밀 키의 크기(비트)를 정의합니다.

  - handle은 특정 암호화 세션을 식별하는 구현 정의 항목입니다. 값은 초기화 루틴에 의해 생성되고 호출자에게 다시 전달됩니다. 후속 암호화 작업 또는 정리 루틴은 이 핸들을 사용하여 세션을 식별합니다.

  - crypto_metadata는 이 알고리즘의 구현에 필요한 메타데이터 영역에 대한 포인터입니다. 메타데이터 영역이 필요 없는 알고리즘의 경우 이 필드는 NX_NULL로 설정되고 초기화 루틴은 메타데이터 영역에 액세스하면 안 됩니다.

  - crypto_metadata_size는 메타데이터 영역의 크기를 지정합니다. 메타데이터 영역 없이 생성된 SA의 경우 이 필드는 0으로 설정되고 초기화 루틴은 메타데이터 영역에 액세스해서는 안 됩니다.

  - 초기화 프로세스가 성공하면 이 루틴은 *NX_SUCCESS* 를 반환합니다. 다른 반환 값은 호출자가 실패로 처리합니다.

- nx_crypto_cleanup: 암호화 알고리즘 구현을 위해 정의된 정리 루틴입니다. TLS 세션이 삭제되거나 다시 시작될 때 호출됩니다.

정리 함수의 프로토타입은 다음과 같습니다.

```C
UINT crypto_cleanup_function(VOID *handle);
```
- handle은 호출자에 의해 정리 함수로 전달됩니다. 이 핸들은 암호화 초기화 루틴에 의해 초기화되고 암호화 알고리즘 상태를 식별하는 데 사용됩니다.

- 정리 프로세스가 성공하면 이 루틴은 *NX_SUCCESS* 를 반환합니다. 다른 반환 값은 호출자가 실패로 처리합니다.

- nx_crypto_operation: 실제 암호화, 암호 해독 및 인증 서비스를 수행하는 루틴입니다. 작업 루틴의 함수 프로토타입은 다음과 같습니다.

```C
UINT crypto_operation_function(UINT   op,
          VOID  *handle,  
          NX_CRYPTO_METHOD* method,
          UCHAR *key,
          UCHAR  key_size_in_bits,
          UCHAR* input,
          ULONG  input_length_in_byte,
          UCHAR* iv_ptr,
          UCHAR* output,
          ULONG  output_length_in_byte,
          VOID *crypto_metadata,
          ULONG crypto_metadata_size,
          NX_PACKET *packet_ptr,
          VOID (*nx_crypto_hw_process_callback)(NX_PACKET 
                          *packet_ptr, UINT status));
```

- op는 이 루틴이 수행할 것으로 예상되는 작업의 유형을 나타냅니다. 유효한 값은 다음과 같습니다.
    
    - NX_CRYPTO_ENCRYPT
    - NX_CRYPTO_DECRYPT
    - NX_CRYPTO_AUTHENTICATE
    - NX_CRYPTO_VERIFY

- handle은 호출자에 의해 작업 함수로 전달됩니다. 암호화 초기화 루틴에 의해 생성됩니다.
- method는 암호화 메서드 제어 블록을 가리킵니다
- key는 이 작업에 사용된 비밀 키를 가리킵니다.
- key_size_in_bits는 비밀 키의 크기(비트)입니다.
- input은 연산이 적용될 메시지의 시작에 대한 포인터입니다.
- input_length_in_byte는 연산이 적용될 메시지의 크기를 나타내기 위해 호출자가 전달합니다.
- iv_ptr은 IV 블록의 시작을 가리키도록 호출자가 설정합니다. IV 블록에 대한 메모리는 호출자가 제공합니다. 암호화를 위해서는 작업 함수가 IV 정보를 이 메모리 블록에 기록해야 하고, 암호 해독을 위해서는 작업 함수가 이 메모리 블록에서 IV 정보를 검색해야 합니다. 인증 및 확인 작업을 위한 알고리즘은 일반적으로 초기화 벡터를 사용하지 않습니다.
- output은 출력 버퍼를 가리키도록 호출자가 설정합니다. 출력 버퍼의 메모리는 호출자가 제공합니다. 암호화를 위해서는 작업 함수가 출력 버퍼에 암호 텍스트를 작성해야 합니다. 암호 해독을 위해서는 작업 함수가 해독된 텍스트(일반 텍스트)를 출력 버퍼에 기록해야 합니다. 인증을 위해서는 해시 값이 출력 버퍼에 기록됩니다. 검증을 위해 출력 버퍼는 해시 정보를 저장하는 데 사용됩니다.
- output_length_in_byte는 출력 버퍼의 크기를 나타냅니다.
- crypto_metadata는 암호화 작업에 사용될 메타데이터 영역을 가리킵니다. 암호화 메타데이터 영역은 일반적으로 crypto_init_function에 의해 초기화됩니다.
- crypto_metadata_size는 메타데이터 영역의 크기를 나타냅니다.
- 작업 프로세스가 성공하면 이 루틴은 *NX_SUCCESS* 를 반환합니다. 다른 반환 값은 호출자가 실패로 처리합니다.
- packet_ptr: 처리되는 데이터가 포함된 패킷입니다. 참고: 이 매개 변수는 TLS에서 사용되지 않으며 NX_NULL로 설정해야 합니다.
- nx_crypto_hw_process_callback: 암호화 메서드가 제공하는 콜백 함수입니다. 암호화 함수가 하드웨어에서 제공되고 콜백 루틴이 필요한 경우 사용됩니다.

NetX Secure TLS는 다음과 같은 암호화 메서드를 제공합니다.

- *AES*  
- *RSA*  
- *NULL*

NetX Secure TLS는 다음과 같은 인증 메서드를 제공합니다.

- *HMAC-MD5*  
- *HMAC-SHA1*  
- *HMAC-SHA256*

다음 예는 NetX Duo IPsec에서 제공하는 암호화 및 인증 메서드를 사용하도록 *NX_CRYPTO_METHOD* 구조체를 구성하는 방법을 보여줍니다.

***AES:***

```C
/* AES-CBC 128. */
NX_CRYPTO_METHOD crypto_method_aes_cbc_128 = 
{
    /* AES crypto algorithm                             */
    NX_CRYPTO_ENCRYPTION_AES_CBC,                       

    /* Key size in bits. For AES-128 this value is 128  */
    NX_CRYPTO_AES_128_KEY_LEN_IN_BITS,              
   
    /* IV size in bits.  For AES-128 this value is 128  */
    NX_CRYPTO_AES_IV_LEN_IN_BITS,

    /* ICV size in bits, not used.                      */
    0,                                              

    /* Block size in bytes.  For AES this value is 16   */
    (NX_CRYPTO_AES_BLOCK_SIZE_IN_BITS >> 3),        

    /* Metadata size in bytes, for AES this value is 262*/
    sizeof(NX_CRYPTO_AES),              

    /* AES-CBC initialization routine.                  */
    _nx_secure_crypto_method_aes_init,               

    /* AES-CBC cleanup routine, not used.               */
    NX_NULL,                                        

    /* AES-CBC operation                                */
    _nx_secure_crypto_method_aes_operation           
};

/* RSA. */
NX_CRYPTO_METHOD crypto_method_rsa = 
{
    /* RSA crypto algorithm                             */
    TLS_CIPHER_RSA,                       

    /* Key size. RSA key sizes vary, so set to 0.         */
    0,              
   
    /* IV size in bits.  RSA does not use an IV.         */
    0,

    /* ICV size in bits, not used.                      */
    0,                                              

    /* Block size in bytes.  RSA does not have a block size. */
    0,        

    /* Metadata size in bytes, for RSA use the control block. */
    sizeof(NX_CRYPTO_RSA),              

    /* RSA initialization routine.                  */
    _nx_secure_crypto_method_rsa_init,               

    /* Cleanup routine, not used.                    */
    NX_NULL,                                        

    /* RSA operation                                */
    _nx_secure_crypto_method_rsa_operation           

};
```
***NULL***

```C
/* NULL encryption method. */
NX_CRYPTO_METHOD crypto_method_null = 
{
    NX_CRYPTO_ENCRYPTION_NULL,/* Name of the crypto algorithm  */
    0,                        /* Key size in bits, not used    */
    0,                        /* IV size in bits, not used     */
    0,                        /* ICV size in bits, not used    */
    4,                        /* Block size in bytes           */
    0,                        /* Metadata size in bytes        */
    NX_NULL,                  /* Initialization routine,unused */
    NX_NULL,                  /* Cleanup routine, not used     */
    _nx_secure_crypto_method_null_operation  /* NULL operation  
*/
}; 
```
***HMAC-SHA1***
```C
NX_CRYPTO_METHOD crypto_method_hmac_sha1 = 
{
    /* HMAC SHA1 algorithm                               */
    TLS_HASH_SHA1,            


    /* Key size in bits. For HMAC-SHA1 this value is 160 */ 
    NX_CRYPTO_HMAC_SHA1_KEY_LEN_IN_BITS,              

    /* IV size in bits, not used                         */
    0,                                            

    /* Transmitted ICV size in bits. Unused.             */
    0, 

    /* Block size in bytes, not used                     */
    0,                                            

    /* Metadata size in bytes                            */
    sizeof(NX_SHA1_HMAC),                                            

    /* Initialization routine, not used                  */
    NX_NULL,                                      

    /* Cleanup routine, not used                         */
    NX_NULL,                                          

    /* HMAC SHA1 operation                               */
    _nx_secure_crypto_method_hmac_sha1_operation   
};
```
***NONE***

특수 메서드 **NX_CRYPTO_NONE** 은 암호화 또는 인증 서비스가 필요하지 않다고 IPsec 모듈에 알리는 데 사용됩니다. 다음과 같이 구성됩니다.

```C
/* NX_CRYPTO_NONE means encryption or authentication
   method is not needed.  */
NX_CRYPTO_METHOD crypto_method_none = 
{
    NX_CRYPTO_NONE,       /* Name of the crypto algorithm */
    0,                    /* Key size in bits, not used   */
    0,                    /* IV size in bits, not used    */
    0,                    /* ICV size in bits, not used   */
    0,                    /* Block size in bytes          */
    0,                    /* Metadata size in bytes       */
    NX_NULL,              /* Initialization routine, not used */
    NX_NULL,              /* Cleanup routine, not used    */
    NX_NULL               /* NULL operation               */
};                                               
```
### <a name="initializing-tls-with-cryptographic-methods"></a>암호화 메서드로 TLS 초기화

이전 섹션에서 설명한 암호화 메서드 서명을 따르는 암호화 루틴을 만든 후에는 NX_SECURE_TLS_SESSION 제어 블록을 초기화할 때 TLS에 전달해야 합니다. 이 작업은 TLS 서비스 nx_secure_tls_session_create에서 수행됩니다.

```C
UINT  nx_secure_tls_session_create(
              NX_SECURE_TLS_SESSION*     session_ptr,
              const NX_SECURE_TLS_CRYPTO*    tls_cipher_table,
              VOID*                encryption_metadata_area,
              ULONG                 encryption_metadata_size
);
```
- session_pointer는 NX_SECURE_TLS_SESSION 제어 블록에 대한 포인터입니다.
- tls_cipher_table은 NX_SECURE_TLS_CRYPTO 제어 블록(아래에 설명됨)에 대한 포인터입니다.
- encryption_metadata_area는 TLS의 암호화 루틴이 사용하는 공간을 가리킵니다.
- encryption_metadata_size는 메타데이터 영역의 크기(바이트)입니다.

### <a name="elliptic-curve-cryptography-ecc-in-netx-secure-tls"></a>NetX Secure TLS의 ECC(타원 곡선 암호화)

ECC(타원 곡선 암호화)는 RSA 대신 사용할 수 있는 공개 키 암호화 체계를 제공합니다. ECC는 일반적으로 더 빠르며 RSA보다 작은 키를 사용하므로 임베디드 TLS에 유용한 옵션이 될 수 있습니다. Azure RTOS 6.0 이전의 X-Ware 버전에는 ECC가 추가 기능으로 제공되어 프로젝트에 ECC 소스 코드를 설치해야 합니다. Azure RTOS 6.0은 ECC를 주류 코드베이스에 통합하기 때문에 더 이상 ECC 파일을 설치할 필요가 없습니다. 하지만 ECC에는 이전 버전과 동일한 초기화가 여전히 필요합니다.

### <a name="supported-ecc-curves"></a>지원되는 ECC 곡선

NetX Secure는 <http://www.secg.org/sec2-v2.pdf>에 따라 곡선의 일부를 구현합니다. 다음 곡선이 지원됩니다<sup>18</sup>.

  - secp256r1 
  - secp384r1 
  - secp521r1 

다른 ECC 곡선이 사용되면 *nx_secure_tls_session_start()* 루틴은 지원되지 않는 곡선이 사용되었음을 나타내는 NX_SECURE_TLS_NO_SUPPORTED_CIPHERS 오류를 반환합니다.

TLS 인증서 체인은 ECC 알고리즘으로도 암호화할 수 있습니다. TLS 클라이언트가 제공한 곡선이 지원되더라도 인증서 체인에 사용된 ECC 곡선이 지원되지 않을 수 있습니다. 이 경우 *nx_secure_tls_session_start* 루틴은 NX_SECURE_TLS_UNSUPPORTED_PUBLIC_CIPHER를 반환합니다.

ECC에 대한 기본 ciphersuite 테이블 예제는 nx_crypto_generic_ciphersuites.c에 제공됩니다. ciphersuite 테이블에 대한 자세한 내용은 "TLS 암호화 암호 테이블" 섹션을 참조하세요.

18. secp192r1 및 secp224r1 곡선에 대한 구현은 레거시 애플리케이션에도 제공됩니다. 단, 이러한 곡선은 이제 약하기 때문에 새로운 애플리케이션 개발에 사용해서는 안 됩니다.

### <a name="crypto-methods-for-ecc"></a>ECC의 암호화 메서드

타원 곡선 그룹의 암호화 메서드:

- NX_CRYPTO_METHOD crypto_method_ec_secp192<sup>15</sup>;  
- NX_CRYPTO_METHOD crypto_method_ec_secp224<sup>15</sup>;  
- NX_CRYPTO_METHOD crypto_method_ec_secp256;  
- NX_CRYPTO_METHOD crypto_method_ec_secp384;  
- NX_CRYPTO_METHOD crypto_method_ec_secp521;

ECC 곡선의 암호화 메서드는 nx_crypto_generic_ciphersuites.c에 정의되어 있습니다.

ECDHE의 암호화 메서드:

- NX_CRYPTO_METHOD crypto_method_ecdhe;

ECDSA의 암호화 메서드:

- NX_CRYPTO_METHOD crypto_method_ecdsa;

ECDSA 및 ECDHE 암호화 메서드는 nx_crypto_generic_ciphersuites.c에 정의되어 있습니다.

RSA, SHA, AES와 같은 다른 암호화 메서드와 결합하여, ciphersuite 조회 테이블의 기본 구성 요소로 사용할 수 있습니다.

### <a name="enabling-ecc-support-for-tls"></a>TLS에 대한 ECC 지원 사용

ECC는 TLS에 대해 기본적으로 사용하도록 설정됩니다. ECC 지원을 사용하지 않도록 설정하려면 NX_SECURE_DISABLE_ECC_CIPHERSUITE 기호를 정의해야 합니다.

변경 내용을 적용하려면 NetX Secure 라이브러리와 이 라이브러리를 사용하는 모든 애플리케이션을 다시 작성해야 합니다.

애플리케이션 코드에서 TLS 세션이 만들어진 후 API n *x_secure_tls_ecc_initialize()* 를 호출해야 합니다. 이 API는 TLS 키 교환 작업 및 인증서 확인에 사용할 곡선 유형을 TLS 세션에 알립니다. TLS 핸드셰이크 단계 중 ECC 알고리즘이 선택되면 클라이언트와 서버는 사용할 곡선을 결정하기 위해 ECC 곡선 관련 매개 변수를 교환합니다.

다음 코드 세그먼트는 API 사용 방법을 보여줍니다. 인수(*nx_crypto_ecc_supported_groups, nx_crypto_ecc_supported_groups_size, nx_crypto_ecc_curves)* 는 모두 *nx_crypto_generic_ciphersuites.c* 에 정의되어 있습니다. 따라서 이러한 기호를 직접 사용할 수 있습니다.

```C
status = nx_secure_tls_ecc_initialize(&tls_session,     
                    nx_crypto_ecc_supported_groups,      
                    nx_crypto_ecc_supported_groups_size,     
                    nx_crypto_ecc_curves);
```
nx_crypto_generic_ciphersuites.c의 예제 구성에는 ECC가 활성화된 경우 사용되는 ECC ciphersuite 조회 테이블이 포함되어 있습니다. ECC를 사용하려면 nx_secure_tls_session_create를 사용하여 TLS 세션을 생성할 때 nx_crypto_tls_ciphers_ecc를 ciphersuite 테이블 매개 변수로 전달하면 됩니다. 예제 테이블에는 ECC 및 비ECC ciphersuite가 모두 포함되어 있습니다.

### <a name="tls-cryptographic-cipher-table"></a>TLS 암호화 암호 테이블

NX_SECURE_TLS_CRYPTO 구조체는 다음과 같이 정의됩니다.

```C
typedef struct NX_SECURE_METHODS_STRUCT
{
    /* Table that maps ciphersuites to crypto methods. */
    NX_SECURE_TLS_CIPHERSUITE_INFO* nx_secure_tls_ciphersuite_lookup_table;
    USHORT nx_secure_tls_ciphersuite_lookup_table_size;

    /* Table that maps X.509 cipher identifiers to crypto methods. */
    NX_SECURE_X509_CRYPTO *nx_secure_tls_x509_cipher_table;
    USHORT nx_secure_tls_x509_cipher_table_size;

    /* Specific routines needed for specific TLS versions. */
#if (NX_SECURE_TLS_TLS_1_0_ENABLED || NX_SECURE_TLS_TLS_1_1_ENABLED)
    NX_CRYPTO_METHOD *nx_secure_tls_handshake_hash_md5_method;
    NX_CRYPTO_METHOD *nx_secure_tls_handshake_hash_sha1_method;
    NX_CRYPTO_METHOD *nx_secure_tls_prf_1_method;
#endif

#if (NX_SECURE_TLS_TLS_1_2_ENABLED)
    NX_CRYPTO_METHOD *nx_secure_tls_handshake_hash_sha256_method;
    NX_CRYPTO_METHOD *nx_secure_tls_prf_sha256_method;
#endif

#if (NX_SECURE_TLS_TLS_1_3_ENABLED)
    const NX_CRYPTO_METHOD *nx_secure_tls_hkdf_method;
    const NX_CRYPTO_METHOD *nx_secure_tls_hmac_method;
    const NX_CRYPTO_METHOD *nx_secure_tls_ecdhe_method;
#endif

} NX_SECURE_TLS_CRYPTO;
```
테이블은 NetX Secure TLS 프로젝트 내에 있는 정적 상수에(일반적으로 암호화 루틴 및 모듈과 함께 있음) 이 구조체의 항목을 채워서 생성됩니다.

예를 들어 NetX Secure와 함께 제공되는 소프트웨어 전용("일반") 암호화 라이브러리에는 다음과 같은 테이블 정의가 포함되어 있습니다(비 ECC ciphersuite 지원용<sup>19</sup>).

```C
/* Define the cipher table object we can pass into TLS. */
const NX_SECURE_TLS_CRYPTO nx_crypto_tls_ciphers =
{
    /* TLS Ciphersuite lookup table and size. */
    _nx_crypto_ciphersuite_lookup_table,
    sizeof(_nx_crypto_ciphersuite_lookup_table) / 
    sizeof(NX_SECURE_TLS_CIPHERSUITE_INFO),

    /* X.509 certificate cipher table and size. */
    _nx_crypto_x509_cipher_lookup_table,
    sizeof(_nx_crypto_x509_cipher_lookup_table) / sizeof(NX_SECURE_X509_CRYPTO),

    /* TLS version-specific methods. */
#if (NX_SECURE_TLS_TLS_1_0_ENABLED || NX_SECURE_TLS_TLS_1_1_ENABLED)
    &crypto_method_md5,
    &crypto_method_sha1,
    &crypto_method_tls_prf_1,
#endif

#if (NX_SECURE_TLS_TLS_1_2_ENABLED)
    &crypto_method_sha256,
    &crypto_method_tls_prf_sha_256
#endif

#if (NX_SECURE_TLS_TLS_1_3_ENABLED)
    &crypto_method_hkdf,
    &crypto_method_hmac,
    &crypto_method_ecdhe,
#endif
};
```
구조체에서 첫 번째 엔트리는 TLS ciphersuite 테이블입니다. NX_SECURE_TLS_CIPHERSUITE_INFO 구조체는 암호화 루틴(NX_CRYPTO_METHOD 포인터 형태)을 TLS 사양에 정의된 특정 ciphersuite에 매핑합니다. 두 번째 값은 첫 번째 필드가 가리키는 테이블의 항목 수입니다.

다음 필드는 디지털 인증서를 처리할 때 X.509에 사용되는 루틴 테이블을 가리키며 NX_SECURE_X509_CRYPTO 구조체의 형태는 NX_SECURE_TLS_CIPHERSUITE_INFO와 유사합니다. 다음 필드는 테이블의 항목 수입니다.

조회 테이블 다음에는 특정 버전의 TLS에 필요한 여러 루틴이 있습니다. 예를 들어 TLS 버전 1.2 이전에는 키 생성 및 핸드셰이크 해시 루틴이 SHA-1과 MD5의 조합을 사용하도록 고정되었습니다. 이러한 루틴용 메서드는 특정 ciphersuite에 묶여 있지 않기 때문에 특별히 암호 구조체로 호출됩니다. TLS 버전 1.2에서는 키 생성 및 해시 루틴이 ciphersuite에 의해 선택되지만 사용할 루틴을 지정하지 않는 ciphersuite의 경우 SHA-256 해시 메서드가 사용되며 암호 구조체는 해당 루틴을 명확하게 호출합니다.

TLS 1.3에는 다양한 작업을 위해 몇 가지 추가 특정 암호가 필요합니다.

19. TLS 1.3 지원에는 ECC가 필요합니다. TLS 1.3이 활성화된 경우 nx_crypto_tls_ciphers_ecc를 사용하십시오.

### <a name="tls-ciphersuite-lookup-table"></a>TLS Ciphersuite 조회 테이블

TLS에 대한 암호 테이블을 채우려면 암호화 루틴을 특정 ciphersuite 식별자에 매핑하는 ciphersuite 조회 테이블도 만들어야 합니다. 식별자는 보편적인 IANA 등록 값입니다. 자세한 내용은 TLS RFC를 참조하세요. 루틴은 각 ciphersuite에 사용되는 5가지 개별 메서드인 공개 암호, 공개 키 인증, 세션 암호, 세션 해시 루틴, TLS PRF(Pseudo-Random Function)를 나타냅니다(일부 ciphersuite는 5가지를 모두 사용하지 않을 수 있음). 다음 표에는 5가지 메서드 각각에 대한 설명이 있습니다.

| **루틴 범주**      | **설명**                                                                                       | **예제 알고리즘**                                            |
| ------------------------- | ----------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------- |
| 공개 암호             | TLS 핸드셰이크 중 키를 교환하는 데 사용됩니다.                                                        | RSA, Diffie-Hellman, ECC                                          |
| 공개 키 인증 | TLS 핸드셰이크 중 데이터를 인증하거나 서명하는 데 사용됩니다.                                            | RSA, DSS                                                          |
| 세션 암호            | TLS 세션 중 애플리케이션 데이터를 암호화하는 데 사용되는 대칭 키 알고리즘                       | AES, RC4                                                          |
| 세션 해시              | TLS 세션 중 메시지의 무결성을 유지하는 데 사용됨(데이터가 변경되지 않도록 보장) | SHA-1, SHA-256                                                    |
| TLS PRF                   | TLS 핸드셰이크의 핸드셰이크 해시에서 키 자료를 생성하는 데 사용                          | PRF는 해시 루틴(SHA-1 + MD5, SHA-256, SHA-512)을 기반으로 합니다. |

NX_SECURE_TLS_CIPHERSUITE_INFO 구조체는 다음과 같이 정의됩니다.

```C
typedef struct NX_SECURE_TLS_CIPHERSUITE_INFO_struct
{
    /* The IANA value of the ciphersuite as defined by the TLS spec.*/
    USHORT nx_secure_tls_ciphersuite;

    /* The Public Key operation in this suite - RSA or DH. */
    NX_CRYPTO_METHOD *nx_secure_tls_public_cipher;

    /* The Public Authentication method used for signing data. */
    NX_CRYPTO_METHOD *nx_secure_tls_public_auth;

    /* The session cipher being used - AES, RC4, etc. */
    NX_CRYPTO_METHOD *nx_secure_tls_session_cipher;

    /* The size of the initialization vectors for the session cipher (bytes).*/
    USHORT nx_secure_tls_iv_size;

    /* The key size for the session cipher (bytes). */
    UCHAR nx_secure_tls_session_key_size;

    /* The hash being used - MD5, SHA-1, SHA-256, etc. */
    NX_CRYPTO_METHOD *nx_secure_tls_hash;

    /* The size of the hash being used. SHA-1 is 20 bytes, MD5 is 16 bytes.*/
    USHORT nx_secure_tls_hash_size;

    /* The TLS PRF being used – this is only for TLSv1.2. */
    NX_CRYPTO_METHOD *nx_secure_tls_prf;

} NX_SECURE_TLS_CIPHERSUITE_INFO;
```
nx_secure_tls_ciphersuite 필드는 IANA ciphersuite 값을 포함하며 NX_CRYPTO_METHOD 포인터는 이 ciphersuite에 사용되는 5가지 메서드를 나타냅니다. 스칼라 값(nx_secure_tls_iv_size, nx_secure_tls_key_size 및 nx_secure_tls_hash_size)은 정보 제공용이며, NX_CRYPTO_METHOD 항목에서 사용하지 못할 수 있는 정보를 제공합니다.

예를 들어, RSA, 128비트 키가 있는 AES-CBC, 세션 해시용 SHA-1 사용을 지정하는 TLS, TLS_RSA_WITH_AES_128_CBC_SHA에 대한 기본 ciphersuite를 살펴보겠습니다. ciphersuite에는 TLS PRF가 지정되지 않기 때문에 TLSv1.2 모드에서는 기본 SHA-256 PRF를 사용합니다. 모든 ciphersuite는 테이블에 지정된 PRF와 상관없이 TLS 1.0 및 1.1에 SHA-1+MD5 PRF를 사용합니다.

일반 암호화 라이브러리에 있는 NX_SECURE_TLS_CIPHERSUITE_INFO 테이블의 엔트리는 다음과 같이 정의됩니다.

```C
{ 
  TLS_RSA_WITH_AES_128_CBC_SHA,     /* Ciphersuite identifier */
  &crypto_method_rsa,               /* Public-key cipher (NX_CRYPTO_METHOD)*/
  &crypto_method_rsa,               /* Authentication method(NX_CRYPTO_METHOD)*/
  &crypto_method_aes_cbc_128,       /* Session cipher method(NX_CRYPTO_METHOD)*/
  16,                               /* Session cipher IV size in bytes */
  16,                               /* Session cipher key size in bytes */
  &crypto_method_hmac_sha1,         /* Session hash routine(NX_CRYPTO_METHOD) */
  20,                               /* Session hash output size in bytes */
  &crypto_method_tls_prf_sha_256    /* TLSv1.2 PRF */
},
```

세션 암호의 경우 키 크기가 ciphersuite에 의해 결정되지만, 공개 키 메서드의 경우 핸드셰이크 중에 교환되는 디지털 인증서에 공개 키가 포함되어 있기 때문에 TLS 핸드셰이크가 진행될 때까지 키 크기를 알 수 없습니다.

### <a name="x509-cipher-lookup-table"></a>X.509 암호화 조회 테이블

NX_SECURE_TLS_CIPHERSUITE_INFO 테이블과 마찬가지로 NX_SECURE_X509_CRYPTO 구조체는 암호화 루틴을 알려진 값에 매핑합니다. X.509의 경우 식별자는 실제로 X.509에 의해 정의되고 ISO 및 ITU 표준 기관에 등록된 OID입니다. OID는 디지털 인증서에 사용되는 암호화 루틴을 포함한 다양한 통신 표준에서 다양한 정보를 고유하게 식별하도록 설계된 가변 길이 멀티바이트 값입니다. OID가 가변 길이라는 사실 때문에 NetX Secure TLS는 공식 OID 값을 내부적으로 사용되는 고정 길이 상수에 매핑합니다(nx_secure_x509.h 참조). 이러한 상수는 NX_SECURE_X509_CRYPTO 구조체에서 사용되며 다음과 같이 정의됩니다.

```C
/* Structure to hold X.509 cryptographic routine information. */
typedef struct NX_SECURE_X509_CRYPTO_struct
{
    /* Internal NetX Secure identifier for certificate "ciphersuite" which consists
       of a hash and a public key operation. These can be mapped to OIDs in X.509.
        */
    USHORT nx_secure_x509_crypto_identifier;

    /* Public-Key Cryptographic method used by certificates. */
    NX_CRYPTO_METHOD *nx_secure_x509_public_cipher_method;

    /* Hash method used by certificates. */
    NX_CRYPTO_METHOD *nx_secure_x509_hash_method;
} NX_SECURE_X509_CRYPTO;
```

첫 번째 필드 *nx_secure_x509_crypto_identifier* 는 NetX Secure에 사용되는 내부 OID 표현입니다.

두 번째 및 세 번째 필드는 해시 루틴과 쌍을 이루는 공개 키 작업인 OID로 식별되는 암호화 메서드를 나타내는 NX_CRYPTO_METHOD 개체를 가리킵니다. 각 디지털 인증서에는 암호화 루틴에 대해 둘 이상의 OID가 있을 수 있습니다.

X.509의 메서드 테이블은 ciphersuite 조회 테이블과 같은 방식으로 구성됩니다. 예를 들어 RSA_SHA1의 OID를 살펴보겠습니다. RSA_SHA1의 실제 OID는 다음과 같습니다.

```C
{iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs-1(1) sha1-with-rsa-
signature(5)}
```
OID는 ASN.1 구문으로 표시되며 숫자 값 1.2.840.113549.1.1.5를 갖습니다. 이 값은 이진 형식으로 인코딩되어 다음 바이트를 생성합니다.

```C
UCHAR RSA_SHA1_OID = { 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05 };
```
ASN.1에서 이진 형식으로 실제 변환하는 내용은 이 문서에서 다루지 않습니다. 자세한 내용은 OID의 ASN.1 인코딩을 검색하십시오. NetX Secure에서 지원하는 OID의 이진 표현은 *nx_secure_x509.c* 파일에서 찾을 수 있습니다.

실제 OID를 내부적으로 인식되는 상수에 매핑하면 NX_SECURE_X509_CRYPTO 테이블에서 RSA_SHA1에 대한 항목을 만들 수 있습니다.

```C
{ 
    NX_SECURE_TLS_X509_TYPE_RSA_SHA_1,    /* Internal OID constant. */
    &crypto_method_rsa,                   /* RSA method (NX_CRYPTO_METHOD). */ 
    &crypto_method_sha1                   /* SHA-1 method (NX_CRYPTO_METHOD). */
}, 
```
### <a name="default-tls-routines"></a>기본 TLS 루틴

위에서 언급했듯이 TLS에는 핸드셰이크 중 키 생성 및 메시지 확인을 위한 몇 가지 기본 루틴이 필요합니다. 기본 루틴은 TLS PRF(Pseudo-Random Function)입니다. PRF는 해시 루틴을 기반으로 하며, 키 생성 또는 기타 목적을 위해 임의의 크기인 의사 난수 데이터<sup>20</sup>를 생성하는 데 사용할 수 있습니다.

PRF 외에도 각 TLS 버전은 제공해야 하는 기본 해시 루틴을 활용합니다. TLS 버전 1.0 및 1.1의 경우 해시 루틴은 MD5 및 SHA-1입니다. TLS 버전 1.2에는 SHA-256만 필요합니다.

NX_SECURE_TLS_CRYPTO 구조체에는 MD5, SHA-1, SHA-256, TLS 버전 1.0/1.1 PRF 및 기본 TLS 1.2 PRF에 대한 NX_CRYPTO_METHOD 포인터가 있습니다.

TLS 1.3 지원은 HKDF(키 생성), HMAC(핸드셰이크 중 사용되는 특정 해시 작업용) 및 ECDHE(TLS 1.3 기능에 필요)에 대한 필드를 추가합니다.

일반 소프트웨어 암호화 라이브러리에는 TLS PRF의 소프트웨어 버전이 제공됩니다. TLS 1.0/1.1의 경우 이 함수를 *nx_crypto_tls_prf_1* 이라고 합니다. TLS 1.2에서는 이 함수를 *nx_secure_tls_prf_sha256* 이라고 합니다. 접미사 "1"은 레거시 TLS 1.0 PRF를 나타내고 "sha256" 접미사는 TLS 1.2 기본 PRF가 SHA-256에 기반한다는 사실을 나타냅니다. 다른 PRF 루틴에 대한 지원이 필요한 경우 해당 루틴의 접미사에는 사용된 해시 메서드가 반영됩니다. PRF 루틴은 해시 메서드에 기반하기 때문에 기본 해시 루틴은 다른 대상 플랫폼에서 독립적으로 하드웨어 가속이 가능할 수 있습니다.

TLS ciphersuite 및 X.509 조회 테이블 외에도 기본 PRF 및 NX_SECURE_TLS_CRYPTO에 채워진 해시 루틴을 사용하여 구조체를 채우고 TLS 세션을 초기화하는 데 사용할 수 있습니다.

20. “의사 난수”란 PRF가 결정적이라는 사실을 의미합니다. 즉, 동일한 입력이 주어지면 항상 동일한 출력을 생성하지만 출력을 예측할 수 없다는 점에서 무작위입니다. TLS는 PRF의 이 속성을 사용하여 RSA와 같은 공개 키 암호를 사용하여 핸드셰이크 중에 교환된 마스터 비밀과 결합된 다양한 공개 데이터에서 세션 키를 생성합니다.

### <a name="cryptographic-metadata"></a>암호화 메타데이터

NX_SECURE_TLS_CRYPTO 테이블을 사용하여 TLS 세션을 초기화하기 전에 암호화 루틴 메타데이터를 위한 버퍼 공간을 할당해야 합니다. 메타데이터는 제어 블록으로 표시되는 특정 루틴과 관련된 모든 상태를 저장하는 데 사용됩니다. 각 NX_CRYPTO_METHOD의 *nx_crypto_metadata_area_size* 필드는 해당 루틴과 관련된 제어 구조체의 크기로 설정되어야 합니다. 그렇지 않으면 TLS 초기화가 필요한 공간을 제대로 처리하지 못하여 버퍼 오버런 문제가 발생할 수 있습니다.

TLS 세션이 만들어지기 전에 메타데이터 버퍼를 할당해야 합니다. 버퍼는 nx_secure_tls_session_create에 의해 자동으로 분할되며, 암호화 메서드 테이블에 제공되는 각 루틴에 대해 공간이 예약됩니다. TLS 세션에서 ciphersuite는 한 번에 하나만 활성이기 때문에 지원되는 ciphersuite의 수는 필요한 메타데이터 공간에 영향을 주지 않습니다. ciphersuite 조회 테이블의 해당 범주에 대한 최대 제어 블록 크기를 사용하여 ciphersuite 루틴 5개 각각에 대한 공간이 예약됩니다.

메타데이터 버퍼 크기를 쉽게 계산하기 위해 *nx_secure_metadata_size_calculate* 서비스는 nx_secure_tls_session_create와 동일한 계산을 수행하지만 필요한 총 메타데이터 버퍼 크기(바이트)만 반환합니다.

### <a name="initializing-the-tls-session"></a>TLS 세션 초기화

NX_CRYPTO_METHOD 및 NX_SECURE_TLS_CRYPTO 개체가 생성되고 메타데이터 영역이 예약되면, 다음과 같이 TLS 세션을 초기화할 수 있습니다(값은 위 예에서 가져옴).

```C
/* Pointer to the platform-specific cipher table. */
extern nx_crypto_tls_ciphers;

/* Cryptographic routine metadata buffer. Size is determined by calling 
nx_secure_tls_metadata_size_calculate with the nx_crypto_tls_ciphers table referenced 
above. */
UCHAR crypto_metadata[4500];

/* Initialize our TLS session using our cipher table and metadata area. Note that we can 
use sizeof for the metadata array because the size parameter expects the size in bytes.*/

nx_secure_tls_session_create(
    &tls_session,            /* Pointer to TLS session.      */
    &nx_crypto_tls_ciphers,  /* Pointer to cipher table.     */
    crypto_metadata,         /* Cryptography metadata buffer.*/
    sizeof(crypto_metadata), /* Size of metadata buffer.     */
);
```
