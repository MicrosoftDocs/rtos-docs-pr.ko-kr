---
title: 3장 - 내부 서비스 캐시 설명
description: NetX Duo mDNS 모듈은 로컬 서비스 캐시와 피어 서비스 캐시 등, 두 가지 내부 서비스 캐시를 관리합니다.
author: philmea
ms.author: philmea
ms.date: 07/09/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 007f1080a076730cfbcdedc9f063ac0c427a414c
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/22/2021
ms.locfileid: "104810729"
---
# <a name="chapter-3---description-of-internal-service-cache"></a><span data-ttu-id="36366-103">3장 - 내부 서비스 캐시 설명</span><span class="sxs-lookup"><span data-stu-id="36366-103">Chapter 3 - Description of internal service cache</span></span>

<span data-ttu-id="36366-104">NetX Duo mDNS 모듈은 로컬 서비스 캐시와 피어 서비스 캐시 등, 두 가지 내부 서비스 캐시를 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="36366-104">NetX Duo mDNS module manages two internal services caches: the local service cache, and the peer service cache.</span></span> <span data-ttu-id="36366-105">로컬 서비스 캐시는 노드에서 실행 중인 애플리케이션에서 제공하는 서비스와 관련한 리소스 레코드를 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="36366-105">The local service cache stores Resource Records related to services offered by applications running on the node.</span></span> <span data-ttu-id="36366-106">들어오는 쿼리의 경우 질문이 제공된 서비스와 일치하면 mDNS가 로컬 서비스 캐시에 저장된 답변으로 응답합니다.</span><span class="sxs-lookup"><span data-stu-id="36366-106">For incoming queries, if the question matches the service offered, mDNS responses with answers stored in the local service cache.</span></span> <span data-ttu-id="36366-107">애플리케이션은 API *nx_mdns_service_add()* 를 호출하여 서비스를 등록합니다.</span><span class="sxs-lookup"><span data-stu-id="36366-107">Applications register services by calling the API *nx_mdns_service_add()*.</span></span> <span data-ttu-id="36366-108">서비스를 제거하려면 애플리케이션이 API *nx_mdns_service_delete()* 를 사용합니다. 그러면 로컬 서비스 캐시에서 해당 항목을 제거하기 전에 "goodbye" 메시지를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="36366-108">To remove services, applications use the API *nx_mdns_service_delete()*, which will in turn send "goodbye" messages before removing the corresponding entries in the local service cache.</span></span>

<span data-ttu-id="36366-109">서비스가 추가되면 mDNS가 로컬 서비스 캐시에 SRV, PTR, TXT 등, 최소 3개의 리소스 레코드를 유지 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="36366-109">When a service is added, mDNS maintains at least 3 Resource Records in the local service cache: SRV, PTR, and TXT.</span></span> <span data-ttu-id="36366-110">서비스 형식에 하위 형식이 포함된 경우 추가 PTR 리소스 레코드가 더해질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="36366-110">Additional PTR Resource Record may be added if the service type includes subtype.</span></span> <span data-ttu-id="36366-111">예를 들어 애플리케이션이 다음과 같이 서비스를 등록합니다.</span><span class="sxs-lookup"><span data-stu-id="36366-111">For example, an application registers a service:</span></span>

```
*name*._*subtype*._sub._*type*._tcp.local,
```

<span data-ttu-id="36366-112">두 PTR 리소스 레코드 두 개는 로컬 서비스 캐시에 추가됩니다. 한 개 -</span><span class="sxs-lookup"><span data-stu-id="36366-112">two PTR Resource Records are added to the local service cache, one for</span></span>

```
“*_subtype._*sub*._type._*tcp.local *PTR name.type._*tcp*.*local”
```

<span data-ttu-id="36366-113">및 다른 한 개 -</span><span class="sxs-lookup"><span data-stu-id="36366-113">and the other one for</span></span>

```
*“_type._*tcp*.*local *PTR name.type._*tcp*.*local”.
```

<span data-ttu-id="36366-114">피어 서비스 캐시는 인접 노드에서 받은 mDNS 리소스 레코드를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="36366-114">The peer service cache contains mDNS Resource Records received from neighboring nodes.</span></span> <span data-ttu-id="36366-115">mDNS 모듈은 네트워크의 다른 노드에서 알린 리소스 레코드를 수집하고, 수신한 정보를 피어 서비스 캐시에 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="36366-115">mDNS module collects Resource Records advertised by other nodes on the network, and stores the received information in the peer service cache.</span></span> <span data-ttu-id="36366-116">애플리케이션에서 호스트 IPv4 또는 IPv6 주소 등과 같은 정보를 쿼리하면 mDNS는 피어 서비스 캐시에서 로컬에 캐시된 응답을 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="36366-116">When application queries for information such as host IPv4 or IPv6 addresses, mDNS searches the peer service cache for locally cached responses.</span></span> <span data-ttu-id="36366-117">애플리케이션이 피어에서 제공되는 서비스를 쿼리하면 mDNS는 캐시에서 관련 PTR, SRV, TXT 및 IPv4/IPv6 주소 레코드를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="36366-117">When application queries for services offered by peers, mDNS searches through the cache for related PTR, SRV, TXT, and IPv4/IPv6 address records.</span></span> <span data-ttu-id="36366-118">피어 서비스 캐시도 노드에 보낸 쿼리를 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="36366-118">The peer service cache also stores queries sent to the node.</span></span> <span data-ttu-id="36366-119">예를 들어 애플리케이션이 *nx_mdns_service_one_shot_query* 를 호출하여 특정 서비스를 요청할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="36366-119">For example, an application may request a particular service by calling *nx_mdns_service_one_shot_query.*</span></span> <span data-ttu-id="36366-120">피어 서비스 캐시에 서비스가 없을 경우 mDNS는 피어 서비스 캐시에 쿼리 질문(PTR, SRV 및 TXT)을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="36366-120">If the service is not found in the peer service cache, mDNS creates query questions (PTR, SRV, and TXT) in the peer service cache.</span></span> <span data-ttu-id="36366-121">이러한 쿼리 질문은 서비스가 확인되거나 시간 초과될 때까지 정기적으로 네트워크에 보낼 수 있습니다. 마찬가지로 애플리케이션은 API *nx_mdns_service_continous_query()* 를 사용하여 장기간에 걸친 특정 서비스를 요청할 수 있습니다(애플리케이션이 API *nx_mdns_service_query_stop()* 을 사용하여 이전에 실행한 연속 쿼리 취소).</span><span class="sxs-lookup"><span data-stu-id="36366-121">These query questions will be sent to the network periodically till the service is resolved, or times out. Similar, the application may use the API *nx_mdns_service_continous_query()* to request a particular service over a long period of time (application cancels a previously issued continuous query by using the API *nx_mdns_service_query_stop()* ).</span></span> <span data-ttu-id="36366-122">네트워크에 쿼리를 보내지 않고 피어 서비스 캐시에서 특정 서비스를 검색하기 위해 애플리케이션은 API *nx_mdns_serivce_lookup()* 을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="36366-122">To search for a particular service in the peer service cache without sending queries to the network, applications can use the API *nx_mdns_serivce_lookup().*</span></span> <span data-ttu-id="36366-123">이 API는 피어 서비스 캐시의 리소스 레코드만 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="36366-123">This API only searches the resource records in the peer service cache.</span></span>

<span data-ttu-id="36366-124">각 리소스 레코드는 서비스 캐시의 *NX_MDNS_RR* 데이터 구조에 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="36366-124">Each Resource Record is stored in a data structure *NX_MDNS_RR* in the service caches.</span></span> <span data-ttu-id="36366-125">리소스 레코드의 문자열은 가변 길이이므로 *NX_MDNS_RR* 구조에 저장되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="36366-125">Strings in Resource Records are variable length, therefore are not stored in the *NX_MDNS_RR* structure.</span></span> <span data-ttu-id="36366-126">리소스 레코드에는 문자열이 저장된 실제 메모리 위치에 대한 포인터가 들어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="36366-126">The Resource Record contains a pointer to the actual memory location where the string is stored.</span></span> <span data-ttu-id="36366-127">문자열 테이블과 리소스 레코드는 서비스 캐시를 공유합니다.</span><span class="sxs-lookup"><span data-stu-id="36366-127">The string table and the Resource Records share the service cache.</span></span> <span data-ttu-id="36366-128">리소스 레코드는 서비스 캐시 시작 부분에 저장되며 캐시 끝 방향으로 확장됩니다.</span><span class="sxs-lookup"><span data-stu-id="36366-128">Resource Records are stored from the beginning of the service cache, and grow towards the end of the cache.</span></span> <span data-ttu-id="36366-129">문자열 테이블은 서비스 캐시 끝에서 시작하여 캐시 시작 방향으로 확장됩니다.</span><span class="sxs-lookup"><span data-stu-id="36366-129">The string table starts from the end of the service cache and grows towards the beginning of the cache.</span></span> <span data-ttu-id="36366-130">문자열 테이블의 각 문자열에는 길이 필드와 카운터 필드가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="36366-130">Each string in the string table has a length field and a counter field.</span></span> <span data-ttu-id="36366-131">문자열이 문자열 테이블에 추가될 때 테이블에 동일한 문자열이 이미 있으면 카운터 값이 증가하고 해당 문자열에 대해 메모리가 할당되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="36366-131">When a string is added to the string table, if the same string is already present in the table, the counter value is incremented and no memory is allocated for the string.</span></span> <span data-ttu-id="36366-132">서비스 캐시에 새 문자열 또는 그 이상의 리소스 레코드를 추가할 수 없으면 서비스 캐시가 가득 찬 것으로 간주됩니다.</span><span class="sxs-lookup"><span data-stu-id="36366-132">The service cache is considered full if no more resource records or new strings can be added to the service cache.</span></span>

<span data-ttu-id="36366-133">애플리케이션은 두 가지 방법으로 로컬 네트워크에서 제공하는 서비스를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="36366-133">There are two ways for an application to find services offered on the local network.</span></span> <span data-ttu-id="36366-134">일회용 쿼리를 통해 특정 서비스 조회를 실행하거나, 연속 쿼리를 시작하여 네트워크의 작업을 “모니터링”할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="36366-134">It can either issue a specific service look up through a one-shot query, or it can initiate a continuous query to “monitor” the activities on the network.</span></span> <span data-ttu-id="36366-135">일회용 쿼리 시나리오에서는 애플리케이션이 서비스 형식을 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="36366-135">In the one-short query scenario, the application must specify the service type.</span></span> <span data-ttu-id="36366-136">mDNS는 로컬 서비스 캐시와 피어 서비스 캐시를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="36366-136">mDNS searches through the local service cache and the peer service cache.</span></span> <span data-ttu-id="36366-137">서비스 인스턴스를 찾은 경우 일회용 쿼리는 리소스 레코드에 있는 정보로 쿼리를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="36366-137">If a service instances is located, the one-shot query returns with the information found in the Resource Records.</span></span> <span data-ttu-id="36366-138">로컬 서비스 캐시나 피어 서비스 캐시에 레코드가 없는 경우 mDNS는 쿼리 메시지를 내보냅니다.</span><span class="sxs-lookup"><span data-stu-id="36366-138">If there are no records in the local service cache or peer service cache, mDNS sends out query messages.</span></span> <span data-ttu-id="36366-139">인스턴스 이름을 지정한 경우 특정 인스턴스 이름을 갖는 *모든* 형식(SRV 및 TXT 형식 쿼리)이 "name.type.local" 형태로 로컬 네트워크로 전송됩니다.</span><span class="sxs-lookup"><span data-stu-id="36366-139">If the instance name is specified, an *ANY* type (query the SRV and TXT type) with the specific instance name, in the form of “name.type.local”, is sent to the local network.</span></span> <span data-ttu-id="36366-140">인스턴스 이름을 지정하지 않으면 쿼리의 PTR 형식이 로컬 네트워크로 전송됩니다.</span><span class="sxs-lookup"><span data-stu-id="36366-140">If the instance name is not specified, a PTR type of query is sent to the local network.</span></span> <span data-ttu-id="36366-141">수신한 첫 번째 전체 서비스가 호출자에게 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="36366-141">The first complete service received is returned to the caller.</span></span>

<span data-ttu-id="36366-142">연속 쿼리는 다르게 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="36366-142">Continuous query works differently.</span></span> <span data-ttu-id="36366-143">연속 쿼리의 일반적인 사용 사례는 로컬 네트워크에서의 특정 서비스 모니터링입니다(예: 로컬 네트워크에서 인쇄 서비스의 지속적인 검색).</span><span class="sxs-lookup"><span data-stu-id="36366-143">The typical use case for a continuous query is to monitor the local network for a specific service (for example to constantly look for printing services on the local network).</span></span> <span data-ttu-id="36366-144">이 경우 애플리케이션은 특정 서비스 형식에 대한 검색 쿼리를 실행합니다(API *nx_mdns_service_continious_* query 사용).</span><span class="sxs-lookup"><span data-stu-id="36366-144">In this case the application issues a search query (via the API *nx_mdns_service_continious_* query) for certain type of services.</span></span> <span data-ttu-id="36366-145">호출자는 일반적으로 특정 응답을 기다리지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="36366-145">The caller typically does not wait for a particular response.</span></span> <span data-ttu-id="36366-146">연속 쿼리로 제출된 쿼리의 경우 mDNS 모듈은 지수로 늘어나는 간격으로 쿼리를 정기적으로 전송합니다.</span><span class="sxs-lookup"><span data-stu-id="36366-146">For queries submitted as continuous query, the mDNS module transmits the queries periodically with exponentially increasing intervals.</span></span> <span data-ttu-id="36366-147">쿼리를 중지하려면 애플리케이션이 API *nx_mdns_service_query_stop* 을 사용하여 해당 쿼리에서 내부 타이머를 중지해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="36366-147">To stop the query, application must use the API *nx_mdns_service_query_stop* to stop the internal timer in these queries.</span></span> <span data-ttu-id="36366-148">쿼리 형식은 NULL이 될 수 있습니다. 이 경우 쿼리 형식이 특수 PTR 형식 “_services._dns-sd._udp.local”로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="36366-148">The query type can be NULL, in which case the query type is set to special PTR type “_services._dns-sd._udp.local”.</span></span> <span data-ttu-id="36366-149">이 서비스 형식은 로컬 네트워크에서 사용할 수 있는 모든 서비스를 검색하기 위한 방법으로 mDNS에서 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="36366-149">This service type is defined by mDNS as a way to discover all services available on the local network.</span></span> <span data-ttu-id="36366-150">인스턴스 이름을 제공한 경우 특정 인스턴스 이름 “name.type.local”을 갖는 모든 형식(SRV 및 TXT 형식 쿼리)을 로컬 네트워크로 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="36366-150">If the instance name is supplied, an ANY type (query the SRV and TXT type) with the specific instance name “name.type.local” is sent to the local network.</span></span> <span data-ttu-id="36366-151">인스턴스 이름이 NULL이면 쿼리의 PTR 형식이 로컬 네트워크로 전송됩니다.</span><span class="sxs-lookup"><span data-stu-id="36366-151">If the instance name is NULL, a PTR type of query is sent to the local network,</span></span>

<span data-ttu-id="36366-152">원치 않는 쿼리의 응답을 비롯한 모든 응답은 피어 서비스 캐시에 기록됩니다.</span><span class="sxs-lookup"><span data-stu-id="36366-152">All responses, including responses from unsolicited queries, are recorded in the peer service cache.</span></span> <span data-ttu-id="36366-153">나중에 애플리케이션이 API *nx_mdns_service_lookup* 을 사용하여 피어 서비스 캐시에서 특정 서비스를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="36366-153">At a later time, the application uses the API *nx_mdns_service_lookup* to retrieve specific service from the peer service cache.</span></span>

<span data-ttu-id="36366-154">조각화 관련 특별 정보: 각 *NX_MDNS_RR* 구조는 크기가 고정이므로 mDNS의 RR 추가 및 삭제에 따른 조각화 대상이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="36366-154">Special note on fragmentation: Each *NX_MDNS_RR* structure is fixed in size, and therefore is not subject to fragmentation as mDNS adds and deletes RRs.</span></span> <span data-ttu-id="36366-155">그러나 문자열은 가변 길이입니다.</span><span class="sxs-lookup"><span data-stu-id="36366-155">However strings are variable length.</span></span> <span data-ttu-id="36366-156">문자열 삭제 후에는 해당 공간이 사용할 수 있게 되며, 부합하는 새 문자열이 있으면 해당 문자열에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="36366-156">After a string is deleted, the space becomes available and could be used for a new string if the new string is able to fit in.</span></span> <span data-ttu-id="36366-157">그러나 이 작업에서는 메모리가 조각화됩니다.</span><span class="sxs-lookup"><span data-stu-id="36366-157">But this operation causes the memory to fragment.</span></span> <span data-ttu-id="36366-158">서비스가 추가 및 제거되면 문자열 테이블이 조각화되어, 서비스 캐시에 사용하지 않은 문자열용 바이트가 충분히 있더라도 새 문자열을 추가하지 못할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="36366-158">As services are added and removed, the string table may be fragmented to the point that no new strings can be added even though the service cache contains enough unused bytes for the string.</span></span> <span data-ttu-id="36366-159">로컬 애플리케이션이 보통 더 안정적이고 예측 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="36366-159">Local applications tend to be more stable and predictable.</span></span> <span data-ttu-id="36366-160">따라서 로컬 서비스 캐시에서는 조각화 문제가 발생할 가능성이 더 낮습니다.</span><span class="sxs-lookup"><span data-stu-id="36366-160">Therefore the local service cache is less likely to suffer from fragmentation.</span></span> <span data-ttu-id="36366-161">반면 피어 서비스 캐시는 서비스가 사용할 수 있게 되면 지속적으로 RR을 추가하거나, 네트워크의 노드에서 서비스가 삭제되면 RR을 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="36366-161">The peer service cache, on the other hand, constantly add RRs as the services become available, or remove RRs as services are deleted by the nodes on the network.</span></span> <span data-ttu-id="36366-162">네트워크에서 서비스가 들어오고 나가면 문자열 테이블에서 할당/삭제 작업이 더 빈번하게 일어납니다.</span><span class="sxs-lookup"><span data-stu-id="36366-162">Services on the network come and go, causing more frequent allocate/delete operations on the string table.</span></span> <span data-ttu-id="36366-163">시간이 지날수록 문자열 테이블이 조각화될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="36366-163">Over time it is possible the string table becomes fragmented.</span></span> <span data-ttu-id="36366-164">이러한 상황이 발생했을 때 간단한 해결 방법은 전체 피어 서비스 캐시를 플러시하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="36366-164">When this situation happens, a simple solution is to flush the entire peer service cache.</span></span> <span data-ttu-id="36366-165">API *nx_mdns_peer_cache_clear()* 를 호출하여 이 작업을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="36366-165">This can be done by calling the API *nx_mdns_peer_cache_clear().*</span></span> <span data-ttu-id="36366-166">이 API는 처리 중인 연속 쿼리를 자동으로 종료합니다.</span><span class="sxs-lookup"><span data-stu-id="36366-166">Note that this API automatically terminates any outstanding continuous queries.</span></span>
