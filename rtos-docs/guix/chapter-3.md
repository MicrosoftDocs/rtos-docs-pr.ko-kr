---
title: 3장 - GUIX의 기능 개요
description: 이 장에는 고성능 GUIX 사용자 인터페이스 제품의 기능 개요가 포함되어 있습니다.
author: philmea
ms.author: philmea
ms.date: 05/19/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 53ffc900debd3bfaa1a38d792ddf294b2ce92461
ms.sourcegitcommit: 60ad844b58639d88830f2660ab0c4ff86b92c10f
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/07/2021
ms.locfileid: "106550306"
---
# <a name="chapter-3---functional-overview-of-guix"></a><span data-ttu-id="b7a34-103">3장 - GUIX의 기능 개요</span><span class="sxs-lookup"><span data-stu-id="b7a34-103">Chapter 3 - Functional Overview of GUIX</span></span>

<span data-ttu-id="b7a34-104">이 장에는 고성능 GUIX 사용자 인터페이스 제품의 기능 개요가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-104">This chapter contains a functional overview of the high-performance GUIX user interface product.</span></span> 

## <a name="execution-overview"></a><span data-ttu-id="b7a34-105">실행 개요</span><span class="sxs-lookup"><span data-stu-id="b7a34-105">Execution Overview</span></span>

<span data-ttu-id="b7a34-106">GUIX는 이벤트 구동 프로그래밍 모델을 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-106">GUIX implements an event driven programming model.</span></span> <span data-ttu-id="b7a34-107">이것은 GUIX 프레임워크가 주로 GUIX 이벤트 큐에 푸시되는 이벤트 수신에 의해 구동됨을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-107">This means that the GUIX framework is primarily driven by the receipt of events pushed into the GUIX event queue.</span></span> <span data-ttu-id="b7a34-108">이러한 이벤트의 처리는 GUIX 시스템 초기화 중에 생성된 ThreadX 스레드인 GUIX 스레드의 컨텍스트에서 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-108">The processing of these events takes place in the context of the GUIX thread, which is a ThreadX thread created during GUIX system initialization.</span></span>

<span data-ttu-id="b7a34-109">GUIX 애플리케이션은 창 및 자식 위젯을 만들기 위한 GUIX API 함수를 호출하여 사용자 인터페이스를 정의하고, 각 창이나 위젯 형식의 색, 스타일, 글꼴 및 기타 다양한 특성을 정의하는 데 사용되는 추가 API 함수를 호출하여 이러한 위젯의 모양을 사용자 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-109">GUIX applications define the user interface by calling GUIX API functions to create windows and child widgets, and customize the appearance of these widgets by calling additional API functions used to define colors, styles, fonts, and various other attributes of each window or widget type.</span></span> <span data-ttu-id="b7a34-110">GUIX Studio를 사용하여 사용자 인터페이스 화면의 모양을 만드는 경우 GUIX API 함수를 호출하여 화면 표시를 만드는 이러한 많은 작업은 GUIX Studio 애플리케이션을 통해 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-110">If you are using GUIX Studio to create the appearance of your user-interface screens, much of this work of calling GUIX API functions to create your display is done for you by the GUIX Studio application.</span></span>

<span data-ttu-id="b7a34-111">GUIX 애플리케이션은 GUIX 이벤트 큐에서 검색된 이벤트를 처리하여 시스템 사용자 및 외부 비즈니스 논리와 상호 작용합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-111">GUIX applications interact with the system user and with external business logic by handling events retrieved from the GUIX event queue.</span></span>
<span data-ttu-id="b7a34-112">이러한 이벤트는 일반적으로 GUIX 위젯에 의해 생성되지만 외부 스레드에 의해 생성될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-112">These events are usually produced by GUIX widgets, but they can also be created by external threads.</span></span> <span data-ttu-id="b7a34-113">일반적인 GUIX 단추를 누르면 해당 단추는 단추의 부모 창으로 이벤트를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-113">When a typical GUIX button is pushed, that button sends an event to the button’s parent window.</span></span> <span data-ttu-id="b7a34-114">애플리케이션은 단추 누름 이벤트에 대한 처리기를 제공하여 해당 단추를 누르면 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-114">Your application program will act on that button push by providing a handler for the button push event.</span></span>

<span data-ttu-id="b7a34-115">입력 드라이버와 같은 항목에 대해 추가 GUIX 스레드가 생성되는 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-115">Additional GUIX threads are often created for things such as input drivers.</span></span> <span data-ttu-id="b7a34-116">일반적인 터치 스크린 입력 드라이버는 주 GUIX 스레드 외부의 독립 실행형 스레드로 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-116">A typical touch screen input driver is executed as a standalone thread external to the main GUIX thread.</span></span> <span data-ttu-id="b7a34-117">터치 입력 드라이버는 GUIX 이벤트 큐에 이벤트를 전송하여 터치 정보를 GUIX 스레드로 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-117">The touch input driver sends touch information into the GUIX thread by sending events into the GUIX event queue.</span></span>

<span data-ttu-id="b7a34-118">애니메이션과 같은 여러 사용자 인터페이스 작업은 정확한 타이밍 정보를 요구하므로 GUIX는 간단하고 사용하기 쉬운 타이머 인터페이스도 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-118">Since many user-interface operations such as animations require accurate timing information, GUIX also implements a simple and easy to use timer interface.</span></span> <span data-ttu-id="b7a34-119">이 타이머 인터페이스는 ThreadX 타이머 서비스를 기준으로 빌드되며 시스템 시작 시 자동으로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-119">This timer interface is built upon the ThreadX timer service, and is configured automatically at system startup.</span></span>

<span data-ttu-id="b7a34-120">대부분의 GUIX 소프트웨어는 하드웨어 종속성에 독립적입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-120">The vast majority of the GUIX software is independent of any hardware dependencies.</span></span> <span data-ttu-id="b7a34-121">프레임워크에는 하드웨어 관련 입력 드라이버 및 하드웨어 관련 그래픽 드라이버가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-121">The framework does require hardware-specific input drivers and hardware-specific graphics drivers.</span></span> <span data-ttu-id="b7a34-122">이러한 하드웨어 관련 드라이버가 구현되는 방법에 대한 자세한 내용은 5장에 설명됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-122">The details of how these hardware specific drivers are implemented are deferred to chapter 5.</span></span>

## <a name="initialization"></a><span data-ttu-id="b7a34-123">초기화</span><span class="sxs-lookup"><span data-stu-id="b7a34-123">Initialization</span></span> 

<span data-ttu-id="b7a34-124">서비스 ***gx_system_initialize*** 는 다른 GUIX 서비스를 호출하기 전에 호출해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-124">The service ***gx_system_initialize*** must be called before any other GUIX service is called.</span></span> <span data-ttu-id="b7a34-125">GUIX 시스템 초기화는 ThreadX ***tx_application_define*** 루틴(초기화 컨텍스트) 또는 애플리케이션 스레드에서 호출될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-125">GUIX system initialization can be called from the ThreadX ***tx_application_define*** routine (initialization context) or from application threads.</span></span> <span data-ttu-id="b7a34-126">***gx_system_initialize*** 함수는 GUIX 이벤트 큐를 만들고, GUIX 타이머 기능을 초기화하고, 주 GUIX 시스템 스레드를 만들고, 애플리케이션을 실행하는 동안 GUIX에서 유지 관리되는 다양한 데이터 구조를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-126">The ***gx_system_initialize*** function creates the GUIX event queue, initializes the GUIX timer facility, creates the main GUIX system thread, and initializes various data structures maintained by GUIX during the execution of your application.</span></span>

<span data-ttu-id="b7a34-127">***gx_system_initialize*** 가 반환된 후에는 애플리케이션에서 화면 표시, 캔버스, 창, 위젯을 만들고 모든 GUIX 개체의 속성을 사용자 지정할 준비가 완료됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-127">After ***gx_system_initialize*** returns, the application is ready to create displays, canvases, windows, widgets, and customize the properties of all GUIX objects.</span></span> <span data-ttu-id="b7a34-128">GUIX 개체 만들기 API의 대부분은 ***tx_application_define*** 또는 애플리케이션 스레드에서 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-128">Much of the GUIX object creation API can be called from ***tx_application_define*** or from application threads.</span></span>

## <a name="application-interface-calls"></a><span data-ttu-id="b7a34-129">애플리케이션 인터페이스 호출</span><span class="sxs-lookup"><span data-stu-id="b7a34-129">Application Interface Calls</span></span> 

<span data-ttu-id="b7a34-130">애플리케이션에서 수행되는 호출은 주로 ***tx_application_define***(초기화 컨텍스트) 또는 애플리케이션 스레드에서 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-130">Calls from the application are largely made from ***tx_application_define*** (initialization context) or from application threads.</span></span> <span data-ttu-id="b7a34-131">4장에서 설명하는 각 GUIX API의 "허용 위치" 섹션을 참조하여 호출 가능 컨텍스트를 확인하세요.</span><span class="sxs-lookup"><span data-stu-id="b7a34-131">Please see the “Allowed From” section of each GUIX API described in Chapter 4 to determine what context it may be called from.</span></span>

<span data-ttu-id="b7a34-132">대부분의 경우 모든 이벤트 처리 및 위젯/창 그리기를 포함하는 처리 집약적 작업은 내부 GUIX 스레드로 지연됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-132">For the most part, processing intensive activities are deferred to the internal GUIX thread, including all event processing and widget/window drawing.</span></span>

<span data-ttu-id="b7a34-133">언제든지 임의 스레드에서 GUIX API 함수를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-133">The GUIX API functions can be called from any thread at any time.</span></span>
<span data-ttu-id="b7a34-134">그러나 일반적으로 사용자 인터페이스 논리에서 시간이 중요한 비즈니스 논리를 분리하는 것이 더 나은 아키텍처가 되는 것으로 간주됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-134">However it is usually considered to be better architecture to separate your time-critical business logic from your user interface logic.</span></span> <span data-ttu-id="b7a34-135">사용자 인터페이스 그리기 작업은 화면 크기와 CPU 성능에 따라 시간이 오래 걸릴 수 있으므로 일반적으로 그리기 작업이 완료될 때까지 시간이 중요한 스레드가 지연되는 것을 원치 않을 것입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-135">Since the user interface drawing operations can sometimes take a long time depending on your display size and CPU performance, you normally would not want to have time-critical threads delayed waiting for a drawing operation to complete.</span></span>

## <a name="internal-guix-thread"></a><span data-ttu-id="b7a34-136">내부 GUIX 스레드</span><span class="sxs-lookup"><span data-stu-id="b7a34-136">Internal GUIX Thread</span></span> 

<span data-ttu-id="b7a34-137">앞서 언급한 것처럼 GUIX에는 대량 GUI 처리를 수행하는 내부 스레드가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-137">As mentioned, GUIX has an internal thread that performs the bulk of the GUI processing.</span></span> <span data-ttu-id="b7a34-138">이 스레드는 애플리케이션 소프트웨어에서 ***gx_system_initialize** _ 다음에 _*_gx_system_start_\*\*를 호출하여 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-138">This thread is created by the application software by calling ***gx_system_initialize** _ followed by _*_gx_system_start_\*\*.</span></span>

<span data-ttu-id="b7a34-139">내부 GUIX 스레드의 우선 순위는 `#define GX_SYSTEM_THREAD_PRIORITY`에 따라 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-139">The priority of the internal GUIX thread is determined by the `#define GX_SYSTEM_THREAD_PRIORITY`.</span></span> <span data-ttu-id="b7a34-140">이 값의 기본값은 16(중간 우선 순위)이지만 gx_port.h 또는 gx_user.h 헤더 파일에서 기본값을 재정의하여 수정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-140">This value defaults to 16 (middle priority) but can be modified by specifying this value in the gx_port.h or gx_user.h header file, overriding the default value.</span></span>

<span data-ttu-id="b7a34-141">GUIX 스레드 시간 조각은 `#define GX_SYSTEM_THREAD_TIMESLICE`에서 유사하게 정의되며 기본값은 10ms입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-141">The GUIX thread time slice is similarly defined by the `#define GX_SYSTEM_THREAD_TIMESLICE`, which defaults to the value 10 ms.</span></span>

<span data-ttu-id="b7a34-142">시스템 스레드의 스택 크기는 ***gx_port.h*** 헤더 파일에 있는 `#define GX_THREAD_STACK_SIZE`로 결정되지만 헤더 파일에 이 값을 지정하여 재정의할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-142">The stack sie of the system thread is determined by the `#define GX_THREAD_STACK_SIZE`, which is found in the ***gx_port.h*** header file, but can also be overridden by specifying this value in your gx_user.h header file.</span></span>

<span data-ttu-id="b7a34-143">내부 GUIX 스레드 실행 루프는 세 가지 작업으로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-143">The internal GUIX thread execution loop is composed of three actions.</span></span>
<span data-ttu-id="b7a34-144">먼저 GUIX는 GUIX 이벤트 큐에서 이벤트를 검색하고 GUIX 창 및 위젯에서 처리될 이벤트를 디스패치합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-144">First, GUIX retrieves events from the GUIX event queue and dispatches those events for processing by the GUIX windows and widgets.</span></span> <span data-ttu-id="b7a34-145">이벤트는 일반적으로 사용자 입력을 처리할 때 정기적 타이머, 입력 디바이스(예: 터치 스크린 또는 키패드)에 의해, 그리고 GUIX 위젯 자체에 의해 GUIX 이벤트 큐에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-145">Events are typically pushed into the GUIX event queue by periodic timers, input devices such as a touch screen or keypad, and by GUIX widgets themselves as they process user input.</span></span> <span data-ttu-id="b7a34-146">그런 다음, 모든 이벤트가 처리되면 GUIX는 화면 새로 고침이 필요한지를 확인하고, 새로 고침이 필요하면 더티로 표시된 창 및 위젯의 그리기 기능을 호출하여 디스플레이 그래픽 데이터를 업데이트하는 데 필요한 처리를 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-146">Next, after all events have been processed, GUIX determines if a screen refresh is needed, and if so performs the processing necessary to update the display graphics data, mainly by calling the drawing functions of those windows and widgets which have been marked as dirty.</span></span> <span data-ttu-id="b7a34-147">마지막으로 GUIX는 새 입력 이벤트가 도달할 때까지 GUIX 스레드를 일시 중단합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-147">Finally, GUIX suspends the GUIX thread until a new input event or events arrive.</span></span>

## <a name="event-processing"></a><span data-ttu-id="b7a34-148">이벤트 처리</span><span class="sxs-lookup"><span data-stu-id="b7a34-148">Event Processing</span></span> 

<span data-ttu-id="b7a34-149">터치 또는 펜 입력 이벤트는 터치 또는 펜 입력 픽셀 위치 아래에 있는 맨 위 창이나 위젯을 확인하고 해당 창/위젯의 이벤트 처리 함수를 호출하여 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-149">Touch or pen input events are processed by determining the top-most window or widget beneath the touch or pen input pixel position and calling that window/widget’s event processing function.</span></span> <span data-ttu-id="b7a34-150">위젯이 펜 입력 이벤트를 이해하는 경우 해당 위젯 유형에 적절하게 이벤트를 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-150">If the widget understands pen input events, it will process the event as appropriate for that widget type.</span></span> <span data-ttu-id="b7a34-151">그렇지 않은 경우 맨 위에 있는 위젯은 처리를 위해 위젯 부모에 터치 또는 펜 입력 이벤트를 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-151">If not, the top-most widget will pass the touch or pen input event to the widget's parent for processing.</span></span> <span data-ttu-id="b7a34-152">이러한 체인까지의 이벤트 전달은 이벤트가 처리되거나 이벤트가 루트 창에 도달할 때(이 경우 이벤트는 삭제됨)까지 계속됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-152">This passing of the event up the chain continues until either the event is handled or the event arrives at the root window, in which case the event is discarded.</span></span>

<span data-ttu-id="b7a34-153">키패드 이벤트는 입력 포커스가 있는 창/위젯에 전송됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-153">Keypad events are sent to the window/widget that has input focus.</span></span> <span data-ttu-id="b7a34-154">입력 포커스 상태는 GUIX gx_system 구성 요소에 의해 유지 관리됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-154">Input focus status is maintained by the GUIX gx_system component.</span></span>

<span data-ttu-id="b7a34-155">타이머 이벤트는 처리를 위해 타이머를 소유하는 창 또는 위젯으로 항상 디스패치됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-155">Timer events are always dispatched to the window or widget that owns the timer for processing.</span></span>

<span data-ttu-id="b7a34-156">단추 클릭 이벤트 또는 슬라이더 값 변경 이벤트와 같이 내부적으로 생성된 이벤트는 항상 이벤트를 생성하는 위젯의 부모로 보내집니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-156">Internally generated events, such as button click events or slider value change events, are always sent to the parent of the widget generating the event.</span></span> <span data-ttu-id="b7a34-157">부모가 이벤트를 처리하지 않으면 터치 또는 펜 입력 이벤트와 유사한 체인으로 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-157">If the parent does not process the event, it is passed up the chain similar to touch or pen input events.</span></span>

## <a name="drawing"></a><span data-ttu-id="b7a34-158">그리기</span><span class="sxs-lookup"><span data-stu-id="b7a34-158">Drawing</span></span> 

<span data-ttu-id="b7a34-159">모든 이벤트 처리가 완료되면 GUIX 내부 스레드는 디스플레이 업데이트가 필요한지 여부를 확인하고 업데이트가 필요하면 적절한 창/위젯 그리기 함수가 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-159">Once all the event processing is complete, the GUIX internal thread determines if any display update is needed and if so the appropriate window/widget drawing functions are called.</span></span> <span data-ttu-id="b7a34-160">그리기가 완료되면 GUIX 내부 스레드는 다음 GUIX 이벤트가 처리될 수 있게 이벤트 큐에서 대기합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-160">When drawing is complete, the GUIX internal thread simply waits on its event queue for the next GUIX event to process.</span></span>

<span data-ttu-id="b7a34-161">GUIX는 각 위젯 및 캔버스에 대해 다시 그려야 하는 영역인 *더티 영역* 개념을 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-161">GUIX implements the concept of *dirty areas*, which are areas that need to be re-drawn, for each widget and canvas.</span></span> <span data-ttu-id="b7a34-162">위젯은 이전에 더티로 표시된 영역에만 그릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-162">A widget can only draw to areas that have previously been marked as dirty.</span></span> <span data-ttu-id="b7a34-163">위젯 그리기 함수를 호출하면 모든 그리기 작업은 내부적으로 이전에 정의된 더티 사각형으로 자릅니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-163">When a widget drawing function is called, all drawing operations are internally clipped to the previously defined dirty rectangle.</span></span>
<span data-ttu-id="b7a34-164">이 영역 외부의 그리기 시도는 무시됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-164">Attempts to draw outside of this area are ignored.</span></span>

<span data-ttu-id="b7a34-165">위젯 및 창은 API 함수 ***gx_system_dirty_mark*** 를 호출하여 자체적으로 더티로 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-165">Widgets and windows mark themselves as dirty by calling the API function ***gx_system_dirty_mark***.</span></span> <span data-ttu-id="b7a34-166">이 함수는 전체 위젯 또는 창을 다시 그려야 하는 것으로 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-166">This function marks the entire widget or window as needing to be redrawn.</span></span> <span data-ttu-id="b7a34-167">두 번째 함수인 ***gx_system_dirty_partial_add*** 는 창이나 위젯의 일부만 더티로 표시하기 위한 대안으로 호출될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-167">A second function, ***gx_system_dirty_partial_add***, can be invoked as an alternative to mark only a portion of a window or widget as dirty.</span></span>

<span data-ttu-id="b7a34-168">위젯을 더티로 표시한 다음, 모든 입력 이벤트가 처리된 경우에만 해당 위젯을 다시 그리는 이러한 모델을 *지연된 그리기* 라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-168">This model of marking widgets as dirty and then redrawing those widgets only when all input events have been processed is referred to as *deferred drawing*.</span></span> <span data-ttu-id="b7a34-169">GUIX 지연된 그리기 알고리즘 및 더티 목록 유지 관리는 그리기 효율성을 향상시키도록 설계되었습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-169">The GUIX deferred drawing algorithm and dirty list maintenance is designed to improve drawing efficiency.</span></span> <span data-ttu-id="b7a34-170">그리기 작업은 일반적으로 비용이 많이 들기 때문에 GUIX에서는 불필요한 그리기를 방지하기 위해 많은 노력을 기울입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-170">Since drawing operations are typically expensive, GUIX works hard to prevent unnecessary drawing.</span></span>

<span data-ttu-id="b7a34-171">GUIX *캔버스* 로 그리기가 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-171">Drawing is done to a GUIX *canvas*.</span></span> <span data-ttu-id="b7a34-172">캔버스는 그래픽 데이터를 저장하기 위해 예약된 메모리 영역입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-172">A canvas is a memory area reserved to hold graphics data.</span></span> <span data-ttu-id="b7a34-173">시스템 아키텍처 및 메모리 제약 조건에 따라 캔버스를 하드웨어 프레임 버퍼에 직접 연결할 수도 있고 그렇지 않을 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-173">A canvas may or may not be directly linked to the hardware frame buffer, depending on the system architecture and memory constraints.</span></span> <span data-ttu-id="b7a34-174">그리기를 수행하려면 먼저 ***gx_canvas_drawing_initiate*** API 함수를 호출하여 그리기를 위해 캔버스를 열어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-174">Before any drawing can occur, a canvas must first be opened for drawing by calling the ***gx_canvas_drawing_initiate*** API function.</span></span> <span data-ttu-id="b7a34-175">이 API는 그리기를 위해 캔버스를 준비하고 현재 *그리기 컨텍스트* 를 설정했습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-175">This API prepares a canvas for drawing and established the current *drawing context*.</span></span> <span data-ttu-id="b7a34-176">GUIX에서 시스템 캔버스 새로 고침을 수행하면 캔버스는 그리기를 위해 열리고 위젯 수준 그리기 API를 호출하기 전에 그리기 컨텍스트가 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-176">When GUIX performs a system canvas refresh, the canvas is opened for drawing and the drawing context established before the widget-level drawing APIs are invoked.</span></span> <span data-ttu-id="b7a34-177">따라서 위젯은 위젯 그리기 함수 내에서 캔버스에 그리기를 시작할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-177">Therefore widgets do not need to initiate drawing on a canvas within the widget drawing function.</span></span>

<span data-ttu-id="b7a34-178">그러나 애플리케이션은 표준 GUIX 지연된 그리기 알고리즘의 흐름 외부에서 캔버스에 즉시 그리기를 수행하려는 경우에는 다른 그리기 API 함수를 호출하기 전에 애플리케이션에서 ***gx_canvas_drawing_initiate*** 를 직접 호출하고, 일단 즉시 그리기가 완료되면 ***gx_canvas_drawing_complete*** 를 호출해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-178">However, if an application desires to perform immediate drawing to a canvas, outside the flow of the standard GUIX deferred drawing algorithm, the application must directly invoke the ***gx_canvas_drawing_initiate*** prior to calling any other drawing API functions, and must call ***gx_canvas_drawing_complete*** once the immediate drawing has been completed.</span></span>

## <a name="user-input"></a><span data-ttu-id="b7a34-179">사용자 입력</span><span class="sxs-lookup"><span data-stu-id="b7a34-179">User Input</span></span> 

<span data-ttu-id="b7a34-180">GUIX는 미리 정의된 이벤트 유형을 사용하여 터치 스크린, 마우스 및 키보드 디바이스를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-180">GUIX supports touch screen, mouse, and keyboard devices with predefined event types.</span></span> <span data-ttu-id="b7a34-181">사용자 지정 이벤트 유형을 정의하거나 사용자 지정 입력 디바이스를 미리 정의된 이벤트 유형에 매핑하여 추가 입력 디바이스를 활용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-181">Additional input devices can be utilized by defining custom event types, or by mapping the custom input device to the predefined event types.</span></span>

<span data-ttu-id="b7a34-182">이러한 디바이스와 관련된 작업은 내부 GUIX 스레드가 처리하는 이벤트로 변환됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-182">Actions associated with these devices are translated into events that are processed by the internal GUIX thread.</span></span> <span data-ttu-id="b7a34-183">터치 스크린을 지원하도록 작성된 드라이버 수준 소프트웨어는 GUIX 이벤트 큐 이벤트를 준비하고, 펜 놓기, 펜 들기 및 펜 끌기 작업으로 전송해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-183">Driver level software written to support a touch screen must prepare and send to the GUIX event queue events for pen-down, pen-up, and pen-drag operations.</span></span> <span data-ttu-id="b7a34-184">마찬가지로 키패드 입력 드라이버는 키 누름 및 키 놓기 입력에 대한 이벤트를 생성해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-184">Similarly a keypad input driver must generate events for key press and key release input.</span></span>

## <a name="modal-dialog-execution"></a><span data-ttu-id="b7a34-185">모달 대화 상자 실행</span><span class="sxs-lookup"><span data-stu-id="b7a34-185">Modal Dialog Execution</span></span> 

<span data-ttu-id="b7a34-186">모달 대화 상자 실행은 다른 GUIX 창 또는 위젯이 사용자 입력을 받을 수 있도록 먼저 닫아야 하는 창을 사용자에게 제공하는 것을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-186">Modal dialog execution refers to presenting a window to the user that must be closed in some way before any other GUIX windows or widgets can receive user input.</span></span> <span data-ttu-id="b7a34-187">모달 대화 상자는 터치 또는 마우스 입력 이벤트의 x, y 위치에 관계없이 대화 상자 창이 표시되는 동안 모든 사용자 입력을 캡처합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-187">Modal dialogs capture all user input while the dialog window is displayed, regardless of the x,y position of touch or mouse input events.</span></span>

<span data-ttu-id="b7a34-188">모달 대화 상자는 ***gx_window_create*** 를 호출하고 GUIX API 함수 ***gx_window_execute*** 를 호출하여 일반적인 방식으로 창을 먼저 만든 다음, 애플리케이션 소프트웨어에 의해 트리거됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-188">Modal dialogs are triggered by the application software by first creating the window in the normal way by calling ***gx_window_create***, and then calling the GUIX API function ***gx_window_execute.***</span></span>

<span data-ttu-id="b7a34-189">***gx_window_execute*** 함수를 호출하면 GUIX가 로컬 이벤트 처리 루프를 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-189">When the ***gx_window_execute*** function is called, GUIX enters a local event processing loop.</span></span> <span data-ttu-id="b7a34-190">***gx_window_execute*** 함수는 사용자 입력에 의해 또는 ***gx_window_close*** 를 호출하여 대화 상자 창을 닫을 때까지 호출자에게 반환하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-190">The ***gx_window_execute*** function does not return to the caller until the dialog window is closed, either by user input or by calling ***gx_window_close***.</span></span> <span data-ttu-id="b7a34-191">따라서 GUIX 내부 스레드 이외의 스레드에서 ***gx_window_execute*** 함수를 호출하지 않는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-191">For this reason, it is very important never to call the ***gx_window_execute*** function from any thread other than the GUIX internal thread.</span></span>

## <a name="periodic-processing"></a><span data-ttu-id="b7a34-192">정기적 처리</span><span class="sxs-lookup"><span data-stu-id="b7a34-192">Periodic Processing</span></span> 

<span data-ttu-id="b7a34-193">디스플레이 효과, 스프라이트 애니메이션 및 애플리케이션 주기적 요청 지원을 제공하기 위해 GUIX는 하나의 ThreadX 타이머를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-193">In order to provide display effects, sprite animation, and support for application periodic requests, GUIX uses one ThreadX timer.</span></span> <span data-ttu-id="b7a34-194">이 단일 타이머는 모든 GUIX 시간 관련 요구를 발생시키는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-194">This single timer is used to drive all GUIX time-related needs.</span></span> <span data-ttu-id="b7a34-195">기본적으로 GUIX 내부 타이머 처리의 빈도는 **_gx_api.h_** 에 정의된 **GX_SYSTEM_TIMER_MS** 상수가 이전에 gx_port.h 또는 gx_user.h 헤더에 정의되지 않는 한, 이 상수를 통해 20ms로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-195">By default, the frequency for the GUIX internal timer processing is set to 20ms via the constant **GX_SYSTEM_TIMER_MS**, which is defined in **_gx_api.h_**, unless the constant is previously defined in gx_port.h or gx_user.h header.</span></span> <span data-ttu-id="b7a34-196">GUIX 라이브러리를 빌드하거나 ***gx_user.h*** 에서 명시적으로 재정의하여 애플리케이션에서 기본 빈도를 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-196">The default frequency may be changed by the application via a compilation option when building the GUIX library or by explicitly redefining it in ***gx_user.h***.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="b7a34-197">GUIX 타이머 빈도는 RTOS 타이머 틱으로 표현되고 **GX_SYSTEM_TIMER_TICKS** 상수에 의해 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-197">Note that the GUIX timer frequency is expressed in RTOS timer ticks, and is defined by the constant **GX_SYSTEM_TIMER_TICKS**.</span></span> <span data-ttu-id="b7a34-198">**GX_SYSTEM_TIMER_TICKS** 값은 **GX_SYSTEM_TIMER_MS** 및 **TX_TIMER_TICKS_PER_SECOND** 를 사용하여 계산됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-198">The value of **GX_SYSTEM_TIMER_TICKS** is calculated using **GX_SYSTEM_TIMER_MS** and **TX_TIMER_TICKS_PER_SECOND**.</span></span> <span data-ttu-id="b7a34-199">사용자는 **gx_port.h** _ 또는 _ \*_gx_user.h_\*\*에 이러한 값을 다시 정의하여 GUIX 타이머 빈도 및 해상도를 조정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-199">The user can re-define any of these values in the ***gx_port.h** _ or _ *_gx_user.h_** to adjust the GUIX timer frequency and resolution.</span></span>

## <a name="display-driver"></a><span data-ttu-id="b7a34-200">디스플레이 드라이버</span><span class="sxs-lookup"><span data-stu-id="b7a34-200">Display Driver</span></span> 

<span data-ttu-id="b7a34-201">디스플레이 드라이버는 일련의 그리기 함수를 핵심 GUIX 코드에 제공하는 일을 담당합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-201">Display drivers are responsible for providing a set of drawing functions to the core GUIX code.</span></span> <span data-ttu-id="b7a34-202">이러한 각 그리기 함수의 구현은 드라이버에 의해 결정되며, 가능한 경우 구현에서는 하드웨어 가속 지원이 활용됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-202">The implementation of each of these drawing functions is determined by the driver, and when possible the implementation will leverage hardware acceleration support.</span></span> <span data-ttu-id="b7a34-203">일반적으로 그리기 함수는 드라이버 아키텍처에 따라 물리적 프레임 버퍼이거나 보조 버퍼일 수 있는 메모리 버퍼에 픽셀 데이터를 기록하는 방식으로 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-203">In general the drawing function works by writing pixel data to a memory buffer, which may be the physical frame buffer or it may be a secondary buffer depending on the driver architecture.</span></span> <span data-ttu-id="b7a34-204">많은 드라이버는 두 개의 프레임 버퍼를 사용하여 이중 버퍼링을 구현하며, 이러한 버퍼는 버퍼 전환 함수를 호출하여 전환됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-204">Many drivers implement double buffering using two frame buffers, and these buffers are toggled by invoking the buffer toggle function.</span></span> <span data-ttu-id="b7a34-205">GUIX는 이러한 함수를 내부적으로 적절한 시간에 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-205">GUIX calls these functions internally at the appropriate times.</span></span> <span data-ttu-id="b7a34-206">메모리가 제한된 시스템의 경우 그리기 함수는 단일 메모리 프레임 버퍼에만 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-206">For memory constrained systems, the drawing functions may only write to a single memory frame buffer.</span></span>

<span data-ttu-id="b7a34-207">GUIX는 모든 지원 색 농도와 형식으로 각 하위 수준 그리기 함수의 기본 소프트웨어 구현을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-207">GUIX provides default software implementations of each low-level drawing function at every support color depth and format.</span></span> <span data-ttu-id="b7a34-208">이러한 함수는 **GX_DISPLAY** 구조체 내에서 유지 관리되는 함수 포인터를 통해 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-208">These functions are invoked via function pointers maintained within the **GX_DISPLAY** structure.</span></span> <span data-ttu-id="b7a34-209">하드웨어 관련 드라이버를 만들면 일반적으로 이러한 일부 함수 포인터를 대상 하드웨어와 관련된 함수로 덮어씁니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-209">When hardware-specific drivers are created, they typically will overwrite some number of these function pointers with functions that are specific to the target hardware.</span></span>

<span data-ttu-id="b7a34-210">일반적인 하드웨어 디스플레이 드라이버는 필요한 색 농도와 형식에 대한 기본 GUIX 디스플레이 드라이버를 먼저 만들어 구현됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-210">A typical hardware display driver is implemented by first creating the default GUIX display driver for the required color depth and format.</span></span>
<span data-ttu-id="b7a34-211">그러면 하드웨어 드라이버가 특정 하드웨어 구현을 위해 최적화되거나 사용자 지정해야 하는 함수를 대체합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-211">Then the hardware driver will replace those functions that need to be optimized or customized for the particular hardware implementation.</span></span>

<span data-ttu-id="b7a34-212">GUIX는 1-bpp 단색에서 32-bpp a:r:g:b 형식 범위의 픽셀 색 형식을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-212">GUIX support pixel color formats ranging from 1-bpp monochrome to 32-bpp a:r:g:b format.</span></span> <span data-ttu-id="b7a34-213">또한 GUIX는 광범위한 색 깊이 범주 내에서 r:g:b 대 b:g:r 바이트 순서, 압축된 픽셀 대 단어 맞춤 픽셀 형식, 알파 채널과 같은 많은 변형을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-213">GUIX also supports many variations within each broad color-depth category, such as r:g:b versus b:g:r byte order, packed pixel versus word-aligned pixel formats, and alpha channels.</span></span> <span data-ttu-id="b7a34-214">현재 25개의 고유한 색 형식이 지원되지만 하드웨어 공급업체가 새 변형을 제공하게 되면 이 목록이 증가합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-214">There are currently 25 distinct color formats supported, but this list grows as hardware vendors deliver new variations.</span></span>

## <a name="display-memory-architectures"></a><span data-ttu-id="b7a34-215">디스플레이 메모리 아키텍처</span><span class="sxs-lookup"><span data-stu-id="b7a34-215">Display Memory Architectures</span></span>

<span data-ttu-id="b7a34-216">다양한 하드웨어 대상과 디스플레이는 대상의 메모리 제약 조건 및 애플리케이션의 기능 요구 사항에 따라 다양한 디스플레이 메모리 아키텍처를 활용합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-216">Various hardware targets and displays utilize a variety of different display memory architectures, depending on the memory constraints of the target and the functionality requirements of the application.</span></span> <span data-ttu-id="b7a34-217">여기에서는 일반적인 메모리 아키텍처 중 일부에 대해 간략하게 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-217">We will outline some of the common memory architectures here with a brief description of each.</span></span>

<span data-ttu-id="b7a34-218">모델 1) 프레임 버퍼 없음, 외부 GRAM에 그래픽 데이터가 저장되어 있음:</span><span class="sxs-lookup"><span data-stu-id="b7a34-218">Model 1) No frame buffer, graphics data held in external GRAM:</span></span>

![프레임 버퍼 없음, 외부 GRAM에 그래픽 데이터가 저장되어 있음](./media/guix/user-guide/no-frame-buffer.png)

<span data-ttu-id="b7a34-220">위의 모델에서 프레임 버퍼에 대한 메모리가 CPU의 로컬 메모리에 존재하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-220">In the model above, no memory for a frame buffer exists in memory local to the CPU.</span></span> <span data-ttu-id="b7a34-221">모든 그래픽 데이터는 디스플레이 자체에 통합되는 외부 GRAM에 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-221">All graphics data is stored in an external GRAM which is incorporated into the display itself.</span></span> <span data-ttu-id="b7a34-222">외부 GRAM에 대한 인터페이스는 병렬 또는 직렬일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-222">The interface to the external GRAM can be parallel or serial.</span></span> <span data-ttu-id="b7a34-223">이 아키텍처 유형은 매우 저렴합니다. 그러나 그래픽 데이터를 업데이트할 때 원치 않는 분열 효과가 나타날 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-223">This type of architecture is very low cost; however it can exhibit unwanted tearing effect when the graphics data is updated.</span></span>

<span data-ttu-id="b7a34-224">모델 2) 하나의 로컬 프레임 버퍼:</span><span class="sxs-lookup"><span data-stu-id="b7a34-224">Model 2) One local frame buffer:</span></span>

![하나의 로컬 프레임 버퍼](./media/guix/user-guide/one-local-frame-buffer.png)

<span data-ttu-id="b7a34-226">이 모델에서 그래픽 데이터에 대한 메모리는 CPU에 직접 액세스할 수 있는 임의 액세스 메모리에서 할당됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-226">In this model, memory for the graphics data is allocated from a random-access memory that is directly accessible the CPU.</span></span> <span data-ttu-id="b7a34-227">타이밍 신호에 따라 그래픽 데이터를 로컬 메모리에서 디스플레이로 반복적으로 전송하기 위한 전용 하드웨어가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-227">Dedicated hardware must be present to repeatedly transmit the graphics data (along with timing signals) from the local memory to the display.</span></span> <span data-ttu-id="b7a34-228">이 모델은 그래픽 메모리가 CPU에서 사용할 수 있는 로컬 SRAM 또는 DRAM의 블록이라는 측면에서 모델 1과 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-228">This model differs from model 1 in that the graphics memory is a block of the local SRAM or DRAM available to the CPU.</span></span> <span data-ttu-id="b7a34-229">스택 및 프로그램 변수가 있는 것과 동일한 메모리일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-229">This may be the same memory in which stack and program variables live.</span></span>

<span data-ttu-id="b7a34-230">모델 3) 로컬 프레임 버퍼 + 외부 GRAM:</span><span class="sxs-lookup"><span data-stu-id="b7a34-230">Model 3) Local frame buffer + external GRAM:</span></span>

![로컬 프레임 버퍼 + 외부 GRAM](./media/guix/user-guide/local-frame-buffer-external-gram.png)

<span data-ttu-id="b7a34-232">모델 3은 처음 두 모델을 조합한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-232">Model 3 is a combination of the first two.</span></span> <span data-ttu-id="b7a34-233">이 모델에서는 하나의 프레임 버퍼를 보유할 수 있는 충분한 로컬 메모리가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-233">In this model, sufficient local memory exists to hold one frame buffer.</span></span> <span data-ttu-id="b7a34-234">또한 디스플레이 디바이스는 외부 GRAM을 제공하며, GRAM에 제공된 데이터를 사용하여 자동으로 새로 고쳐집니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-234">In addition, the display device provides an external GRAM and automatically refreshes itself using the data provided in the GRAM.</span></span> <span data-ttu-id="b7a34-235">이 아키텍처는 로컬 프레임 버퍼의 수정된 부분을 한 블록 전송에서 외부 GRAM으로 전송할 수 있으며, 종종 온보드 DMA 채널을 활용하기 때문에 업데이트 효율성이 향상되는 이점을 얻게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-235">This architecture benefits from improved update efficiency because we can transfer the modified portion of the local frame buffer to the external GRAM in one block transfer, often utilizing onboard DMA channels.</span></span> <span data-ttu-id="b7a34-236">이 모델은 완료된 그래픽 콘텐츠만 외부 GRAM으로 복사되기 때문에 처음 두 모델 중 하나에서 나타날 수 있는 분열 및 깜박임이 해소됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-236">This model also eliminates the tearing and flicker that can be present in either of the first two models, because only completed graphics contents is copied to the external GRAM.</span></span>

<span data-ttu-id="b7a34-237">모델 4) 핑퐁 프레임 버퍼:</span><span class="sxs-lookup"><span data-stu-id="b7a34-237">Model 4) Ping-pong frame buffers:</span></span>

![핑퐁 프레임 버퍼](./media/guix/user-guide/ping-pong-frame-buffers.png)

<span data-ttu-id="b7a34-239">모델 4에서는 두 개의 로컬 프레임 버퍼를 제공하기 위한 충분한 메모리가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-239">In model 4, sufficient memory is present to provide two local frame buffers.</span></span> <span data-ttu-id="b7a34-240">이 경우 GUIX는 하나의 프레임 버퍼를 활성 프레임 버퍼로 취급하고 다른 프레임 버퍼를 작업 프레임 버퍼로 취급합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-240">In this case, GUIX treats one frame buffer as the active frame buffer, and the other as the working frame buffer.</span></span> <span data-ttu-id="b7a34-241">디스플레이 업데이트 또는 그리기 작업이 진행 중인 경우 작업 버퍼에서 진행됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-241">When a display update or drawing operation is in progress, it takes place in the working buffer.</span></span> <span data-ttu-id="b7a34-242">그리기 작업이 완료되면 버퍼가 전환되고 작업 버퍼가 활성 버퍼가 되며 활성 버퍼가 작업 버퍼가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-242">When the drawing operation completes, the buffers are toggled, and the working buffer becomes the active buffer and the active buffer becomes the working buffer.</span></span> <span data-ttu-id="b7a34-243">또한 이 모델에서는 버퍼링된 단일 시스템에서 관찰될 수 있는 화면 깜박임 및 분열이 해소됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-243">This model also eliminates screen flicker and tearing that can be observed in a single buffered system.</span></span>

<span data-ttu-id="b7a34-244">모델 5) 캔버스가 합성된 핑퐁 버퍼:</span><span class="sxs-lookup"><span data-stu-id="b7a34-244">Model 5) Ping-pong buffers with canvas compositing:</span></span>

![캔버스가 합성된 핑퐁 버퍼](./media/guix/user-guide/ping-pong-buffers-canvas-composting.png)

<span data-ttu-id="b7a34-246">모델 5에서는 사용 가능한 메모리 한도까지 여러 캔버스를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-246">In model 5, any number of canvases can be created, up to the limits of available memory.</span></span> <span data-ttu-id="b7a34-247">애플리케이션에서 정의한 대로 캔버스를 겹치거나 혼합하여 캔버스 합성을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-247">The canvases can be overlaid or blended together as defined by the application to create the canvas composite.</span></span> <span data-ttu-id="b7a34-248">화면 새로 고침 작업 후 새 합성이 만들어지면 표준 핑퐁 버퍼 아키텍처와 동일한 작업에서 활성 및 작업 합성 버퍼가 전환됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-248">When a new composite is created after a screen refresh operation, the active and working composite buffers are toggled in an operation identical to the standard ping-pong buffer architecture.</span></span> <span data-ttu-id="b7a34-249">모델 5에서는 캔버스를 최종 출력 합성으로 혼합하여 화면 페이드 및 혼합 작업을 수행할 수 있는 기능을 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-249">Model 5 adds the ability to perform screen fade and blending operations by blending the canvases into the final output composite.</span></span>

<span data-ttu-id="b7a34-250">모델 6) 외부 GRAM으로 캔버스 합성:</span><span class="sxs-lookup"><span data-stu-id="b7a34-250">Model 6) Canvas compositing with external GRAM:</span></span>

![외부 GRAM으로 캔버스 합성](./media/guix/user-guide/canvas-compositing-external-gram.png)

<span data-ttu-id="b7a34-252">모델 6은 모델 5에서 약간 변형된 것으로, 하나의 합성 버퍼만 필요하고 해당 합성 버퍼는 외부 GRAM으로 전송됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-252">Model 6 is a slight variation on Model 5, in which only one composite buffer is required and the composite buffer is then transferred to external GRAM.</span></span> <span data-ttu-id="b7a34-253">이 모델은 전체 화면 혼합 및 오버레이도 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-253">This model also supports full screen blending and overlays.</span></span>

## <a name="string-encoding"></a><span data-ttu-id="b7a34-254">문자열 인코딩</span><span class="sxs-lookup"><span data-stu-id="b7a34-254">String Encoding</span></span> 

<span data-ttu-id="b7a34-255">GUIX는 기본적으로 UTF8 형식 문자열 인코딩을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-255">GUIX by default supports UTF8 format string encoding.</span></span> <span data-ttu-id="b7a34-256">***gx_user.h*** 헤더 파일에 **GX_DISABLE_UTF8_SUPPORT** 를 정의하여 UTF8 문자열 인코딩에 대한 지원을 사용하지 않도록 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-256">Support for UTF8 string encoding can be disabled by defining **GX_DISABLE_UTF8_SUPPORT** in the ***gx_user.h*** header file.</span></span> <span data-ttu-id="b7a34-257">UTF8 인코딩이 사용하지 않도록 설정된 경우 GUIX는 내부적으로 표준 8비트 ASCII와 라틴어-1 코드 페이지 문자 인코딩만 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-257">If UTF8 encoding is disabled, GUIX will internally use only standard 8-bit ASCII plus Latin-1 code page character encoding.</span></span> <span data-ttu-id="b7a34-258">UTF8 문자열 인코딩을 사용하지 않도록 설정하면 GUIX 라이브러리 공간은 약간 더 작아지고, 문자열 처리 및 텍스트 그리기 함수의 런타임 실행 속도도 약간 더 빨라집니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-258">Disabling UTF8 string encoding results in a slightly smaller GUIX library footprint and slightly faster runtime execution of string handling and text drawing functions.</span></span>

<span data-ttu-id="b7a34-259">UTF8 문자열 인코딩에는 다음과 같은 특징이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-259">UTF8 string encoding has the following traits:</span></span>

  - <span data-ttu-id="b7a34-260">ASCII 문자열은 표준 7비트 ASCII 인코딩보다 더 많은 스토리지 공간을 사용하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-260">ASCII strings take no more storage space than standard 7-bit ASCII encoding.</span></span>

  - <span data-ttu-id="b7a34-261">대부분의 ANSI-C 문자열 함수는 수정 없이 UTF8 문자열 인코딩에서 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-261">Most ANSI-C string functions work with UTF8 string encoding without modification.</span></span>

<span data-ttu-id="b7a34-262">간지 문자 집합을 포함하여 전 세계의 모든 활성 문자 집합은 UTF8 문자열 인코딩을 사용하여 나타낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-262">All active character sets in the world, including Kanji character sets, can be represented using UTF8 string encoding.</span></span>

### <a name="static-and-dynamic-strings"></a><span data-ttu-id="b7a34-263">정적 및 동적 문자열</span><span class="sxs-lookup"><span data-stu-id="b7a34-263">Static and Dynamic Strings</span></span> 

<span data-ttu-id="b7a34-264">텍스트 표시를 지원하는 GUIX 위젯에 할당된 문자열은 일반적으로 아래에 설명된 GUIX 문자열 테이블의 일부로 상수 스토리지에 배치되는 정적으로 정의된 문자열 상수 및 **sprintf** _ 또는 _\*_gx_utility_ltoa_\*\*와 같은 서비스를 사용하여 런타임에 생성되는 동적으로 정의된 문자열일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-264">The strings assigned to your GUIX widgets which support text display can be statically defined string constants, which are normally placed in constant storage as part of the GUIX String table described below, and dynamically defined strings, which are strings generated at runtime using services such as ***sprintf** _ or _*_gx_utility_ltoa_\*\*.</span></span>

<span data-ttu-id="b7a34-265">동적 문자열의 예에는 GUIX 프롬프트 위젯 내에 숫자로 표시되는 값 또는 사용자의 위치 및 형식 기본 설정에 따라 동적으로 서식이 지정되는 "시간/날짜" 문자열이 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-265">Examples of dynamic strings might include a value displayed as a number within a GUIX prompt widget, or a “time / date” string which is dynamically formatted based on the user’s location and format preferences.</span></span> <span data-ttu-id="b7a34-266">런타임에 **GX_PROMPT** 또는 **GX_TEXT_BUTTON 위젯** 과 같은 GUIX 위젯에 할당될 문자열을 만드는 경우 이러한 런타임 생성 문자열(예: 전역 문자 배열)에 대해 스토리지를 정적으로 할당하도록 선택하거나</span><span class="sxs-lookup"><span data-stu-id="b7a34-266">If you create strings at runtime which will be assigned to GUIX widgets such as **GX_PROMPT** or **GX_TEXT_BUTTON widgets**, you must choose to either statically allocate the storage for these runtime generated strings (i.e</span></span>
<span data-ttu-id="b7a34-267">동적 메모리 할당자 함수를 정의 및 설치하고, 할당된 텍스트 문자열의 프라이빗 사본을 만들도록 해당 위젯에 지시하는 **GX_STYLE_TEXT_COPY** 스타일을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-267">global character arrays), or you can define and install a dynamic memory allocator function and use the **GX_STYLE_TEXT_COPY** style, which instructs those widgets to create a private copy of text strings assigned.</span></span>

<span data-ttu-id="b7a34-268">자동 문자 배열과 같은 임시 스토리지를 사용하여 동적으로 생성된 문자열을 저장한 다음, **GX_STYLE_TEXT_COPY** 스타일이 없는 위젯에 이 문자열을 할당하는 것은 프로그래밍 오류입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-268">It is a programming error to use temporary storage, such as an automatic character array, to hold a dynamically generated string and then assign this string to a widget that does not have the **GX_STYLE_TEXT_COPY** style.</span></span> <span data-ttu-id="b7a34-269">이 스타일을 사용하도록 설정하지 않으면 위젯은 제공된 문자열 포인터를 복사하고 문자열 데이터를 정적으로 할당해야 합니다. 그러지 않으면 위젯 문자열 포인터가 가비지 데이터를 가리켜 예기치 않은 결과를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-269">When this style is not enabled, the widget simply copies the provided string pointer, and the string data must be statically allocated or the widget string pointer will likely end up pointing at garbage data producing unpredictable results.</span></span>

### <a name="passing-gx_string-arguments"></a><span data-ttu-id="b7a34-270">GX_STRING 인수 전달</span><span class="sxs-lookup"><span data-stu-id="b7a34-270">Passing GX_STRING arguments</span></span> 

<span data-ttu-id="b7a34-271">GX_STRING 매개 변수를 허용하는 GUIX API 함수는 항상 **GX_STRING.gx_string_ptr** 필드로 가리키는 문자열의 길이가 **GX_STRING.gx_string_length** 필드의 값과 일치하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-271">The GUIX API functions which accept a GX_STRING parameter always verify that the length of the string pointed to by the **GX_STRING.gx_string_ptr** field match the value of the **GX_STRING.gx_string_length** field.</span></span> <span data-ttu-id="b7a34-272">두 필드가 일치하지 않으면 **GX_INVALID_STRING_LENGTH** 오류가 반환되고, 문자열 할당을 수락하지 않으면서 호출되는 API가 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-272">If the two fields are not consistent, a **GX_INVALID_STRING_LENGTH** error is returned and the API called returns without accepting the string assignment.</span></span>

<span data-ttu-id="b7a34-273">안전 고려 사항의 경우 GUIX 소프트웨어는 내부적으로 \***strlen** _ 또는 _ \*_strcpy_\*\*와 같은 표준 C 문자열 함수를 사용하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-273">For safety considerations the GUIX software never internally uses the standard C string functions such as ***strlen** _ or _*_strcpy_\*\*.</span></span> <span data-ttu-id="b7a34-274">이러한 함수는 문자열 데이터를 동적으로 가져올 때 악의적인 공격(일반적으로 연결된 애플리케이션에서 주로 발생)에 취약한 것으로 알려져 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-274">These functions have been known to be susceptible to malicious attacks when string data is acquired dynamically which is often the case with connected applications.</span></span>

<span data-ttu-id="b7a34-275">GUIX 라이브러리 릴리스는 매개 변수로 (`GX_CONST GX_CHAR *text`)를 수락하는 릴리스 5.6에서 정의된 API 함수 이전에 릴리스됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-275">GUIX library releases prior to release 5.6 defined API functions which accepted (`GX_CONST GX_CHAR *text`) as a parameter.</span></span> <span data-ttu-id="b7a34-276">이전 버전과의 호환성을 위해 계속 지원되는 이러한 함수는 더 이상 사용되지 않으며 (`GX_CONST GX_STRING *string`)을 입력 매개 변수로 수락하는 기본 설정 API 함수로 대체되었습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-276">These functions, while still supported for backwards compatibility, have been obsoleted and replaced by the preferred API functions which accept (`GX_CONST GX_STRING *string`) as an input parameter.</span></span>

<span data-ttu-id="b7a34-277">기본적으로 더 이상 사용되지 않는 텍스트 처리 API를 사용하여 이전에 작성된 모든 애플리케이션을 GUIX 라이브러리에 대한 최신 업데이트로 완전히 빌드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-277">By default, the deprecated text handling API is enabled allowing all previously written applications to build cleanly with the latest updates to the GUIX library.</span></span> <span data-ttu-id="b7a34-278">더 이상 사용되지 않는 텍스트 처리 API를 사용하지 않도록 설정하려면 **GX_DISABLE_DEPRECATED_STRING_API** 를 **_gx_user.h_ *_ 헤더 파일에 추가해야 합니다. 모든 새 애플리케이션은 _* GX_DISABLE_DEPRECATED_STRING_API** 를 정의해야 하며 대체 API 함수만 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-278">To disable the the deprecated text handling API, the definition **GX_DISABLE_DEPRECATED_STRING_API** should be added to the **_gx_user.h_*_ header file. All new applications should define _\* GX_DISABLE_DEPRECATED_STRING_API*\* and should use only the replacement API functions.</span></span> <span data-ttu-id="b7a34-279">GUIX 라이브러리 버전 릴리스 5.6 이상용 GUIX Studio에서 생성된 모든 출력 파일은 대체 API 함수만 활용합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-279">All output files generated by GUIX Studio for GUIX library version release 5.6 or later will utilize only the replacement API functions.</span></span>

<span data-ttu-id="b7a34-280">다음 표에서는 더 이상 사용되지 않고 새로 정의된 대체 API 함수 이름을 나열합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-280">The following table lists the deprecated and newly defined replacement API function names:</span></span>

| <span data-ttu-id="b7a34-281">**더 이상 사용되지 않는 함수 이름**</span><span class="sxs-lookup"><span data-stu-id="b7a34-281">**Deprecated Function Name**</span></span>              | <span data-ttu-id="b7a34-282">**대체 이름**</span><span class="sxs-lookup"><span data-stu-id="b7a34-282">**Replaced With**</span></span>                              |
| ------------------------------------------ | ----------------------------------------------- |
| <span data-ttu-id="b7a34-283">gx_binres_language_table_load</span><span class="sxs-lookup"><span data-stu-id="b7a34-283">gx_binres_language_table_load</span></span>          | <span data-ttu-id="b7a34-284">gx_binres_language_table_load_ext</span><span class="sxs-lookup"><span data-stu-id="b7a34-284">gx_binres_language_table_load_ext</span></span>          |
| <span data-ttu-id="b7a34-285">gx_canvas_rotated_text_draw</span><span class="sxs-lookup"><span data-stu-id="b7a34-285">gx_canvas_rotated_text_draw</span></span>            | <span data-ttu-id="b7a34-286">gx_canvas_rotated_text_draw_ext</span><span class="sxs-lookup"><span data-stu-id="b7a34-286">gx_canvas_rotated_text_draw_ext</span></span>            |
| <span data-ttu-id="b7a34-287">gx_canvas_text_draw</span><span class="sxs-lookup"><span data-stu-id="b7a34-287">gx_canvas_text_draw</span></span>                     | <span data-ttu-id="b7a34-288">gx_canvas_text_draw_ext</span><span class="sxs-lookup"><span data-stu-id="b7a34-288">gx_canvas_text_draw_ext</span></span>                     |
| <span data-ttu-id="b7a34-289">gx_context_string_get</span><span class="sxs-lookup"><span data-stu-id="b7a34-289">gx_context_string_get</span></span>                   | <span data-ttu-id="b7a34-290">gx_context_string_get_ext</span><span class="sxs-lookup"><span data-stu-id="b7a34-290">gx_context_string_get_ext</span></span>                   |
| <span data-ttu-id="b7a34-291">gx_display_language_table_get</span><span class="sxs-lookup"><span data-stu-id="b7a34-291">gx_display_language_table_get</span></span>          | <span data-ttu-id="b7a34-292">gx_display_language_table_get_ext</span><span class="sxs-lookup"><span data-stu-id="b7a34-292">gx_display_language_table_get_ext</span></span>          |
| <span data-ttu-id="b7a34-293">gx_display_language_table_set</span><span class="sxs-lookup"><span data-stu-id="b7a34-293">gx_display_language_table_set</span></span>          | <span data-ttu-id="b7a34-294">gx_display_language_table_set_ext</span><span class="sxs-lookup"><span data-stu-id="b7a34-294">gx_display_language_table_set_ext</span></span>          |
| <span data-ttu-id="b7a34-295">gx_display_string_get</span><span class="sxs-lookup"><span data-stu-id="b7a34-295">gx_display_string_get</span></span>                   | <span data-ttu-id="b7a34-296">gx_display_string_get_ext</span><span class="sxs-lookup"><span data-stu-id="b7a34-296">gx_display_string_get_ext</span></span>                   |
| <span data-ttu-id="b7a34-297">gx_display_string_table_get</span><span class="sxs-lookup"><span data-stu-id="b7a34-297">gx_display_string_table_get</span></span>            | <span data-ttu-id="b7a34-298">gx_display_string_table_get_ext</span><span class="sxs-lookup"><span data-stu-id="b7a34-298">gx_display_string_table_get_ext</span></span>            |
| <span data-ttu-id="b7a34-299">gx_multi_line_text_button_text_set</span><span class="sxs-lookup"><span data-stu-id="b7a34-299">gx_multi_line_text_button_text_set</span></span>   | <span data-ttu-id="b7a34-300">gx_multi_line_text_button_text_set_ext</span><span class="sxs-lookup"><span data-stu-id="b7a34-300">gx_multi_line_text_button_text_set_ext</span></span>   |
| <span data-ttu-id="b7a34-301">gx_multi_line_text_input_char_insert</span><span class="sxs-lookup"><span data-stu-id="b7a34-301">gx_multi_line_text_input_char_insert</span></span> | <span data-ttu-id="b7a34-302">gx_multi_line_text_input_char_insert_ext</span><span class="sxs-lookup"><span data-stu-id="b7a34-302">gx_multi_line_text_input_char_insert_ext</span></span> |
| <span data-ttu-id="b7a34-303">gx_multi_line_text_input_text_set</span><span class="sxs-lookup"><span data-stu-id="b7a34-303">gx_multi_line_text_input_text_set</span></span>    | <span data-ttu-id="b7a34-304">gx_multi_line_text_input_text_set_ext</span><span class="sxs-lookup"><span data-stu-id="b7a34-304">gx_multi_line_text_input_text_set_ext</span></span>    |
| <span data-ttu-id="b7a34-305">gx_multi_line_text_view_text_set</span><span class="sxs-lookup"><span data-stu-id="b7a34-305">gx_multi_line_text_view_text_set</span></span>     | <span data-ttu-id="b7a34-306">gx_multi_line_text_view_text_set_ext</span><span class="sxs-lookup"><span data-stu-id="b7a34-306">gx_multi_line_text_view_text_set_ext</span></span>     |
| <span data-ttu-id="b7a34-307">gx_prompt_text_get</span><span class="sxs-lookup"><span data-stu-id="b7a34-307">gx_prompt_text_get</span></span>                      | <span data-ttu-id="b7a34-308">gx_prompt_text_get_ext</span><span class="sxs-lookup"><span data-stu-id="b7a34-308">gx_prompt_text_get_ext</span></span>                      |
| <span data-ttu-id="b7a34-309">gx_prompt_text_set</span><span class="sxs-lookup"><span data-stu-id="b7a34-309">gx_prompt_text_set</span></span>                      | <span data-ttu-id="b7a34-310">gx_prompt_text_set_ext</span><span class="sxs-lookup"><span data-stu-id="b7a34-310">gx_prompt_text_set_ext</span></span>                      |
| <span data-ttu-id="b7a34-311">gx_single_line_text_input_text_set</span><span class="sxs-lookup"><span data-stu-id="b7a34-311">gx_single_line_text_input_text_set</span></span>   | <span data-ttu-id="b7a34-312">gx_single_line_text_input_text_set_ext</span><span class="sxs-lookup"><span data-stu-id="b7a34-312">gx_single_line_text_input_text_set_ext</span></span>   |
| <span data-ttu-id="b7a34-313">gx_system_string_width_get</span><span class="sxs-lookup"><span data-stu-id="b7a34-313">gx_system_string_width_get</span></span>             | <span data-ttu-id="b7a34-314">gx_system_string_width_get_ext</span><span class="sxs-lookup"><span data-stu-id="b7a34-314">gx_system_string_width_get_ext</span></span>             |
| <span data-ttu-id="b7a34-315">gx_system_version_string_get</span><span class="sxs-lookup"><span data-stu-id="b7a34-315">gx_system_version_string_get</span></span>           | <span data-ttu-id="b7a34-316">gx_system_version_string_get_ext</span><span class="sxs-lookup"><span data-stu-id="b7a34-316">gx_system_version_string_get_ext</span></span>           |
| <span data-ttu-id="b7a34-317">gx_text_button_text_get</span><span class="sxs-lookup"><span data-stu-id="b7a34-317">gx_text_button_text_get</span></span>                | <span data-ttu-id="b7a34-318">gx_text_button_text_get_ext</span><span class="sxs-lookup"><span data-stu-id="b7a34-318">gx_text_button_text_get_ext</span></span>                |
| <span data-ttu-id="b7a34-319">gx_text_button_text_set</span><span class="sxs-lookup"><span data-stu-id="b7a34-319">gx_text_button_text_set</span></span>                | <span data-ttu-id="b7a34-320">gx_text_button_text_set_ext</span><span class="sxs-lookup"><span data-stu-id="b7a34-320">gx_text_button_text_set_ext</span></span>                |
| <span data-ttu-id="b7a34-321">gx_text_scroll_wheel_callback_set</span><span class="sxs-lookup"><span data-stu-id="b7a34-321">gx_text_scroll_wheel_callback_set</span></span>     | <span data-ttu-id="b7a34-322">gx_text_scroll_wheel_callback_set_ext</span><span class="sxs-lookup"><span data-stu-id="b7a34-322">gx_text_scroll_wheel_callback_set_ext</span></span>     |
| <span data-ttu-id="b7a34-323">gx_utility_string_to_alphamap</span><span class="sxs-lookup"><span data-stu-id="b7a34-323">gx_utility_string_to_alphamap</span></span>          | <span data-ttu-id="b7a34-324">gx_utility_string_to_alphamap_ext</span><span class="sxs-lookup"><span data-stu-id="b7a34-324">gx_utility_string_to_alphamap_ext</span></span>          |
| <span data-ttu-id="b7a34-325">gx_widget_string_get</span><span class="sxs-lookup"><span data-stu-id="b7a34-325">gx_widget_string_get</span></span>                    | <span data-ttu-id="b7a34-326">gx_widget_string_get_ext</span><span class="sxs-lookup"><span data-stu-id="b7a34-326">gx_widget_string_get_ext</span></span>                    |
| <span data-ttu-id="b7a34-327">gx_widget_text_blend</span><span class="sxs-lookup"><span data-stu-id="b7a34-327">gx_widget_text_blend</span></span>                    | <span data-ttu-id="b7a34-328">gx_widget_text_blend_ext</span><span class="sxs-lookup"><span data-stu-id="b7a34-328">gx_widget_text_blend_ext</span></span>                    |
| <span data-ttu-id="b7a34-329">gx_widget_text_draw</span><span class="sxs-lookup"><span data-stu-id="b7a34-329">gx_widget_text_draw</span></span>                     | <span data-ttu-id="b7a34-330">gx_widget_text_draw_ext</span><span class="sxs-lookup"><span data-stu-id="b7a34-330">gx_widget_text_draw_ext</span></span>                     |

### <a name="guix-string-table"></a><span data-ttu-id="b7a34-331">GUIX 문자열 테이블</span><span class="sxs-lookup"><span data-stu-id="b7a34-331">GUIX String Table</span></span> 

<span data-ttu-id="b7a34-332">GUIX 문자열 테이블 및 문자열 리소스는 GUIX 디스플레이 인스턴스에 등록됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-332">The GUIX string table and string resources are registered with a GUIX display instance.</span></span>

<span data-ttu-id="b7a34-333">다중 디스플레이 시스템에 표시되는 각 디스플레이에는 고유한 문자열 테이블이 있으며 각 디스플레이는 선택된 자체 언어로 실행할 수 있습니다. 다른 GUIX 리소스 종류(색, 글꼴 및 pixelmap)는 각 디스플레이 색 형식과 색 깊이에만 국한되므로 GUIX 디스플레이 구성 요소를 통해 유지 관리됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-333">Each display in a multi-display system has its own string table, and each display can run in its own selected language.The other GUIX resource types (colors, fonts, and pixelmaps) are also maintained by the GUIX Display component, since these resource types are specific to each display color format and color depth.</span></span>

<span data-ttu-id="b7a34-334">애플리케이션 문자열 테이블을 수동으로 만들 수 있지만, 대부분의 경우 디스플레이 문자열 테이블은 GUIX Studio 애플리케이션에서 프로젝트 리소스 파일의 일부로 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-334">While you can manually create your application string table, most often the display string table is defined by the GUIX Studio application as part of your project resource file.</span></span> <span data-ttu-id="b7a34-335">사용 가능한 언어는 리소스 헤더 파일에도 정의되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-335">The available languages are also defined in the resource header file.</span></span> <span data-ttu-id="b7a34-336">디스플레이 문자열 테이블은 애플리케이션 문자열에 대한 다중 열 포인터 테이블입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-336">The display string table is a multi-column table of pointers to application strings.</span></span> <span data-ttu-id="b7a34-337">문자열 테이블의 각 열은 애플리케이션에서 지원하는 하나의 언어를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-337">Each column of the string table represents one language supported by the application.</span></span>
<span data-ttu-id="b7a34-338">애플리케이션에서 하나의 언어(예: 영어)만 지원하는 경우 문자열 테이블에는 열이 하나만 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-338">If your application supports only one language, for example English, then your string table will have only one column.</span></span> <span data-ttu-id="b7a34-339">그래도 애플리케이션 소프트웨어를 수정하지 않고 언제든지 다른 언어를 추가적으로 지원할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-339">Still, you can add support for additional languages at any time without modifying your application software.</span></span>

<span data-ttu-id="b7a34-340">활성 문자열 테이블은 ***gx_display_string_table_set*** API 함수를 호출하여 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-340">The active string table is assigned by calling the ***gx_display_string_table_set*** API function.</span></span> <span data-ttu-id="b7a34-341">이 함수는 GUIX Studio에서 생성한 시작 코드에 의해 자동으로 호출되지만 애플리케이션에서 직접 호출하여 활성 문자열 테이블을 변경할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-341">This function is called automatically by the GUIX Studio generated startup code, but can also be called directly by the application to change the active string table.</span></span>

<span data-ttu-id="b7a34-342">활성 언어는 ***gx_display_active_language_set*** API 함수를 호출하여 할당됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-342">The active language is assigned by calling the ***gx_display_active_language_set*** API function.</span></span> <span data-ttu-id="b7a34-343">이 함수는 디스플레이 문자열 테이블에서 활성 상태인 열을 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-343">This function determines which column of the display string table is active.</span></span>

<span data-ttu-id="b7a34-344">이 함수가 호출되면 **GX_EVENT_LANGUAGE_CHANGE** 이벤트가 표시되는 모든 GUIX 위젯으로 전송되어 새로 활성화된 문자열 데이터를 표시하도록 업데이트할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-344">When this function is invoked, a **GX_EVENT_LANGUAGE_CHANGE** event is sent to all visible GUIX widgets, allowing them to update to display the newly active string data.</span></span>

<span data-ttu-id="b7a34-345">위젯 및 애플리케이션 소프트웨어는 문자열 ID 값과 ***gx_display_string_get_ext*** 또는 ***gx_widget_string_get_ext*** API 함수를 사용하여 정적으로 정의된 문자열을 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-345">Widgets and application software resolve statically defined strings using string ID values and the ***gx_display_string_get_ext*** or ***gx_widget_string_get_ext*** API functions.</span></span> <span data-ttu-id="b7a34-346">이러한 함수는 지정된 문자열 ID와 연결된 **GX_STRING** 과 현재 활성화된 언어를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-346">These functions return the **GX_STRING** associated with a given string ID and the currently active language.</span></span>

### <a name="bi-directional-text-display"></a><span data-ttu-id="b7a34-347">양방향 텍스트 표시</span><span class="sxs-lookup"><span data-stu-id="b7a34-347">Bi-directional Text Display</span></span> 

<span data-ttu-id="b7a34-348">GUIX는 양방향 텍스트 지원에 대한 두 가지 전략을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-348">GUIX provide two strategies for bi-directional text support.</span></span>

<span data-ttu-id="b7a34-349">한 가지 옵션은 GUIX Studio 애플리케이션 내에서 양방향 텍스트 재정렬을 수행하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-349">One option is to do bidi text reordering within the GUIX Studio application.</span></span> <span data-ttu-id="b7a34-350">이 옵션을 사용하면 GUIX Studio는 디스플레이 순서대로 출력 파일에 양방향 텍스트를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-350">Using this option GUIX Studio is responsible for generating bidi text to the output file in its display order.</span></span> <span data-ttu-id="b7a34-351">이 솔루션은 런타임 성능에 영향을 주지 않으며 GUIX 런타임 라이브러리를 추가하지 않아도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-351">This solution has zero impact on the runtime performance and does not require any additions to the GUIX runtime library.</span></span> <span data-ttu-id="b7a34-352">GUIX Studio에서 displayorder 양방향 텍스트 문자열을 생성하도록 하려면 GUIX Studio 언어 구성 대화 상자에서 **표시 순서로 양방향 텍스트 생성** 확인란을 선택해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-352">To allow GUIX Studio to generate displayorder bidi text strings, you should select the **Generate Bidi Text in Display Order** checkbox in the GUIX Studio language configuration dialog:</span></span>

![언어 구성](./media/guix/user-guide/configure-languages.png)

<span data-ttu-id="b7a34-354">이러한 옵션을 선택하면 생성된 리소스 파일에 표시 순서로 생성된 양방향 문자열이 포함되며 GUIX 런타임 라이브러리 내에 추가 처리가 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-354">With these options selected, the generated resource file will contain Bidi strings generated in display order, and no extra processing is required within the GUIX runtime library.</span></span>

<span data-ttu-id="b7a34-355">두 번째 옵션은 런타임에 양방향 텍스트를 다시 정렬하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-355">The second option is to do bidi text reordering at runtime.</span></span> <span data-ttu-id="b7a34-356">이 옵션은 GUIX Studio 애플리케이션에서 생성되지 않고 동적으로 정의된 양방향 텍스트 문자열을 처리해야 하는 애플리케이션에서 지원됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-356">This option is supported for those applications that must handle bidi text string that are dynamically defined, and not generated by the GUIX Studio application.</span></span> <span data-ttu-id="b7a34-357">이 경우 GUIX 런타임 라이브러리는 각 텍스트 문자열을 그리기 전에 양방향 텍스트를 다시 정렬해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-357">In this case the GUIX runtime library is responsible for reordering the bidi text before drawing each text string.</span></span> <span data-ttu-id="b7a34-358">이 솔루션에는 런타임 성능 및 메모리에 영향을 미칩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-358">This solution has a runtime performance and memory impact.</span></span> <span data-ttu-id="b7a34-359">양방향 텍스트 다시 정렬 프로세스에는 충분한 동적 메모리를 사용할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-359">Sufficient dynamic memory must be available for bidi text reordering process.</span></span> <span data-ttu-id="b7a34-360">이 솔루션을 사용하려면 GUIX 라이브러리를 빌드할 때 조건부 GX_DYNAMIC_BIDI_TEXT_SUPPORT를 정의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-360">This solution requires that the conditional GX_DYNAMIC_BIDI_TEXT_SUPPORT be defined when building the GUIX library.</span></span> <span data-ttu-id="b7a34-361">런타임에 양방향 텍스트 지원을 사용/사용하지 않도록 설정하기 위해 두 개의 API 함수 ***gx_system_bidi_text_enable*** 및 ***gx_system_bidi_text_disable*** 이 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-361">Two API functions ***gx_system_bidi_text_enable*** and ***gx_system_bidi_text_disable*** are provided to enable/disable bidi text support at runtime.</span></span>

<span data-ttu-id="b7a34-362">**GX_DYNAMIC_BIDI_TEXT_SUPPORT** 를 사용하는 작업과 표시 순서대로 양방향 텍스트를 생성하도록 GUIX Studio를 구성하는 작업을 둘 중 하나만 수행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-362">You should not use both **GX_DYNAMIC_BIDI_TEXT_SUPPORT** and configure GUIX Studio to generate Bidi text in display order.</span></span> <span data-ttu-id="b7a34-363">양방향 텍스트 문자열 처리를 위해 둘 중 한 가지 전략을 선택해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-363">You must select one strategy or the other for bidi text string handling.</span></span>

## <a name="memory-usage"></a><span data-ttu-id="b7a34-364">메모리 사용량</span><span class="sxs-lookup"><span data-stu-id="b7a34-364">Memory Usage</span></span> 

<span data-ttu-id="b7a34-365">GUIX는 애플리케이션과 함께 상주합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-365">GUIX resides along with the application program.</span></span> <span data-ttu-id="b7a34-366">그 결과, GUIX의 정적 메모리(또는 고정 메모리) 사용량은 개발 도구(예: 컴파일러, 링커 및 로케이터)에 의해 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-366">As a result, the static memory (or fixed memory) usage of GUIX is determined by the development tools; e.g., the compiler, linker, and locator.</span></span> <span data-ttu-id="b7a34-367">동적 메모리(또는 런타임 메모리) 사용량은 애플리케이션에서 직접 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-367">Dynamic memory (or run-time memory) usage is under direct control of the application.</span></span>

### <a name="static-memory-usage"></a><span data-ttu-id="b7a34-368">정적 메모리 사용량</span><span class="sxs-lookup"><span data-stu-id="b7a34-368">Static Memory Usage</span></span> 

<span data-ttu-id="b7a34-369">대부분의 개발 도구는 애플리케이션 프로그램 이미지를 명령어, 상수, 초기화된 데이터, 초기화되지 않은 데이터, GUIX 스레드 스택이라는 5가지 기본 영역으로 나눕니다.    </span><span class="sxs-lookup"><span data-stu-id="b7a34-369">Most of the development tools divide the application program image into five basic areas: *instruction*, *constant*, *initialized data*, *uninitialized data*, and the *GUIX thread stack*.</span></span> <span data-ttu-id="b7a34-370">그림 X(X페이지)에서는 이러한 메모리 영역의 예를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-370">Figure X on page X shows an example of these memory areas.</span></span>

<span data-ttu-id="b7a34-371">이것은 단지 예제일 뿐이라는 것을 이해해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-371">It is important to understand that this only an example.</span></span> <span data-ttu-id="b7a34-372">실제 정적 메모리 레이아웃은 프로세서, 개발 도구, 기본 하드웨어 및 애플리케이션 자체에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-372">The actual static memory layout is specific to the processor, development tools, underlying hardware, and the application itself.</span></span>

<span data-ttu-id="b7a34-373">명령어 영역에는 프로그램의 모든 프로세서 명령이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-373">The instruction area contains all of the program’s processor instructions.</span></span> <span data-ttu-id="b7a34-374">이 영역은 종종 ROM에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-374">This area is often located in ROM.</span></span>

<span data-ttu-id="b7a34-375">상수 영역에는 GUIX에서 기본 설정과 모든 애플리케이션 리소스(이미지, 문자열, 글꼴 및 색)를 포함하는 다양한 컴파일된 상수가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-375">The constant area contains various compiled constants, which in GUIX contains default settings and all application resources (images, strings, fonts, and colors).</span></span> <span data-ttu-id="b7a34-376">또한 이 영역에는 초기화된 데이터 영역의 "초기 복사본"이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-376">In addition, this area contains the “initial copy” of the initialized data area.</span></span> <span data-ttu-id="b7a34-377">컴파일러의 초기화 과정에서 상수 영역의 이 부분은 RAM에 초기화된 전역 데이터를 설정하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-377">During the compiler’s initialization process, this portion of the constant area is used to set up the global initialized data in RAM.</span></span> <span data-ttu-id="b7a34-378">상수 영역은 일반적으로 가장 크고 명령 영역을 따르며, ROM에 있는 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-378">The constant area is typically the largest and usually follows the instruction area and is often located in ROM.</span></span>

<span data-ttu-id="b7a34-379">GUIX pixelmap 및 글꼴에는 일반적으로 많은 양의 상수 데이터 스토리지가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-379">GUIX pixelmaps and fonts typically require large amounts of constant data storage.</span></span> <span data-ttu-id="b7a34-380">이러한 대량 정적 데이터 영역은 일반적으로 ROM 또는 FLASH에 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-380">These large static data areas are normally kept in ROM or FLASH.</span></span>

<span data-ttu-id="b7a34-381">GUIX 스레드 스택은 다음과 같이 ***gx_system .h*** 파일에서 초기화되지 않은 데이터 영역 내에 전역 변수로 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-381">The GUIX thread stack is defined within the uninitialized data area (as a global variable) in ***gx_system.h*** file as follows:</span></span>

```C
_gx_system_thread_stack[GX_THREAD_STACK_SIZE];
```

<span data-ttu-id="b7a34-382">**GX_THREAD_STACK_SIZE** 는 **_gx_port.h_** 에 정의되어 있지만 ***gx_user.h*** 헤더 파일이나 프로젝트 옵션 또는 명령줄 매개 변수를 통해 이 기호를 정의하여 애플리케이션에서 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-382">**GX_THREAD_STACK_SIZE** is defined in **_gx_port.h_**, but may be overridden by the application by defining this symbol in the ***gx_user.h*** header file or via project options or command line parameters.</span></span> <span data-ttu-id="b7a34-383">스택 크기는 최악의 이벤트 처리 및 중첩된 그리기 호출을 처리할 수 있을 만큼 커야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-383">The stack size must be large enough to handle the worst case event handling and nested drawing calls.</span></span>

### <a name="dynamic-memory-usage"></a><span data-ttu-id="b7a34-384">동적 메모리 사용량</span><span class="sxs-lookup"><span data-stu-id="b7a34-384">Dynamic Memory Usage</span></span> 

<span data-ttu-id="b7a34-385">앞서 언급했듯이 동적 메모리 사용량은 애플리케이션에서 직접 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-385">As mentioned before, dynamic memory usage is under direct control of the application.</span></span> <span data-ttu-id="b7a34-386">캔버스 등과 연결된 제어 블록 및 메모리는 대상의 메모리 공간 어디에나 배치할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-386">Control blocks and memory associated with canvases, etc. can be placed anywhere in the target’s memory space.</span></span> <span data-ttu-id="b7a34-387">이 기능은 런타임에 다양한 형식의 실제 메모리를 쉽게 활용할 수 있기 때문에 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-387">This is an important feature because it facilitates easy utilization of different types of physical memory – at run-time.</span></span>

<span data-ttu-id="b7a34-388">예를 들어 대상 하드웨어 환경에 빠른 메모리와 느린 메모리가 모두 있다고 가정하겠습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-388">For example, suppose a target hardware environment has both fast memory and slow memory.</span></span> <span data-ttu-id="b7a34-389">애플리케이션에 그리기를 위한 추가 성능이 필요한 경우에는 최상의 성능을 위해 캔버스 메모리를 고속 메모리 영역에 명시적으로 배치할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-389">If the application needs extra performance for drawing, the canvas memory can be explicitly placed in the high-speed memory area for best performance.</span></span>

<span data-ttu-id="b7a34-390">몇 가지 선택적 GUIX 서비스 및 기능에는 일반적으로 힙이라고 하는 런타임 동적 메모리 할당 메커니즘이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-390">Several optional GUIX services and features require a runtime dynamic memory allocation mechanism, commonly referred to as a heap.</span></span> <span data-ttu-id="b7a34-391">이러한 서비스와 기능은 모두 선택적이며 많은 GUIX 애플리케이션은 힙을 사용하지 않으며 런타임 메모리 할당 메커니즘을 정의하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-391">These services and features are completely optional, and many GUIX applications do not use any heap and do not define a runtime memory allocation mechanism.</span></span>

<span data-ttu-id="b7a34-392">런타임 메모리를 할당해야 하는 서비스를 사용하는 경우 메모리를 동적으로 할당하거나 해제해야 하는 경우 GUIX에서 호출하는 함수를 설치해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-392">If you will be using services which require runtime memory allocation, you must install functions which GUIX will call when memory must be dynamically allocated or freed.</span></span> <span data-ttu-id="b7a34-393">이러한 함수를 원하는 대로 구현할 수 있습니다. 이 경우에도 동적 메모리 풀의 위치는 애플리케이션을 통해 제어됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-393">You can implement these functions as you prefer, so that even in this case the location of the dynamic memory pool is under application control.</span></span> <span data-ttu-id="b7a34-394">동적 메모리 할당에 대한 지원을 설치하기 위해 애플리케이션은 프로그램 시작 중에 ***GX_SYSTEM_MEMORY_ALLOCATOR_SET*** API 서비스를 호출하여 메모리 할당 및 메모리 사용 가능 서비스를 정의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-394">To install support for dynamic memory allocation, the application should invoke the API service ***gx_system_memory_allocator_set*** during program startup to define your memory allocation and memory free services.</span></span> <span data-ttu-id="b7a34-395">전체 예제는 이 API의 설명서를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="b7a34-395">Refer to the documentation of this API for a complete example.</span></span>

<span data-ttu-id="b7a34-396">런타임 메모리 할당 및 할당 취소 서비스를 필요로 하는 GUIX 서비스에는 다음이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-396">GUIX services which require a runtime memory allocation and de-allocation service include:</span></span>

  - <span data-ttu-id="b7a34-397">외부 스토리지의 이진 리소스를 GUIX 런타임 환경으로 로드</span><span class="sxs-lookup"><span data-stu-id="b7a34-397">Loading binary resources from external storage into the GUIX runtime environment.</span></span>

  - <span data-ttu-id="b7a34-398">소프트웨어 런타임 jpeg 이미지 디코더</span><span class="sxs-lookup"><span data-stu-id="b7a34-398">The software runtime jpeg image decoder.</span></span>

  - <span data-ttu-id="b7a34-399">소프트웨어 런타임 png 이미지 디코더</span><span class="sxs-lookup"><span data-stu-id="b7a34-399">The software runtime png image decoder.</span></span>

  - <span data-ttu-id="b7a34-400">GX_STYLE_TEXT_COPY에서 텍스트 위젯 사용</span><span class="sxs-lookup"><span data-stu-id="b7a34-400">Using text widgets with GX_STYLE_TEXT_COPY.</span></span>

  - <span data-ttu-id="b7a34-401">런타임 pixemap 크기 조정 및 순환 유틸리티 함수</span><span class="sxs-lookup"><span data-stu-id="b7a34-401">Runtime pixemap resize and rotation utility functions.</span></span>
  - <span data-ttu-id="b7a34-402">런타임 화면 및 위젯 제어 블록 할당</span><span class="sxs-lookup"><span data-stu-id="b7a34-402">Runtime screen and widget control block allocation.</span></span>

<span data-ttu-id="b7a34-403">더 작은 애플리케이션의 경우 GUIX 리소스는 일반적으로 애플리케이션 이미지의 일부로 컴파일되고 정적으로 링크되며, 이진 리소스 설치는 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-403">For smaller applications, GUIX resources are usually compiled and statically linked as part of the application image, and binary resource installation is not required.</span></span> <span data-ttu-id="b7a34-404">이진 리소스를 사용하면 애플리케이션에서 런타임에 플래시 드라이브 또는 URL과 같은 일부 스토리지 위치에서 로드된 리소스(글꼴, 이미지, 언어)를 설치할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-404">Binary resources allow an application to install resources (fonts, images, languages) at runtime loaded from some storage location, such as a flash drive or a URL.</span></span>

<span data-ttu-id="b7a34-405">런타임 jpeg 및 png 디코더는 선택적 구성 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-405">The runtime jpeg and png decoders are optional components.</span></span> <span data-ttu-id="b7a34-406">대부분의 GUIX 애플리케이션에서는 GUIX Studio 도구를 사용하여 필요한 모든 이미지 파일을 미리 디코딩하고 독점 GUIX Pixemap 데이터 리소스로 저장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-406">Most GUIX applications allow the GUIX Studio tool to pre-decode all required image files, and store them as proprietary GUIX Pixemap data resources.</span></span> <span data-ttu-id="b7a34-407">이러한 서비스는 jpeg 및/또는 PNG 이미지를 pixelmap 형식으로 변환해야 하는 애플리케이션이 완전하게 기능하기 위해 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-407">These services are provided for completeness for those applications that require runtime conversion of jpeg and/or PNG images to pixelmap format.</span></span>

<span data-ttu-id="b7a34-408">**GX_STYLE_TEXT_COPY** 를 사용하여 특정 위젯이 동적으로 할당된 텍스트의 전용 복사본을 유지하도록 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-408">**GX_STYLE_TEXT_COPY** allows the user to specify that a particular widget or widgets will keep it’s own private copy of dynamically assigned text.</span></span> <span data-ttu-id="b7a34-409">이 옵션을 사용하려면 사용 전에 메모리 할당 메커니즘을 설치해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-409">Using this option requires that the memory allocation mechanism be installed prior to use.</span></span> <span data-ttu-id="b7a34-410">텍스트 형식 위젯을 만들 때 이 스타일 플래그를 제공하지 **<span class="underline">않으면</span>** 애플리케이션에서 동적으로 생성되고 할당된 모든 텍스트 문자열에 대해 정적 스토리지 영역을 할당해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-410">If this style flag is **<span class="underline">not</span>** provided when a text type widget is created, the application must allocate static storage areas for all dynamically created and assigned text strings.</span></span> <span data-ttu-id="b7a34-411">이 경우 자동 변수를 사용하여 런타임에 생성된 문자열 데이터를 저장하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-411">Automatic variables should not be used in this case to hold runtime generated string data.</span></span> <span data-ttu-id="b7a34-412">**GX_STYLE_TEXT_COPY** 스타일이 사용하도록 설정되는 경우 각 위젯은 할당된 텍스트의 고유한 복사본을 만들기 때문에 자동 변수를 사용하여 GUIX 위젯에 할당된 문자열 데이터를 저장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-412">If the **GX_STYLE_TEXT_COPY** style is enabled, automatic variables may be used to hold string data assigned to GUIX widgets, since each widget will create its own copy of the assigned text.</span></span>

<span data-ttu-id="b7a34-413">Pixelmap 크기 조정 및 순환 유틸리티 함수는 변환된 결과 Pixelmap을 애플리케이션에서 사용할 수 있는 새로운 Pixelmap으로 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-413">Pixelmap resize and rotation utility functions return the resulting translated pixelmap as a new pixelmap available to the application.</span></span>
<span data-ttu-id="b7a34-414">이러한 서비스를 사용하는 경우 이러한 런타임에서 생성된 pixelmap 데이터 블록을 보유할 수 있는 충분한 동적 메모리가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-414">Sufficient dynamic memory must be available to hold these runtime generated pixelmap data blocks if these services are used.</span></span>

<span data-ttu-id="b7a34-415">마지막으로 GUIX 스크린과 위젯에 대한 제어 블록은 정적 또는 동적으로 할당될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-415">Finally, the control blocks for the GUIX screens and widgets can be statically or dynamically allocated.</span></span> <span data-ttu-id="b7a34-416">작은 애플리케이션의 경우 프로그램 시작 시 모든 애플리케이션 화면을 만들고 정적으로 할당된 제어 블록을 사용하는 것이 일반적입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-416">For smaller applications, it is common to create all application screens during program startup and use statically allocated control blocks.</span></span> <span data-ttu-id="b7a34-417">더 큰 애플리케이션의 경우에는 필요에 따라 화면 및 자식 위젯 컨트롤을 동적으로 만드는 것이 일반적입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-417">For large applications, it is common to create the screen and child widget controls dynamically on an as-needed bases.</span></span> <span data-ttu-id="b7a34-418">동적으로 할당된 제어 블록은 GUIX Studio 속성 보기에서 **런타임 할당** 확인란을 선택하거나 표준 API를 통해 위젯을 만들 때 스타일 플래그 **GX_STYLE_DYNAMICALLY_ALLOCATED** 를 전달하여 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-418">Dynamically allocated control blocks are specified by selecting the **Runtime Allocate** checkbox in the GUIX Studio properties view, or by passing in the style flag **GX_STYLE_DYNAMICALLY_ALLOCATED** when creating a widget via the standard API.</span></span> <span data-ttu-id="b7a34-419">동적으로 할당된 위젯 제어 블록을 사용하려면 메모리 할당 및 할당 취소 서비스가 위에서 설명한 대로 정의되어 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-419">Using dynamically allocated widget control blocks requires that memory allocation and deallocation services are defined as described above.</span></span>

## <a name="guix-components"></a><span data-ttu-id="b7a34-420">GUIX 구성 요소</span><span class="sxs-lookup"><span data-stu-id="b7a34-420">GUIX Components</span></span> 

<span data-ttu-id="b7a34-421">GUIX API는 GUIX 시스템의 기본 구성 요소에 해당하는 몇 가지 기본 그룹으로 나뉘어 구성되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-421">The GUIX APIs are divided and organized into several basic groups which correspond to fundamental components of the GUIX system.</span></span> <span data-ttu-id="b7a34-422">기본 구성 요소는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-422">The fundamental components include:</span></span>

| <span data-ttu-id="b7a34-423">구성 요소</span><span class="sxs-lookup"><span data-stu-id="b7a34-423">Components</span></span>  | <span data-ttu-id="b7a34-424">Description</span><span class="sxs-lookup"><span data-stu-id="b7a34-424">Description</span></span>  |
| ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| <span data-ttu-id="b7a34-425">GX_SYSTEM</span><span class="sxs-lookup"><span data-stu-id="b7a34-425">GX_SYSTEM</span></span>  | <span data-ttu-id="b7a34-426">초기화, 이벤트, 타이머, 문자열 테이블 및 표시되는 위젯 계층 구조 관리를 담당하는 GUIX 시스템 구성 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-426">The GUIX system component, responsible for initialization, events, timers, string tables, and visible widget hierarchy management.</span></span>                                                                                                                                                                                                                                                                      |
| <span data-ttu-id="b7a34-427">GX_CANVAS</span><span class="sxs-lookup"><span data-stu-id="b7a34-427">GX_CANVAS</span></span>  | <span data-ttu-id="b7a34-428">그리기 영역입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-428">A drawing area.</span></span> <span data-ttu-id="b7a34-429">캔버스는 하드웨어 프레임 버퍼의 씬 추상화일 수도 있고 순수한 메모리 캔버스일 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-429">A Canvas can be a thin abstraction of the hardware frame buffer, or it might also be a pure memory canvas.</span></span> <span data-ttu-id="b7a34-430">캔버스 형식은 gx_canvas_create API 함수에 전달된 매개 변수에 의해 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-430">The canvas type is determined by parameters passed to the gx_canvas_create API function.</span></span>                                                                                                                                                                                   |
| <span data-ttu-id="b7a34-431">GX_CONTEXT</span><span class="sxs-lookup"><span data-stu-id="b7a34-431">GX_CONTEXT</span></span> | <span data-ttu-id="b7a34-432">그리기 컨텍스트 구성 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-432">The drawing context component.</span></span> <span data-ttu-id="b7a34-433">그리기 컨텍스트는 현재 그리기 작업의 화면, 캔버스, 브러시 및 클리핑 영역에 대한 정보를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-433">The drawing context contains information about the screen, canvas, and brush, and clipping area for the current drawing operations.</span></span>                                                                                                                                                                                                                                      |
| <span data-ttu-id="b7a34-434">GX_DISPLAY</span><span class="sxs-lookup"><span data-stu-id="b7a34-434">GX_DISPLAY</span></span> | <span data-ttu-id="b7a34-435">애플리케이션 및 GUIX 위젯이 캔버스에서 그리기를 수행할 수 있도록 하는 API 및 드라이버 수준 구현을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-435">Provides the APIs and driver-level implementations to allow your application and the GUIX widgets to perform drawing on a canvas.</span></span> <span data-ttu-id="b7a34-436">GX_DISPLAY는 캔버스의 필수 색 형식을 사용하여 각 캔버스에 그래픽을 올바르게 렌더링하도록 구현됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-436">GX_DISPLAY is implemented to correctly render graphics on each canvas using that canvas’ required color format.</span></span> <span data-ttu-id="b7a34-437">GX_DISPLAY 구성 요소는 각 디스플레이에 연결된 캔버스에 대한 위젯 그리기에서 사용할 수 있는 리소스(색, 글꼴 및 pixelmap)도 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-437">The GX_DISPLAY component also manages the resources (colors, fonts, and pixelmaps) available to widgets drawing to canvases linked to each display.</span></span> |
| <span data-ttu-id="b7a34-438">GX_WIDGET</span><span class="sxs-lookup"><span data-stu-id="b7a34-438">GX_WIDGET</span></span>  | <span data-ttu-id="b7a34-439">표시되는 기본 위젯 개체 및 관련된 API입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-439">The basic visible widget object and associated APIs.</span></span> <span data-ttu-id="b7a34-440">모든 GUIX 위젯 형식은 기본 GX_WIDGET 형식을 기준으로 하거나 이러한 형식에서 파생됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-440">All GUIX widget types are based on or derived from the basic GX_WIDGET type.</span></span>                                                                                                                                                                                                                                                                      |
| <span data-ttu-id="b7a34-441">GX_UTILITY</span><span class="sxs-lookup"><span data-stu-id="b7a34-441">GX_UTILITY</span></span> | <span data-ttu-id="b7a34-442">사각형 작업을 위한 유틸리티 함수, 문자열 변환 함수 및 ANSI가 아닌 수학적 함수가 이 그룹에 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-442">Utility functions for working with rectangles, functions for string conversion, and non-ANSI mathematical functions are included in this group.</span></span>                                                                                                                                                                                                                                                         |

<span data-ttu-id="b7a34-443">이러한 기본 구성 요소 외에도 GUIX에는 라이브러리에 제공되는 각 위젯 형식에 고유한 API가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-443">In addition to these basic components, GUIX includes APIs unique to each type of widget provided in the library.</span></span> <span data-ttu-id="b7a34-444">이러한 API는 이 사용자 가이드의 4장 "GUIX 서비스 설명"에 설명되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-444">These APIs are described in Chapter 4 of this User Guide, “Description of GUIX Services”.</span></span>

## <a name="guix-system-component"></a><span data-ttu-id="b7a34-445">GUIX 시스템 구성 요소</span><span class="sxs-lookup"><span data-stu-id="b7a34-445">GUIX System Component</span></span>

<span data-ttu-id="b7a34-446">GUIX 시스템 구성 요소는 UI 애플리케이션에 전역적인 여러 서비스를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-446">The GUIX system component provides several services that are global to the UI application.</span></span> <span data-ttu-id="b7a34-447">이러한 서비스에는 *초기화, 이벤트 관리, 디스플레이 관리, 리소스 관리, 타이머 관리* 및 *위젯 관리* 가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-447">These services include: *initialization, event management, display management, resource management, timer management,* and *widget management*.</span></span> <span data-ttu-id="b7a34-448">각 서비스는 애플리케이션을 구성하는 데 필수적이며, 이러한 서비스에 대한 자세한 내용은 다음 하위 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="b7a34-448">Each service is essential to the organization of your application program, and these services are described in more detail in the following sub-sections.</span></span>

### <a name="initialization"></a><span data-ttu-id="b7a34-449">초기화</span><span class="sxs-lookup"><span data-stu-id="b7a34-449">Initialization</span></span> 

<span data-ttu-id="b7a34-450">GUIX 초기화는 ThreadX ***tx_application_define*** 루틴(초기화 컨텍스트) 또는 애플리케이션 스레드에서 애플리케이션에 의해 호출될 수 있는 서비스 ***gx_system_initialize*** 를 호출하는 애플리케이션에서 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-450">GUIX initialization is accomplished by the application calling the service ***gx_system_initialize***, which may be called by the application from the ThreadX ***tx_application_define*** routine (initialization context) or from application threads.</span></span> <span data-ttu-id="b7a34-451">***gx_system_initialize*** 함수는 모든 전역 GUIX 데이터 구조를 초기화하고 GUIX 시스템 뮤텍스, 이벤트 큐, 타이머 및 스레드를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-451">The ***gx_system_initialize*** function initializes all global GUIX data structures and creates the GUIX system mutex, event queue, timer, and thread.</span></span> <span data-ttu-id="b7a34-452">***gx_system_initialize*** 가 반환되면 애플리케이션은 GUIX를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-452">Once ***gx_system_initialize*** returns, the application can use GUIX.</span></span>

### <a name="thread-processing"></a><span data-ttu-id="b7a34-453">스레드 처리</span><span class="sxs-lookup"><span data-stu-id="b7a34-453">Thread Processing</span></span> 

<span data-ttu-id="b7a34-454">초기화 중에 생성된 내부 GUIX 스레드는 GUIX에서 대부분의 처리를 담당합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-454">The internal GUIX thread – created during initialization – is responsible for most of the processing in GUIX.</span></span> <span data-ttu-id="b7a34-455">이 스레드의 처리는 먼저 기본 디스플레이 드라이버에 필요한 추가 초기화를 완료합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-455">The processing in this thread first completes any additional initialization required by the underlying display driver.</span></span> <span data-ttu-id="b7a34-456">이 작업이 완료되면 GUIX 스레드는 먼저 GUIX 이벤트 큐에 있는 모든 이벤트를 처리한 후 필요한 경우 화면을 새로 고치는 루프를 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-456">Once this is complete, the GUIX thread enters a loop which first processes all events present in the GUIX event queue and then refreshes the screen if required.</span></span> <span data-ttu-id="b7a34-457">화면 새로 고침은 표시되며, 더티로 표시된(다시 그려야 함) 내용에 따라 필요한 GUIX 그리기 함수를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-457">The screen refresh executes the necessary GUIX drawing functions, based on what is visible and has been marked as dirty meaning it needs to be redrawn.</span></span> <span data-ttu-id="b7a34-458">디스플레이에 이벤트가 없고 새로 고칠 항목이 없으면 GUIX 스레드는 일시 중단되고 다음 GUIX 이벤트가 도달할 때까지 대기합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-458">When there are no events and nothing left to refresh on the display, the GUIX thread will suspend, waiting for the next GUIX event to arrive.</span></span>

### <a name="rtos-binding"></a><span data-ttu-id="b7a34-459">RTOS 바인딩</span><span class="sxs-lookup"><span data-stu-id="b7a34-459">RTOS Binding</span></span> 

<span data-ttu-id="b7a34-460">GUIX 시스템 구성 요소는 기본적으로 스레드 서비스, 이벤트 큐 서비스 및 타이머 서비스와 같은 서비스에 대해 ThreadX 실시간 운영 체제를 사용하도록 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-460">The GUIX system component is by default configured to utilize the ThreadX real time operating system for services such as thread services, event queue services, and timer services.</span></span> <span data-ttu-id="b7a34-461">전처리기 지시문 GX_DISABLE_THREADX_BINDING을 사용하고 GUIX 라이브러리를 다시 빌드하여 GUIX를 다른 운영 체제로 쉽게 이식할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-461">GUIX can easily be ported to other operating systems by using the preprocessor directive GX_DISABLE_THREADX_BINDING and re-building the GUIX library.</span></span> <span data-ttu-id="b7a34-462">그러면 GUIX 소스 코드에서 ThreadX 종속성이 제거되고 애플리케이션 개발자가 대상 시스템에서 제공하는 RTOS를 사용하여 필요한 운영 체제 서비스를 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-462">This removes the ThreadX dependencies from the GUIX source code, and allows the application developer to implement the required operating system services using whatever RTOS is provided by the target system.</span></span> <span data-ttu-id="b7a34-463">[부록 F - GUIX RTOS 바인딩 서비스](appendix-f.md)는 Threadx 운영 체제 이외의 운영 체제에 GUIX를 이식하도록 구현해야 하는 서비스를 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-463">[Appendix F - GUIX RTOS Binding Services](appendix-f.md) describes the services that need to be implemented to port GUIX to an operating system other than the ThreadX operating system.</span></span>

### <a name="multithread-safety"></a><span data-ttu-id="b7a34-464">다중 스레드 보안</span><span class="sxs-lookup"><span data-stu-id="b7a34-464">Multithread Safety</span></span> 

<span data-ttu-id="b7a34-465">GUIX API는 다른 애플리케이션 스레드뿐만 아니라 GUIX 스레드 컨텍스트에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-465">The GUIX API is available from the GUIX thread context as well as other application threads.</span></span> <span data-ttu-id="b7a34-466">애플리케이션 스레드는 공유 변수에 액세스하고 GUIX API 함수를 사용하여 이벤트를 보내고 받는 방법으로 GUIX 스레드와 상호 작용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-466">Application threads can interact with the GUIX thread by sending and receiving events, by access to shared variables, and through use of the GUIX API functions.</span></span> <span data-ttu-id="b7a34-467">GUIX는 다중 스레드 리소스 보호를 위해 내부 ThreadX 뮤텍스를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-467">GUIX uses an internal ThreadX mutex for multi-thread resource protection.</span></span> <span data-ttu-id="b7a34-468">또한 GUIX는 화면 새로 고침 작업이 시작된 후 표시되는 위젯의 내부 구조가 수정되지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-468">In addition, GUIX prevents the internal structure of visible widgets from being modified once a screen refresh operation has begun.</span></span> <span data-ttu-id="b7a34-469">그리기 작업이 진행 중인 동안 표시되는 개체의 트리를 수정하는 API가 차단되고, 화면 새로 고침이 완료되면 해제됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-469">APIs which would modify the tree of visible objects are blocked while drawing operations are in progress, and released once the screen refresh is complete.</span></span>

### <a name="system-timers"></a><span data-ttu-id="b7a34-470">시스템 타이머</span><span class="sxs-lookup"><span data-stu-id="b7a34-470">System Timers</span></span> 

<span data-ttu-id="b7a34-471">GUIX는 GUIX 창에 표시되는 데이터의 주기적인 업데이트에 자주 사용되는 주기적인 타이머를 애플리케이션에 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-471">GUIX provides the application with periodic timers, which are often used for periodic update of data displayed in GUIX windows.</span></span> <span data-ttu-id="b7a34-472">이 작업은 GUIX 시스템 수준 효과(예: 화면 페이드 인/페이드 아웃)를 수행하는 데에도 사용되는 ThreadX 정기 타이머를 통해 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-472">This is accomplished via a ThreadX periodic timer, which is also used to perform GUIX system-level effects like screen fade in/out, etc.</span></span>

<span data-ttu-id="b7a34-473">애플리케이션은 타이머를 만들고 GUIX에서 내부적으로 사용되는 것과 동일한 타이머 기능을 활용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-473">The application can create timers and utilize the same timer facility that is used internally by GUIX.</span></span> <span data-ttu-id="b7a34-474">물론, 필요한 경우 애플리케이션은 ThreadX 타이머를 직접 만들고 사용할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-474">Of course the application can also directly create and use ThreadX timers if required.</span></span> <span data-ttu-id="b7a34-475">GUIX 타이머의 장점은 사용하기 쉬우며 GUIX 이벤트 기반 처리 시스템 내에서 작동 하도록 미리 구성되어 있다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-475">The advantage of the GUIX timers is that they are very easy to use and are pre-configured to work within the GUIX event-driven processing system.</span></span>

<span data-ttu-id="b7a34-476">GUIX 타이머를 만들고 시작하려면 애플리케이션이 ***gx_system_timer_start*** 함수를 호출해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-476">To create and start a GUIX timer, the application should invoke the function ***gx_system_timer_start***.</span></span> <span data-ttu-id="b7a34-477">이 함수에 대한 매개 변수에는 호출 위젯에 대한 포인터, 타이머 ID(하나의 위젯이 여러 타이머를 시작하도록 허용), 초기 및 다시 예약 시간 제한 값이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-477">The parameters to this function include a pointer to the calling widget, the timer id (allowing one widget to start many timers), and the initial and reschedule timeout values.</span></span> <span data-ttu-id="b7a34-478">다시 예약 시간 제한 값이 0이면 타이머가 한 번만 실행되며, 일단 만료되고 나면 활성 타이머 목록에서 자동으로 삭제됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-478">If the reschedule timeout value is 0, the timer will only run one time and will delete itself from the active timer list once it expires.</span></span>

<span data-ttu-id="b7a34-479">시작되면 GUIX 타이머는 타이머 다시 예약 값에 따라 한 번 또는 주기적으로 타이머 소유자에게 GX_EVENT_TIMEOUT 이벤트를 전송합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-479">Once started, the GUIX timer will send GX_EVENT_TIMEOUT events to the timer owner, either once or periodically depending on the timer reschedule value.</span></span> <span data-ttu-id="b7a34-480">API 함수 ***GX_SYSTEM_TIMER_STOP*** 을 호출하여 GUIX 타이머를 중지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-480">A GUIX timer can be stopped by calling the API function ***gx_system_timer_stop***.</span></span>

### <a name="pen-speed-configuration"></a><span data-ttu-id="b7a34-481">펜 속도 구성</span><span class="sxs-lookup"><span data-stu-id="b7a34-481">Pen Speed Configuration</span></span> 

<span data-ttu-id="b7a34-482">GUIX 시스템 구성 요소는 펜 속도 추적과 관련된 구성 정보를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-482">The GUIX system component holds configuration information related to pen speed tracking.</span></span> <span data-ttu-id="b7a34-483">GUIX는 터치 입력 드라이버(있는 경우)에서 생성되는 PEN_DOWN 이벤트의 속도와 거리에 따라 **GX_EVENT_VERTICAL_FLICK** 및 **GX_EVENT_HORIZONTAL_FLICK** 이벤트를 내부적으로 생성했습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-483">GUIX internally generated **GX_EVENT_VERTICAL_FLICK** and **GX_EVENT_HORIZONTAL_FLICK** events based on the speed and distance of PEN_DOWN events generated by the touch input driver, if any.</span></span> <span data-ttu-id="b7a34-484">애플리케이션은 **_gx_system_pen_configure_** API 함수를 사용하여 내부적으로 생성된 이러한 이벤트를 트리거하는 데 필요한 최소 거리와 속도를 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-484">The application can configure the minimum distance and speed required to trigger these internally generated events using the **_gx_system_pen_configure_** API function.</span></span>

### <a name="screen-stack"></a><span data-ttu-id="b7a34-485">화면 스택</span><span class="sxs-lookup"><span data-stu-id="b7a34-485">Screen Stack</span></span> 

<span data-ttu-id="b7a34-486">GUIX 시스템 구성 요소는 GUIX 화면 스택과 관련된 서비스를 제공합니다. 이 스택은 애플리케이션에서 런타임에 화면을 푸시, 팝업 및 검색할 수 있는 가상 위젯 스택을 지원하는 선택적 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-486">The GUIX system component provides services related to the GUIX screen stack, which is an optional functionality supporting a virtual widget stack onto which screens can be pushed, popped, and retrieved at runtime by the application.</span></span> <span data-ttu-id="b7a34-487">화면 스택은 사용자가 메뉴 시스템에서 다양한 상태에 도달할 수 있는 경로가 달라질 수 있는 복잡한 메뉴 시스템을 관리하는 데 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-487">The screen stack is useful for managing complex menu systems, wherein the route by which the user may arrive at various states in the menu system is varied.</span></span> <span data-ttu-id="b7a34-488">메뉴 시스템에서 이전 상태로 돌아가는 작업은 먼저 이전 화면 상태를 푸시한 다음, 새 화면을 표시하고 현재 화면을 닫을 때 새 화면이 화면 스택에서 이전 상태를 팝업하도록 허용하여 쉽게 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-488">Returning to the previous state in the menu system can be easily done by first pushing the previous screen state, then displaying the new screen, and allowing the new screen to pop the previous state from the screen stack when the current screen is dismissed.</span></span>

### <a name="clipboard-maintenance"></a><span data-ttu-id="b7a34-489">클립보드 유지 관리</span><span class="sxs-lookup"><span data-stu-id="b7a34-489">Clipboard Maintenance</span></span> 

<span data-ttu-id="b7a34-490">GUIX는 런타임 실행 동안 텍스트를 복사하고 붙여 넣기 위한 클립보드를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-490">GUIX supports a clipboard for copying and pasting text during runtime execution.</span></span> <span data-ttu-id="b7a34-491">이 지원은 GUIX 시스템 구성 요소에서 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-491">This support is provided by the GUIX System component.</span></span>

### <a name="dirty-list-maintenance"></a><span data-ttu-id="b7a34-492">더티 목록 유지 관리</span><span class="sxs-lookup"><span data-stu-id="b7a34-492">Dirty List Maintenance</span></span> 

<span data-ttu-id="b7a34-493">GUIX는 상태가 변경되거나 새로 표시되기 때문에 다시 그려야 하는 더티 위젯의 목록을 유지 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-493">GUIX maintains a list of dirty widgets, meaning widgets that are visible and need to be redrawn due to status changes or being made newly visible.</span></span> <span data-ttu-id="b7a34-494">이 더티 목록은 각 UI가 변경될 때마다 캔버스를 새로 고치지 않고, GUIX에서 한번의 캔버스 새로 고침 작업을 수행하여 모든 현재 변경 내용을 UI 상태에 반영하도록 함으로써 그리기 성능을 향상시킵니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-494">This dirty list improves drawing performance by allowing GUIX to do one canvas refresh operation to reflect all current changes to the UI status, rather than doing a canvas refresh as each UI change is made.</span></span>
<span data-ttu-id="b7a34-495">이 더티 목록은 GUIX 시스템 구성 요소에서 유지 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-495">This dirty list is also maintained by the GUIX system component.</span></span>

### <a name="animation-control-block-pool"></a><span data-ttu-id="b7a34-496">애니메이션 제어 블록 풀</span><span class="sxs-lookup"><span data-stu-id="b7a34-496">Animation Control Block Pool</span></span> 

<span data-ttu-id="b7a34-497">애플리케이션은 종종 동시에 여러 애니메이션 시퀀스를 실행하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-497">Applications often desire to execute multiple animation sequences, often in parallel.</span></span> <span data-ttu-id="b7a34-498">GUIX는 애플리케이션에서 할당하고 사용할 수 있는 애니메이션 제어 블록 풀을 유지 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-498">GUIX maintains a pool of animation control blocks from which the application can allocate and use.</span></span> <span data-ttu-id="b7a34-499">이렇게 하면 애플리케이션에서 이러한 제어 블록을 정적으로 정의하지 않아도 되며, 애플리케이션에서 정의할 수 있는 모든 애니메이션에 대해 고유한 애니메이션 제어 블록을 정의하는 대신, 여러 번 다시 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-499">This frees the application from statically defining these control blocks and allows them to be reused at different times, rather than defining a unique animation control block for every animation that the application might define.</span></span> <span data-ttu-id="b7a34-500">애니메이션 제어 블록 풀도 GUIX 시스템 구성 요소에서 유지 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-500">The animation control block pool is also maintained by the GUIX system component.</span></span>

### <a name="system-error-handling"></a><span data-ttu-id="b7a34-501">시스템 오류 처리</span><span class="sxs-lookup"><span data-stu-id="b7a34-501">System Error Handling</span></span> 

<span data-ttu-id="b7a34-502">GUIX 시스템 오류 처리기는 애플리케이션이 API 관점에서 확인하기가 더 어려울 수 GUIX의 내부 시스템 오류를 찾는 데 도움을 주기 위해 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-502">The GUIX system error handler is intended to assist the application in finding internal system errors in GUIX that might be more difficult to determine from the API perspective.</span></span> <span data-ttu-id="b7a34-503">GUIX 내부에서 시스템 오류가 발생할 때마다 내부 ***_gx_system_error_process*** 함수가 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-503">Whenever a system error occurs inside of GUIX the internal ***_gx_system_error_process*** function is called.</span></span> <span data-ttu-id="b7a34-504">이 함수는 제공된 오류 코드를 저장하고 검색된 시스템 오류의 총 수를 증가시킵니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-504">This function saves the error code provided and increments the total number of system errors detected.</span></span> <span data-ttu-id="b7a34-505">시스템 오류 변수는 다음과 같이 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-505">The system error variables are defined as follows:</span></span>

<span data-ttu-id="b7a34-506">UINT **_gx_system_last_error**</span><span class="sxs-lookup"><span data-stu-id="b7a34-506">UINT **_gx_system_last_error**;</span></span>

<span data-ttu-id="b7a34-507">ULONG **_gx_system_error_count**</span><span class="sxs-lookup"><span data-stu-id="b7a34-507">ULONG **_gx_system_error_count**;</span></span>

<span data-ttu-id="b7a34-508">GUIX 애플리케이션이 이상하게 작동하는 경우 디버거의 오류 개수 변수를 확인하는 것이 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-508">If the GUIX application is behaving strangely, it is useful to look at the error count variable in the debugger.</span></span> <span data-ttu-id="b7a34-509">설정된 경우 문제를 해결하는 좋은 방법은 ***_gx_system_error_process*** 함수에서 중단점을 설정하고 호출되는 시기/위치를 확인하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-509">If it is set, a good way to troubleshoot the problem is to set a breakpoint in the ***_gx_system_error_process*** function and see when/where it is being called from.</span></span>

## <a name="guix-canvas-component"></a><span data-ttu-id="b7a34-510">GUIX 캔버스 구성 요소</span><span class="sxs-lookup"><span data-stu-id="b7a34-510">GUIX Canvas Component</span></span>

<span data-ttu-id="b7a34-511">캔버스 구성 요소는 모든 캔버스 관련 처리를 담당합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-511">The canvas component is responsible for all canvas related processing.</span></span> <span data-ttu-id="b7a34-512">캔버스는 사실상 가상 프레임 버퍼입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-512">A canvas is effectively a virtual frame buffer.</span></span> <span data-ttu-id="b7a34-513">애플리케이션은 그래픽 출력을 생성하기 위해 캔버스를 하나 이상 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-513">Your application must create at least one canvas in order to produce graphical output.</span></span>
<span data-ttu-id="b7a34-514">일반적으로 시스템에서 지원하는 각 물리적 디스플레이에 대해 캔버스를 하나 이상 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-514">Typically, you would create at least one canvas for each physical display supported by your system.</span></span>

<span data-ttu-id="b7a34-515">모든 GUIX 그리기는 캔버스에서 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-515">All GUIX drawing takes place on a canvas.</span></span> <span data-ttu-id="b7a34-516">좀 더 단순하거나 메모리가 제한되는 시스템의 경우 표시되는 프레임 버퍼에 직접 연결될 수 있는 캔버스는 하나 뿐이지만, 더 많은 메모리와 고급 그래픽 요구 사항이 있는 시스템에는 여러 캔버스가 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-516">In simpler or memory constrained systems, there will likely be only one canvas which might be directly linked to the visible frame buffer, whereas systems with more memory and more advanced graphics requirements might require multiple canvases.</span></span> <span data-ttu-id="b7a34-517">한 디스플레이에 여러 개의 캔버스를 사용할 수 있도록 설정하면 화면 및 창 페이드 인 및 페이드 아웃 효과와 같은 기능을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-517">Making multiple canvases available for one display enables features such as screen and window fade-in and fade-out effects.</span></span>
<span data-ttu-id="b7a34-518">캔버스는 단순형 또는 관리형의 두 가지 주요 유형 중 하나일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-518">Canvases can be one of two main types, simple or managed.</span></span>

<span data-ttu-id="b7a34-519">단순형 캔버스는 애플리케이션에서 사용하는 화면 밖 그리기 영역입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-519">A simple canvas is an off-screen drawing area used by the application.</span></span>
<span data-ttu-id="b7a34-520">GUIX는 단순형 캔버스에서는 직접 아무 작업도 수행하지 않지만 애플리케이션은 단순형 캔버스를 사용하여 복잡한 그리기를 화면 밖 버퍼로 렌더링한 다음, 필요할 때 이 화면 밖 버퍼를 사용하여 표시되는 캔버스를 새로 고칠 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-520">GUIX does nothing directly with a simple canvas, but the application can use a simple canvas to render complex drawing to an off-screen buffer, and then use this off-screen buffer to refresh the visible canvas when needed.</span></span>

<span data-ttu-id="b7a34-521">관리형 캔버스는 GUIX에 의해 하드웨어 프레임 버퍼 내에 자동으로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-521">A managed canvas is automatically displayed within the hardware frame buffer by GUIX.</span></span> <span data-ttu-id="b7a34-522">관리형 캔버스는 여러 개의 관리형 캔버스를 지원하기에 충분한 메모리가 있는 시스템을 위한 복합 캔버스를 빌드하기 위해 포함되었습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-522">A managed canvas is included in building a composite canvas for those systems with enough memory to support multiple managed canvases.</span></span> <span data-ttu-id="b7a34-523">관리형 캔버스에는 GUIX에서 유지되는 Z 순서가 적용되며 모든 관리형 캔버스에는 뷰 클리핑이 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-523">Managed canvases have a Z-order maintained by GUIX, and view clipping is enforced on all managed canvases.</span></span>

<span data-ttu-id="b7a34-524">캔버스는 좀 더 일반적이라는 측면에서 프레임 버퍼와 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-524">A canvas differs from a frame buffer in that it is more generic.</span></span> <span data-ttu-id="b7a34-525">메모리 제한 시스템에서 캔버스는 하나만 있을 수 있으며 이 캔버스의 메모리는 표시되는 프레임 버퍼 메모리일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-525">In memory constrained systems, there may be only one canvas and the memory for this canvas might be the visible frame buffer memory.</span></span> <span data-ttu-id="b7a34-526">그러나 고급 그래픽 오버레이 및 여러 캔버스를 지원하는 보다 복잡한 시스템의 경우 관리형 캔버스에는 하드웨어 프레임 버퍼 메모리와 구분되는 자체 메모리 영역이 할당됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-526">However, for more complex systems supporting more advanced graphical overlays and multiple canvases, the managed canvases are each allocated their own memory areas which are distinct from the hardware frame buffer memory.</span></span>
<span data-ttu-id="b7a34-527">이러한 관리형 캔버스는 프레임 버퍼를 새로 고치거나 전환 작업을 수행하는 동안 표시되는 프레임 버퍼로 렌더링됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-527">These managed canvases are rendered into the visible frame buffer during the frame buffer refresh or toggle operation.</span></span>

<span data-ttu-id="b7a34-528">여러 그래픽 계층(예: 겹치는 여러 프레임 버퍼)을 지원하는 하드웨어의 경우 애플리케이션은 ***gx_canvas_hardware_layer_bind*** API를 사용하여 하나 이상의 캔버스를 하드웨어 그래픽 계층에 바인딩할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-528">For hardware supporting multiple graphics layers, i.e. multiple overlayed frame buffers, the application can bind one or more canvases to the hardware graphics layers using the ***gx_canvas_hardware_layer_bind*** API.</span></span> <span data-ttu-id="b7a34-529">이 서비스는 캔버스에 특정 하드웨어 그래픽 계층에 연결되어 있음을 알리고, 연결되면 이 캔버스는 캔버스 표시 여부(즉,</span><span class="sxs-lookup"><span data-stu-id="b7a34-529">This service informs the canvas that it is linked to a particular hardware graphics layer, and once linked this canvas will attempt to utilize hardware support for canvas visibility (i.e</span></span> <span data-ttu-id="b7a34-530">gx_canvas_show, gx_canvas_hide), 캔버스 알파 혼합(즉, ***gx_canvas_alpha_set***) 및 디스플레이 내의 캔버스 오프셋(***gx_canvas_offset_set***)에 대한 하드웨어 지원을 활용하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-530">gx_canvas_show, gx_canvas_hide), canvas alpha blending (i.e. ***gx_canvas_alpha_set***) and canvas offset within the display (***gx_canvas_offset_set***).</span></span>

<span data-ttu-id="b7a34-531">가장 간단한 단일 캔버스/단일 프레임 버퍼 조직 이외의 아키텍처에서 캔버스 크기는 애플리케이션에서 결정되며 프레임 버퍼의 고정 크기와 다를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-531">For architectures other than the simplest single canvas/single frame buffer organization, the size of a canvas is determined by the application and may be different than the fixed size of a frame buffer.</span></span>
<span data-ttu-id="b7a34-532">애플리케이션에서 선택한 오프셋이 될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-532">It may also be at an offset selected by the application.</span></span> <span data-ttu-id="b7a34-533">Z 순서와 같은 기타 정보는 캔버스 내에서 유지 관리됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-533">Other information, such as Z-order is maintained within the canvas.</span></span> <span data-ttu-id="b7a34-534">캔버스 그리기가 완료되면 캔버스의 내용이 디스플레이 드라이버에 의해 물리적 디스플레이로 전송됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-534">When the canvas drawing is complete, the contents of the canvas are transferred to the physical display by the display driver.</span></span> <span data-ttu-id="b7a34-535">별도 캔버스 및 프레임 버퍼 메모리 영역에 충분한 메모리가 없는 일부 시스템에서 캔버스 업데이트는 실제로 디스플레이 드라이버를 통해 물리적 디스플레이로 직접 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-535">In some systems that don’t have enough memory for a separate canvas and frame buffer memory areas, the canvas update is actually made directly to the physical display via the display driver.</span></span>

### <a name="canvas-creation"></a><span data-ttu-id="b7a34-536">캔버스 만들기</span><span class="sxs-lookup"><span data-stu-id="b7a34-536">Canvas Creation</span></span> 

<span data-ttu-id="b7a34-537">캔버스 개체는 초기화 동안 또는 애플리케이션 스레드를 실행하는 동안 언제든지 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-537">A canvas object can be created during initialization or anytime during the execution of application threads.</span></span> <span data-ttu-id="b7a34-538">애플리케이션에서 만들 수 있는 스레드 수에는 제한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-538">There is no limit on the number of canvas objects that can be created by an application.</span></span> <span data-ttu-id="b7a34-539">그러나 대부분의 애플리케이션은 모든 GUIX 그리기에 대해 캔버스 개체를 하나만 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-539">Most applications, however, will create only one canvas object for all GUIX drawing.</span></span>

### <a name="canvas-control-block"></a><span data-ttu-id="b7a34-540">캔버스 제어 블록</span><span class="sxs-lookup"><span data-stu-id="b7a34-540">Canvas Control Block</span></span> 

<span data-ttu-id="b7a34-541">각 캔버스 개체의 특성은 제어 블록 **GX_CANVAS** 에서 찾을 수 있으며 **_gx_api.h_** 에 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-541">The characteristics of each canvas object are found in its control block **GX_CANVAS** and is defined in **_gx_api.h_**.</span></span> <span data-ttu-id="b7a34-542">캔버스 개체에 필요한 메모리는 애플리케이션에서 제공하며 메모리의 어느 위치에나 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-542">The memory required for a canvas object is provided by the application and can be located anywhere in memory.</span></span> <span data-ttu-id="b7a34-543">그러나 캔버스 개체 제어 블록과 그리기 영역을 함수 범위 외부에서 정의하여 전역 구조체로 만드는 것이 가장 일반적입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-543">However, it is most common to make the canvas object control block and the drawing area a global structure by defining them outside the scope of any function.</span></span>

### <a name="canvas-alpha-channel"></a><span data-ttu-id="b7a34-544">캔버스 알파 채널</span><span class="sxs-lookup"><span data-stu-id="b7a34-544">Canvas Alpha Channel</span></span>

<span data-ttu-id="b7a34-545">GUIX는 픽셀당 혼합 비율을 지정하는 비트맵 알파 채널, 16bpp 이상 색 깊이에서 브러시의 혼합 비율을 지정하는 브러시 알파, 오버레이 캔버스의 혼합 비율을 지정하는 캔버스 알파를 비롯한 여러 수준에서 전경색과 배경색의 알파 혼합을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-545">GUIX supports alpha-blending of foreground and background colors on many levels, including bitmap alpha channel which specifies a blending ratio per pixel, brush alpha which specifies the blending ratio for a brush at 16 bpp and higher color depths, and canvas alpha which specifies the blending ratio for an overlay canvas.</span></span>

<span data-ttu-id="b7a34-546">캔버스의 알파 값은 프레임 버퍼 내에 표시하기 위해 함께 합성되는 여러 캔버스가 있는 경우에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-546">The alpha value of a canvas is used when there are multiple canvases which are composited together for display within the frame buffer.</span></span> <span data-ttu-id="b7a34-547">캔버스가 다른 캔버스 위에 오도록 캔버스 Z 순서를 지정하는 경우 캔버스 알파 값을 설정하여 해당 캔버스와 뒤에 놓인 캔버스를 혼합할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-547">If the canvas Z-order is such that a canvas is above other canvases, then the canvas alpha value can be set to blend the canvas with those that lie behind.</span></span> <span data-ttu-id="b7a34-548">캔버스의 알파 값을 빠르게 수정하면 "페이드 인" 화면 전환 효과를 제공할 수 있지만 캔버스 알파는 여러 가지 방법으로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-548">Rapidly modifying the alpha value of a canvas is used to provide “fade in” screen transition effects, but the canvas alpha can be used in many ways.</span></span>

<span data-ttu-id="b7a34-549">gx_canvas_hardware_layer_bind()를 사용하여 캔버스를 하드웨어 그래픽 계층에 바인딩하면 GUIX는 하드웨어 지원을 활용하여 캔버스 알파 혼합을 구현함으로써 오버레이 캔버스 혼합과 관련된 소프트웨어 오버헤드를 최소화합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-549">If a canvas is bound to a hardware graphics layer using gx_canvas_hardware_layer_bind(), GUIX will attempt to implement canvas alpha blending utilizing hardware support, minimizing the software overhead associated with blending an overlay canvas.</span></span>

<span data-ttu-id="b7a34-550">알파 값의 범위는 0에서 255까지입니다. 여기서 값 0은 픽셀이 완전히 투명한 것을 의미하고 0보다 큰 값은 덜 투명한 캔버스를 늘립니다. 알파 값은 캔버스 혼합에 대한 하드웨어 지원이 제공되지 않을 경우 16bpp 이상에서 실행되는 화면 드라이버에 대해서만 지원될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-550">Alpha values range from 0 through 255, where a value of 0 means the pixel is fully transparent and values greater than 0 are increasing less transparent canvas alpha value can only be supported for screen drivers running at 16-bpp and higher unless hardware assistance for canvas blending is provided.</span></span>

### <a name="canvas-offset"></a><span data-ttu-id="b7a34-551">캔버스 오프셋</span><span class="sxs-lookup"><span data-stu-id="b7a34-551">Canvas Offset</span></span> 

<span data-ttu-id="b7a34-552">***Gx_canvas_offset_set*** API 서비스를 호출하여 표시되는 프레임 버퍼 내에서 캔버스를 오프셋할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-552">A canvas can be offset within the visible frame buffer by invoking the ***gx_canvas_offset_set*** API service.</span></span> <span data-ttu-id="b7a34-553">캔버스 오프셋은 일반적으로 스프라이트 애니메이션을 구현하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-553">Canvas offsets are usually used to implement sprite animations.</span></span> <span data-ttu-id="b7a34-554">***gx_canvas_hardware_layer_bind*** API 함수를 호출하여 캔버스를 하드웨어 그래픽 레이어에 바인딩하면 GUIX는 하드웨어 지원을 활용하여 캔버스 오프셋 변경을 구현하려고 시도함으로써 캔버스 위치 이동과 관련된 소프트웨어 오버헤드를 최소화합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-554">If a canvas is bound to a hardware graphics layer by invoking the ***gx_canvas_hardware_layer_bind*** API function, GUIX will attempt to implement canvas offset changes utilizing hardware support, minimizing the software overhead associated with shifting the canvas position.</span></span>

### <a name="canvas-drawing"></a><span data-ttu-id="b7a34-555">캔버스 그리기</span><span class="sxs-lookup"><span data-stu-id="b7a34-555">Canvas Drawing</span></span> 

<span data-ttu-id="b7a34-556">GUIX 캔버스 구성 요소는 애플리케이션에 완전한 그리기 API를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-556">The GUIX canvas component provides a full drawing API to the application.</span></span> <span data-ttu-id="b7a34-557">***gx_canvas_line_draw*** 또는 ***gx_canvas_pixelmap_draw*** 같은 그리기 API를 호출하려면 먼저 ***gx_canvas_drawing_initiate*** API 함수를 호출하여 그리기를 위한 대상 캔버스를 열어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-557">Before the drawing APIs such as ***gx_canvas_line_draw*** or ***gx_canvas_pixelmap_draw*** can be invoked, the target canvas must be opened for drawing by invoking the ***gx_canvas_drawing_initiate*** API function.</span></span> <span data-ttu-id="b7a34-558">이 함수는 그리기를 위해 캔버스를 준비하고 ***그리기 컨텍스트*** 를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-558">This function prepares a canvas for drawing and creates a ***drawing context***.</span></span>

<span data-ttu-id="b7a34-559">***gx_canvas_line_draw** _ 또는 _*_gx_canvas_text_draw_\*_ 와 같이 캔버스로 렌더링되는 그리기 API는 현재 그리기 컨텍스트 브러시에 있는 매개 변수를 사용하여 선 스타일, 두께 및 색을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-559">The drawing APIs that render to the canvas, such as ***gx_canvas_line_draw** _ or _*_gx_canvas_text_draw_\*_, use parameters found in the current drawing context brush to define the line style, width, and colors.</span></span> <span data-ttu-id="b7a34-560">이러한 브러시 매개 변수는 _*_gx_canvas_drawing_initiate_\*\*를 호출하여 그리기 컨텍스트를 설정한 후에 _*_gx_context_brush_define_*_, _*_gx_context_brush_set_\*\*, \***gx_context_brush_style_set**_ 및 유사한 API 함수를 호출하여 수정됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-560">These brush parameters are modified by calling the _*_gx_context_brush_define_*_, _\*_gx_context_brush_set_\*\*, \***gx_context_brush_style_set**_, and similar API functions after a drawing context has been established by calling _\*_gx_canvas_drawing_initiate_\*\*.</span></span>

<span data-ttu-id="b7a34-561">GUIX가 지연된 캔버스 새로 고침 작업의 일부로 창 및 위젯 그리기 함수를 호출하는 경우 위젯 그리기 함수 호출 전에 그리기 위해 대상 캔버스를 엽니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-561">When GUIX invokes the window and widget drawing functions as part of a deferred canvas refresh operation, the target canvas is opened for drawing prior to calling the widget drawing function(s).</span></span> <span data-ttu-id="b7a34-562">따라서 대상 캔버스를 여는 데는 표준 위젯 그리기 함수가 필요하지 않습니다. 이 작업은 이미 수행되었기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-562">Therefore the standard widget drawing functions are not required to open the target canvas, this has been done for them.</span></span>

<span data-ttu-id="b7a34-563">경우에 따라 애플리케이션에서 캔버스에 즉시 그리기를 강제로 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-563">In some cases the application may want to force immediate drawing to a canvas.</span></span> <span data-ttu-id="b7a34-564">이 경우 애플리케이션은 다음 단계를 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-564">In this case, the application can perform the following steps.</span></span>

1. <span data-ttu-id="b7a34-565">***gx_canvas_drawing_initiate*** API 함수를 호출하여 대상 캔버스와 애플리케이션이 그리려는 캔버스 내의 사각형을 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-565">Call the ***gx_canvas_drawing_initiate*** API function, passing in the target canvas and rectangle within that canvas on which the application wants to draw.</span></span> 

2. <span data-ttu-id="b7a34-566">원하는 그리기를 수행하기 위해 캔버스 그리기 API를 제한없이 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-566">Call any number of canvas drawing APIs to accomplish the desired drawing.</span></span>

3. <span data-ttu-id="b7a34-567">***gx_canvas_drawing_complete*** API 함수를 호출하여 그리기가 완료되었음을 알립니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-567">Call the ***gx_canvas_drawing_complete*** API function to signal that drawing has been completed.</span></span> <span data-ttu-id="b7a34-568">이렇게 하면 시스템 메모리 아키텍처에 따라, 캔버스가 표시되는 프레임 버퍼로 플러시되거나 버퍼 전환 작업이 트리거됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-568">This flushes the canvas to the visible frame buffer and/or triggers a buffer toggle operation, depending on the system memory architecture.</span></span>

### <a name="drawing-apis"></a><span data-ttu-id="b7a34-569">그리기 API</span><span class="sxs-lookup"><span data-stu-id="b7a34-569">Drawing APIs</span></span> 

<span data-ttu-id="b7a34-570">GUIX에서 화면에 모든 시각적 요소를 그리기 위해 몇 가지 주요 그리기 기본 형식이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-570">There are several principal drawing primitives that are required by GUIX to draw all the visual elements on the screen.</span></span> <span data-ttu-id="b7a34-571">이러한 그리기 API를 일반적으로 사용자 지정 위젯 그리기 함수의 일부로 애플리케이션 소프트웨어에서 호출할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-571">These drawing APIs can also be invoked by application software, usually as part of a custom widget drawing function.</span></span> <span data-ttu-id="b7a34-572">이러한 GUIX 캔버스 그리기 API는 매개 변수 유효성 검사 및 클리핑을 수행한 다음, 잘린 그리기 좌표를 하드웨어 및 색 형식의 특정 그리기 구현을 위해 디스플레이 드라이버에 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-572">These GUIX canvas drawing APIs perform parameter validation and clipping, and then pass the clipped drawing coordinates down to the display driver for hardware and color-format specific drawing implementations.</span></span> <span data-ttu-id="b7a34-573">이러한 그리기 API 함수는 다음과 같이 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-573">These drawing API functions are defined as follows.</span></span>

- <span data-ttu-id="b7a34-574">gx_canvas_alpha_set</span><span class="sxs-lookup"><span data-stu-id="b7a34-574">gx_canvas_alpha_set</span></span>
- <span data-ttu-id="b7a34-575">gx_canvas_arc_draw</span><span class="sxs-lookup"><span data-stu-id="b7a34-575">gx_canvas_arc_draw</span></span>
- <span data-ttu-id="b7a34-576">gx_canvas_block_move</span><span class="sxs-lookup"><span data-stu-id="b7a34-576">gx_canvas_block_move</span></span>
- <span data-ttu-id="b7a34-577">gx_canvas_circle_draw</span><span class="sxs-lookup"><span data-stu-id="b7a34-577">gx_canvas_circle_draw</span></span>
- <span data-ttu-id="b7a34-578">gx_canvas_ellipse_draw</span><span class="sxs-lookup"><span data-stu-id="b7a34-578">gx_canvas_ellipse_draw</span></span>
- <span data-ttu-id="b7a34-579">gx_canvas_glyphs_draw</span><span class="sxs-lookup"><span data-stu-id="b7a34-579">gx_canvas_glyphs_draw</span></span>
- <span data-ttu-id="b7a34-580">gx_canvas_hardware_layer_bind</span><span class="sxs-lookup"><span data-stu-id="b7a34-580">gx_canvas_hardware_layer_bind</span></span>
- <span data-ttu-id="b7a34-581">gx_canvas_hide</span><span class="sxs-lookup"><span data-stu-id="b7a34-581">gx_canvas_hide</span></span>
- <span data-ttu-id="b7a34-582">gx_canvas_line_draw</span><span class="sxs-lookup"><span data-stu-id="b7a34-582">gx_canvas_line_draw</span></span>
- <span data-ttu-id="b7a34-583">gx_canvas_offset_set</span><span class="sxs-lookup"><span data-stu-id="b7a34-583">gx_canvas_offset_set</span></span>
- <span data-ttu-id="b7a34-584">gx_canvas_pie_draw</span><span class="sxs-lookup"><span data-stu-id="b7a34-584">gx_canvas_pie_draw</span></span>
- <span data-ttu-id="b7a34-585">gx_canvas_pixel_draw</span><span class="sxs-lookup"><span data-stu-id="b7a34-585">gx_canvas_pixel_draw</span></span>
- <span data-ttu-id="b7a34-586">gx_canvas_pixelmap_blend</span><span class="sxs-lookup"><span data-stu-id="b7a34-586">gx_canvas_pixelmap_blend</span></span>
- <span data-ttu-id="b7a34-587">gx_canvas_pixelmap_rotate</span><span class="sxs-lookup"><span data-stu-id="b7a34-587">gx_canvas_pixelmap_rotate</span></span>
- <span data-ttu-id="b7a34-588">gx_canvas_pixelmap_tile</span><span class="sxs-lookup"><span data-stu-id="b7a34-588">gx_canvas_pixelmap_tile</span></span>
- <span data-ttu-id="b7a34-589">gx_canvas_polygon_draw</span><span class="sxs-lookup"><span data-stu-id="b7a34-589">gx_canvas_polygon_draw</span></span>
- <span data-ttu-id="b7a34-590">gx_canvas_rectangle_draw</span><span class="sxs-lookup"><span data-stu-id="b7a34-590">gx_canvas_rectangle_draw</span></span>
- <span data-ttu-id="b7a34-591">gx_canvas_rotated_text_draw</span><span class="sxs-lookup"><span data-stu-id="b7a34-591">gx_canvas_rotated_text_draw</span></span>
- <span data-ttu-id="b7a34-592">gx_canvas_shift</span><span class="sxs-lookup"><span data-stu-id="b7a34-592">gx_canvas_shift</span></span>
- <span data-ttu-id="b7a34-593">gx_canvas_show</span><span class="sxs-lookup"><span data-stu-id="b7a34-593">gx_canvas_show</span></span>
- <span data-ttu-id="b7a34-594">gx_canvas_text_draw</span><span class="sxs-lookup"><span data-stu-id="b7a34-594">gx_canvas_text_draw</span></span>

<span data-ttu-id="b7a34-595">그리기 API는 GUIX 캔버스 API를 통해 호출되며 모든 그리기는 gx_canvas_\* API 함수를 사용하여 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-595">The drawing API is invoked via the GUIX Canvas API, and all drawing is done using gx_canvas_\* API functions.</span></span> <span data-ttu-id="b7a34-596">그리기는 현재 그리기 컨텍스트에서 현재 브러시를 사용하여 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-596">Drawing is done using the current brush in the current drawing context.</span></span> <span data-ttu-id="b7a34-597">위의 셰이프 그리기 함수는 현재 브러시에서 정의한 대로 윤곽선으로 표시하거나, 단색으로 채우거나, pixelmap으로 채울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-597">Any of the shape drawing functions above can be outlined, solid color filled, or pixelmap filled as defined by the current brush.</span></span> <span data-ttu-id="b7a34-598">셰이프 윤곽선 너비, 색 또는 채우기를 수정하려면 gx_context_brush_\* API 함수를 사용하여 현재 그리기 컨텍스트 내의 브러시를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-598">To modify the shape outline width, color, or fill, use the gx_context_brush_\* API functions to define the brush within the current drawing context.</span></span>

<span data-ttu-id="b7a34-599">위의 애플리케이션 수준 그리기 API는 캔버스에 실제 그리기를 수행하지 않고, 디스플레이 드라이버 수준 그리기 함수를 호출하기 전에 호출자의 매개 변수를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-599">The above application level drawing APIs don’t do actual drawing to the canvas, but instead verify the caller’s parameters before invoking the display driver level drawing function.</span></span> <span data-ttu-id="b7a34-600">드라이버 수준 그리기 함수는 실제로 캔버스 메모리에 픽셀 데이터를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-600">The driver level drawing function actually writes pixel data into the canvas memory.</span></span>

<span data-ttu-id="b7a34-601">GUIX는 픽셀당 1, 2, 4, 8, 16, 24 및 32비트(bpp)를 비롯한 다양한 색 깊이에 대해 스톡 또는 제네릭 디스플레이 드라이버 그리기 함수를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-601">GUIX provides stock or generic display driver drawing functions for various color depths, including 1, 2, 4, 8, 16, 24, and 32 bits per pixel (bpp).</span></span> <span data-ttu-id="b7a34-602">경우에 따라 기본 소프트웨어 그리기 구현이 2D 그리기 가속기를 제공하는 하드웨어 대상을 위해 하드웨어 가속 구현으로 대체됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-602">In some cases, the default software drawing implementation is replaced by hardware-accelerated implementations for those hardware targets that provide a 2D drawing accelerator.</span></span>

### <a name="color-depth"></a><span data-ttu-id="b7a34-603">색 농도</span><span class="sxs-lookup"><span data-stu-id="b7a34-603">Color Depth</span></span> 

<span data-ttu-id="b7a34-604">GUIX은 색 농도를 최대 32bpp, 단색 및 회색조까지 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-604">GUIX supports color depths up to 32-bpp as well as monochrome and grayscale.</span></span> <span data-ttu-id="b7a34-605">이것은 주로 기본 물리적 디스플레이의 용량에 의해 결정되는 색 농도 유형으로, 캔버스 그리기 영역에 필요한 메모리 양에도 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-605">The type of color depth support largely determined by the capabilities of the underlying physical display and also has an impact on how much memory is required for the canvas drawing area.</span></span> <span data-ttu-id="b7a34-606">다음은 지원되는 색 농도와 색 농도 내의 변형에 대한 간략한 설명 목록입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-606">The following is a list of color depth support along with a brief description of the variations within that color depth.</span></span>

| <span data-ttu-id="b7a34-607">색&nbsp;형식</span><span class="sxs-lookup"><span data-stu-id="b7a34-607">Color&nbsp;Format</span></span>       | <span data-ttu-id="b7a34-608">Description</span><span class="sxs-lookup"><span data-stu-id="b7a34-608">Description</span></span>                                                                                                   |
| ------------------ | -------------------------------------------------------------------------------------------------------------------------------- |
| <span data-ttu-id="b7a34-609">1비트 단색</span><span class="sxs-lookup"><span data-stu-id="b7a34-609">1-bit monochrome</span></span>   | <span data-ttu-id="b7a34-610">픽셀당 1비트 압축 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-610">1-bit per pixel packed format.</span></span>                                                                                                   |
| <span data-ttu-id="b7a34-611">2비트 회색조</span><span class="sxs-lookup"><span data-stu-id="b7a34-611">2-bit grayscale</span></span>    | <span data-ttu-id="b7a34-612">바이트당 4개 픽셀로 압축된 4개의 회색 수준입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-612">4 gray levels, packed four pixels per byte.</span></span>                                                                                      |
| <span data-ttu-id="b7a34-613">4비트 회색조</span><span class="sxs-lookup"><span data-stu-id="b7a34-613">4-bit grayscale</span></span>    | <span data-ttu-id="b7a34-614">바이트당 2개 픽셀로 압축된 16개의 회색 수준입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-614">16 gray levels, packed two pixels per byte.</span></span>                                                                                      |
| <span data-ttu-id="b7a34-615">4비트 색</span><span class="sxs-lookup"><span data-stu-id="b7a34-615">4-bit color</span></span>        | <span data-ttu-id="b7a34-616">VGA 형식의 평면 메모리 구성입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-616">A VGA format planar memory organization.</span></span>                                                                                         |
| <span data-ttu-id="b7a34-617">8비트 회색조</span><span class="sxs-lookup"><span data-stu-id="b7a34-617">8-bit grayscale</span></span>    | <span data-ttu-id="b7a34-618">256 회색 수준</span><span class="sxs-lookup"><span data-stu-id="b7a34-618">256 gray levels</span></span>                                                                                                                  |
| <span data-ttu-id="b7a34-619">8비트 색상표 모드</span><span class="sxs-lookup"><span data-stu-id="b7a34-619">8-bit palette mode</span></span> | <span data-ttu-id="b7a34-620">픽셀당 1바이트가 색상표 인덱스로 사용</span><span class="sxs-lookup"><span data-stu-id="b7a34-620">1 byte per pixel used as palette index</span></span>                                                                                           |
| <span data-ttu-id="b7a34-621">8비트 r:g:b 모드</span><span class="sxs-lookup"><span data-stu-id="b7a34-621">8-bit r:g:b mode</span></span>   | <span data-ttu-id="b7a34-622">덜 일반적으로 사용되는 2:3:2 r:g:b 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-622">A less commonly used 2:3:2 r:g:b format.</span></span>                                                                                         |
| <span data-ttu-id="b7a34-623">16비트</span><span class="sxs-lookup"><span data-stu-id="b7a34-623">16-bit</span></span>             | <span data-ttu-id="b7a34-624">각 픽셀에는 2바이트가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-624">Each pixel requires two bytes.</span></span> <span data-ttu-id="b7a34-625">r:g:b 또는 b:g:r 바이트 순서일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-625">Can be r:g:b or b:g:r byte order.</span></span> <span data-ttu-id="b7a34-626">일반적으로 5:6:5 구조체이지만 5:5:5 구조체 또는 4:4:4:4 a:r:g:b 구조체일 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-626">Normally 5:6:5 structure, but can also be 5:5:5 structure or 4:4:4:4 a:r:g:b structure.</span></span> |
| <span data-ttu-id="b7a34-627">24비트</span><span class="sxs-lookup"><span data-stu-id="b7a34-627">24-bit</span></span>             | <span data-ttu-id="b7a34-628">각 픽셀에는 3바이트(압축 형식) 또는 4바이트(압축 해제 형식)가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-628">Each pixel requires 3 (packed format) or 4 (unpacked format) bytes.</span></span> <span data-ttu-id="b7a34-629">하드웨어에 필요한 r:g:b 또는 b:g:r 바이트 순서일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-629">Can be in r:g:b or b:g:r byte order as required by hardware.</span></span> |
| <span data-ttu-id="b7a34-630">32비트</span><span class="sxs-lookup"><span data-stu-id="b7a34-630">32-bit</span></span>             | <span data-ttu-id="b7a34-631">각 픽셀에는 알파 채널에 4바이트가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-631">Each pixel requires 4 bytes with an alpha channel.</span></span> <span data-ttu-id="b7a34-632">a:r:g:b 또는 b:g:r:a 바이트 순서일 수 있으며 하드웨어에 의해 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-632">Can be a:r:g:b or b:g:r:a byte order and determined by hardware.</span></span>              |

### <a name="mouse-support"></a><span data-ttu-id="b7a34-633">마우스 지원</span><span class="sxs-lookup"><span data-stu-id="b7a34-633">Mouse Support</span></span> 

<span data-ttu-id="b7a34-634">GUIX는 원하는 캔버스에서의 마우스 커서 그리기를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-634">GUIX supports drawing a mouse cursor on any desired canvas.</span></span> <span data-ttu-id="b7a34-635">마우스 커서는 소프트웨어에서 그리거나 하드웨어 커서 오버레이를 통해 지원될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-635">The mouse cursor can be drawing in software or might be supported by hardware cursor overlay.</span></span> <span data-ttu-id="b7a34-636">두 경우 모두, 마우스 커서 지원과 관련된 애플리케이션에 제공되는 API가 소프트웨어 마우스 커서 그리기와 하드웨어 마우스 커서 그리기 둘 다에서 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-636">In either case, the API provided to the application related to mouse cursor support is the same whether using software or hardware mouse cursor drawing.</span></span>

<span data-ttu-id="b7a34-637">GUIX 마우스 지원은 `#define GX_MOUSE_SUPPORT`가 GUIX 라이브러리를 빌드하기 전에 gx_user.h 헤더 파일에 정의되어 있는 경우에만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-637">GUIX mouse support is only enabled if the `#define GX_MOUSE_SUPPORT` is defined in the gx_user.h header file before building the GUIX library.</span></span>

<span data-ttu-id="b7a34-638">애플리케이션은 ***gx_canvas_mouse_define*** API 함수를 사용하여 마우스 커서 및 핫스팟을 정의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-638">The application must define the mouse cursor and hotspot using the ***gx_canvas_mouse_define*** API function.</span></span> <span data-ttu-id="b7a34-639">이 API는 커서 이미지를 그려야 하는 캔버스에 대한 포인터와 왼쪽 위 모서리 이미지를 기준으로 마우스 커서 이미지와 마우스 이미지의 핫스팟을 정의하는 **GX_MOUSE_CURSOR_INFO** 구조체에 대한 포인터를 받습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-639">This API accepts a pointer to the canvas on which the cursor image should be drawn, and a pointer to a **GX_MOUSE_CURSOR_INFO** structure, which defines the mouse cursor image and hotspot of the mouse image relative the image top-left corner.</span></span>

## <a name="guix-display-component"></a><span data-ttu-id="b7a34-640">GUIX 디스플레이 구성 요소</span><span class="sxs-lookup"><span data-stu-id="b7a34-640">GUIX Display Component</span></span> 

<span data-ttu-id="b7a34-641">디스플레이 구성 요소는 하나 이상의 캔버스, 위젯 및 창을 포함하는 모든 디스플레이 개체의 처리를 관리하기 때문에 GUIX의 기본 구성 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-641">The display component is fundamental in GUIX, since it manages the processing of all display objects, which in themselves contain one or more canvases, widgets, and windows.</span></span> <span data-ttu-id="b7a34-642">또한 디스플레이 구성 요소는 일련의 함수 포인터를 통해 각 디스플레이와 연결된 기본 하드웨어 화면 드라이버와 상호 작용합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-642">The display component also interacts with the underlying hardware screen driver associated with each display through a series of function pointers.</span></span>

### <a name="display-creation"></a><span data-ttu-id="b7a34-643">디스플레이 만들기</span><span class="sxs-lookup"><span data-stu-id="b7a34-643">Display Creation</span></span> 

<span data-ttu-id="b7a34-644">디스플레이 개체는 초기화 동안 또는 애플리케이션 스레드를 실행하는 동안 언제든지 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-644">A display object can be created during initialization or anytime during the execution of application threads.</span></span> <span data-ttu-id="b7a34-645">일반적으로 애플리케이션은 각 물리적 화면을 관리하는 하나의 디스플레이 개체를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-645">Typically an application creates one display object to manage each physical screen.</span></span> <span data-ttu-id="b7a34-646">GUIX Studio를 사용하여 애플리케이션을 정의했으며 물리적 디스플레이를 사용할 수 있는 경우 gx_studio_display_configure API 함수를 사용하여 각 디스플레이를 만들고 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-646">If you have used GUIX Studio to define your application and the physical displays available, you will use the gx_studio_display_configure API function to create and initialize each of your displays.</span></span>

### <a name="display-control-block"></a><span data-ttu-id="b7a34-647">디스플레이 제어 블록</span><span class="sxs-lookup"><span data-stu-id="b7a34-647">Display Control Block</span></span> 

<span data-ttu-id="b7a34-648">각 디스플레이 개체의 특성은 해당 제어 블록 \***GX_DISPLAY** 에서 찾을 수 있으며 \*_gx_api_\*\*에 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-648">The characteristics of each display object are found in its control block ***GX_DISPLAY** _ and are defined in _*_gx_api.h_\*\*.</span></span> <span data-ttu-id="b7a34-649">디스플레이 개체에 필요한 메모리는 애플리케이션에서 제공하며 메모리의 어느 위치에나 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-649">The memory required for a display object is provided by the application and can be located anywhere in memory.</span></span> <span data-ttu-id="b7a34-650">그러나 함수 범위 외부에서 정의하여 디스플레이 제어 블록이 전역 구조를 차단하도록 하는 것이 가장 일반적입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-650">However, it is most common to make the display control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="resource-management"></a><span data-ttu-id="b7a34-651">리소스 관리</span><span class="sxs-lookup"><span data-stu-id="b7a34-651">Resource Management</span></span> 

<span data-ttu-id="b7a34-652">리소스는 애플리케이션에 필요한 UI 구성 요소이지만 애플리케이션 코드가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-652">Resources are UI components that are needed by the application, but they are not application code.</span></span> <span data-ttu-id="b7a34-653">리소스는 애플리케이션 데이터이며 일반적으로 정적으로 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-653">Resources are application data and are usually statically defined.</span></span> <span data-ttu-id="b7a34-654">리소스 종류에는 pixelmap, 글꼴, 색 및 문자열이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-654">Resource types include pixelmaps, fonts, colors, and strings.</span></span> <span data-ttu-id="b7a34-655">이러한 리소스는 일반적으로 애플리케이션 소프트웨어를 변경하지 않고 언제든지 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-655">These resources can be changed at any time, usually without changing any application software.</span></span> <span data-ttu-id="b7a34-656">애플리케이션 소프트웨어를 변경하게 되면 소프트웨어를 다시 테스트하고 확인하는 과정이 필요하게 되므로 애플리케이션 코드를 변경할 필요가 없도록 리소스의 스토리지와 참조를 애플리케이션 소프트웨어와 분리하는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-656">It is important to keep the storage of and references to resources separated from the application software to allow changing UI appearance without changing application code since changes to the application software usually require the associated re-testing and verification of that software.</span></span>

<span data-ttu-id="b7a34-657">GUIX ***디스플레이*** 모듈은 디스플레이의 색 농도와 형식에 따라 달라지는 모든 리소스에 대한 리소스 관리 기능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-657">The GUIX ***display*** module provides resource management facilities for all resources that are dependent on the color depth and format of the display.</span></span> <span data-ttu-id="b7a34-658">이러한 기능에는 활성 pixelmap 테이블, 활성 글꼴 테이블 및 활성 색상표를 유지 관리하는 작업이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-658">These facilities include maintaining the active pixelmap table, active font table, and active color table.</span></span> <span data-ttu-id="b7a34-659">일반적으로 문자열 리소스는 색 농도 및 형식에 따라 변경할 필요가 없으므로 GUIX 시스템 모듈에서 이러한 문자열 테이블 리소스를 유지 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-659">The string table resource is maintained by the GUIX system module, since string resources do not normally need to be changed based on color depth and format.</span></span>

<span data-ttu-id="b7a34-660">애플리케이션 소프트웨어는 리소스 테이블의 인덱스에 해당하는 리소스 ID를 기준으로 리소스를 참조합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-660">The application software references resources by their resource Id, which is an index into the corresponding resource table.</span></span> <span data-ttu-id="b7a34-661">이렇게 하면 테이블이 변경될 수 있습니다. 예를 들어, 제품이 "주간 모드"에서 "야간 모드"로 변경될 경우 색 테이블은 변경될 수 있지만 색 ID 값은 동일하게 유지됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-661">This allows the table to be changed, for example the color table might be changed when a product changes from “day mode” to “night mode”, but the color ID values to remain the same.</span></span>

<span data-ttu-id="b7a34-662">애플리케이션 리소스는 GUIX Studio 애플리케이션에서 리소스 파일(또는 리소스 파일 세트)에 기록됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-662">Your application resources are written to a resource file (or set of resource files) by the GUIX Studio application.</span></span> <span data-ttu-id="b7a34-663">기본 색, pixelmap 및 글꼴은 새 GUIX Studio 프로젝트를 만들 때 자동으로 제공되지만 이러한 기본값은 애플리케이션의 모양과 느낌을 정의하면서 쉽게 바뀝니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-663">Default colors, pixelmaps, and fonts are provided automatically when you create a new GUIX Studio project, but these defaults are easily replaced as you define the look and feel of your application.</span></span>

<span data-ttu-id="b7a34-664">색, 글꼴 및 pixelmap에 대한 리소스 ID는 활성 디스플레이 구성 요소가 알려질 때까지 실제 색, 글꼴 또는 pixelmap 값으로 확인할 수 없다는 점에 유의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-664">It is important to note that Resource IDs for colors, fonts, and pixelmaps cannot be resolved to their actual color, font, or pixelmap values until the active Display component is known.</span></span> <span data-ttu-id="b7a34-665">GUIX 아키텍처는 여러 활성 디스플레이를 지원하므로 위젯 및 관련된 리소스 ID를 특정 디스플레이로 확인할 수 있는 경우에만 리소스 ID를 리소스 값으로 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-665">Since the GUIX architecture supports multiple active displays, Resource IDs can only be resolved to resource values when a widget and its associated Resource ID can be resolved to a specific display.</span></span> <span data-ttu-id="b7a34-666">이 속성을 동적 바인딩이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-666">This property is known as dynamic binding.</span></span> <span data-ttu-id="b7a34-667">텍스트 색과 같은 속성의 리소스 ID(예: 리소스 ID **GX_COLOR_ID_TEXT**)는 한 디스플레이에서는 흰색을 나타내는 16비트 R:G:B 값으로 확인될 수 있지만, 다른 디스플레이에서는 단색 검정 색 값으로 확인될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-667">The Resource ID for a property such as a text color, for example the resource ID **GX_COLOR_ID_TEXT,** might resolve to a 16-bit R:G:B value for white when used on one display, but the same color ID might resolve to a monochrome black color value when used on another display.</span></span>

<span data-ttu-id="b7a34-668">실제로 리소스 값에 리소스 ID를 동적으로 바인딩하는 것은 애플리케이션 소프트웨어 및 GUIX 내부 구성 요소가 활성 그리기 컨텍스트 내에서 리소스 ID를 리소스 값으로만 확인해야 함을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-668">In practice this dynamic binding of Resources IDs to resource values means that application software and GUIX internal components should most often only resolve Resource IDs to resource values within an active drawing context.</span></span> <span data-ttu-id="b7a34-669">활성 그리기 컨텍스트는 GUIX가 각 리소스 ID를 특정 리소스 값으로 확인할 수 있도록 현재 활성 디스플레이를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-669">An active drawing context specifies the currently active display, which allows GUIX to resolve each Resource ID to a specific resource value.</span></span> <span data-ttu-id="b7a34-670">애플리케이션 소프트웨어가 그리기 컨텍스트 외부에서 특정 리소스 값을 찾아야 하는 경우 표시되는 위젯에 대해서도 이 작업을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-670">If the application software is required to find a specific resource value outside of a drawing context, this can also be done for visible widgets.</span></span> <span data-ttu-id="b7a34-671">표시되는 위젯은 루트 창에 연결되어 해당 위젯에 대한 활성 캔버스 및 디스플레이를 확인하는 데도 사용될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-671">Visible widgets are linked to a root window which can also be used to resolve the active canvas and display for that widget.</span></span>

<span data-ttu-id="b7a34-672">위젯이 만들어졌지만 아직 표시되지 않은 경우(즉, 루트 창이나 기타 표시되는 부모 항목에 연결되지 않은 경우) 해당 위젯에 연결된 리소스 ID는 특정 디스플레이에 할당된 리소스 테이블에 직접 인덱싱되는 경우가 아니면 특정 리소스 값으로 확인될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-672">If a widget has been created but not yet displayed (i.e., has not been linked to any root window or other visible parent), any resource IDs associated with that widget cannot be resolved to a specific resource value other than by directly indexing into the resource table assigned to a specific display.</span></span> <span data-ttu-id="b7a34-673">애플리케이션 소프트웨어에서 특정 리소스 테이블에 직접 액세스하는 것은 안전할 수 있지만 내부 GUIX 라이브러리 소프트웨어에서는 절대 액세스하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-673">This direct access to a specific resource table can safely be done by the application software, but is never done in the internal GUIX library software.</span></span>

### <a name="widget-defaults"></a><span data-ttu-id="b7a34-674">위젯 기본값</span><span class="sxs-lookup"><span data-stu-id="b7a34-674">Widget Defaults</span></span> 

<span data-ttu-id="b7a34-675">또한 GUIX 디스플레이 구성 요소는 다양한 위젯 특성에 대한 기본 정의를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-675">The GUIX display component also provides default definitions for various widget attributes.</span></span> <span data-ttu-id="b7a34-676">애플리케이션에서 다르게 지정되지 않은 경우 이러한 시스템 특성을 사용하여 위젯/창을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-676">Unless otherwise specified by the application, widgets/windows are created with these system attributes.</span></span> <span data-ttu-id="b7a34-677">이러한 시스템 특성은 주로 시스템 리소스 테이블에서 유지 관리되는 글꼴, 색 및 비트맵으로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-677">These system attributes are mainly composed of fonts, colors, and bitmaps maintained in the system resource tables.</span></span> <span data-ttu-id="b7a34-678">기본 스크롤 막대 모양에 대한 추가 특성도 GUIX 디스플레이 구성 요소에서 유지 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-678">Additional attributes for default scrollbar appearance are also maintained by the GUIX display component.</span></span>

<span data-ttu-id="b7a34-679">기본 색 설정은 각 디스플레이에 할당된 색 테이블 및 미리 정의된 기본 색 ID로 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-679">The default color settings are defined by the color table assigned to each display and the pre-defined default color IDs.</span></span> <span data-ttu-id="b7a34-680">이러한 기본 색 ID는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-680">These default color ids include the following.</span></span>

| <span data-ttu-id="b7a34-681">색 ID</span><span class="sxs-lookup"><span data-stu-id="b7a34-681">Color ID</span></span> | <span data-ttu-id="b7a34-682">Description</span><span class="sxs-lookup"><span data-stu-id="b7a34-682">Description</span></span> |
| ------------------ | -------------------------------------------------------------------------------------------------------------------------------- |
| <span data-ttu-id="b7a34-683">GX_COLOR_ID_CANVAS</span><span class="sxs-lookup"><span data-stu-id="b7a34-683">GX_COLOR_ID_CANVAS</span></span> | <span data-ttu-id="b7a34-684">기본 캔버스(예: 표시 배경) 색</span><span class="sxs-lookup"><span data-stu-id="b7a34-684">Default canvas (i.e. display background) color</span></span> |
| <span data-ttu-id="b7a34-685">GX_COLOR_ID_WIDGET_FILL</span><span class="sxs-lookup"><span data-stu-id="b7a34-685">GX_COLOR_ID_WIDGET_FILL</span></span> | <span data-ttu-id="b7a34-686">기본 위젯 채우기 색</span><span class="sxs-lookup"><span data-stu-id="b7a34-686">Default widget fill color</span></span> |
| <span data-ttu-id="b7a34-687">GX_COLOR_ID_WINDOW_FILL</span><span class="sxs-lookup"><span data-stu-id="b7a34-687">GX_COLOR_ID_WINDOW_FILL</span></span> | <span data-ttu-id="b7a34-688">기본 창 채우기 색</span><span class="sxs-lookup"><span data-stu-id="b7a34-688">Default window fill color</span></span> |
| <span data-ttu-id="b7a34-689">GX_COLOR_ID_DISABLED_FILL</span><span class="sxs-lookup"><span data-stu-id="b7a34-689">GX_COLOR_ID_DISABLED_FILL</span></span> | <span data-ttu-id="b7a34-690">사용하지 않도록 설정된 기본 위젯 채우기 색</span><span class="sxs-lookup"><span data-stu-id="b7a34-690">Default disabled widget fill color</span></span> |
| <span data-ttu-id="b7a34-691">GX_COLOR_ID_DEFAULT_BORDER</span><span class="sxs-lookup"><span data-stu-id="b7a34-691">GX_COLOR_ID_DEFAULT_BORDER</span></span> | <span data-ttu-id="b7a34-692">기본 위젯 테두리 색</span><span class="sxs-lookup"><span data-stu-id="b7a34-692">Default widget border color</span></span> |
| <span data-ttu-id="b7a34-693">GX_COLOR_ID_WINDOW_BORDER</span><span class="sxs-lookup"><span data-stu-id="b7a34-693">GX_COLOR_ID_WINDOW_BORDER</span></span> | <span data-ttu-id="b7a34-694">기본 창 테두리 색</span><span class="sxs-lookup"><span data-stu-id="b7a34-694">Default window border color</span></span> |
| <span data-ttu-id="b7a34-695">GX_COLOR_ID_TEXT</span><span class="sxs-lookup"><span data-stu-id="b7a34-695">GX_COLOR_ID_TEXT</span></span> | <span data-ttu-id="b7a34-696">기본 텍스트 색</span><span class="sxs-lookup"><span data-stu-id="b7a34-696">Default text color</span></span> |
| <span data-ttu-id="b7a34-697">GX_COLOR_ID_SELECTED_TEXT</span><span class="sxs-lookup"><span data-stu-id="b7a34-697">GX_COLOR_ID_SELECTED_TEXT</span></span> | <span data-ttu-id="b7a34-698">선택한 기본 텍스트 색</span><span class="sxs-lookup"><span data-stu-id="b7a34-698">Default selected text color</span></span> |
| <span data-ttu-id="b7a34-699">GX_COLOR_ID_DISABLED_TEXT</span><span class="sxs-lookup"><span data-stu-id="b7a34-699">GX_COLOR_ID_DISABLED_TEXT</span></span> | <span data-ttu-id="b7a34-700">사용하지 않도록 설정된 기본 색</span><span class="sxs-lookup"><span data-stu-id="b7a34-700">Default disabled text color</span></span> |
| <span data-ttu-id="b7a34-701">GX_COLOR_ID_SELECTED_TEXT_FILL</span><span class="sxs-lookup"><span data-stu-id="b7a34-701">GX_COLOR_ID_SELECTED_TEXT_FILL</span></span> | <span data-ttu-id="b7a34-702">선택한 기본 텍스트 채우기 색</span><span class="sxs-lookup"><span data-stu-id="b7a34-702">Default selected text fill color</span></span> |
| <span data-ttu-id="b7a34-703">GX_COLOR_ID_READONLY_TEXT</span><span class="sxs-lookup"><span data-stu-id="b7a34-703">GX_COLOR_ID_READONLY_TEXT</span></span> | <span data-ttu-id="b7a34-704">기본 읽기 전용 텍스트 색</span><span class="sxs-lookup"><span data-stu-id="b7a34-704">Default readonly text color</span></span> |
| <span data-ttu-id="b7a34-705">GX_COLOR_ID_READONLY_FILL</span><span class="sxs-lookup"><span data-stu-id="b7a34-705">GX_COLOR_ID_READONLY_FILL</span></span> | <span data-ttu-id="b7a34-706">기본 읽기 전용 텍스트 채우기 색</span><span class="sxs-lookup"><span data-stu-id="b7a34-706">Default readonly text fill color</span></span> |
| <span data-ttu-id="b7a34-707">GX_COLOR_ID_SCROLL_FILL</span><span class="sxs-lookup"><span data-stu-id="b7a34-707">GX_COLOR_ID_SCROLL_FILL</span></span> |    <span data-ttu-id="b7a34-708">스크롤 막대 채우기 색</span><span class="sxs-lookup"><span data-stu-id="b7a34-708">Scrollbar fill color</span></span> |
| <span data-ttu-id="b7a34-709">GX_COLOR_ID_SCROLL_BUTTON</span><span class="sxs-lookup"><span data-stu-id="b7a34-709">GX_COLOR_ID_SCROLL_BUTTON</span></span> | <span data-ttu-id="b7a34-710">스크롤 막대 단추 채우기 색</span><span class="sxs-lookup"><span data-stu-id="b7a34-710">Scrollbar button fill color</span></span> |
| <span data-ttu-id="b7a34-711">GX_COLOR_ID_SHADOW</span><span class="sxs-lookup"><span data-stu-id="b7a34-711">GX_COLOR_ID_SHADOW</span></span> | <span data-ttu-id="b7a34-712">기본 그림자 색</span><span class="sxs-lookup"><span data-stu-id="b7a34-712">Default shadow color</span></span> |
| <span data-ttu-id="b7a34-713">GX_COLOR_ID_SHINE</span><span class="sxs-lookup"><span data-stu-id="b7a34-713">GX_COLOR_ID_SHINE</span></span> | <span data-ttu-id="b7a34-714">기본 강조 색</span><span class="sxs-lookup"><span data-stu-id="b7a34-714">Default highlight color</span></span> |
| <span data-ttu-id="b7a34-715">GX_COLOR_ID_BUTTON_BORDER</span><span class="sxs-lookup"><span data-stu-id="b7a34-715">GX_COLOR_ID_BUTTON_BORDER</span></span> | <span data-ttu-id="b7a34-716">단추 위젯 테두리 색</span><span class="sxs-lookup"><span data-stu-id="b7a34-716">Button widget border color</span></span> |
| <span data-ttu-id="b7a34-717">GX_COLOR_ID_BUTTON_UPPER</span><span class="sxs-lookup"><span data-stu-id="b7a34-717">GX_COLOR_ID_BUTTON_UPPER</span></span> | <span data-ttu-id="b7a34-718">단추 위젯 위쪽 채우기 색</span><span class="sxs-lookup"><span data-stu-id="b7a34-718">Button widget upper fill color</span></span> |
| <span data-ttu-id="b7a34-719">GX_COLOR_ID_BUTTON_LOWER</span><span class="sxs-lookup"><span data-stu-id="b7a34-719">GX_COLOR_ID_BUTTON_LOWER</span></span> | <span data-ttu-id="b7a34-720">단추 위젯 아래쪽 채우기 색</span><span class="sxs-lookup"><span data-stu-id="b7a34-720">Button widget lower fill color</span></span> |
| <span data-ttu-id="b7a34-721">GX_COLOR_ID_BUTTON_TEXT</span><span class="sxs-lookup"><span data-stu-id="b7a34-721">GX_COLOR_ID_BUTTON_TEXT</span></span> | <span data-ttu-id="b7a34-722">단추 위젯 텍스트 색</span><span class="sxs-lookup"><span data-stu-id="b7a34-722">Button widget text color</span></span> |
| <span data-ttu-id="b7a34-723">GX_COLOR_ID_TEXT_INPUT_TEXT</span><span class="sxs-lookup"><span data-stu-id="b7a34-723">GX_COLOR_ID_TEXT_INPUT_TEXT</span></span> | <span data-ttu-id="b7a34-724">텍스트 입력 위젯 텍스트 색</span><span class="sxs-lookup"><span data-stu-id="b7a34-724">Text input widget text color</span></span> |
| <span data-ttu-id="b7a34-725">GX_COLOR_ID_TEXT_INPUT_FILL</span><span class="sxs-lookup"><span data-stu-id="b7a34-725">GX_COLOR_ID_TEXT_INPUT_FILL</span></span> | <span data-ttu-id="b7a34-726">텍스트 입력 채우기 색</span><span class="sxs-lookup"><span data-stu-id="b7a34-726">Text input fill color</span></span> |
| <span data-ttu-id="b7a34-727">GX_COLOR_ID_SLIDER_TICK</span><span class="sxs-lookup"><span data-stu-id="b7a34-727">GX_COLOR_ID_SLIDER_TICK</span></span> | <span data-ttu-id="b7a34-728">슬라이더 눈금 표시를 그리는 데 사용되는 색</span><span class="sxs-lookup"><span data-stu-id="b7a34-728">Color used to draw slider tick marks.</span></span> |
| <span data-ttu-id="b7a34-729">GX_COLOR_ID_SLIDER_GROOVE_BOTTOM</span><span class="sxs-lookup"><span data-stu-id="b7a34-729">GX_COLOR_ID_SLIDER_GROOVE_BOTTOM</span></span> | <span data-ttu-id="b7a34-730">슬라이더 홈 양각을 그리는 데 사용되는 색</span><span class="sxs-lookup"><span data-stu-id="b7a34-730">Color used to draw slider groove</span></span> |
| <span data-ttu-id="b7a34-731">GX_COLOR_ID_SLIDER_NEEDLE_OUTLINE</span><span class="sxs-lookup"><span data-stu-id="b7a34-731">GX_COLOR_ID_SLIDER_NEEDLE_OUTLINE</span></span> | <span data-ttu-id="b7a34-732">니들 윤곽선을 그리는 데 사용되는 색</span><span class="sxs-lookup"><span data-stu-id="b7a34-732">Color used to draw needle outline</span></span> |
| <span data-ttu-id="b7a34-733">GX_COLOR_ID_SLIDER_NEEDLE_FILL</span><span class="sxs-lookup"><span data-stu-id="b7a34-733">GX_COLOR_ID_SLIDER_NEEDLE_FILL</span></span> | <span data-ttu-id="b7a34-734">슬라이더 니들을 채우는 데 사용되는 색</span><span class="sxs-lookup"><span data-stu-id="b7a34-734">Color used to fill slider needle</span></span> |
| <span data-ttu-id="b7a34-735">GX_COLOR_ID_SLIDER_NEEDLE_LINE1</span><span class="sxs-lookup"><span data-stu-id="b7a34-735">GX_COLOR_ID_SLIDER_NEEDLE_LINE1</span></span> | <span data-ttu-id="b7a34-736">니들 강조 표시를 그리는 데 사용되는 색</span><span class="sxs-lookup"><span data-stu-id="b7a34-736">Color used to draw needle highlight</span></span> |
| <span data-ttu-id="b7a34-737">GX_COLOR_ID_SLIDER_NEEDLE_LINE2</span><span class="sxs-lookup"><span data-stu-id="b7a34-737">GX_COLOR_ID_SLIDER_NEEDLE_LINE2</span></span> | <span data-ttu-id="b7a34-738">니들 그림자를 그리는 데 사용되는 색입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-738">Color used to draw needle shadow</span></span> |

<span data-ttu-id="b7a34-739">이러한 색 ID 값은 각 디스플레이에 할당된 색상표로 정의된 특정 색 값에 매핑됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-739">These color ID values are mapped to a specific color value as defined by the color table assigned to each display.</span></span> <span data-ttu-id="b7a34-740">이러한 기본값을 ***gx_display_color_table_set*** API 함수를 호출하여 단일 디스플레이 그룹으로 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-740">These defaults can be changed as a group for one display by calling the ***gx_display_color_table_set*** API function.</span></span> <span data-ttu-id="b7a34-741">GUIX Studio를 사용하는 경우 애플리케이션에서 ***gx_studio_display_configure*** 함수를 호출하면 디스플레이 색상표가 자동으로 초기화됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-741">If you are using GUIX Studio, the display color table is automatically initialized when your application calls the ***gx_studio_display_configure*** function.</span></span>

<span data-ttu-id="b7a34-742">GUIX 디스플레이 구성 요소는 기본 글꼴 테이블도 유지 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-742">The GUIX display component also maintains a default font table.</span></span> <span data-ttu-id="b7a34-743">기본 글꼴 테이블은 애플리케이션에서 특별히 지정하지 않은 경우 각 위젯 유형에 사용되는 글꼴을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-743">The default font table defines the font used by each widget type unless specifically specified by the application.</span></span> <span data-ttu-id="b7a34-744">미리 정의된 디스플레이 글꼴 테이블 ID는 다음 값을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-744">The pre-defined display font table IDs include the following values.</span></span>

| <span data-ttu-id="b7a34-745">글꼴&nbsp;ID</span><span class="sxs-lookup"><span data-stu-id="b7a34-745">Font&nbsp;ID</span></span> | <span data-ttu-id="b7a34-746">Description</span><span class="sxs-lookup"><span data-stu-id="b7a34-746">Description</span></span> |
| ------------------ | --------------------------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="b7a34-747">GX_FONT_ID_DEFAULT</span><span class="sxs-lookup"><span data-stu-id="b7a34-747">GX_FONT_ID_DEFAULT</span></span> | <span data-ttu-id="b7a34-748">특정 글꼴을 정의하지 않을 때 사용되는 기본 글꼴</span><span class="sxs-lookup"><span data-stu-id="b7a34-748">Default font used when no specific font is defined</span></span> |
| <span data-ttu-id="b7a34-749">GX_FONT_ID_BUTTON</span><span class="sxs-lookup"><span data-stu-id="b7a34-749">GX_FONT_ID_BUTTON</span></span> | <span data-ttu-id="b7a34-750">단추의 모든 텍스트에 사용되는 기본 글꼴</span><span class="sxs-lookup"><span data-stu-id="b7a34-750">Default font used for all text on buttons</span></span> |
| <span data-ttu-id="b7a34-751">GX_FONT_ID_TEXT_INPUT</span><span class="sxs-lookup"><span data-stu-id="b7a34-751">GX_FONT_ID_TEXT_INPUT</span></span> | <span data-ttu-id="b7a34-752">텍스트 편집 필드에 사용되는 기본 글꼴</span><span class="sxs-lookup"><span data-stu-id="b7a34-752">Default font used for text edit fields</span></span> |

<span data-ttu-id="b7a34-753">텍스트 형식 위젯에 사용되는 글꼴 ID는 각 텍스트 관련 위젯 유형에 대해 제공되는 **gx_<widget_type>_font_set** API를 사용하여 다시 할당할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-753">The font ID used by any text type widget can be re-assigned by using the **gx_<widget_type>_font_set** API provided for each text-related widget type.</span></span> <span data-ttu-id="b7a34-754">**gx_display_font_table_set** API 함수를 호출하여 전체 글꼴 테이블을 다시 할당할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-754">The entire font table can be re-assigned by calling the **gx_display_font_table_set** API function.</span></span>

### <a name="scrollbar-appearance"></a><span data-ttu-id="b7a34-755">스크롤 막대 모양</span><span class="sxs-lookup"><span data-stu-id="b7a34-755">Scrollbar Appearance</span></span> 

<span data-ttu-id="b7a34-756">GUIX 디스플레이는 해당 디스플레이에 대한 기본 스크롤 막대 모양 설정도 유지 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-756">GUIX Display also maintains default scrollbar appearance settings for that display.</span></span> <span data-ttu-id="b7a34-757">이러한 설정은 아래에 정의된 **GX_SCROLLBAR_APPEARANCE** 구조로 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-757">These settings are defined by the **GX_SCROLLBAR_APPEARANCE** structure which is defined below.</span></span> <span data-ttu-id="b7a34-758">GUIX 디스플레이는 세로 스크롤 막대에 대한 하나의 스크롤 막대 모양 구조와 가로 스크롤 막대에 대한 두 번째 구조를 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-758">GUIX Display maintains one scrollbar appearance structure for vertical scrollbars and a second structure for horizontal scroll bars.</span></span> <span data-ttu-id="b7a34-759">애플리케이션은 **GX_SCROLLBAR_APPEARANCE** 구조체를 초기화하고 API 함수 ***gx_display_scroll_appearance_set*** 을 호출하여 디스플레이에 대한 기본 스크롤 막대 모양을 수정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-759">The application can modify the default scrollbar appearance for any display by initializing a **GX_SCROLLBAR_APPEARANCE** structure and invoking the API function ***gx_display_scroll_appearance_set***.</span></span>

```c
typedef struct GX_SCROLLBAR_APPEARANCE_STRUCT
{
    GX_VALUE       gx_scroll_width;
    GX_VALUE       gx_scroll_thumb_width;
    GX_VALUE       gx_scroll_thumb_travel_min;
    GX_VALUE       gx_scroll_thumb_travel_max;
    GX_UBYTE       gx_scroll_thumb_border_style;
    GX_RESOURCE_ID gx_scroll_fill_pixelmap;
    GX_RESOURCE_ID gx_scroll_thumb_pixelmap;
    GX_RESOURCE_ID gx_scroll_up_pixelmap;
    GX_RESOURCE_ID gx_scroll_down_pixelmap;
    GX_RESOURCE_ID gx_scroll_thumb_color;
    GX_RESOURCE_ID gx_scroll_thumb_border_color;
    GX_RESOURCE_ID gx_scroll_button_color;
} GX_SCROLLBAR_APPEARANCE;
```
| <span data-ttu-id="b7a34-760">GX_SCROLLBAR_APPEARANCE 구조체 멤버</span><span class="sxs-lookup"><span data-stu-id="b7a34-760">GX_SCROLLBAR_APPEARANCE Structure Member</span></span> | <span data-ttu-id="b7a34-761">Description</span><span class="sxs-lookup"><span data-stu-id="b7a34-761">Description</span></span> |
| --- | --- |
| <span data-ttu-id="b7a34-762">gx_scroll_width</span><span class="sxs-lookup"><span data-stu-id="b7a34-762">gx_scroll_width</span></span> | <span data-ttu-id="b7a34-763">세로 스크롤 막대의 너비 또는 가로 스크롤 막대의 높이(픽셀)입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-763">Width of a vertical scrollbar or height of a horizontal scrollbar, in pixels.</span></span> |
| <span data-ttu-id="b7a34-764">gx_scroll_thumb_width</span><span class="sxs-lookup"><span data-stu-id="b7a34-764">gx_scroll_thumb_width</span></span> | <span data-ttu-id="b7a34-765">엘리베이터 및 끝 단추의 너비(픽셀)입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-765">Width of the elevator and end buttons, in pixels.</span></span> |
| <span data-ttu-id="b7a34-766">gx_scroll_thumb_travel_max</span><span class="sxs-lookup"><span data-stu-id="b7a34-766">gx_scroll_thumb_travel_max</span></span> | <span data-ttu-id="b7a34-767">스크롤 막대의 끝에서 최대 엄지 단추 이동 지점까지의 오프셋입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-767">Offset from the end of scroll bar to maximum thumb button travel point.</span></span> |
| <span data-ttu-id="b7a34-768">gx_scroll_fill_pixelmap</span><span class="sxs-lookup"><span data-stu-id="b7a34-768">gx_scroll_fill_pixelmap</span></span> | <span data-ttu-id="b7a34-769">스크롤 배경을 채우는 데 사용되는 Pixelmap입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-769">Pixelmap used to fill scroll background.</span></span> |
| <span data-ttu-id="b7a34-770">gx_scroll_thumb_pixelmap</span><span class="sxs-lookup"><span data-stu-id="b7a34-770">gx_scroll_thumb_pixelmap</span></span> | <span data-ttu-id="b7a34-771">스크롤 엄지 단추를 그리는 데 사용되는 Pixelmap입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-771">Pixelmap used to draw scroll thumb button.</span></span> |
| <span data-ttu-id="b7a34-772">gx_scroll_up_pixelmap</span><span class="sxs-lookup"><span data-stu-id="b7a34-772">gx_scroll_up_pixelmap</span></span> | <span data-ttu-id="b7a34-773">위로 스크롤 단추를 그리는 데 사용되는 Pixelmap입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-773">Pixelmap used to draw scroll up button.</span></span> |
| <span data-ttu-id="b7a34-774">gx_scroll_down_pixelmap</span><span class="sxs-lookup"><span data-stu-id="b7a34-774">gx_scroll_down_pixelmap</span></span> | <span data-ttu-id="b7a34-775">아래로 스크롤 단추를 그리는 데 사용되는 Pixelmap입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-775">Pixelmap used to draw scroll down button.</span></span> |
| <span data-ttu-id="b7a34-776">gx_scroll_fill_color</span><span class="sxs-lookup"><span data-stu-id="b7a34-776">gx_scroll_fill_color</span></span> | <span data-ttu-id="b7a34-777">스크롤 막대 배경을 채우는 데 사용되는 색의 색 ID입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-777">Color ID of color used to fill scrollbar background.</span></span> |
| <span data-ttu-id="b7a34-778">gx_scroll_button_color</span><span class="sxs-lookup"><span data-stu-id="b7a34-778">gx_scroll_button_color</span></span> | <span data-ttu-id="b7a34-779">스크롤 막대 엄지 단추를 채우는 데 사용되는 색의 색 ID입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-779">Color ID of color used to fill scrollbar thumb button.</span></span> |

<span data-ttu-id="b7a34-780">글꼴, 색 및 스타일에 대한 이러한 기본 설정 외에도 애플리케이션은 각 위젯 형식에서 제공하는 API를 사용하여 필요에 따라 사례별로 매개 변수를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-780">In addition to these default settings for fonts, color, and styles, the application may specify any of the parameters on a case by case basis as desired using API provided by each widget type.</span></span>

### <a name="skinning-and-themes"></a><span data-ttu-id="b7a34-781">스키닝 및 테마</span><span class="sxs-lookup"><span data-stu-id="b7a34-781">Skinning and Themes</span></span>

<span data-ttu-id="b7a34-782">스키닝을 사용하면 GUIX 위젯 및 창이 기본 모양을 쉽게 변경할 수 있습니다. 즉, 한 곳에서 "스킨"을 변경하면 연결된 모든 위젯 및 창의 기본 모양이 변경됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-782">Skinning allows GUIX widgets and windows to easily change their base appearance, i.e., changing the “skin” in one place will change the base appearance of all associated widgets and windows.</span></span>

<span data-ttu-id="b7a34-783">GUIX 애플리케이션을 다시 스키닝하려면 GUIX 디스플레이 리소스 테이블에 새 색, 글꼴 및/또는 pixelmap 테이블을 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-783">Re-skinning your GUIX application requires that you supply a new color, font and or pixelmap table to the GUIX Display resource tables.</span></span> <span data-ttu-id="b7a34-784">모든 GUIX 위젯은 해당 색, 비트맵 또는 글꼴을 리소스 ID로 참조하므로 새 리소스 테이블을 제공하면 원하는 디스플레이에 자체적으로 그려질 때 모든 GUIX 위젯이 자동으로 새 색 및 pixelmap을 사용하기 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-784">Since all GUIX widgets refer to their color, bitmap, or font by resource ID, providing a new resource table automatically causes all GUIX widgets to begin using your new colors and pixelmaps when they draw themselves to the desired display.</span></span>

<span data-ttu-id="b7a34-785">멋진 모양을 제공하기 위해 함께 작동하도록 디자인된 새로운 글꼴, 색 및 pixelmap 세트를 *테마* 라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-785">A new set of fonts, colors, and pixelmaps that are designed to work together to provide an attractive appearance is called a *theme*.</span></span> <span data-ttu-id="b7a34-786">테마는 리소스 테이블 세트와 각 리소스 테이블의 크기를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-786">A theme defines a set of resource tables and the size of each resource table.</span></span> <span data-ttu-id="b7a34-787">GUIX Studio 애플리케이션을 사용하여 모든 디스플레이에 대해 제한 없는 수의 테마를 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-787">Any number of themes can be defined for any display using the GUIX Studio application.</span></span> <span data-ttu-id="b7a34-788">시작 테마 인덱스를 GUIX Studio 생성 함수 ***gx_studio_display_configure*** 에 전달해야 합니다. 이 함수는 만든 디스플레이에 초기 테마를 설치합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-788">You must pass the starting theme index to the GUIX Studio generated function ***gx_studio_display_configure***, which installs the initial theme into the created display.</span></span> <span data-ttu-id="b7a34-789">모든 디스플레이의 활성 테마는 ***gx_display_theme_install*** 함수를 호출하여 언제든지 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-789">The active theme for any display can be changed at any time by calling the function ***gx_display_theme_install***.</span></span>

### <a name="root-window"></a><span data-ttu-id="b7a34-790">루트 창</span><span class="sxs-lookup"><span data-stu-id="b7a34-790">Root Window</span></span>

<span data-ttu-id="b7a34-791">애플리케이션에서 만든 표시되는 각 캔버스에 대해 애플리케이션은 해당 캔버스에 대해 루트 창도 하나 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-791">For each visible canvas created by an application, the application must also create one Root Window for that canvas.</span></span> <span data-ttu-id="b7a34-792">이 특수 창은 기본적으로 모든 최상위 애플리케이션 창 및 위젯의 컨테이너 역할을 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-792">This special window basically acts as a container for all the top-level application windows and widgets.</span></span> <span data-ttu-id="b7a34-793">루트 창은 캔버스 배경을 그리며, **GX_WINDOW** 클래스에서 파생되므로 배경 무늬가 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-793">The root window draws the canvas background, and since the root window is derived from the **GX_WINDOW** class the root window can also have wallpaper.</span></span> <span data-ttu-id="b7a34-794">디스플레이 또는 캔버스의 배경색을 변경하려면 해당 캔버스에 연결된 루트 창의 채우기 색을 변경하기만 하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-794">To change the background color of your display or canvas, you simply change the fill color of the root window attached to that canvas.</span></span>

<span data-ttu-id="b7a34-795">***gx_studio_display_configure*** 라는 GUIX Studio 생성 함수를 사용하여 디스플레이를 구성하는 경우 각 디스플레이의 캔버스 및 루트 창이 이 초기화 함수의 일부로 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-795">If you use the GUIX Studio generated function named ***gx_studio_display_configure*** to configure your displays, then the canvas and root window for each display are created for you as part of this initialization function.</span></span>

### <a name="anti-aliasing"></a><span data-ttu-id="b7a34-796">앤티앨리어싱</span><span class="sxs-lookup"><span data-stu-id="b7a34-796">Anti-Aliasing</span></span> 

<span data-ttu-id="b7a34-797">앤티앨리어싱은 선, 곡선 및 글꼴을 부드럽게 하는 데 사용되는 GUIX의 선택적 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-797">Anti-Aliasing is an optional feature in GUIX that is used to smooth lines, curves, and fonts.</span></span> <span data-ttu-id="b7a34-798">앤티앨리어싱은 16bpp 이상의 색 농도를 활용하여 디스플레이 드라이버에서 실행될 때만 지원됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-798">Anti-aliasing is only supported when running with a display driver utilizing 16-bpp or higher color depth.</span></span>

<span data-ttu-id="b7a34-799">활성 브러시에서 **GX_BRUSH_ALIAS** 플래시를 설정하여 앤티앨리어싱된 선 그리기를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-799">Anti-aliased line drawing is enabled by setting the **GX_BRUSH_ALIAS** flash in the active brush.</span></span> <span data-ttu-id="b7a34-800">이러한 방식은 다각형 또는 원의 테두리로 그린 선뿐만 아니라 직접 그린 선에도 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-800">This applies to lines drawn directly as well as to lines drawn as the border of a polygon or circle.</span></span>

<span data-ttu-id="b7a34-801">앤티앨리어싱된 텍스트 그리기는 GUIX Studio 애플리케이션에서 생성하는 앤티앨리어싱 글꼴을 사용하여 지원됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-801">Anti-aliased text drawing is enabled by using an anti-aliased font which is produced by the GUIX studio application.</span></span> <span data-ttu-id="b7a34-802">글꼴을 만들 때 글꼴이 앤티앨리어싱 또는 바이너리 중 어떤 방식으로 생성되어야 하는지를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-802">You specify whether a font should be generated as antialiased or binary when you create the font.</span></span>
<span data-ttu-id="b7a34-803">GUIX의 앤티앨리어싱 글꼴은 각 픽셀에 대해 16가지 수준의 투명도를 활용합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-803">Anti-aliased fonts in GUIX utilize 16 levels of transparency for each pixel.</span></span>

### <a name="clipping"></a><span data-ttu-id="b7a34-804">클리핑</span><span class="sxs-lookup"><span data-stu-id="b7a34-804">Clipping</span></span> 

<span data-ttu-id="b7a34-805">클리핑은 GUIX 디스플레이 구성 요소에서 내부적으로, 그리고 GUIX 위젯에서 유지 관리되는 부모-자식 아키텍처에 따라 창 및 위젯 계층에서 지원됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-805">Clipping is supported internally by the GUIX display component, and at the window and widget layers by the parent-child architecture maintained by GUIX widgets.</span></span> <span data-ttu-id="b7a34-806">창이나 위젯을 해당 위젯의 영역 외부에 그릴 수 없으며, 창은 해당 위젯의 부모 영역 외부에 절대 그릴 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-806">No window or widget is ever allowed to draw outside of that widget’s area, and a widget is never allowed to draw outside of the area of that widget’s parent.</span></span>

<span data-ttu-id="b7a34-807">따라서 위젯을 캔버스 메모리 외부에 있는 픽셀 좌표에 그려 메모리 손상이나 시스템 오류를 야기하는 상황이 방지됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-807">This also prevents widgets from drawing at pixel coordinates that lay outside of the canvas memory which likely lead to memory corruption or a system failure.</span></span> <span data-ttu-id="b7a34-808">위젯은 위젯의 영역, 위젯의 부모 영역 또는 캔버스 범위를 벗어나 그릴 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-808">Widgets are not allowed to draw outside of the widget’s area, the widget’s parent area, or beyond the canvas extent.</span></span>

<span data-ttu-id="b7a34-809">또한 위젯은 이전에 더티로 표시된 영역에만 그릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-809">In addition, widgets can only draw to areas that have previously been marked as dirty.</span></span> <span data-ttu-id="b7a34-810">따라서 창의 구석만 표시되는 경우처럼 전체 창이 그려지지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-810">This prevents an entire window being drawn, for example, when only a corner of the window has been revealed.</span></span> <span data-ttu-id="b7a34-811">실제로 새로 고쳐야 하는 창의 부분만 더티로 표시되므로 창 그리기 함수는 실제로 더티 영역의 픽셀만 새로 고칩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-811">Only the portion of the window that actually needs to be refreshed is marked as dirty, and so the window drawing function only truly refreshes pixels in the dirty area.</span></span>

<span data-ttu-id="b7a34-812">GUIX 디스플레이 구성 요소는 드라이버 수준 그리기 함수를 호출하기 전에 이러한 클리핑 알고리즘을 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-812">The GUIX dispaly component enforces these clipping algorithms before invoking the driver level drawing functions.</span></span>

### <a name="views"></a><span data-ttu-id="b7a34-813">보기</span><span class="sxs-lookup"><span data-stu-id="b7a34-813">Views</span></span> 

<span data-ttu-id="b7a34-814">GUIX는 항상 각 루트 창 및 루트 창의 각 자식 창에 대한 뷰 세트를 유지 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-814">GUIX always maintains a set of views for each root window and each child window of the root window.</span></span> <span data-ttu-id="b7a34-815">뷰는 창 위치 및 Z 순서로 변경되는 런타임에 결정되는 동적 클리핑 영역입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-815">Views are a dynamic, run-time determined clipping area that changes as window position and Z-order are modified.</span></span>
<span data-ttu-id="b7a34-816">GUIX는 뷰를 사용하여 배경의 창이나 위젯이 전경의 창이나 위젯 위에 그려지지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-816">GUIX uses views to prevent a window or widget in the background from drawing on top of a window or widget in the foreground.</span></span> <span data-ttu-id="b7a34-817">뷰는 Z-순서 규칙을 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-817">Views enforce Z-order discipline.</span></span> <span data-ttu-id="b7a34-818">또한 뷰는 배경의 창을 보이지 않는 캔버스 영역에 그리지 않도록 한다는 측면에서 효율적입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-818">In addition, views are important for efficiency in that they prevent a window in the background from drawing to any area of the canvas that cannot be seen.</span></span> <span data-ttu-id="b7a34-819">창이 다른 창으로 완전히 덮이면 덮인 창을 캔버스에 그리려고 해도 그렇게 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-819">If a window is completely covered by another window, the covered window will not be allowed to draw to the canvas at all, even if it is attempting to do so.</span></span>

### <a name="display-driver-interface"></a><span data-ttu-id="b7a34-820">디스플레이 드라이버 인터페이스</span><span class="sxs-lookup"><span data-stu-id="b7a34-820">Display Driver Interface</span></span> 

<span data-ttu-id="b7a34-821">GUIX 디스플레이 드라이버는 기본 물리적 화면과의 모든 상호 작용을 담당합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-821">GUIX display drivers are responsible for all interaction with the underlying physical screen.</span></span> <span data-ttu-id="b7a34-822">디스플레이 드라이버에는 초기화, 그리기 및 프레임 버퍼 디스플레이의 세 가지 기본 기능이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-822">The display drivers have three basic functions: initialization, drawing, and frame buffer display.</span></span>
<span data-ttu-id="b7a34-823">초기화는 물리적 디스플레이 하드웨어를 준비하고, 물리적 디스플레이 하드웨어의 속성을 GUIX에 알리고, 사용해야 하는 특정 그리기 함수를 GUIX에 알립니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-823">Initialization is responsible for preparing the physical display hardware, informing GUIX of the properties of the physical display hardware, and for informing GUIX which specific drawing functions should be used.</span></span> <span data-ttu-id="b7a34-824">기본 디스플레이 드라이버 초기화는 GUIX ***gx_display_create*** 함수에서 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-824">The main display driver initialization is called from the GUIX ***gx_display_create*** function.</span></span> <span data-ttu-id="b7a34-825">또한 GUIX 스레드는 스레드 컨텍스트에서 보조 디스플레이 드라이버 초기화도 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-825">In addition, the GUIX thread will also call a secondary display driver initialization from the thread context.</span></span> <span data-ttu-id="b7a34-826">이 보조 디스플레이 드라이버는 초기화하는 동안 RTOS 서비스가 필요한 경우(예: 초기화 프로세스의 단계 간 지연을 위한 ***tx_thread_sleep*** 요청 또는 디바이스 인터럽트)에만 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-826">This secondary display driver is only needed if the driver requires RTOS services during its initialization, e.g., device interrupts or ***tx_thread_sleep*** requests for delay between steps in the initialization process.</span></span>

<span data-ttu-id="b7a34-827">초기화가 완료되면 디스플레이 드라이버는 물리적 디스플레이 하드웨어에서 수행할 수 있는 모든 직접 그리기를 진행합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-827">Once initialization is complete, the display driver is responsible for any direct drawing that can be done in the physical display hardware.</span></span>
<span data-ttu-id="b7a34-828">마지막으로 디스플레이 드라이버는 프레임 버퍼를 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-828">Finally, the display driver is responsible for displaying the frame buffer.</span></span>

## <a name="guix-widget-component"></a><span data-ttu-id="b7a34-829">GUIX 위젯 구성 요소</span><span class="sxs-lookup"><span data-stu-id="b7a34-829">GUIX Widget Component</span></span>

<span data-ttu-id="b7a34-830">GUIX 위젯은 표시되는 그래픽 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-830">A GUIX widget is a visible graphical element.</span></span> <span data-ttu-id="b7a34-831">타이머 및 수학 유틸리티 함수와 같이 표시되지 않는 GUIX 구성 요소가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-831">There are GUIX components which are not visible, such as timers and math utility functions.</span></span>
<span data-ttu-id="b7a34-832">그러나 표시되는 모든 구성 요소는 기본 GUIX 위젯 구성 요소에서 파생됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-832">However all visible components are derived from the basic GUIX widget component.</span></span> <span data-ttu-id="b7a34-833">GUIX 위젯은 GUIX 디스플레이의 기본 구성 요소입니다. 다른 모든 그래픽 요소는 기본 위젯 기능에서 파생됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-833">A GUIX widget is the primary building block of the GUIX display – all other graphic elements are derived from the base widget functionality.</span></span>

<span data-ttu-id="b7a34-834">GUIX 위젯은 상속을 완벽하게 지원하는 개체 지향 방식으로 구현됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-834">GUIX widgets are implemented in an object oriented manner with full support of inheritance.</span></span> <span data-ttu-id="b7a34-835">이를 위해 ANSI C를 사용하므로 메모리 및 처리 요구 사항을 최소화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-835">This is accomplished using ANSI C, which results in the smallest possible memory and processing requirements.</span></span> <span data-ttu-id="b7a34-836">**GX_BUTTON** 과 같은 특정 위젯을 사용하는 경우 기본 **GX_WIDGET** 과 같은 다른 위젯에서 *파생* 된다는 것은 **GX_BUTTON** 제어 구조체에 **GX_WIDGET** 의 모든 멤버 변수 및 함수 포인터가 포함되어 있고 **GX_BUTTON** 에만 적용되는 몇 가지 추가 변수가 있다는 것을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-836">When we speak of one particular widget, such as **GX_BUTTON**, being *derived from* another widget, such as the base **GX_WIDGET**, what we mean is that the **GX_BUTTON** control structure contains all of the member variables and function pointers of **GX_WIDGET**, with some additional variables that are specific to **GX_BUTTON**.</span></span> <span data-ttu-id="b7a34-837">GUIX는 이러한 방식으로 위젯의 계층을 구성하므로 더 복잡한 위젯은 항상 더 간단한 위젯을 기준으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-837">GUIX builds up layers of widgets in this fashion, so that more complex widgets are always based on a simpler widget before them.</span></span> <span data-ttu-id="b7a34-838">이 계층형 파생 모델을 통해 위젯 매개 변수를 수정하는 데 사용되는 API를 보다 쉽게 학습할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-838">This hierarchical model of derivation makes it easier to learn the APIs used to modify widget parameters.</span></span> <span data-ttu-id="b7a34-839">단추의 색을 수정하려는 경우 위젯 색을 수정하는 데 사용하는 것과 동일한 API, 즉 ***gx_widget_fill_color_set*** 을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-839">If you want to modify the color of a button, you use the same API you use to modify the color of a widget, namely ***gx_widget_fill_color_set***.</span></span>

<span data-ttu-id="b7a34-840">표시되는 위젯의 구성은 자식 위젯을 부모에 연결하는 트리 구조 목록을 사용하여 부모-자식 방식으로 유지 관리됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-840">The organization of visible widgets is maintained in a parent-child manner using tree structured lists linking child widgets to their parents.</span></span> <span data-ttu-id="b7a34-841">자식은 그릴 수 있는 뷰 및 그리는 캔버스와 같은 특성을 부모로부터 상속합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-841">The children inherit characteristics from their parents such as the views into which they can draw and the canvas on which they draw.</span></span>
<span data-ttu-id="b7a34-842">자식 위젯은 자체 자식 위젯이 있을 수 있으며 이러한 자식 역시 부모로부터 다양한 특성을 상속합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-842">Child widgets may have their own child widgets, again inheriting various characteristics from the parent.</span></span> <span data-ttu-id="b7a34-843">다양한 GUIX API 호출을 통해 모든 위젯의 특성을 명시적으로 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-843">The characteristics of any widget may be explicitly redefined via various GUIX API calls.</span></span>

### <a name="widget-creation"></a><span data-ttu-id="b7a34-844">위젯 만들기</span><span class="sxs-lookup"><span data-stu-id="b7a34-844">Widget Creation</span></span> 

<span data-ttu-id="b7a34-845">위젯 개체는 초기화 동안 또는 애플리케이션 스레드를 실행하는 동안 언제든지 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-845">A widget object can be created during initialization or anytime during the execution of application threads.</span></span> <span data-ttu-id="b7a34-846">애플리케이션에서 만들 수 있는 위젯 개체 수에는 제한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-846">There is no limit on the number of widget objects that can be created by an application.</span></span> <span data-ttu-id="b7a34-847">대상 하드웨어의 메모리 제한 내에서 위젯에 포함될 수 있는 자식 수에도 제한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-847">There is also no limit on the number of children any widget may have, within the memory limits of your target hardware.</span></span>

<span data-ttu-id="b7a34-848">각 위젯 유형에는 \***gx_button_create** _ 또는 _ \*_gx_prompt_create_\*\*와 같은 고유한 만들기 함수가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-848">Each widget type has its own create function, such as ***gx_button_create** _ or _*_gx_prompt_create_\*\*.</span></span> <span data-ttu-id="b7a34-849">이러한 함수에 대한 처음 세 매개 변수인 위젯 제어 구조체에 대한 포인터, 위젯 이름에 대한 문자열 포인터 및 위젯의 부모에 대한 포인터는 항상 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-849">The first three parameters to these functions are always the same, namely a pointer to the widget control structure, a string pointer to the widget name, and a pointer to the widget’s parent.</span></span> <span data-ttu-id="b7a34-850">각 만들기 함수에는 특정 위젯 형식의 요구 사항에 따라 제한 없는 수의 추가 매개 변수를 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-850">Each create function may have any number of additional parameters depending on the requirements of that particular widget type.</span></span>

### <a name="widget-control-block"></a><span data-ttu-id="b7a34-851">위젯 제어 블록</span><span class="sxs-lookup"><span data-stu-id="b7a34-851">Widget Control Block</span></span> 

<span data-ttu-id="b7a34-852">각 위젯 개체의 특성은 해당 제어 블록 **GX_WIDGET** 에서 찾을 수 있으며 **_gx_api.h_** 에 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-852">The characteristics of each widget object are found in its control block **GX_WIDGET** and are defined in **_gx_api.h_**.</span></span> <span data-ttu-id="b7a34-853">위젯 개체에 필요한 메모리는 애플리케이션이 제공하며 메모리의 어느 위치에나 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-853">The memory required for a widget object is provided by the application and can be located anywhere in memory.</span></span> <span data-ttu-id="b7a34-854">그러나 함수 범위 외부에서 정의하여 위젯 개체 제어 블록이 전역 구조를 차단하도록 하는 것이 가장 일반적입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-854">However, it is most common to make the widget object control block a global structure by defining it outside the scope of any function.</span></span> <span data-ttu-id="b7a34-855">GUIX Studio를 사용하는 경우 위젯 제어 블록은 Studio 생성 사양 파일 내에서 정적으로 할당되거나 애플리케이션을 통해 동적으로 할당될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-855">If you are using GUIX Studio, your widget control blocks can be statically allocated within your Studio generated specifications file, or they can be dynamically allocated by your application.</span></span>

### <a name="dynamic-widget-control-block-allocation-and-de-allocation"></a><span data-ttu-id="b7a34-856">동적 위젯 제어 블록 할당 및 할당 취소</span><span class="sxs-lookup"><span data-stu-id="b7a34-856">Dynamic Widget Control Block Allocation and De-allocation</span></span> 

<span data-ttu-id="b7a34-857">동적 제어 블록 할당을 사용하는 경우 GUIX에서 위젯 제어 블록에 필요한 메모리를 할당하고 해제하는 데 사용하는 두 가지 함수를 정의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-857">If you are using dynamic control block allocation, you will need to define two functions that GUIX will use to allocate and free the memory required for your widget control blocks.</span></span> <span data-ttu-id="b7a34-858">메모리 관리용 함수는 ***gx_system_memory_allocator_set*** API 함수를 통해 GUIX 시스템 구성 요소에 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-858">Your functions for memory management are passed to the GUIX system component via the ***gx_system_memory_allocator_set*** API function.</span></span> <span data-ttu-id="b7a34-859">이 함수를 사용하면 두 개의 함수 포인터를 GUIX에 전달할 수 있습니다. 첫 번째는 메모리 할당 함수에 대한 포인터이고 두 번째는 메모리 해제 함수에 대한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-859">This function allows you to pass two function pointers into GUIX: the first is a pointer to a memory allocation function, and the second is a pointer to a memory free function.</span></span> <span data-ttu-id="b7a34-860">ThreadX 바이트 풀을 사용하여 이러한 함수를 구현하는 경우가 가장 많지만 GUIX 디자인을 사용하면 원하는 방식으로 동적 메모리 관리를 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-860">Most often, you will implement these functions using ThreadX byte pools, but the design of GUIX allows you to implement dynamic memory management in whatever way you prefer.</span></span>

<span data-ttu-id="b7a34-861">Studio 위젯 속성 필드에서 "동적으로 할당" 옵션을 선택하면 Studio에서 생성된 애플리케이션 사양 파일 내에서 동적 위젯 할당이 주로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-861">Dynamic widget allocation is most often employed within your Studio generated application specifications file, when you select the “dynamically allocated” option in the Studio widget properties field.</span></span> <span data-ttu-id="b7a34-862">그러나 애플리케이션 내에서 동적 제어 블록 할당을 사용할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-862">However, you can also use dynamic control block allocation within your application.</span></span> <span data-ttu-id="b7a34-863">애플리케이션 내에서 동적 제어 블록 할당을 사용하는 경우 \***gx_widget_allocate** _ API 함수를 호출하여 위젯 제어 블록을 할당해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-863">If you use dynamic control block allocation within your application, you should invoke the \***gx_widget_allocate** _ API function to allocate the widget control block.</span></span> <span data-ttu-id="b7a34-864">그런 다음, 위젯을 만들 때 사용자가 _ *GX_WIDGET_STYLE_DYNAMICALLY_ALLOCATED*\* 스타일 플래그(기타 필요한 스타일 플래그와 함께)를 위젯 만들기 함수로 전달하도록 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-864">Next, when you create the widget, make certain you pass the _ *GX_WIDGET_STYLE_DYNAMICALLY_ALLOCATED*\* style flag (along with any other needed style flags) to the widget create function.</span></span> <span data-ttu-id="b7a34-865">이 플래그는 위젯을 위젯 상태 필드에 동적으로 할당된 것으로 표시하는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-865">This flag is used to mark the widget as being dynamically allocated in the widget status field.</span></span> <span data-ttu-id="b7a34-866">**_gx_widget_delete_** 를 사용하여 나중에 위젯을 삭제하는 경우, GUIX는 이 상태 필드를 확인하고 메모리 누수가 없도록 메모리 할당 취소 함수를 자동으로 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-866">When and if the widget is later deleted using **_gx_widget_delete_**, GUIX will check this status field and automatically call your memory de-allocator function to insure there are no memory leaks.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="b7a34-867">동적으로 할당된 제어 블록을 사용하여 만든 위젯은 메모리 손실을 방지하기 위해 **GX_WIDGET_STYLE_DYNAMICALLY_ALLOCATED** 스타일 플래그를 사용하여 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-867">A widget created using a dynamically allocated control block must be created with the **GX_WIDGET_STYLE_DYNAMICALLY_ALLOCATED** style flag to prevent memory loss.</span></span>

### <a name="types"></a><span data-ttu-id="b7a34-868">형식</span><span class="sxs-lookup"><span data-stu-id="b7a34-868">Types</span></span>

<span data-ttu-id="b7a34-869">GUIX는 다양한 기능을 갖춘 기본 제공 위젯 세트를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-869">GUIX provides a rich, fully functional set of built-in widgets.</span></span> <span data-ttu-id="b7a34-870">앞에서 설명한 것처럼 모든 특수 위젯은 기본 위젯에서 파생됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-870">As mentioned previously, all specialized widgets are derived from the base widget.</span></span> <span data-ttu-id="b7a34-871">다음은 GUIX의 기본 제공 위젯 목록입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-871">Following is a list of the built-in widgets in GUIX:</span></span>

<span data-ttu-id="b7a34-872">**GX_TYPE_WIDGET**</span><span class="sxs-lookup"><span data-stu-id="b7a34-872">**GX_TYPE_WIDGET**</span></span>

<span data-ttu-id="b7a34-873">**GX_TYPE_BUTTON**</span><span class="sxs-lookup"><span data-stu-id="b7a34-873">**GX_TYPE_BUTTON**</span></span>

<span data-ttu-id="b7a34-874">**GX_TYPE_TEXT_BUTTON**</span><span class="sxs-lookup"><span data-stu-id="b7a34-874">**GX_TYPE_TEXT_BUTTON**</span></span>

<span data-ttu-id="b7a34-875">**GX_TYPE_MULTI_LINE_TEXT_BUTTON**</span><span class="sxs-lookup"><span data-stu-id="b7a34-875">**GX_TYPE_MULTI_LINE_TEXT_BUTTON**</span></span>

<span data-ttu-id="b7a34-876">**GX_TYPE_RADIO_BUTTON**</span><span class="sxs-lookup"><span data-stu-id="b7a34-876">**GX_TYPE_RADIO_BUTTON**</span></span>

<span data-ttu-id="b7a34-877">**GX_TYPE_CHECKBOX**</span><span class="sxs-lookup"><span data-stu-id="b7a34-877">**GX_TYPE_CHECKBOX**</span></span>

<span data-ttu-id="b7a34-878">**GX_TYPE_PIXELMAP_BUTTON**</span><span class="sxs-lookup"><span data-stu-id="b7a34-878">**GX_TYPE_PIXELMAP_BUTTON**</span></span>

<span data-ttu-id="b7a34-879">**GX_TYPE_ICON_BUTTON**</span><span class="sxs-lookup"><span data-stu-id="b7a34-879">**GX_TYPE_ICON_BUTTON**</span></span>

<span data-ttu-id="b7a34-880">**GX_TYPE_ICON**</span><span class="sxs-lookup"><span data-stu-id="b7a34-880">**GX_TYPE_ICON**</span></span>

<span data-ttu-id="b7a34-881">**GX_TYPE_SPRITE**</span><span class="sxs-lookup"><span data-stu-id="b7a34-881">**GX_TYPE_SPRITE**</span></span>

<span data-ttu-id="b7a34-882">**GX_TYPE_SLIDER**</span><span class="sxs-lookup"><span data-stu-id="b7a34-882">**GX_TYPE_SLIDER**</span></span>

<span data-ttu-id="b7a34-883">**GX_TYPE_PIXELMAP_SLIDER**</span><span class="sxs-lookup"><span data-stu-id="b7a34-883">**GX_TYPE_PIXELMAP_SLIDER**</span></span>

<span data-ttu-id="b7a34-884">**GX_TYPE_VERTICAL_SCROLL**</span><span class="sxs-lookup"><span data-stu-id="b7a34-884">**GX_TYPE_VERTICAL_SCROLL**</span></span>

<span data-ttu-id="b7a34-885">**GX_TYPE_HORIZONTAL_SCROLL**</span><span class="sxs-lookup"><span data-stu-id="b7a34-885">**GX_TYPE_HORIZONTAL_SCROLL**</span></span>

<span data-ttu-id="b7a34-886">**GX_TYPE_PROGRESS_BAR**</span><span class="sxs-lookup"><span data-stu-id="b7a34-886">**GX_TYPE_PROGRESS_BAR**</span></span>

<span data-ttu-id="b7a34-887">**GX_TYPE_PROMPT**</span><span class="sxs-lookup"><span data-stu-id="b7a34-887">**GX_TYPE_PROMPT**</span></span>

<span data-ttu-id="b7a34-888">**GX_TYPE_NUMERIC_PROMPT**</span><span class="sxs-lookup"><span data-stu-id="b7a34-888">**GX_TYPE_NUMERIC_PROMPT**</span></span>

<span data-ttu-id="b7a34-889">**GX_TYPE_PIXELMAP_PROMPT**</span><span class="sxs-lookup"><span data-stu-id="b7a34-889">**GX_TYPE_PIXELMAP_PROMPT**</span></span>

<span data-ttu-id="b7a34-890">**GX_TYPE_NUMERIC_PIXELMAP_PROMPT**</span><span class="sxs-lookup"><span data-stu-id="b7a34-890">**GX_TYPE_NUMERIC_PIXELMAP_PROMPT**</span></span>

<span data-ttu-id="b7a34-891">**GX_TYPE_SINGLE_LINE_TEXT_INPUT**</span><span class="sxs-lookup"><span data-stu-id="b7a34-891">**GX_TYPE_SINGLE_LINE_TEXT_INPUT**</span></span>

<span data-ttu-id="b7a34-892">**GX_TYPE_MULTI_LINE_TEXT_VIEW**</span><span class="sxs-lookup"><span data-stu-id="b7a34-892">**GX_TYPE_MULTI_LINE_TEXT_VIEW**</span></span>

<span data-ttu-id="b7a34-893">**GX_TYPE_MULTI_LINE_TEXT_INPUT**</span><span class="sxs-lookup"><span data-stu-id="b7a34-893">**GX_TYPE_MULTI_LINE_TEXT_INPUT**</span></span>

<span data-ttu-id="b7a34-894">**GX_TYPE_WINDOW**</span><span class="sxs-lookup"><span data-stu-id="b7a34-894">**GX_TYPE_WINDOW**</span></span>

<span data-ttu-id="b7a34-895">**GX_TYPE_ROOT_WINDOW**</span><span class="sxs-lookup"><span data-stu-id="b7a34-895">**GX_TYPE_ROOT_WINDOW**</span></span>

<span data-ttu-id="b7a34-896">**GX_TYPE_VERTICAL_LIST**</span><span class="sxs-lookup"><span data-stu-id="b7a34-896">**GX_TYPE_VERTICAL_LIST**</span></span>

<span data-ttu-id="b7a34-897">**GX_TYPE_HORIZONTAL_LIST**</span><span class="sxs-lookup"><span data-stu-id="b7a34-897">**GX_TYPE_HORIZONTAL_LIST**</span></span>

<span data-ttu-id="b7a34-898">**GX_TYPE_POPUP_LIST**</span><span class="sxs-lookup"><span data-stu-id="b7a34-898">**GX_TYPE_POPUP_LIST**</span></span>

<span data-ttu-id="b7a34-899">**GX_TYPE_DROP_LIST**</span><span class="sxs-lookup"><span data-stu-id="b7a34-899">**GX_TYPE_DROP_LIST**</span></span>

<span data-ttu-id="b7a34-900">**GX_TYPE_LINE_CHART**</span><span class="sxs-lookup"><span data-stu-id="b7a34-900">**GX_TYPE_LINE_CHART**</span></span>

<span data-ttu-id="b7a34-901">**GX_TYPE_DIALOG**</span><span class="sxs-lookup"><span data-stu-id="b7a34-901">**GX_TYPE_DIALOG**</span></span>

<span data-ttu-id="b7a34-902">**GX_TYPE_KEYBOARD**</span><span class="sxs-lookup"><span data-stu-id="b7a34-902">**GX_TYPE_KEYBOARD**</span></span>

<span data-ttu-id="b7a34-903">**GX_TYPE_SCROLL_WHEEL**</span><span class="sxs-lookup"><span data-stu-id="b7a34-903">**GX_TYPE_SCROLL_WHEEL**</span></span>

<span data-ttu-id="b7a34-904">**GX_TYPE_TEXT_SCROLL_WHEEL**</span><span class="sxs-lookup"><span data-stu-id="b7a34-904">**GX_TYPE_TEXT_SCROLL_WHEEL**</span></span>

<span data-ttu-id="b7a34-905">**GX_TYPE_STRING_SCROLL_WHEEL**</span><span class="sxs-lookup"><span data-stu-id="b7a34-905">**GX_TYPE_STRING_SCROLL_WHEEL**</span></span>

<span data-ttu-id="b7a34-906">**GX_TYPE_NUMERIC_SCROLL_WHEEL**</span><span class="sxs-lookup"><span data-stu-id="b7a34-906">**GX_TYPE_NUMERIC_SCROLL_WHEEL**</span></span>

<span data-ttu-id="b7a34-907">**GX_TYPE_CIRCULAR_GAUGE**</span><span class="sxs-lookup"><span data-stu-id="b7a34-907">**GX_TYPE_CIRCULAR_GAUGE**</span></span>

<span data-ttu-id="b7a34-908">**GX_TYPE_RADIAL_PROGRESS_BAR**</span><span class="sxs-lookup"><span data-stu-id="b7a34-908">**GX_TYPE_RADIAL_PROGRESS_BAR**</span></span>

<span data-ttu-id="b7a34-909">**GX_TYPE_RADIAL_SLIDER**</span><span class="sxs-lookup"><span data-stu-id="b7a34-909">**GX_TYPE_RADIAL_SLIDER**</span></span>

<span data-ttu-id="b7a34-910">**GX_TYPE_MENU_LIST**</span><span class="sxs-lookup"><span data-stu-id="b7a34-910">**GX_TYPE_MENU_LIST**</span></span>

<span data-ttu-id="b7a34-911">**GX_TYPE_MENU**</span><span class="sxs-lookup"><span data-stu-id="b7a34-911">**GX_TYPE_MENU**</span></span>

<span data-ttu-id="b7a34-912">**GX_TYPE_ACCORDION_MENU**</span><span class="sxs-lookup"><span data-stu-id="b7a34-912">**GX_TYPE_ACCORDION_MENU**</span></span>

<span data-ttu-id="b7a34-913">**GX_TYPE_TREE_VIEW**</span><span class="sxs-lookup"><span data-stu-id="b7a34-913">**GX_TYPE_TREE_VIEW**</span></span>


### <a name="styles"></a><span data-ttu-id="b7a34-914">스타일</span><span class="sxs-lookup"><span data-stu-id="b7a34-914">Styles</span></span>

<span data-ttu-id="b7a34-915">위젯 스타일은 앞에서 설명한 대로 특정 위젯 형식에 대한 속성 뿐만 아니라 테두리 속성(볼록, 오목, 가늘게, 굵게 또는 테두리 없음)과 같은 항목으로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-915">Widget styles consist of things like border properties (raised, recessed, thin, thick, or no boarder at all) as well as properties for specific widget types, as listed previously.</span></span> <span data-ttu-id="b7a34-916">위젯 스타일 플래그는 위젯의 모양을 수정하는 가장 간단한 방법을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-916">The widget style flags offer the simplest method for modifying the appearance of any widget.</span></span>
<span data-ttu-id="b7a34-917">초기 위젯 스타일은 항상 위젯 유형 특정 만들기 함수로 전달되는 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-917">The initial widget style is always a parameter passed to the widget type specific create function.</span></span>

### <a name="colors"></a><span data-ttu-id="b7a34-918">색</span><span class="sxs-lookup"><span data-stu-id="b7a34-918">Colors</span></span> 

<span data-ttu-id="b7a34-919">위젯은 시스템 색 테이블에 정의된 색을 사용하여 자신을 그립니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-919">Widgets draw themselves using colors defined in the system color table.</span></span>
<span data-ttu-id="b7a34-920">색 ID는 캔버스 배경, 기본 위젯 채우기 색, 단추 채우기 색, 텍스트 위젯 채우기 색, 창 채우기 색 및 기타 여러 기본 색 값에 대해 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-920">Color IDs are defined for canvas background, default widget fill color, button fill color, text widget fill color, window fill color, and several other default color values.</span></span> <span data-ttu-id="b7a34-921">또한 **GX_WINDOW** 개체는 창 클라이언트가 채워질 때 비트맵 또는 배경 화면을 표시하도록 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-921">In addition, **GX_WINDOW** objects support displaying a bitmap or wallpaper as the window client is filled.</span></span>

<span data-ttu-id="b7a34-922">기본 색 구성표를 변경하는 가장 간단한 방법은 GUIX Studio를 사용하여 요구 사항을 충족하는 색 구성표를 만들거나 정의하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-922">The simplest method of changing the default color scheme is to use GUIX Studio and create or define a color scheme that meets your requirements.</span></span>
<span data-ttu-id="b7a34-923">GX_COLOR 값의 배열을 만들고 gx_system_color_table_set API 함수를 호출하여 색 구성표를 수동으로 정의할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-923">You can also define your color scheme manually by creating an array of GX_COLOR values and invoking the gx_system_color_table_set API function.</span></span>

### <a name="event-notification"></a><span data-ttu-id="b7a34-924">이벤트 알림</span><span class="sxs-lookup"><span data-stu-id="b7a34-924">Event Notification</span></span> 

<span data-ttu-id="b7a34-925">GUIX 이벤트는 특정 작업을 수행하고 사용자 입력 및 내부 시스템 상태 변경 내용을 위젯에 알리기 위해 하나 이상의 위젯에 대해 수행되는 요청입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-925">GUIX events are requests made to one or more widgets to perform a particular action and notifications to notify widgets of user input and internal system status changes.</span></span> <span data-ttu-id="b7a34-926">예를 들어, 위젯이 포커스를 얻으면 **GX_EVENT_FOCUS_GAINED** 가 ***gx_system_event_send*** API 서비스를 통해 위젯에 전송됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-926">For example, when a widget gains focus, the **GX_EVENT_FOCUS_GAINED** is sent to the widget via the ***gx_system_event_send*** API service.</span></span>

<span data-ttu-id="b7a34-927">이벤트는 GUIX 이벤트 큐를 통해 전달되며 각 이벤트는 **GX_EVENT** 데이터 구조의 인스턴스입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-927">Events are passed through the GUIX event queue, and each event is an instance of the **GX_EVENT** data structure.</span></span> <span data-ttu-id="b7a34-928">**GX_EVENT** 데이터 구조는 ***gx_api.h*** 에 정의되어 있지만 구조체에서 가장 중요한 필드는 **gx_event_type**, **gx_event_sender**, **gx_event_target** 및 **gx_event_payload** 입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-928">The **GX_EVENT** data structure is defined in ***gx_api.h***, however the most important fields of the structure are the **gx_event_type**, **gx_event_sender**, **gx_event_target**, and **gx_event_payload**.</span></span>

<span data-ttu-id="b7a34-929">**gx_event_type** 필드는 특정 이벤트 클래스를 식별하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-929">The **gx_event_type** field is used to identify the particular event class.</span></span> <span data-ttu-id="b7a34-930">이벤트 유형은 **GX_EVENT_PEN_DOWN** 이벤트인지 또는 **GX_EVENT_TIMER** 이벤트인지를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-930">The event type indicates if this is, for example, a **GX_EVENT_PEN_DOWN** event or a **GX_EVENT_TIMER** event.</span></span> <span data-ttu-id="b7a34-931">**gx_event_payload** 는 다양한 데이터 필드의 합집합이며 모든 이벤트 유형에 유효하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-931">The **gx_event_payload** is a union of various data fields, and they are not all valid for every event type.</span></span>
<span data-ttu-id="b7a34-932">다른 이벤트 데이터 필드를 검사하기 전에 이벤트 유형 필드를 먼저 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-932">You use the event type field first, before examining the other event data fields.</span></span>

<span data-ttu-id="b7a34-933">**gx_event_sender** 필드는 이벤트가 자식-위젯 알림인 경우 이벤트를 생성한 위젯의 ID를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-933">The **gx_event_sender** field contains the ID of the widget that generated the event if the event is a child-widget notification.</span></span>

<span data-ttu-id="b7a34-934">**gx_event_target** 필드를 사용하여 사용자 정의 이벤트를 특정 창이 나 위젯에 라우팅할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-934">The **gx_event_target** field can be used to route user-defined events to a particular window or widget.</span></span> <span data-ttu-id="b7a34-935">특정 창에 이벤트를 보내려면 창에 고유한 ID 값을 지정하고(정확하게 식별할 수 있도록), 이벤트를 빌드할 때 **gx_event_target** 필드에 창 ID 값을 입력해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-935">If you want to send an event to a particular window, you should give the window a unique Id value (so that it can be positively identified), and when building the event place the window Id value in the **gx_event_target** field.</span></span> <span data-ttu-id="b7a34-936">대상 ID를 모르는 경우나 입력 포커스가 있는 위젯에 이벤트를 라우팅하도록 하려면 **gx_event_target** 필드를 0으로 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-936">If you don’t know the target Id or if you just want the event to be routed to the widget that has input focus, make sure to set the **gx_event_target** field to 0.</span></span>

<span data-ttu-id="b7a34-937">마지막으로 **gx_event_payload** 필드는 다양한 데이터 형식의 합집합입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-937">Finally, the **gx_event_payload** field is a union of various data types.</span></span> <span data-ttu-id="b7a34-938">**GX_EVENT_PEN_DOWN** 및 **GX_EVENT_PEN_UP** 이벤트의 경우 **gx_event_pointdata** 필드에 펜 위치의 x, y 픽셀 좌표가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-938">For **GX_EVENT_PEN_DOWN** and **GX_EVENT_PEN_UP** events, the **gx_event_pointdata** field contains the x,y pixel coordinate the pen position.</span></span> <span data-ttu-id="b7a34-939">타이머 이벤트의 경우 **gx_event_timer_id** 필드에 만료된 타이머의 ID가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-939">For timer events, the **gx_event_timer_id** field contains the ID of the expired timer.</span></span> <span data-ttu-id="b7a34-940">다른 페이로드 데이터 필드는 다른 이벤트 유형에 활용됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-940">Other payload data fields are utilized for other event types.</span></span> <span data-ttu-id="b7a34-941">미리 정의된 이벤트 유형 및 해당 페이로드 필드의 전체 목록은 [부록 E - GUIX 이벤트 설명](appendix-e.md)에 정의되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-941">The complete list of pre-defined event types and their payload fields is defined in [Appendix E - GUIX Event Descriptions](appendix-e.md).</span></span>

<span data-ttu-id="b7a34-942">애플리케이션은 상수 **GX_FIRST_APP_EVENT** 다음에 나오는 숫자로 시작하는 고유한 사용자 지정 이벤트를 추가할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-942">The application can also add its own custom events, starting numerically after the constant **GX_FIRST_APP_EVENT**.</span></span> <span data-ttu-id="b7a34-943">이 상수 이후의 모든 이벤트 번호는 애플리케이션 사용을 위해 예약됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-943">All event numbers after this constant are reserved for the application’s use.</span></span> <span data-ttu-id="b7a34-944">물론 애플리케이션의 위젯 이벤트 처리기에서는 이러한 애플리케이션 이벤트를 처리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-944">Of course, the application’s widget event handler must have processing for such application events.</span></span>

### <a name="event-processing"></a><span data-ttu-id="b7a34-945">이벤트 처리</span><span class="sxs-lookup"><span data-stu-id="b7a34-945">Event Processing</span></span> 

<span data-ttu-id="b7a34-946">***gx_<widget-type>_event_process*** 라는 모든 위젯에 대한 기본 위젯 이벤트 처리 함수가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-946">There is a default widget event processing function for each and every widget, named ***gx_<widget-type>_event_process***.</span></span> <span data-ttu-id="b7a34-947">대부분의 경우 애플리케이션은 지정된 위젯의 이벤트 처리를 신경쓸 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-947">In most cases, the application won’t need to worry about the event handling of any given widget.</span></span> <span data-ttu-id="b7a34-948">그러나 애플리케이션은 사용자 지정 또는 보완 이벤트 처리가 필요한 경우 GUIX API ***gx_widget_event_process_set*** 을 통해 기본 처리 함수를 자체 함수로 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-948">However, in situations where the application requires custom or supplemental event processing, the application may override the default processing function with its own via the GUIX API ***gx_widget_event_process_set***.</span></span> <span data-ttu-id="b7a34-949">이 함수는 API에 지정된 이벤트 함수 처리 함수를 사용하여 기본 이벤트 처리 함수를 재정의합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-949">This function overrides the default event processing function with the event function processing function specified in the API.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="b7a34-950">애플리케이션 이벤트 처리 함수는 기본 ***gx_widget_event_process*** 처리를 직접 호출하여 기본 처리를 활용할 수 있습니다(즉, 처리를 복제하지 않음).</span><span class="sxs-lookup"><span data-stu-id="b7a34-950">Application event processing functions can take advantage (i.e., not duplicate the processing) of the default processing by simply calling the default ***gx_widget_event_process*** processing directly.</span></span>

<span data-ttu-id="b7a34-951">이벤트 처리는 내부 GUIX 시스템 스레드의 컨텍스트와는 별개로 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-951">Event processing is called exclusively from the context of the internal GUIX system thread.</span></span> <span data-ttu-id="b7a34-952">이러한 방식으로 이벤트 처리를 진행하기 위한 스택 요구 사항은 GUIX 스레드에만 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-952">In this way, the stack requirements to process the event handling only applies to the GUIX thread.</span></span>

### <a name="implementing-custom-event-processing-example"></a><span data-ttu-id="b7a34-953">사용자 지정 이벤트 처리 구현(예제)</span><span class="sxs-lookup"><span data-stu-id="b7a34-953">Implementing Custom Event Processing (example)</span></span> 

<span data-ttu-id="b7a34-954">GUIX 시스템의 위젯 또는 창에 대해 사용자 고유의 이벤트 처리 함수를 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-954">You can provide your own event processing function for any widget or window in the GUIX system.</span></span> <span data-ttu-id="b7a34-955">사용자 고유의 사용자 지정 위젯 유형을 만드는 경우 일반적으로 위젯 생성 함수에 사용자 지정 이벤트 처리기를 설치합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-955">If you are creating your own custom widget type, you will normally install your custom event handler in the widget creation function.</span></span> <span data-ttu-id="b7a34-956">기존 위젯 또는 창의 작업을 확장하거나 수정하는 경우 위젯 또는 창이 만들어진 후에 gx_widget_event_process_set API 함수를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-956">If you are just extending or modifying the operation of an existing widget or window, you can call the gx_widget_event_process_set API function after the widget or window has been created.</span></span> <span data-ttu-id="b7a34-957">자식 컨트롤에 의해 생성되는 이벤트를 처리하기 위해 거의 항상 최상위 창(화면이라고도 함)에 대한 고유한 이벤트 처리를 제공하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-957">You will almost always provide your own event handling for your top-level windows (also called Screens) in order to process events generated by your child controls.</span></span> <span data-ttu-id="b7a34-958">화면의 자식 컨트롤에 의해 생성되는 이벤트 처리는 GUIX 애플리케이션에 기능을 추가하는 기본적인 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-958">Processing event generated by the child controls of a screen is the main way you add functionality to your GUIX application.</span></span>

<span data-ttu-id="b7a34-959">예를 들어, "main_menu"라는 최상위 화면을 정의한다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-959">As an example, suppose you define a top-level screen named “main_menu”.</span></span>
<span data-ttu-id="b7a34-960">이 화면은 GUIX Studio를 사용하여 정의하거나 애플리케이션 코드에서 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-960">This screen might be defined using GUIX Studio, or you might create this screen in your application code.</span></span> <span data-ttu-id="b7a34-961">GUIX Studio 내에서 화면을 정의하는 경우 해당 화면에 대한 Studio 속성 필드에 이벤트 처리기의 이름을 입력하면 Studio에서 생성된 사양 코드가 이벤트 처리기를 자동으로 설치합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-961">If you define the screen within GUIX Studio, you simply type the name of your event handler in the Studio properties field for that screen, and the Studio generated specifications code will automatically install your event handler.</span></span> <span data-ttu-id="b7a34-962">이 경우 사용자 지정 이벤트 처리기 ***main_menu_event_handler*** 를 호출하고 다음과 같이 코딩해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-962">In this case, we will call the custom event handler ***main_menu_event_handler*** and it should be coded like this:</span></span>

```C
int main_menu_item; /* example: variable to keep track of selected item */

UINT main_menu_event_handler(GX_WINDOW *main_screen, GX_EVENT *event_ptr)
{
    UINT status = GX_SUCCESS;

    switch(event_ptr->gx_event_type)
    {
    /* this is an example for catching events from a child button */
    case GX_SIGNAL(IDB_CHILD_BUTTON, GX_EVENT_CLICKED):
        /* insert your button handler code here */
        break;

    case GX_EVENT_SHOW:
        /* add functionality to the show event handler */
        /* first, do default processing */
        status = gx_window_event_process(main_screen, event_ptr); /* note 1 */

        /* now add my own processing */
        main_menu_item = 0;
        break;

    default:
        /* pass all other events to base processing function */
        status = gx_window_event_process(main_screen, event_ptr); /* note 1 */
        break;
    }
    return status;
}
```

<span data-ttu-id="b7a34-963">위의 예제에서 **GX_EVENT_SHOW** 와 같은 시스템 이벤트(상태 변경을 위젯에 알리기 위해 내부적으로 생성된 이벤트)의 경우 애플리케이션에서 이러한 이벤트를 기본 위젯 이벤트 처리 함수에 전달하여 정상적인 처리가 수행되도록 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-963">In the example above, it is important to notice that for system events like **GX_EVENT_SHOW** (events generated internally to notify a widget of a status change), the application must pass those events to the base widget event processing function to insure that the normal processing occurs.</span></span> <span data-ttu-id="b7a34-964">그러면 애플리케이션은 필요에 따라 추가 논리를 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-964">The application can then add additional logic as desired.</span></span> <span data-ttu-id="b7a34-965">애플리케이션에서 처리하지 않은 모든 이벤트(위의 기본 사례)도 기본 이벤트 처리 함수에 전달되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-965">All events that are not handled by the application (the default case above) should also be passed to the base event processing function.</span></span> <span data-ttu-id="b7a34-966">이 예제는 **GX_WINDOW** 기반 최상위 화면에 대한 것이므로 기본 이벤트 처리 함수는 gx_window_event_process입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-966">Since this example was for a top-level screen based on **GX_WINDOW**, the default event processing function is gx_window_event_process.</span></span>

### <a name="drawing-function"></a><span data-ttu-id="b7a34-967">그리기 함수</span><span class="sxs-lookup"><span data-stu-id="b7a34-967">Drawing Function</span></span> 

<span data-ttu-id="b7a34-968">모든 위젯 그리기는 이벤트 처리와는 별도로 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-968">All widget drawing is performed separately from the event handling.</span></span> <span data-ttu-id="b7a34-969">일반적으로 CPU 주기 측면에서 그리기가 비용이 많이 들기 때문에 이렇게 하는 것이 더 효율적입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-969">This is more efficient because drawing is usually expensive in terms of CPU cycles.</span></span> <span data-ttu-id="b7a34-970">지연된 그리기 알고리즘을 구현하면 그리기를 수행하기 전에 처리 중인 모든 이벤트 및 연결된 디스플레이 변경을 완료할 수 있으므로 그리기가 낭비되는 것을 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-970">By implementing a deferred drawing algorithm, all of the outstanding events and associated display changes can be completed before any drawing is done, thus eliminating wasted drawing.</span></span> <span data-ttu-id="b7a34-971">이벤트 처리와 마찬가지로, 대부분의 위젯을 위한 ***gx_<widget-type>_draw*** 라는 기본 위젯 그리기 함수가 있습니다. 여기서 xxx는 위젯 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-971">Similar to event processing, there is a default widget drawing function for most widgets, named ***gx_<widget-type>_draw***, where xxx is the widget type.</span></span> <span data-ttu-id="b7a34-972">대부분의 경우 애플리케이션은 지정된 위젯의 그리기 함수를 신경쓸 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-972">In most cases, the application won’t need to worry about the drawing function of any given widget.</span></span> <span data-ttu-id="b7a34-973">그러나 애플리케이션은 사용자 지정 또는 보완 그리기가 필요한 경우 GUIX API ***gx_widget_draw_set*** 을 통해 기본 그리기 함수를 자체 함수로 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-973">However, in situations where the application requires custom or supplemental drawing, the application may override the default drawing function with its own via the GUIX API ***gx_widget_draw_set***.</span></span> <span data-ttu-id="b7a34-974">이 함수를 사용하면 애플리케이션에서 위젯에 대해 고유한 사용자 지정 그리기 함수를 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-974">This function allows the application to provide its own customized drawing function for any widget.</span></span> <span data-ttu-id="b7a34-975">이를 통해 애플리케이션에서 완전히 새로운 위젯 형식을 정의할 수 있게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-975">This further allows the application to define entire new widget types.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="b7a34-976">애플리케이션 그리기 함수는 재정의된 그리기 함수에서 직접 호출하여 기본 그리기의 이점(예: 중복 코딩 없음)을 활용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-976">Application drawing functions can take advantage (i.e., not duplicate the coding) of the default drawing by simply calling it directly from the overridden drawing function.</span></span>

<span data-ttu-id="b7a34-977">위젯 그리기는 내부 GUIX 시스템 스레드의 컨텍스트와는 별개로 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-977">Widget drawing is called exclusively from the context of the internal GUIX system thread.</span></span> <span data-ttu-id="b7a34-978">따라서 그리기를 수행하는 데 필요한 타이밍 및 스택 요구 사항이 GUIX 스레드에만 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-978">In this way, the timing and stack requirements to perform the drawing only apply to the GUIX thread.</span></span>

### <a name="implementing-custom-drawing-example"></a><span data-ttu-id="b7a34-979">사용자 지정 그리기 구현(예제)</span><span class="sxs-lookup"><span data-stu-id="b7a34-979">Implementing Custom Drawing (example)</span></span> 

<span data-ttu-id="b7a34-980">모든 위젯의 그리기 함수는 GX_WIDGET 제어 블록의 멤버인 간접 함수 포인터를 통해 참조됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-980">The drawing function for any widget is referenced through an indirect function pointer which is a member of the GX_WIDGET control block.</span></span> <span data-ttu-id="b7a34-981">GUIX Studio를 사용하여 위젯을 정의하는 경우 위젯 속성의 "그리기 함수" 매개 변수에 함수 이름을 입력하여 자체 함수 포인터를 설치할 수 있습니다. 그러면 위젯이 생성될 때 Studio에서 함수 포인터를 설치합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-981">If you use GUIX Studio to define your widget, you can install your own function pointer simply by typing the name of your function in the “Drawing Function” parameter of the widget properties, and Studio will install your function pointer for you when the widget is created.</span></span> <span data-ttu-id="b7a34-982">애플리케이션 코드에서 위젯을 만드는 경우 위젯을 만든 후에 ***gx_widget_draw_set*** API 함수를 사용하여 사용자 지정 그리기 함수를 설치해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-982">If you create the widget in your application code, you must use the ***gx_widget_draw_set*** API function to install your custom drawing function after the widget has been created.</span></span>

<span data-ttu-id="b7a34-983">이 예제에서는 단추의 모양을 사용자 지정하려 한다고 가정해 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-983">For this example, let’s assume that you want to customize the appearance of a button.</span></span> <span data-ttu-id="b7a34-984">단추는 **GX_TEXT_BUTTON** 과 매우 유사하지만 단추를 누를 때 단추의 오른쪽 가운데 부분에 녹색의 작은 "LED_ON" 비트맵이 그려지고, 단추를 뗄 때 작은 "LED_OFF" 비트맵이 그려집니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-984">The button will look very much like a **GX_TEXT_BUTTON**, but we will add drawing a small green “LED_ON” bitmap in the middle-right portion of the button when the button is pressed, and small “LED_OFF” bitmap when the button is not pressed.</span></span> <span data-ttu-id="b7a34-985">아래 그림처럼 보이는 단추를 만들려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-985">We want to create a button that looks like the illustrations below.</span></span>

![켜짐에 해당하는 녹색 단추의 스크린샷](./media/guix/image4.jpg) <span data-ttu-id="b7a34-987">사용자 지정 단추 "켜짐"</span><span class="sxs-lookup"><span data-stu-id="b7a34-987">custom button “on”</span></span>

![꺼짐에 해당하는 빨간색 단추의 스크린샷](./media/guix/image5.jpg) <span data-ttu-id="b7a34-989">사용자 지정 단추 "꺼짐"</span><span class="sxs-lookup"><span data-stu-id="b7a34-989">custom button “off”</span></span>

<span data-ttu-id="b7a34-990">이 경우 다음과 같이 표시되는 단추 그리기 함수를 작성합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-990">In this case, we would write a button drawing function that looks something like the following.</span></span>

```C
UINT my_button_draw(GX_TEXT_BUTTON *button)
{
    GX_PIXELMAP *map;
    ULONG button_style;
    INT xpos;
    INT ypos;

    /* first, do the normal text button drawing */
    gx_text_button_draw(button);

    /* now add our extra pixelmap */

    gx_widget_style_get(button, &button_style);

    if (button_style & GX_STYLE_BUTTON_PUSHED)
    {
        /* use the ON pixelmap */
        gx_context_pixelmap_get(GX_PIXELMAP_ID_LED_ON, &map);
    }
    else
    {
        /* use the OFF pixelmap */
        gx_context_pixelmap_get(GX_PIXELMAP_ID_LED_OFF, &map);
    }
    if (map)
    {
        /* draw it 20 pixels in from right edge */
        xpos = button->gx_widget_size.gx_rectangle_right;
        xpos -= map->gx_pixelmap_width + 20;

        /* and draw 10 pixels from the top edge */
        ypos = button->gx_widget_size.gx_rectangle_top + 10;

        /* draw the extra pixelmap on top of the button */
        gx_canvas_pixelmap_draw(xpos, ypos, map);
    }
}
```

## <a name="guix-drawing-context-component"></a><span data-ttu-id="b7a34-991">GUIX 그리기 컨텍스트 구성 요소</span><span class="sxs-lookup"><span data-stu-id="b7a34-991">GUIX Drawing Context Component</span></span> 

<span data-ttu-id="b7a34-992">GUIX가 각 캔버스 새로 고침 작업을 수행하면 그리기 컨텍스트가 런타임에 동적으로 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-992">The drawing context is created dynamically, at runtime, as GUIX performs each canvas refresh operation.</span></span> <span data-ttu-id="b7a34-993">그리기 컨텍스트는 현재 그리기 작업을 수행하는 데 사용되는 캔버스, 화면 드라이버 및 브러시를 함께 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-993">The drawing context ties together the canvas, screen driver, and brush being used to perform the current drawing operations.</span></span>

<span data-ttu-id="b7a34-994">그리기 컨텍스트는 **GX_DRAW_CONTEXT** 구조체로 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-994">The drawing context is defined by the **GX_DRAW_CONTEXT** structure.</span></span>
<span data-ttu-id="b7a34-995">이 구조체에는 현재 그리기 작업의 클리핑 및 뷰를 정의하고, 현재 캔버스를 정의하고, 현재 화면 드라이버를 사용 중인 것으로 정의하는 변수가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-995">This structure contains variables that define the clipping and view of the current drawing operation, define the current canvas, and define the current screen driver in use.</span></span> <span data-ttu-id="b7a34-996">**GX_DRAW_CONTEXT** 구조체는 그리기에 사용 되는 브러시도 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-996">The **GX_DRAW_CONTEXT** structure also holds the brush being used for drawing.</span></span> <span data-ttu-id="b7a34-997">그리기 컨텍스트 브러시는 사용자 지정 그리기 함수에서 직접 사용하게 되는 멤버입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-997">The draw context brush is the member that you will work directly with in your custom drawing functions.</span></span> <span data-ttu-id="b7a34-998">브러시 구조는 아래 코드와 같이 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-998">The brush structure is defined as shown in the code below.</span></span>

```C
typedef struct GX_BRUSH_STRUCT
{
    GX_PIXELMAP *gx_brush_pixelmap;
    GX_FONT     *gx_brush_font;
    ULONG        gx_brush_line_pattern;
    ULONG        gx_brush_pattern_mask;
    GX_COLOR     gx_brush_fill_color;  
    GX_COLOR     gx_brush_line_color;  
    UINT         gx_brush_style;
    GX_VALUE     gx_brush_width;
    UCHAR        gx_brush_alpha;  
} GX_BRUSH;
```

<span data-ttu-id="b7a34-999">**gx_brush_pixelmap** 필드는 사각형 및 다각형 채우기에 사용할 pixelmap을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-999">The **gx_brush_pixelmap** field defines a pixelmap to use for rectangle and polygon fills.</span></span> <span data-ttu-id="b7a34-1000">**gx_brush_style** 에 **GX_BRUSH_PIXELMAP** 스타일이 포함되어 있지 않으면 이 멤버가 사용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1000">This member is not used unless the **gx_brush_style** is includes the **GX_BRUSH_PIXELMAP** style.</span></span>

<span data-ttu-id="b7a34-1001">**gx_brush_font** 멤버는 텍스트 그리기에 사용되는 글꼴을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1001">The **gx_brush_font** member defines the font used for text drawing.</span></span>
<span data-ttu-id="b7a34-1002">**gx_brush_line_pattern** 멤버는 파선에 사용되는 패턴을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1002">The **gx_brush_line_pattern** member defines the pattern used for dashed lines.</span></span>
<span data-ttu-id="b7a34-1003">**gx_brush_style** 멤버는 브러시 특성을 완전히 정의하기 위해 OR로 연결될 수 있는 스타일 플래그 세트입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1003">The **gx_brush_style** member is a set of style flags that can be OR’d together to fully define the brush attributes.</span></span> <span data-ttu-id="b7a34-1004">사용 가능한 브러시 스타일 플래그는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1004">The available brush style flags include the following.</span></span>

<span data-ttu-id="b7a34-1005">**GX_BRUSH_OUTLINE**</span><span class="sxs-lookup"><span data-stu-id="b7a34-1005">**GX_BRUSH_OUTLINE**</span></span>  
<span data-ttu-id="b7a34-1006">**GX_BRUSH_SOLID_FILL**</span><span class="sxs-lookup"><span data-stu-id="b7a34-1006">**GX_BRUSH_SOLID_FILL**</span></span>  
<span data-ttu-id="b7a34-1007">**GX_BRUSH_PIXELMAP_FILL**</span><span class="sxs-lookup"><span data-stu-id="b7a34-1007">**GX_BRUSH_PIXELMAP_FILL**</span></span>  
<span data-ttu-id="b7a34-1008">**GX_BRUSH_ALIAS**</span><span class="sxs-lookup"><span data-stu-id="b7a34-1008">**GX_BRUSH_ALIAS**</span></span>  
<span data-ttu-id="b7a34-1009">**GX_BRUSH_UNDERLINE**</span><span class="sxs-lookup"><span data-stu-id="b7a34-1009">**GX_BRUSH_UNDERLINE**</span></span>  
<span data-ttu-id="b7a34-1010">**GX_BRUSH_ROUND**</span><span class="sxs-lookup"><span data-stu-id="b7a34-1010">**GX_BRUSH_ROUND**</span></span>

<span data-ttu-id="b7a34-1011">**gx_brush_width** 멤버는 선 그리기의 줄 또는 윤곽선이 있는 도형 그리기의 윤곽선 너비를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1011">The **gx_brush_width** member defines the line with for line drawing, or the outline width for outlined shape drawing.</span></span>

<span data-ttu-id="b7a34-1012">**gx_brush_line_color** 멤버는 줄 그리기 및 텍스트 그리기의 전경색을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1012">The **gx_brush_line_color** member defines the foreground color for line drawing and for text drawing.</span></span>

<span data-ttu-id="b7a34-1013">**gx_brush_fill_color** 멤버는 도형 채우기에 사용되는 단색 채우기 색을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1013">The **gx_brush_fill_color** member defines the solid fill color used for shape filling.</span></span> <span data-ttu-id="b7a34-1014">GUIX 컨텍스트 구성 요소는 활성 컨텍스트 내에서 현재 브러시를 매우 쉽게 수정할 수 있도록 하기 위해 디자인된 API 세트를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1014">The GUIX context component provides a set of APIs designed to make it very easy to modify the current brush within the active context.</span></span> <span data-ttu-id="b7a34-1015">이러한 API에는 **gx_context_brush_define**, **gx_context_line_color_set**, **gx_context_fill_color_set**, **gx_context_font_set** 등이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1015">These APIs include **gx_context_brush_define**, **gx_context_line_color_set**, **gx_context_fill_color_set**, **gx_context_font_set**, and many others.</span></span>

<span data-ttu-id="b7a34-1016">부모 개체의 그리기 컨텍스트는 개체 자식로 상속됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1016">The draw context of a parent object is inherited by the objects children.</span></span> <span data-ttu-id="b7a34-1017">실제로 부모 그리기 컨텍스트의 복제본은 해당 그리기 함수가 호출될 때 자식 개체로 상속됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1017">Actually, a clone of the parent drawing context is inherited by the child objects when their drawing functions are invoked.</span></span> <span data-ttu-id="b7a34-1018">자식은 부모 그리기에 영향을 주지 않으면서 컨텍스트를 수정할 수 있지만, 원할 경우 브러시 색, 스타일 등의 부모 정보를 상속할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1018">The child can modify the context without affecting the parent drawing, but it can also inherit information from the parent such as brush color and style if desired.</span></span>

## <a name="guix-window-component"></a><span data-ttu-id="b7a34-1019">GUIX 창 구성 요소</span><span class="sxs-lookup"><span data-stu-id="b7a34-1019">GUIX Window Component</span></span> 

<span data-ttu-id="b7a34-1020">창 구성 요소는 GUIX의 모든 창 처리를 담당합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1020">The window component is responsible for all window processing in GUIX.</span></span> <span data-ttu-id="b7a34-1021">GUIX 창은 기본적으로 하나 이상의 자식 위젯을 포함할 수 있는 고유한 디스플레이 영역입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1021">A GUIX window is fundamentally a distinct display area that may contain one or more child widgets.</span></span> <span data-ttu-id="b7a34-1022">GUIX에서 창은 실제로 기본 위젯 개체의 한 가지 특수한 형태에 불과합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1022">In GUIX, the window is actually just a special form of the fundamental widget object.</span></span>

<span data-ttu-id="b7a34-1023">GUIX 창은 상속을 완벽하게 지원하는 개체 지향 방식으로 구현됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1023">GUIX windows are implemented in an object oriented manner with full support of inheritance.</span></span> <span data-ttu-id="b7a34-1024">이 작업은 ANSI C를 사용하여 수행되며, 결과적으로 메모리 및 처리 요구 사항이 최소화됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1024">This is accomplished using ANSI C, which results in the smallest possible memory and processing requirements.</span></span>

<span data-ttu-id="b7a34-1025">GUIX 창은 주로 가로 및 세로 스크롤에 대한 지원을 추가하여 GUIX 위젯의 기능을 확장합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1025">GUIX windows extend the functionality of the GUIX widget primarily by adding support for horizontal and vertical scrolling.</span></span> <span data-ttu-id="b7a34-1026">GUIX 창 개체는 스크롤 막대를 자동으로 만들고 표시하며, 스크롤 막대 입력에 응답할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1026">GUIX window objects can automatically create and display scroll bars and respond to scroll bar input.</span></span> <span data-ttu-id="b7a34-1027">이동 가능한 창에는 펜 입력 이벤트를 기준으로 창을 이동하거나 끌 수 있는 기본 제공 이벤트 처리 기능도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1027">Movable windows also have built in event handling to allow the window to be moved or dragged based on pen input events.</span></span>
<span data-ttu-id="b7a34-1028">마지막으로 GUIX 창은 창 Z 순서 맨 앞으로 창을 이동하여 수신 입력 포커스에 대응합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1028">Finally, GUIX window responds to receiving input focus by moving the window to the front of the window Z-order.</span></span>

<span data-ttu-id="b7a34-1029">GUIX 창에는 창 테두리 및 스크롤 막대와 같은 비클라이언트 개체가 사용 가능한 영역에서 제거되면 창의 내부 부분이 되는 ‘클라이언트 영역’ 개념이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1029">GUIX window maintains the concept of *client area*, which is the inner portion of the window once the window borders and non-client objects such as scrollbars are removed from the available area.</span></span> <span data-ttu-id="b7a34-1030">클라이언트 영역 자식 위젯은 창 클라이언트 영역까지 잘립니다. 그렇지만 스크롤 막대와 같은 비클라이언트 자식 항목은 클라이언트 영역 외부에 그릴 수 있지만 여전히 창 외부 차원까지 잘립니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1030">Client area child widgets are clipped to the window client area, while non-client children such as scroll bars are allowed to draw outside of the client area, but are still clipped to the window outer dimensions.</span></span>

<span data-ttu-id="b7a34-1031">창은 부모-자식 방식으로 유지 관리됩니다. 이러한 방식에서 자식은 부모의 특성을 상속합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1031">Windows are maintained in a parent-child manner, where the children inherit characteristics from their parent.</span></span> <span data-ttu-id="b7a34-1032">자식 창은 자체 자식 창이 있을 수 있으며 이러한 자식 역시 부모로부터 다양한 특성을 상속합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1032">Children windows may have their own child windows, again inheriting various characteristics from the parent.</span></span> <span data-ttu-id="b7a34-1033">다양한 GUIX API 호출을 통해 모든 창의 특성을 명시적으로 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1033">The characteristics of any window may be explicitly redefined via various GUIX API calls.</span></span>

### <a name="window-creation"></a><span data-ttu-id="b7a34-1034">창 만들기</span><span class="sxs-lookup"><span data-stu-id="b7a34-1034">Window Creation</span></span> 

<span data-ttu-id="b7a34-1035">창 개체는 초기화 동안 또는 애플리케이션 스레드를 실행하는 동안 언제든지 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1035">A window object can be created during initialization or anytime during the execution of application threads.</span></span> <span data-ttu-id="b7a34-1036">애플리케이션에서 만들 수 있는 창 개체 수에는 제한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1036">There is no limit on the number of window objects that can be created by an application.</span></span> <span data-ttu-id="b7a34-1037">또한 창에 포함될 수 있는 자식 창의 수에도 제한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1037">There is also no limit on the number of children any window may have.</span></span>

### <a name="window-control-block"></a><span data-ttu-id="b7a34-1038">창 제어 블록</span><span class="sxs-lookup"><span data-stu-id="b7a34-1038">Window Control Block</span></span> 

<span data-ttu-id="b7a34-1039">각 창 개체의 특성은 해당 제어 블록 **GX_WINDOW** 에서 찾을 수 있으며 **_gx_api.h_** 에 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1039">The characteristics of each window object are found in its control block **GX_WINDOW** and are defined in **_gx_api.h_**.</span></span> <span data-ttu-id="b7a34-1040">창 개체에 필요한 메모리는 애플리케이션이 제공하며 메모리의 어느 위치에나 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1040">The memory required for a window object is provided by the application and can be located anywhere in memory.</span></span> <span data-ttu-id="b7a34-1041">그러나 함수 범위 외부에서 정의하여 창 개체 제어 블록이 전역 구조를 차단하도록 하는 것이 가장 일반적입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1041">However, it is most common to make the window object control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="root-window"></a><span data-ttu-id="b7a34-1042">루트 창</span><span class="sxs-lookup"><span data-stu-id="b7a34-1042">Root Window</span></span> 

<span data-ttu-id="b7a34-1043">GUIX에는 각 캔버스에 대한 루트 창이라는 항목이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1043">GUIX requires what is called a root window for each canvas.</span></span> <span data-ttu-id="b7a34-1044">루트 창은 테두리가 없고 연결된 캔버스와 동일한 차원이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1044">The root window is borderless and has the same dimensions as the canvas to which it is attached.</span></span> <span data-ttu-id="b7a34-1045">주로 모든 첫 번째 수준 위젯 및 창에 대한 컨테이너로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1045">It is used primarily as a container for all first-level widgets and windows.</span></span> <span data-ttu-id="b7a34-1046">일반적으로 루트 창은 화면 및 캔버스를 만든 직후에 API 함수 ***gx_window_root_create*** 를 통해 애플리케이션에서 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1046">The root window is typically created by the application via the API function ***gx_window_root_create***, shortly after the creation of the screen and canvas.</span></span> <span data-ttu-id="b7a34-1047">Studio에서 생성한 gx_studio_display_configure 함수를 사용하는 경우 이 함수에 대한 마지막 매개 변수로 전달된 위치에서 루트 창의 주소를 반환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1047">If you use the Studio generated function gx_studio_display_configure, the address of the root window can be returned in the location passed as the last parameter to this function.</span></span>

<span data-ttu-id="b7a34-1048">루트 창은 기본적으로 이동 가능하지 않으며, 가장 간단한 경우에는 루트 창이 캔버스의 크기가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1048">A root window defaults to being un-moveable, and in the simplest case the root window is the size of the canvas.</span></span> <span data-ttu-id="b7a34-1049">결과적으로 루트 창은 디스플레이 배경을 그리므로 디스플레이 배경색을 변경하거나 배경 무늬를 표시하려면 루트 창에 색 또는 배경 무늬를 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1049">The root window in effect draws the display background, so to change the display background color or to display background wallpaper you would assign a color or wallpaper to the root window.</span></span>

<span data-ttu-id="b7a34-1050">루트 창이 이동 가능한 경우 자식 창처럼 캔버스에서의 위치를 변경하는 것이 아니라 캔버스 자체를 이동하여 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1050">If a root window is moveable, it moves not by changing its position on the canvas as a child window would do, but by moving the canvas itself.</span></span>
<span data-ttu-id="b7a34-1051">이 기능을 사용하면 GUIX 루트 창에서 하드웨어 오프셋 레지스터가 있는 여러 프레임 버퍼를 지원하는 하드웨어를 활용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1051">This feature allows the GUIX root window to leverage hardware that supports multiple frame buffers with hardware offset registers.</span></span>

### <a name="background"></a><span data-ttu-id="b7a34-1052">배경</span><span class="sxs-lookup"><span data-stu-id="b7a34-1052">Background</span></span> 

<span data-ttu-id="b7a34-1053">창 배경은 단색 또는 비트맵 이미지 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1053">Window backgrounds are either solid colors or bitmap images.</span></span> <span data-ttu-id="b7a34-1054">초기 창 세트에 대한 기본값을 제공하는 기본 창 배경이 시스템 수준에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1054">There is a default window background at the system level which provides the default for the initial set of windows.</span></span> <span data-ttu-id="b7a34-1055">물론 모든 창 배경은 GUIX API를 통해 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1055">Of course, any window background can be changed via the GUIX API.</span></span>

<span data-ttu-id="b7a34-1056">창의 단색 배경을 변경하려면 ***gx_widget_fill_color_set*** API를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1056">To change the solid color background of a window, use the ***gx_widget_fill_color_set*** API.</span></span> <span data-ttu-id="b7a34-1057">창에 배경 무늬를 할당하려면 ***gx_window_wallpaper_set*** API를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1057">To assign a background wallpaper to a window, use the ***gx_window_wallpaper_set*** API.</span></span>

### <a name="scrolling"></a><span data-ttu-id="b7a34-1058">스크롤</span><span class="sxs-lookup"><span data-stu-id="b7a34-1058">Scrolling</span></span> 

<span data-ttu-id="b7a34-1059">GUIX는 창 자식을 표시하는 데 필요한 영역이 창의 현재 크기를 가로 및/또는 세로로 초과하는 경우 표준 창 스크롤을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1059">GUIX supports standard window scrolling when area required to display the window children exceeds the current size of the window – horizontally and/or vertically.</span></span> <span data-ttu-id="b7a34-1060">스크롤을 사용하려면 애플리케이션에서 원하는 스크롤 막대를 만들어 창에 연결해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1060">To enable scrolling, the application must create the desired scroll bars and attach them to the window.</span></span>

<span data-ttu-id="b7a34-1061">GUIX 창 구성 요소는 창 클라이언트 영역의 크기와 모든 자식 위젯의 범위를 기준으로 하는 기본 스크롤 구현을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1061">The GUIX window component provides a default scrolling implementation based on the size of the window client area and the extent of the all child widgets.</span></span> <span data-ttu-id="b7a34-1062">애플리케이션은 특정 창에 대해 ***gx_window_scroll_info_get*** 함수를 재정의하여 자체 스크롤 구현 및 해석을 제공할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1062">Applications can also provide their own scrolling implementation and interpretation by overriding the ***gx_window_scroll_info_get*** function for a particular window.</span></span>

### <a name="event-notification"></a><span data-ttu-id="b7a34-1063">이벤트 알림</span><span class="sxs-lookup"><span data-stu-id="b7a34-1063">Event Notification</span></span> 

<span data-ttu-id="b7a34-1064">기본 창 이벤트 처리 함수는 주로 스크롤 및 크기 조정 이벤트를 처리하는 GX_WIDGET 이벤트 처리와 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1064">The default window event processing function differs from the GX_WIDGET event processing primarily in the handling of scrolling and sizing events.</span></span> <span data-ttu-id="b7a34-1065">GX_WINDOW는 스크롤 및 크기 조정 이벤트를 위한 기본 처리기를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1065">GX_WINDOW provided defalt handlers for scrolling and sizing events.</span></span>

<span data-ttu-id="b7a34-1066">애플리케이션은 상수 **GX_FIRST_APP_EVENT** 다음에 나오는 숫자로 시작하는 고유한 사용자 지정 이벤트를 추가할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1066">The application can also add its own custom events, starting numerically after the constant **GX_FIRST_APP_EVENT**.</span></span> <span data-ttu-id="b7a34-1067">이 상수 이후의 모든 이벤트 번호는 애플리케이션 사용을 위해 예약됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1067">All event numbers after this constant are reserved for the application’s use.</span></span> <span data-ttu-id="b7a34-1068">물론 애플리케이션의 창 이벤트 처리기에서는 이러한 애플리케이션 이벤트를 처리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1068">Of course, the application’s window event handler must have processing for such application events.</span></span>

### <a name="event-processing"></a><span data-ttu-id="b7a34-1069">이벤트 처리</span><span class="sxs-lookup"><span data-stu-id="b7a34-1069">Event Processing</span></span> 

<span data-ttu-id="b7a34-1070">다른 모든 위젯 유형과 마찬가지로 ***gx_window_event_process*** 라는 모든 창에 대한 기본 창 이벤트 처리 함수가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1070">Just like all other widget types, there is a default window event processing function for every window, named ***gx_window_event_process***.</span></span> <span data-ttu-id="b7a34-1071">일반적으로 이 이벤트 처리 함수는 만드는 창에서 사용자 고유의 이벤트 처리기를 사용하여 재정의합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1071">You will usually override this event handling function with your own event handler in the windows that you create.</span></span> <span data-ttu-id="b7a34-1072">이러한 방식으로 창 자식 컨트롤이 생성하는 이벤트를 기준으로 이벤트에 대응하고 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1072">This is how you will respond to events and take action based on events generated by the window child controls.</span></span>

<span data-ttu-id="b7a34-1073">이벤트 처리기를 재정의하는 경우 GUIX 시스템 이벤트에 대한 기본 ***gx_window_event_process*** 함수를 호출하여 이벤트 처리기에 추가하는 작업 외에 기본 이벤트 처리가 발생할 수 있도록 하는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1073">It is important to remember to invoke the base ***gx_window_event_process*** function for GUIX system events if you override that event handler, to allow the default event handling to occur in addition to whatever action you are adding to the event handler.</span></span> <span data-ttu-id="b7a34-1074">예를 들어, **GX_EVENT_SHOW** 이벤트에 대한 사용자 지정 처리기를 제공하고 이 이벤트를 ***gx_window_event_process*** 에 전달하지 않으면 창이 표시되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1074">For example if you provide a custom handler for the **GX_EVENT_SHOW** event, and do not pass this event to ***gx_window_event_process***, your window will never become visible.</span></span>
<span data-ttu-id="b7a34-1075">창에 대한 사용자 지정 이벤트 처리기를 제공하려면 ***gx_widget_event_process_set*** 함수를 사용하여 이벤트 처리기의 주소를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1075">To provide a custom event handler for a window, use the ***gx_widget_event_process_set*** function to define the address of your event handler.</span></span> <span data-ttu-id="b7a34-1076">이 함수는 API에 지정된 이벤트 함수 처리 함수를 사용하여 기본 이벤트 처리 함수를 재정의합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1076">This function overrides the default event processing function with the event function processing function specified in the API.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="b7a34-1077">애플리케이션 이벤트 처리 함수는 기본 ***gx_window_event_process*** 를 직접 호출하여 기본 처리를 활용할 수 있습니다(즉, 처리를 복제하지 않음).</span><span class="sxs-lookup"><span data-stu-id="b7a34-1077">Application event processing functions can take advantage (i.e., not duplicate the processing) of the default processing by simply calling the default ***gx_window_event_process*** directly.</span></span>

<span data-ttu-id="b7a34-1078">이벤트 처리는 내부 GUIX 시스템 스레드의 컨텍스트와는 별개로 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1078">Event processing is called exclusively from the context of the internal GUIX system thread.</span></span> <span data-ttu-id="b7a34-1079">이러한 방식으로 이벤트 처리를 진행하기 위한 스택 요구 사항은 GUIX 스레드에만 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1079">In this way, the stack requirements to process the event handling only applies to the GUIX thread.</span></span>

## <a name="guix-image-reader-component"></a><span data-ttu-id="b7a34-1080">GUIX 이미지 판독기 구성 요소</span><span class="sxs-lookup"><span data-stu-id="b7a34-1080">GUIX Image Reader Component</span></span> 

<span data-ttu-id="b7a34-1081">이미지 판독기 구성 요소는 원시 압축 이미지를 GUIX pixelmap 형식으로 압축 해제하는 유틸리티 및 API 함수를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1081">The image reader component provides utilities and API functions to decompress raw compressed images to GUIX pixelmap format.</span></span> <span data-ttu-id="b7a34-1082">JPEG 및 PNG 형식 원시 이미지 데이터가 지원되며 추가 형식이 후속 릴리스에 추가로 지원될 예정입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1082">JPEG and PNG format raw image data are supported, with additional formats reserved for future releases.</span></span>

<span data-ttu-id="b7a34-1083">대부분의 GUIX 애플리케이션에서 GUIX 이미지 판독기 구성 요소는 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1083">Note that for the vast majority of GUIX applications, the GUIX Image Reader component is not required.</span></span> <span data-ttu-id="b7a34-1084">대부분의 애플리케이션은 GUIX Studio 애플리케이션을 사용하여 JPEG 및 PNG 형식 그래픽 자산을 GUIX 호환 가능 **GX_PIXELMAP** 리소스로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1084">Most applications rely on the GUIX Studio application to convert JPEG and PNG format graphics assets into GUIX compatible **GX_PIXELMAP** resources.</span></span> <span data-ttu-id="b7a34-1085">GUIX 이미지 판독기 구성 요소는 원시 그래픽 자산이 런타임에만 알려져 있거나 시스템 스토리지 제약 조건으로 인해 리소스가 **GX_PIXELMAP** 형식으로 저장되지 않는 경우에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1085">The GUIX image reader component is utilized when the raw graphics assets are known only at runtime, or when the system storage constraints prevent storing resources in **GX_PIXELMAP** format.</span></span> <span data-ttu-id="b7a34-1086">JPEG 및 PNG 형식 이미지 데이터는 일반적으로 **GX_PIXELMAP** 형식보다 더 간결하지만 이러한 이미지 형식의 압축 풀기 및 색 공간 변환을 동적으로 수행하는 것과 관련해서 상당한 런타임 오버헤드가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1086">JPEG and PNG format image data is generally more compact than **GX_PIXELMAP** format, however there is considerable runtime overhead associated with performing decompression and color space conversion of these image types dynamically.</span></span>

<span data-ttu-id="b7a34-1087">원시 형식 JPEG 또는 PNG 이미지가 gx_canvas_pixelmap_draw API 함수에 전달되면 GUIX는 JPEG 또는 PNG 데이터를 동적으로 압축 해제하고 그립니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1087">If raw format JPEG or PNG images are passed to the gx_canvas_pixelmap_draw API function, GUIX dynamically decompresses and draws the JPEG or PNG data.</span></span> <span data-ttu-id="b7a34-1088">이러한 방식은 런타임 그리기 속도에 상당히 부정적인 영향을 미칠 수 있으며, 하드웨어 지원 JPEG 또는 PNG 압축 해제를 지원하는 하드웨어 대상을 사용하지 않는 한, 원시 형식 이미지 데이터를 gx_canvas_pixelmap_draw 함수에 전달하는 것은 권장되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1088">Note that this will have a significant negative impact on runtime drawing speed, and passing RAW format image data to the gx_canvas_pixelmap_draw function is not recommended unless you are using a hardware target that supports hardware assisted JPEG or PNG decompression.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="b7a34-1089">원시 JPEG 또는 PNG 형식의 이미지를 gx_canvas_pixelmap_draw API에 전달하면 대부분의 대상 하드웨어에 대해 상당한 런타임 오버헤드가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1089">Passing raw JPEG or PNG formatted images to the gx_canvas_pixelmap_draw API incurs significant runtime overhead for most target hardware.</span></span>

<span data-ttu-id="b7a34-1090">대신 이미지 판독기 구성 요소를 사용하여 런타임에 원시 JPEG 및 PNG 데이터를 GX_PIXELMAP 형식으로 변환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1090">As an alternative, raw JPEG and PNG data may be converted to GX_PIXELMAP format at runtime using the Image Reader component.</span></span>
<span data-ttu-id="b7a34-1091">이러한 방식으로 생성된 Pixelmap은 Studio에서 생성되고 리소스 파일 내에 포함되는 Pixelmap처럼 사용하고 그릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1091">Pixelmaps produced in this way can be used and drawn just like pixelmaps produced by Studio and contained within your resource file.</span></span> <span data-ttu-id="b7a34-1092">따라서 애플리케이션은 이미지 압축 풀기, 디더링 및 색 공간 변환을 한번만(일반적으로 프로그램 시작 시) 수행하면 되며 이미지를 그릴 때마다 수행할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1092">This allows your application to perform the image decompression, dithering, and color space conversion one time (usually during program startup) rather than performing these operations each time the image is drawn.</span></span>

<span data-ttu-id="b7a34-1093">이미지 판독기 구성 요소 함수는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1093">The Image Reader component functions include:</span></span>

<span data-ttu-id="b7a34-1094">***gx_image_reader_create***</span><span class="sxs-lookup"><span data-stu-id="b7a34-1094">***gx_image_reader_create***</span></span>  
<span data-ttu-id="b7a34-1095">***gx_image_reader_palette_set***</span><span class="sxs-lookup"><span data-stu-id="b7a34-1095">***gx_image_reader_palette_set***</span></span>  
<span data-ttu-id="b7a34-1096">***gx_image_reader_start***</span><span class="sxs-lookup"><span data-stu-id="b7a34-1096">***gx_image_reader_start***</span></span>

## <a name="guix-animation-component"></a><span data-ttu-id="b7a34-1097">GUIX 애니메이션 구성 요소</span><span class="sxs-lookup"><span data-stu-id="b7a34-1097">GUIX Animation Component</span></span> 

<span data-ttu-id="b7a34-1098">GUIX 애니메이션 구성 요소는 화면 및 위젯 전환을 자동화하는 데 사용되는 함수 및 서비스 세트입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1098">The GUIX Animation component is a set of functions and services used to automate screen and widget transition automations.</span></span> <span data-ttu-id="b7a34-1099">GUIX 애니메이션 구성 요소는 모든 위젯 유형의 페이드 인, 페이드 아웃, 이동 또는 슬라이드 유형 애니메이션을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1099">The GUIX Animation component supports fading in, fading out, and movement or slide type animations of any widget type.</span></span>

<span data-ttu-id="b7a34-1100">페이드 유형 애니메이션은 페이딩 위젯의 내부 알파 값을 변경하거나(**GX_BRUSH_ALPHA_SUPPORT** 를 사용하도록 설정한 경우), 별도의 메모리 캔버스에 위젯 컬렉션을 그린 후 배경과 혼합하는 방식으로 지원할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1100">Fade type animations can be supported either by varying the fading widget(s) internal alpha value (if **GX_BRUSH_ALPHA_SUPPORT** is enabled), or by drawing any collection of widgets to a separate memory canvas when is then blended with the background.</span></span> <span data-ttu-id="b7a34-1101">여러 하드웨어 그래픽 계층을 지원하는 하드웨어 대상의 경우 부드러운 페이딩 효과는 이 캔버스 혼합 방식을 사용할 때 가장 잘 지원되며 코어 CPU 대역폭도 거의 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1101">For hardware targets that support multiple hardware graphics layers, support for smooth fading effects is best accomplished using this canvas blending approach, often with very little core CPU bandwidth required.</span></span> <span data-ttu-id="b7a34-1102">여러 그래픽 계층을 지원하지 않는 하드웨어 대상의 경우 16bpp 이상 색 깊이에서 GUIX 브러시 알파 값을 사용하여 혼합할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1102">For hardware targets that do not support multiple graphics layers, blending using the GUIX brush alpha value is supported when running at 16 bpp and higher color depths.</span></span>

<span data-ttu-id="b7a34-1103">애니메이션에서 별도의 그리기 캔버스를 사용해야 하는 경우 GUIX 애니메이션 구성 요소는 이 목적을 위해 API 서비스 gx_animation_canvas_define을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1103">If an animation should use a separate drawing canvas, the GUIX Animation component provides the API service gx_animation_canvas_define for this purpose.</span></span> <span data-ttu-id="b7a34-1104">다른 애니메이션 형식에는 별도의 캔버스가 필요하지 않지만 가능한 경우 사용될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1104">Other animation types do not require a separate canvas, but they will utilize it if it is available.</span></span> <span data-ttu-id="b7a34-1105">이 경우 여러 하드웨어 화면에 대한 기본 하드웨어 지원을 최대한 활용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1105">This makes the best possible use of any underlying hardware support for multiple hardware surfaces.</span></span>

<span data-ttu-id="b7a34-1106">애니메이션을 제어하는 변수는 두 개의 제어 블록으로 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1106">The variables controlling an animation are defined by two control blocks.</span></span> <span data-ttu-id="b7a34-1107">먼저 애니메이션 컨트롤러를 정의하는 **GX_ANIMATION** 제어 블록이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1107">First, the **GX_ANIMATION** control block which defines the animation controller.</span></span> <span data-ttu-id="b7a34-1108">이 애니메이션 컨트롤러는 사용자가 정의하는 애니메이션 시퀀스를 실행하는 구동 엔진입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1108">The animation controller is the driving engine that executes the animation sequence you define.</span></span> <span data-ttu-id="b7a34-1109">단일 애니메이션 컨트롤러를 여러 번 다시 사용해서 다양한 애니메이션 시퀀스를 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1109">A single animation controller can be re-used many times to run many different animation sequences.</span></span> <span data-ttu-id="b7a34-1110">여러 애니메이션 시퀀스를 동시에 실행 야 하는 경우 여러 **GX_ANIMATION** 애니메이션 컨트롤러를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1110">If you need to run multiple animation sequences simultaneously, you can create multiple **GX_ANIMATION** animation controllers.</span></span>

<span data-ttu-id="b7a34-1111">체GUIX 시스템 구성 요소는 재사용이 가능한 **GX_ANIMATION** 제어 구조체 블록을 제공할 수 있습니다. 이 블록은 애니메이션이 필요할 때 애플리케이션에서 요청할 수 있으며 애니메이션 시퀀스가 완료되면 시스템 풀에 자동으로 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1111">The GUIX system component can provide a re-usable block of **GX_ANIMATION** control structures, which can be requested by the application when and animation is needed and are automatically returned to the system pool when the animation sequence is completed.</span></span> <span data-ttu-id="b7a34-1112">따라서 애플리케이션에서는 구현될 수 있는 모든 애니메이션에 대한 **GX_ANIMATION** 구조체를 정적으로 정의하지 않아도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1112">This frees the application from statically defining a **GX_ANIMATION** structure for every animation that might be implemented.</span></span> <span data-ttu-id="b7a34-1113">이 **GX_ANIMATION** 구조체 풀의 크기는 기본적으로 6으로 설정되는 상수 **GX_ANIMATION_POOL_SIZE** 로 정의됩니다. 즉, 기본적으로 6개의 동시 애니메이션이 시스템 풀에서 할당될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1113">The size of this pool of **GX_ANIMATION** structures is defined by the constant **GX_ANIMATION_POOL_SIZE**, which defaults to 6, meaning that by default 6 simultaneous animations can be allocated from the system pool.</span></span> <span data-ttu-id="b7a34-1114">이 상수는 gx_user.h 헤더 파일에서 다시 정의할 수 있습니다. 이 경우 더 많은 동시 애니메이션이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1114">This constant can of course be re-defined in the gx_user.h header file is more simultaneous animations are required.</span></span> <span data-ttu-id="b7a34-1115">**GX_ANIMATION_POOL_SIZE** 를 0으로 설정하면 GUIX 시스템 구성 요소가 애니메이션 풀 또는 관련 서비스를 제공하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1115">If **GX_ANIMATION_POOL_SIZE** is set to zero, then the GUIX system component does not provide an animation pool or related services.</span></span>

<span data-ttu-id="b7a34-1116">애니메이션을 정의하는 데 사용되는 두 번째 제어 블록 또는 구조체는 **GX_ANIMATION_INFO** 구조체입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1116">The second control block or structure used to define an animation is the **GX_ANIMATION_INFO** structure.</span></span> <span data-ttu-id="b7a34-1117">이 구조체는 특정 애니메이션 시퀀스 하나를 정의하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1117">This structure is used to define one particular animation sequence.</span></span> <span data-ttu-id="b7a34-1118">gx_animation_start API 서비스를 사용하여 애니메이션 시퀀스를 시작하기 위해 이 정보 구조를 애니메이션 컨트롤러에 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1118">You pass this information structure to your animation controller to initiate an animation sequence using the gx_animation_start API service.</span></span> <span data-ttu-id="b7a34-1119">**GX_ANIMATION_INFO** 구조체에는 다음 필드가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1119">The **GX_ANIMATION_INFO** structure contains the following fields:</span></span>

```C
typedef struct GX_ANIMATION_INFO_STRUCT
{
    GX_WIDGET *gx_animation_target;
    GX_WIDGET *gx_animation_parent;
    GX_WIDGET *gx_animation_screen_list;
    USHORT gx_animation_style;
    USHORT gx_animation_id;
    USHORT gx_animation_start_delay;
    USHORT gx_animation_frame_interval;
    GX_POINT gx_animation_start_position;
    GX_POINT gx_animation_end_position;
    GX_UBYTE gx_animation_start_alpha;
    GX_UBYTE gx_animation_end_alpha;
    GX_UBYTE gx_animation_steps;
} GX_ANIMATION_INFO;
```

<span data-ttu-id="b7a34-1120">**gx_animation_target** 멤버는 애니메이션 컨트롤러에서 작업할 대상 위젯을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1120">The **gx_animation_target** member defines the target widget that the animation controller will act upon.</span></span>

<span data-ttu-id="b7a34-1121">**gx_animation_parent** 멤버는 애니메이션 시퀀스가 완료될 때 대상 위젯이 연결되는 부모 위젯을 정의합니다(있는 경우).</span><span class="sxs-lookup"><span data-stu-id="b7a34-1121">The **gx_animation_parent** member defines the parent widget, if any, to which the target widget will be attached when the animation sequence is complete.</span></span> <span data-ttu-id="b7a34-1122">gx_animation_parent는 애니메이션이 완료될 때 생성되는 GX_ANIMATION_COMPLETE 이벤트의 수신자이기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1122">The gx_animation_parent is also the recipient of the GX_ANIMATION_COMPLETE event that is generated when an animation is completed.</span></span>

<span data-ttu-id="b7a34-1123">**gx_animation_screen_list** 멤버는 펜 입력 구동 화면 슬라이드 애니메이션에 대한 위젯 목록을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1123">The **gx_animation_screen_list** member defines a widget list for pen-input-driven screen slide animations.</span></span> <span data-ttu-id="b7a34-1124">위젯 목록은 GX_NULL 포인터로 종료해야 하며 목록의 각 위젯은 gx_animation_parent와 동일한 x, y 차원이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1124">The widge list should be terminated with GX_NULL pointer, and each widget in the list should have the same x,y dimensions as the gx_animation_parent.</span></span>

<span data-ttu-id="b7a34-1125">**gx_animation_style** 은 수행할 애니메이션 형식과 관련 옵션을 정의하는 비트 마스크입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1125">The **gx_animation_style** is a bitmask defining the type of animation to be performed and associated options.</span></span> <span data-ttu-id="b7a34-1126">애니메이션 스타일 플래그에는 다음이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1126">The animation style flags include the following.</span></span>

| <span data-ttu-id="b7a34-1127">애니메이션&nbsp;스타일&nbsp;플래그</span><span class="sxs-lookup"><span data-stu-id="b7a34-1127">Animation&nbsp;Style&nbsp;Flag</span></span> | <span data-ttu-id="b7a34-1128">Description</span><span class="sxs-lookup"><span data-stu-id="b7a34-1128">Description</span></span> |
| --- | --- |
| <span data-ttu-id="b7a34-1129">GX_ANIMATION_TRANSLATE</span><span class="sxs-lookup"><span data-stu-id="b7a34-1129">GX_ANIMATION_TRANSLATE</span></span> | <span data-ttu-id="b7a34-1130">슬라이드 또는 페이드 형식 애니메이션을 요청합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1130">Request a slide or fade type animation.</span></span> |
| <span data-ttu-id="b7a34-1131">GX_ANIMATION_SCREEN_DRAG</span><span class="sxs-lookup"><span data-stu-id="b7a34-1131">GX_ANIMATION_SCREEN_DRAG</span></span> | <span data-ttu-id="b7a34-1132">펜 입력 구동 화면 끌기 애니메이션을 요청합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1132">Request a pen-input driven screen drag animation.</span></span> |

<span data-ttu-id="b7a34-1133">다음 플래그를 **SCREEN_DRAG** 형식 애니메이션과 함께 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1133">The following flags can be used in combination with **SCREEN_DRAG** type animations.</span></span>

| <span data-ttu-id="b7a34-1134">화면&nbsp;끌기&nbsp;플래그</span><span class="sxs-lookup"><span data-stu-id="b7a34-1134">Screen&nbsp;Drag&nbsp;Flags</span></span> | <span data-ttu-id="b7a34-1135">Description</span><span class="sxs-lookup"><span data-stu-id="b7a34-1135">Description</span></span> |
| --- | --- |
| <span data-ttu-id="b7a34-1136">GX_ANIMATION_WRAP</span><span class="sxs-lookup"><span data-stu-id="b7a34-1136">GX_ANIMATION_WRAP</span></span> | <span data-ttu-id="b7a34-1137">화면 목록이 끝에서 시작까지 다시 래핑됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1137">The screen list should wrap from end back to start.</span></span> |
| <span data-ttu-id="b7a34-1138">GX_ANIMATION_HORIZONTAL</span><span class="sxs-lookup"><span data-stu-id="b7a34-1138">GX_ANIMATION_HORIZONTAL</span></span> | <span data-ttu-id="b7a34-1139">가로 방향으로 화면 끌기를 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1139">Screen drag allowed in horizontal direction.</span></span>  |
| <span data-ttu-id="b7a34-1140">GX_ANIMATION_VERTICAL</span><span class="sxs-lookup"><span data-stu-id="b7a34-1140">GX_ANIMATION_VERTICAL</span></span> | <span data-ttu-id="b7a34-1141">세로 방향으로 화면 끌기를 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1141">Screen drag allowed in vertical direction.</span></span> |

<span data-ttu-id="b7a34-1142">다음 플래그는 변환 애니메이션과 함께 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1142">The following flag can be used in combination with translate animations.</span></span>

| <span data-ttu-id="b7a34-1143">애니메이션&nbsp;변환&nbsp;플래그</span><span class="sxs-lookup"><span data-stu-id="b7a34-1143">Translate&nbsp;Animations&nbsp;Flags</span></span> | <span data-ttu-id="b7a34-1144">Description</span><span class="sxs-lookup"><span data-stu-id="b7a34-1144">Description</span></span> |
| --- | --- |
| <span data-ttu-id="b7a34-1145">GX_ANIMATION_DETACH</span><span class="sxs-lookup"><span data-stu-id="b7a34-1145">GX_ANIMATION_DETACH</span></span> | <span data-ttu-id="b7a34-1146">애니메이션이 완료되면 애니메이션 부모 항목에서 애니메이션 대상을 분리합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1146">Detach the animation target from the animation parent when the animation is completed.</span></span> <span data-ttu-id="b7a34-1147">GUIX Studio에서 생성된 자동화 이벤트 처리를 통해 대상이 동적으로 할당되고 만들어진 경우에는 분리된 후 삭제됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1147">If the target was dynamically allocated and created by the GUIX Studio generated automated event handling, the target will be deleted after it is detached.</span></span> |
| <span data-ttu-id="b7a34-1148">GX_ANIMATION_TRANSLATE</span><span class="sxs-lookup"><span data-stu-id="b7a34-1148">GX_ANIMATION_TRANSLATE</span></span> | <span data-ttu-id="b7a34-1149">애니메이션 형식은 타이머 기반 애니메이션입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1149">Animation types are timer driven animations.</span></span> <span data-ttu-id="b7a34-1150">애플리케이션은 대상 위젯에 대한 시작 및 끝 위치와 시작 및 끝 알파 값을 정의하고, 애니메이션 관리자는 애니메이션 실행을 구동하게 될 타이머를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1150">The application defines the starting and ending position and starting and ending alpha value for the target widget, and the animation manager creates a timer to serve and as the driving force to execute the animation.</span></span>
| <span data-ttu-id="b7a34-1151">GX_ANIMATION_SCREEN_DRAG</span><span class="sxs-lookup"><span data-stu-id="b7a34-1151">GX_ANIMATION_SCREEN_DRAG</span></span> | <span data-ttu-id="b7a34-1152">이 애니메이션 형식은 펜 입력 이벤트에 의해 구동된다는 점에서 **TRANSLATE** 애니메이션과 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1152">Differs from the **TRANSLATE** animations in that this animation type is driven by pen input events.</span></span> <span data-ttu-id="b7a34-1153">이 애니메이션은 사용자가 펜 또는 스타일러스를 입력 터치 스크린에서 끌 때 터치 스크린 입력을 따르면서 대상 위젯을 살짝 밉니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1153">This animation type tracks along with the touch screen input to swipe the target widget as the user drags a pen or stylus across the input touch screen.</span></span> <span data-ttu-id="b7a34-1154">이러한 유형의 애니메이션을 활용하려면 애플리케이션에서 **_gx_animation_drag_enable_** API를 호출하여 이 애니메이션을 사용하도록 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1154">To utilize this type of animation, the application should call the **_gx_animation_drag_enable_** API to enable this animation.</span></span> |

<span data-ttu-id="b7a34-1155">**gx_animation_id** 값은 **GX_ANIMATION_COMPLETE** 이벤트의 event.gx_event_sender 필드에서 애니메이션 부모 항목으로 다시 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1155">The **gx_animation_id** value is passed back to the animation parent in the event.gx_event_sender field of the **GX_ANIMATION_COMPLETE** event.</span></span> <span data-ttu-id="b7a34-1156">애니메이션 부모 항목은 이 값을 사용하여 완료를 보고하는 자식 애니메이션을 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1156">This value is used by the animation parent to determine which of possibly several child animations is reporting completion.</span></span> <span data-ttu-id="b7a34-1157">이 값은 0일 수 있으며, ID 값이 0인 애니메이션은 **ANIMATION_COMPLETE** 이벤트를 전혀 생성하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1157">This value can be 0, and an animation with ID value 0 will not generate an **ANIMATION_COMPLETE** event at all.</span></span>

<span data-ttu-id="b7a34-1158">**gx_animation_start_delay** 값은 **_gx_animation_start_ *_가 호출된 후, 애니메이션을 실제로 실행하기 전에 연기할 타이머 틱 수를 나타내는 GUIX 틱 수입니다. _* _gx_animation_start_** 를 호출한 직후에 애니메이션을 시작하려면 이 값을 0으로 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1158">The **gx_animation_start_delay** value is a GUIX tick count indicating the number of timer ticks to delay after **_gx_animation_start_*_ is called before actually executing the animation. The value can be 0 to start the animation immediately upon calling _*_gx_animation_start_**.</span></span>

<span data-ttu-id="b7a34-1159">**gx_animation_frame_interval** 필드는 애니메이션 시퀀스의 각 프레임 사이에서 지연되는 GUIX 타이머 틱 수(기본 OS 틱 속도의 배수)를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1159">The **gx_animation_frame_interval** field defines the number of GUIX timer ticks (a multiple of the underlying OS tick rate) to delay between each frame of the animation sequence.</span></span> <span data-ttu-id="b7a34-1160">최소값은 1입니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1160">The minimum value is 1.</span></span>

<span data-ttu-id="b7a34-1161">**gx_animation_start_position** 은 변환 애니메이션에 대한 대상 위젯의 왼쪽 위 시작 지점을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1161">The **gx_animation_start_position** defines the top-left starting point for the target widget for translation animations.</span></span>

<span data-ttu-id="b7a34-1162">**gx_animation_end_position** 은 변환 형식 애니메이션에 대한 대상 위젯의 왼쪽 위 끝 위치를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1162">The **gx_animation_end_position** defines the top-left ending position for the target widget for translation type animations.</span></span>

<span data-ttu-id="b7a34-1163">**gx_animation_start_alpha** 필드는 변환 형식 애니메이션에 대한 시작 캔버스 알파 값을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1163">The **gx_animation_start_alpha** field defines the starting canvas alpha value for translation type animations.</span></span>

<span data-ttu-id="b7a34-1164">**gx_animation_end_alpha** 필드는 변환 형식 애니메이션에 대한 끝 캔버스 알파 값을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1164">The **gx_animation_end_alpha** field defines the ending canvas alpha value for translation type animations.</span></span>

<span data-ttu-id="b7a34-1165">**gx_animation_steps** 필드는 컨트롤러에서 변환 애니메이션에 대해 실행해야 하는 단계 또는 프레임 수를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1165">The **gx_animation_steps** field defines how many steps or frames the controller should execute for translation animations.</span></span> <span data-ttu-id="b7a34-1166">단계가 더 많으면 슬라이드가 더 부드럽게 진행되고 페이드 모양이 생성되지만 더 큰 시스템 대역폭이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1166">A larger number of steps produces a smoother slide and/or fade appearance, but also requires greater system bandwidth.</span></span>

<span data-ttu-id="b7a34-1167">애플리케이션에서 애니메이션 효과를 구현하려면 먼저 ***gx_animation_create*** 를 호출하여 애니메이션 컨트롤러를 초기화해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1167">To implement animation effects in your application, you must first call ***gx_animation_create*** to initialize your animation controller.</span></span> <span data-ttu-id="b7a34-1168">애니메이션이 보조 캔버스를 사용하는 경우 gx_animation_canvas_define을 호출하여 이 캔버스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1168">If your animation will be using a secondary canvas, initialize this canvas by calling gx_animation_canvas_define.</span></span> <span data-ttu-id="b7a34-1169">다음으로 **GX_ANIMATION_INFO** 구조체를 초기화하여 수행할 특정 형식의 애니메이션 및 기타 애니메이션 매개 변수를 정의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1169">Next, you should initialize the **GX_ANIMATION_INFO** structure to define the specific type of animation to be performed and the other animation parameters.</span></span> <span data-ttu-id="b7a34-1170">마지막으로 gx_animation_start를 호출하여 애니메이션 시퀀스를 트리거합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1170">Finally, call gx_animation_start to trigger the animation sequence.</span></span>

<span data-ttu-id="b7a34-1171">애니메이션 컨트롤러는 애니메이션 시퀀스를 완료하면 부모 위젯에 **GX_ANIMATION_COMPLETE** 이벤트를 전송하여 해당 시점에 애니메이션 캔버스의 원하는 정리가 수행될 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1171">When the animation controller completes an animation sequence, it sends an **GX_ANIMATION_COMPLETE** event to the parent widget, allowing the any desired cleanup of the animation canvas to be done at that time.</span></span>

## <a name="guix-utility-component"></a><span data-ttu-id="b7a34-1172">GUIX 유틸리티 구성 요소</span><span class="sxs-lookup"><span data-stu-id="b7a34-1172">GUIX Utility Component</span></span> 

<span data-ttu-id="b7a34-1173">유틸리티 구성 요소는 GUIX의 모든 일반 유틸리티 함수를 담당합니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1173">The utility component is responsible for all common utility functions in GUIX.</span></span> <span data-ttu-id="b7a34-1174">유용한 유틸리티에 해당하는 일반적인 함수이며 애플리케이션 또는 내부 GUIX 코드의 어디에서나 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1174">These are common functions that are useful utilities and can be invoked from anywhere in the application or the internal GUIX code.</span></span> <span data-ttu-id="b7a34-1175">유틸리티 구성 요소 함수에는 다음이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7a34-1175">The utility component functions include the following.</span></span>

<span data-ttu-id="b7a34-1176">***gx_utility_canvas_to_bmp***</span><span class="sxs-lookup"><span data-stu-id="b7a34-1176">***gx_utility_canvas_to_bmp***</span></span>

<span data-ttu-id="b7a34-1177">***gx_utility_circle_point_get***</span><span class="sxs-lookup"><span data-stu-id="b7a34-1177">***gx_utility_circle_point_get***</span></span>

<span data-ttu-id="b7a34-1178">***gx_utility_alphamap_create***</span><span class="sxs-lookup"><span data-stu-id="b7a34-1178">***gx_utility_alphamap_create***</span></span>

<span data-ttu-id="b7a34-1179">***gx_utility_gradient_create***</span><span class="sxs-lookup"><span data-stu-id="b7a34-1179">***gx_utility_gradient_create***</span></span>

<span data-ttu-id="b7a34-1180">***gx_utility_gradient_delete***</span><span class="sxs-lookup"><span data-stu-id="b7a34-1180">***gx_utility_gradient_delete***</span></span>

<span data-ttu-id="b7a34-1181">***gx_utlity_ltoa***</span><span class="sxs-lookup"><span data-stu-id="b7a34-1181">***gx_utlity_ltoa***</span></span>

<span data-ttu-id="b7a34-1182">***gx_utility_math_acos***</span><span class="sxs-lookup"><span data-stu-id="b7a34-1182">***gx_utility_math_acos***</span></span>

<span data-ttu-id="b7a34-1183">***gx_utility_math_asin***</span><span class="sxs-lookup"><span data-stu-id="b7a34-1183">***gx_utility_math_asin***</span></span>

<span data-ttu-id="b7a34-1184">***gx_utility_math_cos***</span><span class="sxs-lookup"><span data-stu-id="b7a34-1184">***gx_utility_math_cos***</span></span>

<span data-ttu-id="b7a34-1185">***gx_utility_math_sin***</span><span class="sxs-lookup"><span data-stu-id="b7a34-1185">***gx_utility_math_sin***</span></span>

<span data-ttu-id="b7a34-1186">***gx_utility_math_sqrt***</span><span class="sxs-lookup"><span data-stu-id="b7a34-1186">***gx_utility_math_sqrt***</span></span>

<span data-ttu-id="b7a34-1187">***gx_utility_pixelmap_resize***</span><span class="sxs-lookup"><span data-stu-id="b7a34-1187">***gx_utility_pixelmap_resize***</span></span>

<span data-ttu-id="b7a34-1188">***gx_utility_pixelmap_rotate***</span><span class="sxs-lookup"><span data-stu-id="b7a34-1188">***gx_utility_pixelmap_rotate***</span></span>

<span data-ttu-id="b7a34-1189">***gx_utility_pixelmap_simple_rotate***</span><span class="sxs-lookup"><span data-stu-id="b7a34-1189">***gx_utility_pixelmap_simple_rotate***</span></span>

<span data-ttu-id="b7a34-1190">***gx_utility_rectangle_center***</span><span class="sxs-lookup"><span data-stu-id="b7a34-1190">***gx_utility_rectangle_center***</span></span>

<span data-ttu-id="b7a34-1191">***gx_utility_rectangle_center_find***</span><span class="sxs-lookup"><span data-stu-id="b7a34-1191">***gx_utility_rectangle_center_find***</span></span>

<span data-ttu-id="b7a34-1192">***gx_utility_rectangle_combine***</span><span class="sxs-lookup"><span data-stu-id="b7a34-1192">***gx_utility_rectangle_combine***</span></span>

<span data-ttu-id="b7a34-1193">***gx_utility_rectangle_compare***</span><span class="sxs-lookup"><span data-stu-id="b7a34-1193">***gx_utility_rectangle_compare***</span></span>

<span data-ttu-id="b7a34-1194">***gx_utility_rectangle_define***</span><span class="sxs-lookup"><span data-stu-id="b7a34-1194">***gx_utility_rectangle_define***</span></span>

<span data-ttu-id="b7a34-1195">***gx_utility_rectangle_overlap_detect***</span><span class="sxs-lookup"><span data-stu-id="b7a34-1195">***gx_utility_rectangle_overlap_detect***</span></span>

<span data-ttu-id="b7a34-1196">***gx_utility_rectangle_point_detect***</span><span class="sxs-lookup"><span data-stu-id="b7a34-1196">***gx_utility_rectangle_point_detect***</span></span>

<span data-ttu-id="b7a34-1197">***gx_utility_rectangle_resize***</span><span class="sxs-lookup"><span data-stu-id="b7a34-1197">***gx_utility_rectangle_resize***</span></span>

<span data-ttu-id="b7a34-1198">***gx_utility_rectangle_shift***</span><span class="sxs-lookup"><span data-stu-id="b7a34-1198">***gx_utility_rectangle_shift***</span></span>

<span data-ttu-id="b7a34-1199">***gx_utility_string_to_alphamap***</span><span class="sxs-lookup"><span data-stu-id="b7a34-1199">***gx_utility_string_to_alphamap***</span></span>
