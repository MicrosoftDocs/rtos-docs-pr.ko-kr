---
title: 1장 - Azure RTOS NetX DNS 클라이언트 소개
description: Azure RTOS NetX DNS는 도메인 이름과 실제 IP 주소 간의 매핑을 포함하는 분산 데이터베이스를 제공합니다.
author: philmea
ms.author: philmea
ms.date: 06/04/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 3426b0895e259bd70e758aae8b56349082a3a95a
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/22/2021
ms.locfileid: "104811592"
---
# <a name="chapter-1---introduction-to-the-azure-rtos-netx-dns-client"></a><span data-ttu-id="659aa-103">1장 - Azure RTOS NetX DNS 클라이언트 소개</span><span class="sxs-lookup"><span data-stu-id="659aa-103">Chapter 1 - Introduction to the Azure RTOS NetX DNS Client</span></span>

<span data-ttu-id="659aa-104">Azure RTOS NetX DNS는 도메인 이름과 실제 IP 주소 간의 매핑을 포함하는 분산 데이터베이스를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-104">The Azure RTOS NetX DNS provides a distributed database that contains mapping between domain names and physical IP addresses.</span></span> <span data-ttu-id="659aa-105">이 데이터베이스는 인터넷에서 전체 매핑을 포함하는 단일 엔터티가 없기 때문에 *분산* 이라고 부릅니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-105">The database is referred to as *distributed* because there is no single entity on the Internet that contains the complete mapping.</span></span> <span data-ttu-id="659aa-106">매핑 부분을 유지 관리하는 엔터티를 DNS 서버라고 부릅니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-106">An entity that maintains a portion of the mapping is called a DNS Server.</span></span> <span data-ttu-id="659aa-107">인터넷은 무수히 많은 DNS 서버들로 구성됩니다. 이러한 각 서버에는 데이터베이스 하위 집합이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-107">The Internet is composed of numerous DNS Servers, each of which contains a subset of the database.</span></span> <span data-ttu-id="659aa-108">또한 DNS 서버는 서버에 요청된 매핑이 포함된 경우에만 도메인 이름 매핑 정보에 대한 DNS 클라이언트 요청에 응답합니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-108">DNS Servers also respond to DNS Client requests for domain name mapping information, only if the server has the requested mapping.</span></span>

<span data-ttu-id="659aa-109">NetX용 DNS 클라이언트 프로토콜은 하나 이상의 DNS 서버에서 매핑 정보를 요청하기 위해 애플리케이션에 서비스를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-109">The DNS Client protocol for NetX provides the application with services to request mapping information from one or more DNS Servers.</span></span>

## <a name="dns-client-setup"></a><span data-ttu-id="659aa-110">DNS 클라이언트 설정</span><span class="sxs-lookup"><span data-stu-id="659aa-110">DNS Client Setup</span></span>

<span data-ttu-id="659aa-111">DNS 클라이언트 패키지가 제대로 작동하기 위해서는 NetX IP 인스턴스가 이미 생성되어 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-111">In order to function properly, the DNS Client package requires that a NetX IP instance has already been created.</span></span>

<span data-ttu-id="659aa-112">DNS 클라이언트를 만든 후 애플리케이션이 DNS 클라이언트에서 유지 관리되는 서버 목록에 하나 이상의 DNS 서버를 추가해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-112">After creating the DNS Client, the application must add one or more DNS servers to the server list maintained by the DNS Client.</span></span> <span data-ttu-id="659aa-113">DNS 서버를 추가하기 위해 애플리케이션은 *nx_dns_server_add* 서비스를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-113">To add DNS servers, the application uses the *nx_dns_server_add* service.</span></span>

<span data-ttu-id="659aa-114">NX_DNS_IP_GATEWAY_SERVER 옵션이 사용하도록 설정되었고, IP 인스턴스 게이트웨이 주소가 0이 아니면 IP 인스턴스 게이트웨이가 주 DNS 서버로 자동으로 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-114">If the NX_DNS_IP_GATEWAY_SERVER option is enabled, and the IP instance gateway address is non zero, the IP instance gateway is automatically added as the primary DNS server.</span></span> <span data-ttu-id="659aa-115">DNS 서버 정보가 정적으로 알려지지 않았으면 NetX용 DHCP(Dynamic Host Configuration Protocol)를 통해 파생될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-115">If DNS server information is not statically known, it may also be derived through the Dynamic Host Configuration Protocol (DHCP) for NetX.</span></span> <span data-ttu-id="659aa-116">자세한 내용은 NetX DHCP 사용자 가이드를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="659aa-116">Please refer to the NetX DHCP User Guide for more information.</span></span>

<span data-ttu-id="659aa-117">DNS 클라이언트에는 DNS 메시지를 전송하기 위한 패킷 풀이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-117">The DNS Client requires a packet pool for transmitting DNS messages.</span></span> <span data-ttu-id="659aa-118">기본적으로 DNS 클라이언트는 *nx_dns_create* 서비스가 호출될 때 이 패킷 풀을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-118">By default, the DNS Client creates this packet pool when the *nx_dns_create* service is called.</span></span> <span data-ttu-id="659aa-119">NX_DNS_PACKET_PAYLOAD 및 NX_DNS_PACKET_POOL_SIZE 구성 옵션을 통해 애플리케이션이 이 패킷 풀의 각 패킷 페이로드 및 패킷 풀 크기(예: 패킷 수)를 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-119">The configuration options NX_DNS_PACKET_PAYLOAD and NX_DNS_PACKET_POOL_SIZE allow the application to determine the packet payload and packet pool size (e.g. number of packets) of this packet pool respectively.</span></span> <span data-ttu-id="659aa-120">이러한 옵션에 대해서는 2장의 “구성 옵션” 섹션에 설명되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-120">These options are described in section “Configuration Options” in Chapter Two.</span></span>

<span data-ttu-id="659aa-121">고유 패킷 풀을 만드는 DNS 클라이언트에 대한 대안은 애플리케이션이 패킷 풀을 만들고 *nx_dns_packet_pool_set* 서비스를 사용하여 DNS 클라이언트의 패킷 풀로 설정하도록 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-121">An alternative to the DNS Client creating its own packet pool is for the application to create the packet pool and set it as the DNS Client’s packet pool using the *nx_dns_packet_pool_set* service.</span></span> <span data-ttu-id="659aa-122">이렇게 하려면 NX_DNS_CLIENT_USER_CREATE_PACKET_POOL 옵션을 정의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-122">To do so, the NX_DNS_CLIENT_USER_CREATE_PACKET_POOL option must be defined.</span></span> <span data-ttu-id="659aa-123">또한 이 옵션에서는 *nx_packet_pool_create* 를 *nx_dns_packet_pool_set* 에 대한 패킷 풀 포인터 입력으로 사용하여 이전에 생성된 패킷 풀이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-123">This option also requires a previously created packet pool using *nx_packet_pool_create* as the packet pool pointer input to *nx_dns_packet_pool_set*.</span></span> <span data-ttu-id="659aa-124">DNS 클라이언트 인스턴스가 삭제되면 NX_DNS_CLIENT_USER_CREATE_PACKET_POOL이 사용하도록 설정된 경우 더 이상 필요하지 않을 때 애플리케이션이 DNS 클라이언트 패킷 풀 삭제를 담당합니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-124">When the DNS Client instance is deleted, the application is responsible for deleting the DNS Client packet pool if NX_DNS_CLIENT_USER_CREATE_PACKET_POOL is enabled if it is no longer needed.</span></span>

>[!NOTE] 
> <span data-ttu-id="659aa-125">**NX_DNS_CLIENT_USER_CREATE_PACKET_POOL 옵션** 을 사용하여 고유 패킷 풀을 제공하도록 선택하는 애플리케이션의 경우 UDP 헤더, IPv4 헤더 및 MAC 헤더를 위한 공간을 포함하여 DNS 최대 메시지 크기(512바이트)를 저장할 수 있는 패킷 크기가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-125">For applications choosing to provide its own packet pool using the **NX_DNS_CLIENT_USER_CREATE_PACKET_POOL option,** the packet size needs to be able to hold the DNS maximum massage size (512 bytes) plus rooms for UDP header, IPv4 header, and the MAC header.</span></span>

## <a name="dns-messages"></a><span data-ttu-id="659aa-126">DNS 메시지</span><span class="sxs-lookup"><span data-stu-id="659aa-126">DNS Messages</span></span>

<span data-ttu-id="659aa-127">DNS에는 호스트 이름과 IP 주소 사이에 매핑을 얻기 위한 매우 간단한 메커니즘이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-127">The DNS has a very simple mechanism for obtaining mapping between host names and IP addresses.</span></span> <span data-ttu-id="659aa-128">매핑을 얻기 위해 DNS 클라이언트는 확인해야 하는 이름 또는 IP 주소가 포함된 DNS 쿼리 메시지를 준비합니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-128">To obtain a mapping, the DNS Client prepares a DNS query message containing the name or the IP address that needs to be resolved.</span></span> <span data-ttu-id="659aa-129">그런 후 서버 목록에서 첫 번째 DNS 서버에 메시지가 전송됩니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-129">The message is then sent to the first DNS server in the server list.</span></span> <span data-ttu-id="659aa-130">서버에 이러한 매핑이 있으면 요청된 매핑 정보가 포함된 DNS 응답 메시지를 사용하여 DNS 클라이언트에 회신합니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-130">If the server has such a mapping, it replies to the DNS Client using a DNS response message that contains the requested mapping information.</span></span> <span data-ttu-id="659aa-131">서버가 응답하지 않으면 모든 DNS 서버에 쿼리가 수행될 때까지 DNS 클라이언트가 목록에 있는 다음 서버에 쿼리를 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-131">If the server does not respond, the DNS Client queries the next server on its list until all its DNS servers have been queried.</span></span> <span data-ttu-id="659aa-132">모든 DNS 서버에서 응답이 수신되지 않을 경우 DNS 클라이언트는 재시도 논리를 사용하여 DNS 메시지를 다시 전송합니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-132">If no response from all its DNS servers is received, the DNS Client has retry logic to retransmit the DNS message.</span></span> <span data-ttu-id="659aa-133">DNS 쿼리를 다시 보낼 때는 재전송 시간 제한이 두 배가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-133">On resending a DNS query, the retransmission timeout is doubled.</span></span> <span data-ttu-id="659aa-134">이 프로세스는 최대 전송 시간 제한(*nxd_dns.h* 에서 NX_DNS_MAX_RETRANS_TIMEOUT으로 정의됨)에 도달하거나 서버로부터 성공 응답이 수신될 때까지 계속됩니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-134">This process continues until the maximum transmission timeout (defined as NX_DNS_MAX_RETRANS_TIMEOUT in *nxd_dns.h*) is reached or until a successful response is received from that server is obtained.</span></span>

<span data-ttu-id="659aa-135">NetX DNS 클라이언트는 *nx_dns_host_by_name_get* 또는 *nx_dns_ipv4_address_by_name_get* 을 호출하여 IPv4 주소 조회(A 형식)를 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-135">NetX DNS Client can perform IPv4 address lookups (type A) by calling *nx_dns_host_by_name_get or* *nx_dns_ipv4_address_by_name_get*.</span></span> <span data-ttu-id="659aa-136">DNS 클라이언트는 *nx_dns_host_by_address_get* 을 사용하여 웹 호스트 이름을 가져오기 위해 IP 주소의 역방향 조회(PTR 형식 쿼리)를 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-136">The DNS Client can perform reverse lookups of IP addresses (type PTR queries) to obtain web host names using *nx_dns_host_by_address_get*.</span></span>

<span data-ttu-id="659aa-137">DNS 메시지는 UDP 프로토콜을 사용하여 요청 및 필드 응답을 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-137">DNS messaging utilizes the UDP protocol to send requests and field responses.</span></span> <span data-ttu-id="659aa-138">DNS 서버는 클라이언트의 쿼리에 대해 포트 번호 53에서 수신 대기합니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-138">A DNS Server listens on port number 53 for queries from clients.</span></span> <span data-ttu-id="659aa-139">따라서 이전에 생성된 IP 인스턴스(_\*_nx_ip_create_\*\*)에서 \***nx_udp_enable** _ 서비스를 사용하여 NetX에 UDP 서비스가 사용하도록 설정되어 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-139">Therefore UDP services must be enabled in NetX using the ***nx_udp_enable** _ service on a previously created IP instance (_*_nx_ip_create_\*\*).</span></span>

<span data-ttu-id="659aa-140">이제 DNS 클라이언트가 애플리케이션에서 요청을 수락하고 DNS 쿼리를 보낼 준비가 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-140">At this point, the DNS Client is ready to accept requests from the application and send out DNS queries.</span></span>

## <a name="extended-dns-resource-record-types"></a><span data-ttu-id="659aa-141">확장된 DNS 리소스 레코드 형식</span><span class="sxs-lookup"><span data-stu-id="659aa-141">Extended DNS Resource Record Types</span></span>

<span data-ttu-id="659aa-142">NX_DNS_ENABLE_EXTENDED_RR_TYPES가 사용하도록 설정된 경우 NetX DNS 클라이언트는 다음 레코드 형식 쿼리도 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-142">If NX_DNS_ENABLE_EXTENDED_RR_TYPES is enabled, NetX DNS Client also supports the following record type queries:</span></span>

- <span data-ttu-id="659aa-143">**CNAME**: 별칭의 정식 이름을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-143">**CNAME**: contains the canonical name for an alias</span></span>

- <span data-ttu-id="659aa-144">**TXT**: 텍스트 문자열을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-144">**TXT**: contains a text string</span></span>

- <span data-ttu-id="659aa-145">**NS**: 권한이 있는 이름 서버를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-145">**NS**: contains an authoritative name server</span></span>

- <span data-ttu-id="659aa-146">**SOA**: 권한 영역의 시작을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-146">**SOA**: contains the start of a zone of authority</span></span>

- <span data-ttu-id="659aa-147">**MX**: 메일 교환에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-147">**MX**: used for mail exchange</span></span>

- <span data-ttu-id="659aa-148">**SRV**: 도메인에서 제공되는 서비스에 대한 정보를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-148">**SRV**: contains information on the service offered by the domain</span></span>

<span data-ttu-id="659aa-149">CNAME 및 TXT 레코드 형식을 제외하고 DNS 데이터 레코드를 수신하기 위해 애플리케이션이 4바이트로 정렬된 버퍼를 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-149">With the exception of CNAME and TXT record types, the application must supply a 4-byte aligned buffer to receive the DNS data record.</span></span>

<span data-ttu-id="659aa-150">NetX DNS 클라이언트에서 레코드 데이터는 버퍼 공간을 가장 효율적으로 사용할 수 있는 방식으로 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-150">In NetX DNS Client, record data is stored in such a way to make most efficient use of buffer space.</span></span>

<span data-ttu-id="659aa-151">호스트 이름이 가변 길이인 NS 레코드와 같이 레코드 형식에 가변 데이터 길이가 포함된 쿼리의 경우 NetX DNS 클라이언트가 데이터를 다음과 같이 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-151">For those queries whose record types have variable data length, such as NS records whose host names are of variable length, NetX DNS Client saves the data as follows.</span></span> <span data-ttu-id="659aa-152">DNS 클라이언트 쿼리에 제공된 버퍼는 고정 길이 데이터 영역과 비구조적 메모리 영역으로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-152">The buffer supplied in the DNS Client query is organized into an area of fixed length data and an area of unstructured memory.</span></span> <span data-ttu-id="659aa-153">메모리 버퍼 위쪽은 4바이트로 정렬된 레코드 항목으로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-153">The top of the memory buffer is organized into 4-byte aligned record entries.</span></span> <span data-ttu-id="659aa-154">각 레코드 항목에는 IP 주소와 해당 IP 주소의 가변 길이 데이터에 대한 포인터가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-154">Each record entry contains the IP address and a pointer to the variable length data for that IP address.</span></span> <span data-ttu-id="659aa-155">각 IP 주소의 가변 길이 데이터는 메모리 버퍼 끝에서 시작하는 비구조적 영역 메모리에 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-155">The variable length data for each IP address are stored in the unstructured area memory starting at the end of the memory buffer.</span></span> <span data-ttu-id="659aa-156">연속된 각 레코드 항목의 가변 길이 데이터는 이전 레코드 항목 가변 데이터에 인접한 다음 영역 메모리에 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-156">The variable length data for each successive record entry is saved in the next area memory adjacent to the previous record entries variable data.</span></span> <span data-ttu-id="659aa-157">따라서 다른 레코드 항목 및 가변 데이터를 저장하기에 메모리가 부족해질 때까지 레코드 항목을 포함하는 메모리의 구조적 영역으로 가변 데이터가 ‘증가’합니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-157">Hence, the variable data ‘grows’ towards the structured area of memory containing the record entries until there is insufficient memory to store another record entry and variable data.</span></span>

<span data-ttu-id="659aa-158">아래 그림과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-158">This is shown in the figure below:</span></span>

![DNS 도메인 이름(NS) 데이터 스토리지의 예를 보여주는 다이어그램](media/image1.png)

<span data-ttu-id="659aa-160">DNS 도메인 이름(NS) 데이터 스토리지의 예는 위에 나와 있습니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-160">The example of the DNS domain name (NS) data storage is shown above.</span></span>

<span data-ttu-id="659aa-161">레코드 스토리지 형식을 사용하는 NetX DNS 클라이언트 쿼리는 레코드 버퍼에 저장된 레코드 수를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-161">NetX DNS Client queries using the record storage format return the number of records saved to the record buffer.</span></span> <span data-ttu-id="659aa-162">이 정보에 따라 애플리케이션이 레코드 버퍼에서 NS 레코드를 추출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-162">This information enables the application to extract NS records from the record buffer.</span></span>

<span data-ttu-id="659aa-163">이 레코드 스토리지 형식을 사용하여 가변 길이 DNS 데이터를 저장하는 DNS 클라이언트 쿼리 예제는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-163">An example of a DNS Client query that stores variable length DNS data using this record storage format is shown below:</span></span>

```c
UINT     _nx_dns_domain_name_server_get(NX_DNS *dns_ptr, UCHAR  *host_name, 
                                        VOID *record_buffer, UINT buffer_size, 
                                        UINT *record_count, ULONG wait_option);
```

<span data-ttu-id="659aa-164">자세한 내용은 3장 “DNS 클라이언트 서비스 설명”을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="659aa-164">More details are available in Chapter 3, “Description of DNS Client Services”.</span></span>

## <a name="dns-cache"></a><span data-ttu-id="659aa-165">DNS 캐시</span><span class="sxs-lookup"><span data-stu-id="659aa-165">DNS Cache</span></span>

<span data-ttu-id="659aa-166">NX_DNS_CACHE_ENABLE이 사용하도록 설정된 경우 NetX DNS 클라이언트가 DNS 캐시 기능을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-166">If NX_DNS_CACHE_ENABLE is enabled, NetX DNS Client supports the DNS Cache feature.</span></span> <span data-ttu-id="659aa-167">DNS 클라이언트를 만든 후 애플리케이션이 API *nx_dns_cache_initialize()* 를 호출하여 특별한 DNS 캐시를 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-167">After creating the DNS Client, the application can call the API *nx_dns_cache_initialize()* to set the special DNS Cache.</span></span> <span data-ttu-id="659aa-168">DNS 캐시 기능을 사용하도록 설정하면 DNS 클라이언트가 DNS 쿼리 전송을 시작하기 전 DNS 캐시에서 사용 가능한 답변을 찾을 수 있습니다. 사용 가능한 답변을 찾으면 애플리케이션에 답변을 직접 반환하고, 그렇지 않으면 DNS 클라이언트가 DNS 서버에 쿼리 메시지를 보내고 회신을 기다립니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-168">If enable DNS Cache feature, DNS Client will find the available answer from DNS Cache before starts to send DNS query, if find the available answer, directly return the answer to application, otherwise DNS Client sends out query message to DNS server and waits for the reply.</span></span> <span data-ttu-id="659aa-169">DNS 클라이언트가 응답 메시지를 가져오고 사용 가능한 캐시가 있으면 DNS 클라이언트가 답변을 애플리케이션에 반환하고 DNS 캐시에도 리소스 레코드로 답변을 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-169">When DNS Client gets the response message and there is free cache available, DNS Client returns the answer to the application and also adds the answer as resource record into DNS cache.</span></span>

<span data-ttu-id="659aa-170">각 항목은 캐시의 데이터 구조 *NX_DNS_RR*(리소스 레코드)에 답변합니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-170">Each answer a data structure *NX_DNS_RR* (Resource Record) in the cache.</span></span> <span data-ttu-id="659aa-171">레코드의 문자열(리소스 레코드 이름 및 데이터)은 가변 길이이므로 NX_DNS_RR 구조에 저장되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-171">Strings (resource record name and data) in Records are variable length, therefore are not stored in the NX_DNS_RR structure.</span></span> <span data-ttu-id="659aa-172">레코드에는 문자열이 저장되는 실제 메모리 위치에 대한 포인터가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-172">The Record contains pointers to the actual memory location where the strings are stored.</span></span> <span data-ttu-id="659aa-173">문자열 테이블 및 레코드는 캐시를 공유합니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-173">The string table and the Records share the cache.</span></span> <span data-ttu-id="659aa-174">레코드는 캐시 시작 부분에서 저장되며 캐시 끝을 향해 증가합니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-174">Records are stored from the beginning of the cache, and grow towards the end of the cache.</span></span> <span data-ttu-id="659aa-175">문자열 테이블은 캐시 끝에서 시작하여 캐시 시작을 향해 증가합니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-175">The string table starts from the end of the cache and grows towards the beginning of the cache.</span></span> <span data-ttu-id="659aa-176">문자열 테이블의 각 문자열에는 길이 필드와 카운터 필드가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-176">Each string in the string table has a length field and a counter field.</span></span> <span data-ttu-id="659aa-177">문자열이 문자열 테이블에 추가될 때 테이블에 동일한 문자열이 이미 있으면 카운터 값이 증가하고 해당 문자열에 대해 메모리가 할당되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-177">When a string is added to the string table, if the same string is already present in the table, the counter value is incremented and no memory is allocated for the string.</span></span> <span data-ttu-id="659aa-178">캐시에 새 문자열 또는 그 이상의 리소스 레코드를 추가할 수 없으면 캐시가 가득 찬 것으로 간주됩니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-178">The cache is considered full if no more resource records or new strings can be added to the cache.</span></span>

## <a name="dns-client-limitations"></a><span data-ttu-id="659aa-179">DNS 클라이언트 제한 사항</span><span class="sxs-lookup"><span data-stu-id="659aa-179">DNS Client Limitations</span></span>

<span data-ttu-id="659aa-180">DNS 클라이언트는 한 번에 하나의 DNS 요청을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-180">The DNS Client supports one DNS request at a time.</span></span> <span data-ttu-id="659aa-181">다른 DNS 요청을 수행하려고 시도하는 스레드는 이전 DNS 요청이 완료될 때까지 일시적으로 차단됩니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-181">Threads attempting to make another DNS request are temporarily blocked until the previous DNS request is complete.</span></span>

<span data-ttu-id="659aa-182">NetX DNS 클라이언트는 정식 답변의 데이터를 사용하여 추가 DNS 쿼리를 다른 DNS 서버로 전달하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-182">The NetX DNS Client does not use data from authoritative answers to forward additional DNS queries to other DNS servers.</span></span>

## <a name="dns-rfcs"></a><span data-ttu-id="659aa-183">DNS RFC</span><span class="sxs-lookup"><span data-stu-id="659aa-183">DNS RFCs</span></span>

<span data-ttu-id="659aa-184">NetX DNS는 다음 RFC와 호환됩니다.</span><span class="sxs-lookup"><span data-stu-id="659aa-184">NetX DNS is compliant with the following RFCs:</span></span>

- <span data-ttu-id="659aa-185">RFC1034 도메인 이름 - 개념 및 기능</span><span class="sxs-lookup"><span data-stu-id="659aa-185">RFC1034 DOMAIN NAMES - CONCEPTS AND FACILITIES</span></span>
- <span data-ttu-id="659aa-186">RFC1035 도메인 이름 - 구현 및 사양</span><span class="sxs-lookup"><span data-stu-id="659aa-186">RFC1035 DOMAIN NAMES - IMPLEMENTATION AND SPECIFICATION</span></span>
- <span data-ttu-id="659aa-187">RFC1480 미국 도메인</span><span class="sxs-lookup"><span data-stu-id="659aa-187">RFC1480 The US Domain</span></span>
- <span data-ttu-id="659aa-188">RFC 2782 서비스 위치를 지정하기 위한 DNS RR(DNS SRV)</span><span class="sxs-lookup"><span data-stu-id="659aa-188">RFC 2782 A DNS RR for specifying the location of services (DNS SRV)</span></span>