---
title: 3장 - Azure RTOS NetX Secure의 기능 설명
description: 이 챕터에는 NetX Secure TLS에 대한 기능 설명이 포함되어 있습니다.
author: philmea
ms.author: philmea
ms.date: 06/04/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: c28ad0255f99986a4ddfe5faefad81e70840e5e0
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/22/2021
ms.locfileid: "104810501"
---
# <a name="chapter-3---functional-description-of-azure-rtos-netx-secure"></a><span data-ttu-id="14b4a-103">3장 - Azure RTOS NetX Secure의 기능 설명</span><span class="sxs-lookup"><span data-stu-id="14b4a-103">Chapter 3 - Functional description of Azure RTOS NetX Secure</span></span>

## <a name="execution-overview"></a><span data-ttu-id="14b4a-104">실행 개요</span><span class="sxs-lookup"><span data-stu-id="14b4a-104">Execution Overview</span></span>

<span data-ttu-id="14b4a-105">이 챕터에는 Azure RTOS NetX Secure TLS에 대한 기능 설명이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-105">This chapter contains a functional description of Azure RTOS NetX Secure TLS.</span></span> <span data-ttu-id="14b4a-106">NetX Secure TLS 애플리케이션에는 초기화 및 애플리케이션 인터페이스 호출이라는 두 가지 주요 프로그램 실행 형식이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-106">There are two primary types of program execution in a NetX Secure TLS application: initialization and application interface calls.</span></span> 

<span data-ttu-id="14b4a-107">NetX Secure는 ThreadX 및 NetX/NetXDuo가 있다고 가정합니다. ThreadX에서는 스레드 실행, 일시 중단, 주기적 타이머, 상호 배제 기능이 필요합니다. NetX/NetXDuo에서는 TCP/IP 네트워킹 기능과 드라이버가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-107">*NetX Secure assumes the existence of ThreadX and NetX/NetXDuo. From ThreadX, it requires thread execution, suspension, periodic timers, and mutual exclusion facilities. From NetX/NetXDuo it requires the TCP/IP networking facilities and drivers.*</span></span>

## <a name="transport-layer-security-tls-and-secure-sockets-layer-ssl"></a><span data-ttu-id="14b4a-108">TLS(전송 계층 보안) 및 SSL(Secure Sockets Layer)</span><span class="sxs-lookup"><span data-stu-id="14b4a-108">Transport Layer Security (TLS) and Secure Sockets Layer (SSL)</span></span>

<span data-ttu-id="14b4a-109">NetX Secure의 보안 네트워크 프로토콜 구성 요소는 RFC 2246(버전 1.0), 4346(버전 1.1), 5246(버전 1.2), 8446(버전 1.3)에 설명되어 있는 TLS(전송 계층 보안) 프로토콜을 구현한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-109">The secure network protocol component of NetX secure is an implementation of the Transport Layer Security (TLS) protocol as described in RFCs 2246 (version 1.0), 4346 (version 1.1), 5246 (version 1.2) and 8446 (version 1.3).</span></span> <span data-ttu-id="14b4a-110">기본 X.509(RFC 5280)에 대한 지원 루틴도 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-110">Also included are support routines for basic X.509 (RFC 5280).</span></span>

<span data-ttu-id="14b4a-111">NetX Secure TLS는 TLS 버전 1.2 및 1.3을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-111">NetX Secure TLS supports TLS versions 1.2 and 1.3.</span></span> <span data-ttu-id="14b4a-112">현재 더 이상 사용되지 않는 TLS 1.0 및 TLS 1.1에 대한 구현이 제공되지만 명시적으로 초기화해야 하며 새 제품에는 사용하지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-112">Implementations are provided for the now-deprecated TLS 1.0 and TLS 1.1, but they must be explicitly initialized and are not recommended for use in new products.</span></span>

<span data-ttu-id="14b4a-113">SSL(*Secure Sockets Layer*)은 RFC 2246에서 표준이 되기 전 TLS의 원래 이름이며 "SSL"이 TLS 프로토콜의 일반적인 이름으로 사용되는 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-113">*Secure Sockets Layer* (SSL) was the original name of TLS before it became a standard in RFC 2246 and "SSL" is often used as a generic name for the TLS protocols.</span></span> <span data-ttu-id="14b4a-114">SSL의 마지막 버전은 3.0이고 TLS 1.0을 SSL 버전 3.1이라고 하는 경우도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-114">The last version of SSL was 3.0, and TLS 1.0 is sometimes referred to as SSL version 3.1.</span></span> <span data-ttu-id="14b4a-115">공식 "SSL" 프로토콜의 모든 버전은 더 이상 사용되지 않고 안전하지 않은 것으로 간주되며 현재 NetX Secure는 SSL 구현을 제공하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-115">All versions of the official "SSL" protocol are considered obsolete and insecure and currently NetX Secure does not provide an SSL implementation.</span></span>

<span data-ttu-id="14b4a-116">TLS는 TLS 클라이언트와 서버 간의 TLS 핸드셰이크 중에 만들어지는 세션 키를 생성하는 프로토콜을 지정하며, 이러한 키는 TLS 세션 중에 애플리케이션에서 보낸 데이터를 암호화하는 데 사용됩니다.  </span><span class="sxs-lookup"><span data-stu-id="14b4a-116">TLS specifies a protocol to generate *session keys* which are created during the TLS *handshake* between a TLS client and server and those keys are used to encrypt data sent by the application during the TLS *session.*</span></span>

<span data-ttu-id="14b4a-117">TLS 데이터는 개념상 TCP 패킷과 동일한 레코드로 나뉩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-117">TLS data is divided into *records* which are equivalent in concept to a TCP packet.</span></span> <span data-ttu-id="14b4a-118">모든 TLS 레코드에는 헤더가 있고 TLS 암호화 레코드에는 바닥글(체크섬 해시)도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-118">Every TLS record has a header, and TLS encrypted records also have a footer (checksum hash).</span></span> <span data-ttu-id="14b4a-119">TLS 핸드셰이크 레코드에는 더 큰 TLS 레코드 내에 캡슐화된 추가 헤더가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-119">TLS handshake records have an additional header encapsulated within the larger TLS record.</span></span> <span data-ttu-id="14b4a-120">TLS 레코드는 TCP 패킷이 IP 패킷에 의해 캡슐화되는 것과 같은 방식으로 전송 계층 네트워크 프로토콜에 의해 캡슐화됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-120">The TLS record is encapsulated by the  transport layer network protocol in the same manner that a TCP packet is encapsulated by an IP packet.</span></span>

### <a name="tls-13"></a><span data-ttu-id="14b4a-121">TLS 1.3</span><span class="sxs-lookup"><span data-stu-id="14b4a-121">TLS 1.3</span></span>

<span data-ttu-id="14b4a-122">2018년 8월에 TLS 1.3 사양이 완성되었습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-122">In August 2018, the TLS 1.3 specification was finalized.</span></span> <span data-ttu-id="14b4a-123">새 버전의 프로토콜은 TLS의 기본 보안 및 성능에 대한 몇 가지 기본적인 측면을 변경하는 상당히 중요한 업데이트입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-123">The new version of the protocol is a fairly significant update that changes some fundamental aspects of the underlying security and performance of TLS.</span></span> <span data-ttu-id="14b4a-124">하지만 이러한 변화는 주로 TLS 핸드셰이크 상태 시스템 및 세션 키 생성에 적용되기 때문에 일반적인 TLS 사용자에게는 거의 보이지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-124">However, these changes are largely invisible to the typical TLS user since they apply primarily to the TLS handshake state machine and session key generation.</span></span> <span data-ttu-id="14b4a-125">몇 가지 선택적 기능과 확장도 추가되었습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-125">A number of optional features and extensions were added as well.</span></span> <span data-ttu-id="14b4a-126">다음은 변경 내용 및 TLS 기능에 미치는 영향에 대한 요약입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-126">The following is a summary of the changes and how they impact TLS functionality.</span></span>

- <span data-ttu-id="14b4a-127">서버에 의한 전체 메시지 교환을 제거하여 핸드셰이크 상태 시스템이 최적화되었습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-127">The handshake state machine was optimized by removing an entire exchange of messages by the server.</span></span>
- <span data-ttu-id="14b4a-128">키 생성이 HKDF(HMAC-based Key Derivation Function)라는 표준화된 루틴을 사용하고 세션 키를 모든 핸드셰이크 메시지(몇 가지 select 매개 변수 대신)에 연결하도록 업데이트되었습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-128">Key generation was updated to use a standardized routine called HKDF (HMAC-based Key Derivation Function) and ties the session keys to all of the handshake messages (instead of a few select parameters).</span></span>
- <span data-ttu-id="14b4a-129">모든 TLS 1.2 및 이전 ciphersuite는 더 이상 사용되지 않으며 TLS 1.3과 호환되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-129">All TLS 1.2 and earlier ciphersuites are deprecated and are incompatible with TLS 1.3.</span></span> <span data-ttu-id="14b4a-130">마찬가지로 모든 TLS 1.3 ciphersuite는 이전 버전에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-130">Similarly, all TLS 1.3 ciphersuites are unusable with previous versions.</span></span>
- <span data-ttu-id="14b4a-131">모든 TLS 1.3 ciphersuite는 사용 후 삭제(ephemeral) 키<sup>6</sup>를 사용하여 PFS(Perfect Forward Secrecy)를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-131">All TLS 1.3 ciphersuites provide Perfect Forward Secrecy (PFS) using ephemeral keys<sup>6</sup></span></span> 
- <span data-ttu-id="14b4a-132">TLS 1.3은 AEAD<sup>7</sup> 암호화를 사용하기 위해 각 레코드에서 "MAC"(메시지 인증 코드)를 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-132">TLS 1.3 removes the "message authentication code" (MAC) in each record in favor of using AEAD<sup>7</sup> ciphers</span></span>
- <span data-ttu-id="14b4a-133">핸드셰이크 중에 애플리케이션 데이터를 보낼 수 있는 0-RTT(제로 왕복 시간)를 비롯한 몇 가지 선택적 기능이 더 추가되었습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-133">Some additional optional features were added, including 0-RTT (Zero Round Trip Time) which allows for application data to be sent during the handshake.</span></span> <span data-ttu-id="14b4a-134">0-RTT는 전적으로 선택 사항이며 현재 Azure RTOS TLS에서 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-134">0-RTT is purely optional and is not currently supported in Azure RTOS TLS.</span></span>

<span data-ttu-id="14b4a-135">TLS 1.3은 사용자 애플리케이션에 크게 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-135">TLS 1.3 does not significantly affect user applications.</span></span> <span data-ttu-id="14b4a-136">API는 버전 간에 정확히 동일하게 유지되며, ciphersuite가 표시되므로 단일 ciphersuite 테이블을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-136">The API remains exactly the same between versions, and ciphersuites are marked so a single ciphersuite table may be used.</span></span>

<span data-ttu-id="14b4a-137">TLS 1.3을 사용하려면 NX_SECURE_TLS_ENABLE_TLS_1_3 매크로를 전역적으로 정의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-137">In order to use TLS 1.3, the macro NX_SECURE_TLS_ENABLE_TLS_1_3 must be globally defined.</span></span> <span data-ttu-id="14b4a-138">TLS 1.3은 Azure RTOS TLS에서 기본적으로 비활성화되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-138">TLS 1.3 is disabled by default in Azure RTOS TLS.</span></span>

6. <span data-ttu-id="14b4a-139">"사용 후 삭제(ephemeral)" 키는 TLS 핸드셰이크 중에 생성되고 해당 세션의 비밀 교환에만 사용되는 비대칭 키 쌍입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-139">“Ephemeral” keys are asymmetric key pairs that are generated during the TLS handshake and used for the secrets exchange for only that session.</span></span> <span data-ttu-id="14b4a-140">이 키 쌍은 사용 후 삭제됩니다. 이렇게 하면 나중에 인증서 프라이빗 키가 손상되더라도 기록된 TLS 세션의 암호화된 데이터에 공격자가 액세스할 수 없기 때문에 “PFS(Perfect Forward Secrecy)”라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-140">They key pair is discarded after use – this prevents an attacker from being able to access encrypted data in a recorded TLS session even if a certificate private key is compromised at any time in the future – hence “Perfect Forward Secrecy”.</span></span>

7. <span data-ttu-id="14b4a-141">관련 데이터를 사용하여 인증된 암호화 – 암호화와 무결성 검사를 단일 작업으로 결합하여 무결성 검사를 위한 별도의 데이터 해시가 필요하지 않은 AES와 같은 암호용 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-141">Authenticated Encryption with Associated Data – a mode for ciphers like AES that combines encryption and integrity checking in a single operation, eliminating the need for a separate hash of the data for integrity checking.</span></span>

### <a name="tls-record-header"></a><span data-ttu-id="14b4a-142">TLS 레코드 헤더</span><span class="sxs-lookup"><span data-stu-id="14b4a-142">TLS Record header</span></span>

<span data-ttu-id="14b4a-143">유효한 TLS 레코드에는 TLS 헤더가 있어야 합니다. 자세한 내용은 오류!</span><span class="sxs-lookup"><span data-stu-id="14b4a-143">Any valid TLS record must have a TLS header, as shown in Error!</span></span> <span data-ttu-id="14b4a-144">참조 소스를 찾을 수 없습니다. 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="14b4a-144">Reference source not found.</span></span>

![TLS 레코드 헤더의 다이어그램](media/image2.png)

<span data-ttu-id="14b4a-146">그림 1 - TLS 레코드 헤더</span><span class="sxs-lookup"><span data-stu-id="14b4a-146">Figure 1 - TLS record header</span></span>

<span data-ttu-id="14b4a-147">TLS 레코드 헤더의 필드는 다음과 같이 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-147">The fields of the TLS record header are defined as follows:</span></span>

| <span data-ttu-id="14b4a-148">TLS 헤더 필드</span><span class="sxs-lookup"><span data-stu-id="14b4a-148">TLS Header Field</span></span> | <span data-ttu-id="14b4a-149">용도</span><span class="sxs-lookup"><span data-stu-id="14b4a-149">Purpose</span></span>     |
| ---------------- | ------------- |
| <span data-ttu-id="14b4a-150">**8비트 메시지 유형**</span><span class="sxs-lookup"><span data-stu-id="14b4a-150">**8-bit Message Type**</span></span> | <span data-ttu-id="14b4a-151">이 필드에는 전송되는 TLS 레코드 형식이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-151">This field contains the type of TLS record being sent.</span></span> <span data-ttu-id="14b4a-152">유효한 형식은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-152">Valid types are as follows:</span></span><br /><span data-ttu-id="14b4a-153">- ChangeCipherSpec<sup>8</sup>: 0x14</span><span class="sxs-lookup"><span data-stu-id="14b4a-153">- ChangeCipherSpec<sup>8</sup>: 0x14</span></span><br /><span data-ttu-id="14b4a-154">- 경고: 0x15</span><span class="sxs-lookup"><span data-stu-id="14b4a-154">- Alert: 0x15</span></span><br /><span data-ttu-id="14b4a-155">- 핸드셰이크: 0x16</span><span class="sxs-lookup"><span data-stu-id="14b4a-155">- Handshake: 0x16</span></span><br /><span data-ttu-id="14b4a-156">- 애플리케이션 데이터: 0x17</span><span class="sxs-lookup"><span data-stu-id="14b4a-156">- Application Data: 0x17</span></span> |
| <span data-ttu-id="14b4a-157">**16비트 프로토콜 버전**</span><span class="sxs-lookup"><span data-stu-id="14b4a-157">**16-bit Protocol Version**</span></span> | <span data-ttu-id="14b4a-158">이 필드에는 TLS 프로토콜 버전이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-158">This field contains the TLS protocol version.</span></span> <span data-ttu-id="14b4a-159">유효한 값은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-159">Valid values are as follows:</span></span><br /><span data-ttu-id="14b4a-160">- SSL 3.0: 0x0300</span><span class="sxs-lookup"><span data-stu-id="14b4a-160">- SSL 3.0: 0x0300</span></span><br /><span data-ttu-id="14b4a-161">- TLS 1.0: 0x0301</span><span class="sxs-lookup"><span data-stu-id="14b4a-161">- TLS 1.0: 0x0301</span></span><br /><span data-ttu-id="14b4a-162">- TLS 1.1: 0x0302</span><span class="sxs-lookup"><span data-stu-id="14b4a-162">- TLS 1.1: 0x0302</span></span><br /><span data-ttu-id="14b4a-163">- TLS 1.2: 0x0303</span><span class="sxs-lookup"><span data-stu-id="14b4a-163">- TLS 1.2: 0x0303</span></span><br /><span data-ttu-id="14b4a-164">- **TLS 1.3 <sup>9</sup>** : **0x0303**</span><span class="sxs-lookup"><span data-stu-id="14b4a-164">- **TLS 1.3 <sup>9</sup>**: **0x0303**</span></span> |
| <span data-ttu-id="14b4a-165">**16비트 길이**</span><span class="sxs-lookup"><span data-stu-id="14b4a-165">**16-bit Length**</span></span> | <span data-ttu-id="14b4a-166">이 필드에는 TLS 레코드에 캡슐화된 데이터의 길이가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-166">This field contains the length of the data encapsulated in the TLS record.</span></span> |

8. <span data-ttu-id="14b4a-167">TLS 1.3에서 ChangeCipherSpec 메시지는 더 이상 사용되지 않지만 호환성을 위해 아직 보낼 수 있으며, 이런 경우 메시지는 무시됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-167">In TLS 1.3 the ChangeCipherSpec message is no longer used, though it still may be sent for compatibility reasons in which case the message is ignored.</span></span>

9. <span data-ttu-id="14b4a-168">이 스키마가 계속 사용되었다면 TLS 1.3은 기술적으로 0x0304 값을 갖게 되지만 프로토콜이 확장의 실제 프로토콜 버전을 갖도록 변경되었기 때문에 모든 TLS 1.3 레코드는 이전 버전과의 호환성을 위해 프로토콜 버전 필드에 0x0303을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-168">TLS 1.3 would technically have a value of 0x0304 if this scheme was continued, but the protocol was changed to have the actual protocol version in an extension, so all TLS 1.3 records use 0x0303 in protocol version fields for backward-compatibility.</span></span>

### <a name="tls-handshake-record-header"></a><span data-ttu-id="14b4a-169">TLS 핸드셰이크 레코드 헤더</span><span class="sxs-lookup"><span data-stu-id="14b4a-169">TLS Handshake Record header</span></span>

<span data-ttu-id="14b4a-170">그림 2와 같이, 유효한 모든 TLS 핸드셰이크 레코드에는 TLS 핸드셰이크 헤더가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-170">Any valid TLS handshake record must have a TLS Handshake header, as shown in Figure 2.</span></span>

![TLS 핸드셰이크 레코드 헤더의 다이어그램입니다.](media/image3.png)

<span data-ttu-id="14b4a-172">그림 2 - TLS 핸드셰이크 레코드 헤더</span><span class="sxs-lookup"><span data-stu-id="14b4a-172">Figure 2 - TLS Handshake record header</span></span>

<span data-ttu-id="14b4a-173">TLS 핸드셰이크 레코드 헤더의 필드는 다음과 같이 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-173">The fields of the TLS Handshake record header are defined as follows:</span></span>

| <span data-ttu-id="14b4a-174">TLS 헤더 필드</span><span class="sxs-lookup"><span data-stu-id="14b4a-174">TLS Header Field</span></span> | <span data-ttu-id="14b4a-175">용도</span><span class="sxs-lookup"><span data-stu-id="14b4a-175">Purpose</span></span> |
| ---------------- |----------------------- |
| <span data-ttu-id="14b4a-176">**8비트 메시지 유형**</span><span class="sxs-lookup"><span data-stu-id="14b4a-176">**8-bit Message Type**</span></span> | <span data-ttu-id="14b4a-177">이 필드에는 전송되는 TLS 레코드 형식이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-177">This field contains the type of TLS record being sent.</span></span> <span data-ttu-id="14b4a-178">유효한 형식은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-178">Valid types are as follows:</span></span><br /><span data-ttu-id="14b4a-179">- ChangeCipherSpec<sup>10</sup>: 0x14</span><span class="sxs-lookup"><span data-stu-id="14b4a-179">- ChangeCipherSpec<sup>10</sup>: 0x14</span></span><br /><span data-ttu-id="14b4a-180">- 경고: 0x15</span><span class="sxs-lookup"><span data-stu-id="14b4a-180">- Alert: 0x15</span></span><br /><span data-ttu-id="14b4a-181">- 핸드셰이크: 0x16</span><span class="sxs-lookup"><span data-stu-id="14b4a-181">- Handshake: 0x16</span></span><br /><span data-ttu-id="14b4a-182">- 애플리케이션 데이터: 0x17</span><span class="sxs-lookup"><span data-stu-id="14b4a-182">- Application Data: 0x17</span></span> |
| <span data-ttu-id="14b4a-183">**16비트 프로토콜 버전**</span><span class="sxs-lookup"><span data-stu-id="14b4a-183">**16-bit Protocol Version**</span></span> | <span data-ttu-id="14b4a-184">이 필드에는 TLS 프로토콜 버전이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-184">This field contains the TLS protocol version.</span></span> <span data-ttu-id="14b4a-185">유효한 값은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-185">Valid values are as follows:</span></span><br /><span data-ttu-id="14b4a-186">- SSL 3.0: 0x0300</span><span class="sxs-lookup"><span data-stu-id="14b4a-186">- SSL 3.0: 0x0300</span></span><br /><span data-ttu-id="14b4a-187">- TLS 1.0: 0x0301</span><span class="sxs-lookup"><span data-stu-id="14b4a-187">- TLS 1.0: 0x0301</span></span><br /><span data-ttu-id="14b4a-188">- TLS 1.1: 0x0302</span><span class="sxs-lookup"><span data-stu-id="14b4a-188">- TLS 1.1: 0x0302</span></span><br /><span data-ttu-id="14b4a-189">- TLS 1.2: 0x0303</span><span class="sxs-lookup"><span data-stu-id="14b4a-189">- TLS 1.2: 0x0303</span></span><br /><span data-ttu-id="14b4a-190">- **TLS 1.3 <sup>11</sup>** : **0x0303**</span><span class="sxs-lookup"><span data-stu-id="14b4a-190">- **TLS 1.3 <sup>11</sup>**: **0x0303**</span></span> |
| <span data-ttu-id="14b4a-191">**16비트 길이**</span><span class="sxs-lookup"><span data-stu-id="14b4a-191">**16-bit Length**</span></span>    | <span data-ttu-id="14b4a-192">이 필드에는 TLS 레코드에 캡슐화된 데이터의 길이가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-192">This field contains the length of the data encapsulated in the TLS record.</span></span> |
| <span data-ttu-id="14b4a-193">**8비트 핸드셰이크 유형**</span><span class="sxs-lookup"><span data-stu-id="14b4a-193">**8-bit Handshake Type**</span></span> | <span data-ttu-id="14b4a-194">이 필드는 핸드셰이크 메시지 유형을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-194">This field contains the handshake message type.</span></span> <span data-ttu-id="14b4a-195">유효한 값은 다음과 같습니다(\***굵게 표시** 된 메시지는 TLS 1.3에 추가됨).</span><span class="sxs-lookup"><span data-stu-id="14b4a-195">Valid values are as follows (\*messages in **bold** were added in TLS 1.3):</span></span><br /><span data-ttu-id="14b4a-196">- HelloRequest: 0x00</span><span class="sxs-lookup"><span data-stu-id="14b4a-196">- HelloRequest: 0x00</span></span><br /><span data-ttu-id="14b4a-197">- ClientHello: 0x01</span><span class="sxs-lookup"><span data-stu-id="14b4a-197">- ClientHello: 0x01</span></span><br /><span data-ttu-id="14b4a-198">- ServerHello: 0x02</span><span class="sxs-lookup"><span data-stu-id="14b4a-198">- ServerHello: 0x02</span></span><br /><span data-ttu-id="14b4a-199">- **HelloVerifyRequest**: **0x03**</span><span class="sxs-lookup"><span data-stu-id="14b4a-199">- **HelloVerifyRequest**: **0x03**</span></span><br /><span data-ttu-id="14b4a-200">- **NewSessionTicket**: **0x04**</span><span class="sxs-lookup"><span data-stu-id="14b4a-200">- **NewSessionTicket**: **0x04**</span></span><br /><span data-ttu-id="14b4a-201">- **EndOfEarlyData**: **0x05**</span><span class="sxs-lookup"><span data-stu-id="14b4a-201">- **EndOfEarlyData**: **0x05**</span></span><br /><span data-ttu-id="14b4a-202">- **EncryptedExtensions**: **0x08**</span><span class="sxs-lookup"><span data-stu-id="14b4a-202">- **EncryptedExtensions**: **0x08**</span></span><br /><span data-ttu-id="14b4a-203">- Certificate: 0x0B</span><span class="sxs-lookup"><span data-stu-id="14b4a-203">- Certificate: 0x0B</span></span><br /><span data-ttu-id="14b4a-204">- ServerKeyExchange: 0x0C</span><span class="sxs-lookup"><span data-stu-id="14b4a-204">- ServerKeyExchange: 0x0C</span></span><br /><span data-ttu-id="14b4a-205">- CertificateRequest: 0x0D</span><span class="sxs-lookup"><span data-stu-id="14b4a-205">- CertificateRequest: 0x0D</span></span><br /><span data-ttu-id="14b4a-206">- ServerHelloDone: 0x0E</span><span class="sxs-lookup"><span data-stu-id="14b4a-206">- ServerHelloDone: 0x0E</span></span><br /><span data-ttu-id="14b4a-207">- CertificateVerify: 0x0F</span><span class="sxs-lookup"><span data-stu-id="14b4a-207">- CertificateVerify: 0x0F</span></span><br /><span data-ttu-id="14b4a-208">- ClientKeyExchange: 0x10</span><span class="sxs-lookup"><span data-stu-id="14b4a-208">- ClientKeyExchange: 0x10</span></span><br /><span data-ttu-id="14b4a-209">- Finished: 0x14</span><span class="sxs-lookup"><span data-stu-id="14b4a-209">- Finished: 0x14</span></span><br /><span data-ttu-id="14b4a-210">- **KeyUpdate**: **0x18**</span><span class="sxs-lookup"><span data-stu-id="14b4a-210">- **KeyUpdate**: **0x18**</span></span><br /><span data-ttu-id="14b4a-211">- **MessageHash**: **0xFE**</span><span class="sxs-lookup"><span data-stu-id="14b4a-211">- **MessageHash**: **0xFE**</span></span> |
| <span data-ttu-id="14b4a-212">**24비트 길이**</span><span class="sxs-lookup"><span data-stu-id="14b4a-212">**24-bit Length**</span></span>    | <span data-ttu-id="14b4a-213">이 필드는 핸드셰이크 메시지 데이터의 길이를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-213">This field contains the length of the handshake message data.</span></span> |

10. <span data-ttu-id="14b4a-214">TLS 1.3에서 ChangeCipherSpec 메시지는 더 이상 사용되지 않지만 호환성을 위해 아직 보낼 수 있으며, 이런 경우 메시지는 무시됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-214">In TLS 1.3 the ChangeCipherSpec message is no longer used, though it still may be sent for compatibility reasons in which case the message is ignored.</span></span>

11. <span data-ttu-id="14b4a-215">이 스키마가 계속 사용되었다면 TLS 1.3은 기술적으로 0x0304 값을 갖게 되지만 프로토콜이 확장의 실제 프로토콜 버전을 갖도록 변경되었기 때문에 모든 TLS 1.3 레코드는 이전 버전과의 호환성을 위해 프로토콜 버전 필드에 0x0303을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-215">TLS 1.3 would technically have a value of 0x0304 if this scheme was continued, but the protocol was changed to have the actual protocol version in an extension, so all TLS 1.3 records use 0x0303 in protocol version fields for backward-compatibility.</span></span>

### <a name="the-tls-handshake-and-tls-session"></a><span data-ttu-id="14b4a-216">TLS 핸드셰이크 및 TLS 세션</span><span class="sxs-lookup"><span data-stu-id="14b4a-216">The TLS Handshake and TLS Session</span></span>

<span data-ttu-id="14b4a-217">일반적인 TLS 핸드셰이크(버전 1.0-1.2)는 그림 3에 나와 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-217">A typical TLS handshake (versions 1.0-1.2) is shown in Figure 3.</span></span> <span data-ttu-id="14b4a-218">TLS 핸드셰이크는 TLS 클라이언트가 TLS 서버에 *ClientHello* 메시지(TLS 세션을 시작하려는 의도를 나타냄)를 보낼 때 시작됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-218">A TLS handshake begins when the TLS Client sends a *ClientHello* message to a TLS server, indicating its desire to start a TLS session.</span></span> <span data-ttu-id="14b4a-219">이 메시지에는 클라이언트가 세션에 사용할 암호화에 대한 정보와 함께 나중에 핸드셰이크에서 세션 키를 생성하는 데 사용되는 정보가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-219">The message contains information about the encryption the client would like to use for the session, along with information used to generate the session keys later in the handshake.</span></span> <span data-ttu-id="14b4a-220">세션 키가 생성될 때까지 TLS 핸드셰이크의 모든 메시지는 암호화되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-220">Until the session keys are generated, all messages in the TLS handshake are not encrypted.</span></span> <span data-ttu-id="14b4a-221">TLS 1.3은 핸드셰이크를 다소 변경합니다. – 자세한 내용은 다음 섹션에 나와 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-221">TLS 1.3 changes the handshake somewhat – details are presented in the next section.</span></span>

<span data-ttu-id="14b4a-222">TLS 서버는 ClientHello에 ServerHello 메시지(클라이언트가 제공한 암호화 옵션의 선택 항목을 나타냄)로 응답합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-222">The TLS Server responds to the ClientHello with a ServerHello message, indicating a selection from the encryption options provided by the client.</span></span> <span data-ttu-id="14b4a-223">ServerHello 뒤에는 Certificate 메시지가 오며, 여기에는 클라이언트에서 서버의 ID를 인증하기 위해 서버가 제공하는 디지털 인증서가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-223">The ServerHello is followed by a Certificate message, in which the server provides a digital certificate to authenticate its identity to the client.</span></span> <span data-ttu-id="14b4a-224">마지막으로 서버는 ServerHelloDone 메시지를 보내서 더 이상 보낼 메시지가 없음을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-224">Finally, the server sends a ServerHelloDone message to indicate it has no more messages to send.</span></span> <span data-ttu-id="14b4a-225">서버는 ServerHello 다음에 다른 메시지를 보낼 수 있고 경우에 따라 Certificate 메시지를 보내지 않을 수도 있기 때문에 ServerHelloDone 메시지가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-225">The server may optionally send other messages following the ServerHello and in some cases it may not send a Certificate message, hence the need for the ServerHelloDone message.</span></span>

<span data-ttu-id="14b4a-226">클라이언트가 서버의 모든 메시지를 수신하면 세션 키를 생성하기에 충분한 정보를 갖게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-226">Once the client has received all the server's messages, it has enough information to generate the session keys.</span></span> <span data-ttu-id="14b4a-227">TLS는 고정 크기이며 암호화가 활성화되면 필요한 모든 키를 생성하기 위해 시드로 사용되는 *Pre-Master Secret* 이라는 임의 데이터의 공유 비트를 생성하여 이 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-227">TLS does this by creating a shared bit of random data called the *Pre-Master Secret*, which is a fixed-size and is used as a seed to generate all the keys needed once encryption is enabled.</span></span> <span data-ttu-id="14b4a-228">Pre-Master Secret은 Hello 메시지에 지정된 공개 키 알고리즘(예: RSA)(공개 키 알고리즘에 대한 자세한 내용은 아래 참조) 및 서버가 인증서에서 제공한 공개 키를 사용하여 암호화됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-228">The Pre-Master Secret is encrypted using the public key algorithm (e.g. RSA) specified in the Hello messages (see below for information on public key algorithms) and the public key provided by the server in its certificate.</span></span> <span data-ttu-id="14b4a-229">PSK(미리 공유한 키)라는 선택적 TLS 기능을 사용하면 인증서를 사용하는 대신 호스트 간에 공유되는 비밀 값(일반적으로 물리적 전송 또는 기타 보안 방법을 통해)을 사용하는 ciphersuite를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-229">An optional TLS feature called Pre-Shared Keys (PSK) enables ciphersuites that do not use a certificate but instead use a secret value shared between the hosts (usually through physical transfer or other secured method).</span></span> <span data-ttu-id="14b4a-230">공유 비밀은 암호화된 메시지를 사용하여 Pre-Master Secret을 보내는 대신 Pre-Master Secret을 생성하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-230">The shared secret is used to generate the Pre-Master Secret instead of using an encrypted message to send the Pre-Master Secret.</span></span> <span data-ttu-id="14b4a-231">아래에서 미리 공유한 키 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="14b4a-231">See the section on Pre-Shared Keys below.</span></span>

<span data-ttu-id="14b4a-232">암호화된 Pre-Master Secret은 ClientKeyExchange 메시지에 포함되어 서버로 전송됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-232">The encrypted Pre-Master Secret is sent to the server in the ClientKeyExchange message.</span></span> <span data-ttu-id="14b4a-233">서버가 ClientKeyExchange 메시지를 받으면 자체 프라이빗 키를 사용하여 Pre-Master Secret을 해독하고 TLS 클라이언트와 병렬로 세션 키 생성을 진행합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-233">The server, upon receiving the ClientKeyExchange message, decrypts the Pre-Master Secret using its private key and proceeds to generate the session keys in parallel with the TLS client.</span></span>

<span data-ttu-id="14b4a-234">세션 키가 생성되면 Hello 메시지에서 선택한 프라이빗 키 알고리즘(예: AES)을 사용하여 모든 추가 메시지를 암호화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-234">Once the session keys are generated, all further messages can be encrypted using the private-key algorithm (e.g. AES) selected in the Hello messages.</span></span> <span data-ttu-id="14b4a-235">클라이언트와 서버 모두에서 ChangeCipherSpec이라는 암호화되지 않은 마지막 메시지 하나를 보내서 모든 추가 메시지가 암호화된다는 것을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-235">One final un-encrypted message called ChangeCipherSpec is sent by both the client and server to indicate that all further messages will be encrypted.</span></span>

<span data-ttu-id="14b4a-236">클라이언트와 서버 모두에서 보낸 첫 번째 암호화된 메시지는 Finished라는 최종 TLS 핸드셰이크 메시지이기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-236">The first encrypted message sent by both the client and server is also the final TLS handshake message, called Finished.</span></span> <span data-ttu-id="14b4a-237">이 메시지는 송수신한 모든 핸드셰이크 메시지의 해시를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-237">This message contains a hash of all the handshake messages received and sent.</span></span> <span data-ttu-id="14b4a-238">이 해시는 핸드셰이크의 어떤 메시지도 변조되거나 손상(보안 위반 가능성을 나타냄)되지 않았다는 것을 확인하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-238">This hash is used to verify that none of the messages in the handshake have been tampered with or corrupted (indicating a possible breach of security).</span></span>

<span data-ttu-id="14b4a-239">Finished 메시지를 받고 핸드셰이크 해시가 확인되면, TLS 세션이 시작되고 애플리케이션은 데이터 송수신을 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-239">Once the Finished messages are received and the handshake hashes are verified, the TLS session begins, and the application begins sending and receiving data.</span></span> <span data-ttu-id="14b4a-240">TLS 세션 중에 양쪽에서 전송된 모든 데이터는 먼저 Hello 메시지에서 선택한 해시 알고리즘을 사용하여 해시되고(메시지 무결성을 제공하기 위해) 생성된 세션 키와 함께 선택한 프라이빗 키 알고리즘을 사용하여 암호화됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-240">All data sent by either side during the TLS session is first hashed using the hash algorithm chosen in the Hello messages (to provide message integrity) and encrypted using the chosen private-key algorithm with the generated session keys.</span></span>

<span data-ttu-id="14b4a-241">마지막으로, TLS 세션은 클라이언트나 서버에서 종료하기로 선택하는 경우에만 성공적으로 종료될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-241">Finally, a TLS session can only be successfully ended if either the Client or Server chooses to do so.</span></span> <span data-ttu-id="14b4a-242">잘린 세션은 보안 위반으로 간주되며(모든 송신 데이터가 수신되는 것을 공격자가 막으려고 시도할 수 있기 때문에) 따라서 둘 중 한쪽에서 세션을 종료하려고 하면 CloseNotify 경고라는 특별한 알림이 전송됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-242">A truncated session is considered a security breach (since an attacker may be attempting to prevent all the data being sent from being received) so a special notification is sent when either side wants to end the session, called a CloseNotify alert.</span></span> <span data-ttu-id="14b4a-243">세션 종료에 성공하려면 클라이언트와 서버 모두 CloseNotify 경고를 보내고 처리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-243">Both the client and server must send and process a CloseNotify alert for a successful session shutdown.</span></span>

![일반적인 TLS 핸드셰이크의 다이어그램](media/image4.png)

<span data-ttu-id="14b4a-245">그림 3- 일반적인 TLS 핸드셰이크</span><span class="sxs-lookup"><span data-stu-id="14b4a-245">Figure 3- Typical TLS handshake</span></span>

### <a name="tls-13-handshake"></a><span data-ttu-id="14b4a-246">TLS 1.3 핸드셰이크</span><span class="sxs-lookup"><span data-stu-id="14b4a-246">TLS 1.3 Handshake</span></span>

<span data-ttu-id="14b4a-247">TLS 1.3은 TLS 프로토콜에서 상당히 많이 재정비되었습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-247">TLS 1.3 is a fairly major overhaul of the TLS protocol.</span></span> <span data-ttu-id="14b4a-248">대부분의 변화는 보안과 성능을 높이기 위해 핸드셰이크에 적용되었습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-248">The vast majority of the changes were made to the handshake to increase security and performance.</span></span> <span data-ttu-id="14b4a-249">일반적인 TLS 1.3 핸드셰이크는 그림 4에 나와 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-249">A typical TLS 1.3 handshake is shown in Figure 4.</span></span> <span data-ttu-id="14b4a-250">주요 차이는 서버와 클라이언트 사이의 교환 수에서 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-250">The primary difference can be seen in the number of exchanges between the server and client.</span></span>

<span data-ttu-id="14b4a-251">TLS 1.2 및 이전 버전에서는 서버가 메시지 플라이트<sup>12</sup>를 2개 보냅니다. – 먼저 ServerHello를 보낸 다음, ChangeCipherSpec 메시지를 보낸 후 핸드셰이크를 종료하는 암호화된 Finished 메시지를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-251">In TLS 1.2 and earlier, the server would send two flights<sup>12</sup> of messages – first the ServerHello and then a ChangeCipherSpec message before sending the encrypted Finished message that ends the handshake.</span></span> <span data-ttu-id="14b4a-252">TLS 1.3에서는 서버가 모든 것을(ServerHello, Extensions, Certificate 및 Finished) 첫 번째 플라이트에 포함하여 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-252">In TLS 1.3, the server sends everything in the first flight – ServerHello, extensions, certificate, and Finished.</span></span> <span data-ttu-id="14b4a-253">ChangeCipherSpec 메시지는 제거되었으며 서버가 세션 키를 생성하고 ServerHello 직후에 핸드셰이크 메시지 암호화를 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-253">The ChangeCipherSpec message was eliminated and the server generates its session keys and starts encrypting handshake messages immediately following the ServerHello.</span></span>

<span data-ttu-id="14b4a-254">새로운 방식은 암호화를 통해 TLS 핸드셰이크를 더 많이 보호하여 공격자가 액세스할 수 있는 일반 텍스트의 양을 제한하는 것을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-254">The new arrangement means that more of the TLS handshake is protected by encryption, limiting the amount of plaintext data an attacker can access.</span></span> <span data-ttu-id="14b4a-255">또한 두 번째 서버 플라이트(ChangeCipherSpec 다음에 Finished가 있음)를 제거하면 TLS 클라이언트는 애플리케이션 데이터 전송을 시작할 때까지 더 이상 기다릴 필요가 없으며 클라이언트가 자체 Finished 메시지를 보내는 즉시 세션이 시작됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-255">Additionally, the removal of the second server flight (which was just a ChangeCipherSpec followed by a Finished) means that a TLS client no longer needs to wait to start transmitting application data – as soon as the client sends its own Finished message the session is started.</span></span>

12. <span data-ttu-id="14b4a-256">플라이트는 한 그룹에 포함되어 동시에 전송되는 TLS 메시지의 모음입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-256">A flight is simply a collection of TLS messages sent simultaneously in a group.</span></span>

![TLS 1.3 핸드셰이크 다이어그램](media/image5.png)

<span data-ttu-id="14b4a-258">그림 4 - TLS 1.3 핸드셰이크</span><span class="sxs-lookup"><span data-stu-id="14b4a-258">Figure 4 - TLS 1.3 Handshake</span></span>

> [!NOTE]
> <span data-ttu-id="14b4a-259">TLS 1.3에는 "Early data" 및 0-RTT(제로 왕복 시간)라는 개념도 도입되었습니다. 일부 애플리케이션 데이터를 메시지의 첫 번째 플라이트에 포함하여 보낼 수 있다는 의미입니다. 이 선택적 기능은 주로 웹 브라우저 응답성을 위한 최적화(예: 페이지 렌더링을 시작하기 위해 이른(early) HTTP 헤더 보내기)로 추가되었습니다. Azure RTOS 6.0부터는 이 기능이 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-259">*TLS 1.3 also introduced the notion of "Early data" and 0-RTT (Zero Round Trip Time), meaning that some application data can be sent in the first flight of messages. This optional feature was added primarily as an optimization for web browser responsiveness (e.g. to send early HTTP headers to start rendering a page). As of Azure RTOS 6.0 this feature is NOT supported.*</span></span>

### <a name="initialization"></a><span data-ttu-id="14b4a-260">초기화</span><span class="sxs-lookup"><span data-stu-id="14b4a-260">Initialization</span></span>

<span data-ttu-id="14b4a-261">NetX 또는 NetXDuo TCP/IP 스택은 NetX Secure TLS를 사용하기 전에 초기화해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-261">The NetX or NetXDuo TCP/IP stack must be initialized prior to using NetX Secure TLS.</span></span> <span data-ttu-id="14b4a-262">TCP/IP 스택을 제대로 초기화하는 방법에 대한 자세한 내용은 NetX 또는 NetXDuo 사용자 가이드를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="14b4a-262">Refer to the NetX or NetXDuo User Guide for information on how to properly initialize the TCP/IP stack.</span></span>

<span data-ttu-id="14b4a-263">NetX TCP/IP 스택이 초기화되면 TLS를 활성화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-263">Once the NetX TCP/IP stack has been initialized, TLS can be enabled.</span></span> <span data-ttu-id="14b4a-264">내부적으로 모든 TLS 네트워크 트래픽 및 처리는 사용자의 개입 없이도 NetX/NetXDuo 스택에 의해 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-264">Internally, all TLS network traffic and processing is handled by the NetX/NetXDuo stack without requiring user intervention.</span></span> <span data-ttu-id="14b4a-265">단, TLS에는 기본 네트워크 스택과 별개로 처리해야 하는 특정 요구 사항이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-265">However, TLS has some specific requirements that must be handled separately from the underlying network stack.</span></span> <span data-ttu-id="14b4a-266">이러한 매개 변수는_ *_nx_secure_tls_session_create_*\* 서비스를 사용하여 \***NX_SECURE_TLS_SESSION** _이라는 TLS 제어 블록에 할당됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-266">These parameters are assigned to the TLS control block called ***NX_SECURE_TLS_SESSION** _ using the _ *_nx_secure_tls_session_create_** service.</span></span>

<span data-ttu-id="14b4a-267">TLS에는 서버 및 클라이언트라는 두 가지 모드가 있으며, 애플리케이션에서 둘 중 하나를 활성화할 수 있고(단, NetX 소켓당 한 가지 모드) 각각 고유한 요구 사항(아래에 자세히 설명되어 있음)이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-267">TLS has two modes, Server and Client, either of which may be enabled in an application (but only one mode per NetX socket), and each have their own specific requirements, detailed below.</span></span>

<span data-ttu-id="14b4a-268">어느 모드에서든 NetX Secure TLS는 원격 호스트와의 TCP 통신을 위해 TCP 소켓(\***NX_TCP_SOCKET** _)을 만들고 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-268">In either mode, NetX Secure TLS requires a TCP socket (\***NX_TCP_SOCKET** _) to be created and set up for TCP communications with the remote host.</span></span> <span data-ttu-id="14b4a-269">TCP 소켓은 _ *_nx_secure_tls_session_start_*\* 서비스(아래에 자세히 설명되어 있음)를 사용하여 TLS 세션 인스턴스에 할당됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-269">The TCP socket is assigned to a TLS session instance with the _ *_nx_secure_tls_session_start_*\* service, detailed below.</span></span>

### <a name="initialization--tls-server"></a><span data-ttu-id="14b4a-270">초기화 – TLS 서버</span><span class="sxs-lookup"><span data-stu-id="14b4a-270">Initialization – TLS Server</span></span>

<span data-ttu-id="14b4a-271">TCP 소켓 외에도 NetX Secure TLS 서버 모드에는 디지털 인증서(연결하는 TLS 클라이언트에 TLS 서버를 식별하는 데 사용되는 문서)와 프라이빗 키에 해당하는 인증서(일반적으로 RSA 암호화 알고리즘에 사용됨)가 필요합니다. </span><span class="sxs-lookup"><span data-stu-id="14b4a-271">In addition to a TCP socket, NetX Secure TLS Server mode requires a *Digital Certificate*, which is a document used to identify the TLS server to the connecting TLS client, and the certificates corresponding *Private Key*, usually for the RSA encryption algorithm.</span></span> <span data-ttu-id="14b4a-272">International Telecommunications Union X.509 표준은 TLS에서 사용하는 인증서 형식을 지정하며 X.509 디지털 인증서를 만들 수 있는 다양한 유틸리티가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-272">The International Telecommunications Union X.509 standard specifies the certificate format used by TLS and there are numerous utilities for creating X.509 digital certificates.</span></span>

<span data-ttu-id="14b4a-273">NetX Secure TLS의 경우 X.509 인증서는 DER(Distinguished Encoding Rules) 형식인 ASN.1을 사용하여 이진으로 인코딩해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-273">For NetX Secure TLS, the X.509 certificate must be binary-encoded using the Distinguished Encoding Rules (DER) format of ASN.1.</span></span> <span data-ttu-id="14b4a-274">DER은 인증서에 사용되는 표준 TLS 네트워크 이진 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-274">DER is the standard TLS over-the-wire binary format for certificates.</span></span>

<span data-ttu-id="14b4a-275">제공된 인증서와 연결된 프라이빗 키는 DER로 인코딩된 PKCS#1 형식이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-275">The private key associated with the provided certificate must be in DER-Encoded PKCS#1 format.</span></span> <span data-ttu-id="14b4a-276">프라이빗 키는 디바이스에서만 사용되며 네트워크를 통해 전송되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-276">The private key is only used on the device and will never be transmitted over the wire.</span></span> <span data-ttu-id="14b4a-277">프라이빗 키는 TLS 통신 보안에 중요하므로 안전하게 보관해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-277">Keep private keys safe as they provide the security for TLS communications!</span></span>

<span data-ttu-id="14b4a-278">TLS 서버 인증서를 초기화하려면 애플리케이션에서 ***nx_secure_x509_certificate_intialize** _ 서비스를 사용하여 DER 인코딩 X.509 인증서 및 선택적 DER 인코딩 PKCS#1 RSA 프라이빗 키 데이터를 포함하는 버퍼에 대한 포인터를 제공해야 합니다. 이 서비스는 _ *NX_SECURE_X509_CERT** 구조를 TLS에서 사용할 적절한 인증서 데이터로 채우는 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-278">To initialize the TLS Server certificate, the application must provide a pointer to a buffer containing the DER-encoded X.509 certificate and optional DER-encoded PKCS#1 RSA private key data using the ***nx_secure_x509_certificate_intialize** _ service, which populates the _ *NX_SECURE_X509_CERT** structure with the appropriate certificate data for use by TLS.</span></span>

<span data-ttu-id="14b4a-279">서버 인증서가 초기화되면 ***nx_secure_tls_local_certificate_add*** 서비스를 사용하여 TLS 제어 블록에 인증서를 추가해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-279">Once the server certificate has been initialized, it must be added to the TLS control block using the ***nx_secure_tls_local_certificate_add*** service.</span></span>

<span data-ttu-id="14b4a-280">서버 인증서가 TLS 제어 블록에 추가되면 소켓을 사용하여 보안 TLS 서버 연결을 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-280">Once the server's certificate has been added to the TLS control block, the socket may be used to establish a secure TLS Server connection.</span></span>

### <a name="initialization--tls-client"></a><span data-ttu-id="14b4a-281">초기화 – TLS 클라이언트</span><span class="sxs-lookup"><span data-stu-id="14b4a-281">Initialization – TLS Client</span></span>

<span data-ttu-id="14b4a-282">NetX Secure TLS 클라이언트 모드에는 신뢰할 수 있는 인증서 저장소가 필요합니다. 이것은 신뢰할 수 있는 CA(인증 기관)의 X.509 인코딩 디지털 인증서의 모음입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-282">NetX Secure TLS Client mode requires a *Trusted Certificate Store*, which is a collection of X.509-encoded digital certificates from trusted Certificate Authorities (CA's).</span></span> <span data-ttu-id="14b4a-283">이러한 인증서는 TLS 프로토콜에서 "신뢰할 수 있는" 것으로 간주되며 TLS 서버 엔터티가 NetX Secure TLS 클라이언트에 제공하는 인증서를 인증하기 위한 기반으로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-283">These certificates are assumed by the TLS protocol to be "trusted" and serve as the basis for authenticating certificates provided by TLS server entities to NetX Secure TLS Client.</span></span>

<span data-ttu-id="14b4a-284">신뢰할 수 있는 CA 인증서는 자체 서명되거나 다른 CA에서 서명될 수 있으며, 이 경우 해당 인증서를 ICA(중간 CA)라고 합니다. </span><span class="sxs-lookup"><span data-stu-id="14b4a-284">A trusted CA certificate may either be *self-signed* or signed by another CA, in which case that certificate is called an *Intermediate CA* (ICA).</span></span> <span data-ttu-id="14b4a-285">일반적인 TLS 애플리케이션에서 서버는 자체 서버 인증서와 함께 ICA 인증서를 제공하지만, 인증이 성공하기 위해서는 발급자 체인(다른 인증서에 서명하는 데 사용되는 인증서)을 서버 인증서에서 신뢰할 수 있는 인증서 저장소의 신뢰할 수 있는 CA 인증서로 다시 추적할 수 있어야 하며, 이것이 유일한 요구 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-285">In a typical TLS application, the server provides the ICA certificates along with its server certificate, but the only requirement for successful authentication is that a chain of issuers (certificates used to sign other certificates) can be traced from the server certificate back to a trusted CA certificate in the Trusted Certificate Store.</span></span> <span data-ttu-id="14b4a-286">이 체인을 신뢰 체인 또는 인증서 체인이라고 합니다. </span><span class="sxs-lookup"><span data-stu-id="14b4a-286">This chain is known as a  *chain of trust* or *certificate chain*.</span></span>

<span data-ttu-id="14b4a-287">신뢰할 수 있는 CA 또는 ICA 인증서를 초기화하려면 애플리케이션에서 ***nx_secure_x509_certificate_intialize** _ 서비스를 사용하여 DER로 인코딩된 X.509 인증서를 포함하는 버퍼에 대한 포인터를 제공해야 합니다. 이 서비스는 _ *NX_SECURE_X509_CERT** 구조를 TLS에서 사용할 적절한 인증서 데이터로 채우는 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-287">To initialize a trusted CA or ICA certificate, the application must provide a pointer to a buffer containing the DER-encoded X.509 certificate using the ***nx_secure_x509_certificate_intialize** _ service, which populates the _ *NX_SECURE_X509_CERT** structure with the appropriate certificate data for use by TLS.</span></span>

<span data-ttu-id="14b4a-288">그러면 초기화된 신뢰할 수 있는 인증서는 ***nx_secure_tls_trusted_certificate_add*** 서비스를 사용하여 TLS 제어 블록에 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-288">Trusted certificates that have been initialized are then added to the TLS control block using the ***nx_secure_tls_trusted_certificate_add*** service.</span></span> <span data-ttu-id="14b4a-289">인증서를 추가하지 못하면 TLS 프로토콜이 원격 TLS 서버 호스트를 인증할 방법이 없기 때문에 TLS 클라이언트 세션이 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-289">Failure to add a certificate will cause the TLS Client session to fail as there will be no way for the TLS protocol to authenticate remote TLS server hosts.</span></span>

<span data-ttu-id="14b4a-290">TLS 클라이언트에는 수신 서버 인증서를 할당할 공간도 필요합니다(미리 공유한 키 모드가 사용되지 않는다고 가정).</span><span class="sxs-lookup"><span data-stu-id="14b4a-290">The TLS Client also needs space for the incoming server certificate to be allocated (assuming a Pre-Shared Key mode is not being used).</span></span> <span data-ttu-id="14b4a-291">NetX Secure TLS 5.12부터는 애플리케이션이 더 이상 원격 인증서를 위한 공간을 할당할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-291">As of NetX Secure TLS 5.12, it is no longer necessary for the application to allocate space for remote certificate.</span></span> <span data-ttu-id="14b4a-292">단, 서버 인증서를 위한 공간을 할당하는 레거시 옵션을 계속 사용할 수 있으며 내부 인증서 버퍼 최적화 <sup>13</sup> 전에는 사용자가 할당한 인증서가 사용됩니다. 자세한 내용은 ***nx_secure_tls_remote_certificate_allocate*** 서비스를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="14b4a-292">However, the legacy option to allocate space for a server certificate is still available and user-allocated certificates will be used before the internal certificate buffer optimization <sup>13</sup> – see the ***nx_secure_tls_remote_certificate_allocate*** service for more information.</span></span>

<span data-ttu-id="14b4a-293">신뢰할 수 있는 인증서 저장소가 생성되고 서버 인증서를 위한 공간이 할당되면 소켓을 사용하여 보안 TLS 클라이언트 연결을 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-293">Once the Trusted Certificate Store has been created and space for the server certificate has been allocated, the socket may be used to establish a secure TLS Client connection.</span></span>

13. <span data-ttu-id="14b4a-294">최적화는 이전 버전의 NetX Secure TLS에서 사용된 사용자 제공 구조를 사용하는 대신 *nx_secure_tls_session_packet_buffer_set* 을 사용하여 사용자 애플리케이션이 TLS 세션에 제공한 "패킷 버퍼"를 활용하여 X.509 구문 분석 구조를 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-294">The optimization utilizes the “packet buffer” supplied by the user application to the tls session using *nx_secure_tls_session_packet_buffer_set* to allocate the X.509 parsing structures instead of using the user-supplied structures used in earlier versions of NetX Secure TLS.</span></span> <span data-ttu-id="14b4a-295">패킷 버퍼의 크기를 초과하는 인증서 체인이 발생할 가능성은 거의 없으며, 만약 발생하면 패킷 버퍼 크기를 늘리거나 *nx_secure_tls _remote_certificate_allocate* 를 사용하여 인증서 체인에 더 많은 공간을 할당할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-295">There is an unlikely possibility of encountering a certificate chain exceeding the size of the packet buffer in which case either the packet buffer size may be increased or *nx_secure_tls _remote_certificate_allocate* may be used to allocate more space for the certificate chain.</span></span>

### <a name="application-interface-calls"></a><span data-ttu-id="14b4a-296">애플리케이션 인터페이스 호출</span><span class="sxs-lookup"><span data-stu-id="14b4a-296">Application Interface Calls</span></span>

<span data-ttu-id="14b4a-297">NetX Secure TLS 애플리케이션은 일반적으로 ThreadX RTOS에서 실행되는 애플리케이션 스레드 내에서 함수 호출을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-297">NetX Secure TLS applications will typically make function calls from within application threads running under the ThreadX RTOS.</span></span> <span data-ttu-id="14b4a-298">일부 초기화, 특히 기본 네트워크 통신 프로토콜(예: TCP 및 IP)에 대한 초기화는 ***tx_application_define*** 에서 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-298">Some initialization, particularly for the underlying network communications protocols (e.g. TCP and IP) may be called from \***tx_application_define\*.**</span></span> <span data-ttu-id="14b4a-299">네트워크 통신 초기화에 대한 자세한 내용은 NetX/NetXDuo 사용자 가이드를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="14b4a-299">See the NetX/NetXDuo User Guide for more information on initializing network communications.</span></span>

<span data-ttu-id="14b4a-300">TLS는 프로세서 사용량이 많은 작업인 암호화 루틴을 많이 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-300">TLS makes heavy use of encryption routines which are processor-intensive operations.</span></span> <span data-ttu-id="14b4a-301">일반적으로 이러한 작업은 호출 스레드의 컨텍스트 내에서 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-301">Generally, these operations will be performed within the context of calling thread.</span></span>

### <a name="tls-session-start"></a><span data-ttu-id="14b4a-302">TLS 세션 시작</span><span class="sxs-lookup"><span data-stu-id="14b4a-302">TLS Session Start</span></span>

<span data-ttu-id="14b4a-303">TLS가 작동하려면 기본 전송 계층 네트워크 프로토콜이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-303">TLS requires an underlying transport-layer network protocol in order to function.</span></span> <span data-ttu-id="14b4a-304">일반적으로 사용되는 프로토콜은 TCP입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-304">The protocol typically used is TCP.</span></span> <span data-ttu-id="14b4a-305">NetX Secure TLS 세션을 설정하려면 NetX/NetXDuo TCP API를 사용하여 TCP 연결을 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-305">In order to establish a NetX Secure TLS session, a TCP connection must be established using the NetX/NetXDuo TCP API.</span></span> <span data-ttu-id="14b4a-306">**NX_TCP_SOCKET** 을 생성해야 하고 **_nx_tcp_server_socket_listen_ *_ 및 _* _nx_tcp_server_socket_accept_ *_ 서비스(TLS 서버용) 또는 _* _nx_tcp_client_socket_connect_** 서비스(TLS 클라이언트 용)를 사용하여 연결을 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-306">An **NX_TCP_SOCKET** must be created and a connection established using the **_nx_tcp_server_socket_listen_*_ and _*_nx_tcp_server_socket_accept_*_ services (for TLS Server) or the _*_nx_tcp_client_socket_connect_** service (for TLS Client).</span></span>

<span data-ttu-id="14b4a-307">TCP 연결이 설정되면 TCP 소켓이 ***nx_secure_tls_session_start*** 서비스에 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-307">Once a TCP connection has been established, the TCP socket is then passed to the ***nx_secure_tls_session_start*** service.</span></span>

### <a name="tls-packet-allocation"></a><span data-ttu-id="14b4a-308">TLS 패킷 할당</span><span class="sxs-lookup"><span data-stu-id="14b4a-308">TLS Packet Allocation</span></span>

<span data-ttu-id="14b4a-309">NetX Secure TLS는 NetX/NetXDuo TCP(***NX_PACKET** _)와 동일한 패킷 구조를 사용합니다. 단, _*_nx_packet_allocate_*_ 서비스를 호출하는 대신 _ *_nx_secure_tls_packet_allocate_** 서비스를 호출해야 TLS 헤더를 위한 공간이 제대로 할당될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-309">NetX Secure TLS uses the same packet structure as NetX/NetXDuo TCP (***NX_PACKET** _) except that instead of calling the _*_nx_packet_allocate_*_ service, the _ *_nx_secure_tls_packet_allocate_** service must be called so that space for the TLS header may be allocated properly.</span></span>

### <a name="tls-session-send"></a><span data-ttu-id="14b4a-310">TLS 세션 보내기</span><span class="sxs-lookup"><span data-stu-id="14b4a-310">TLS Session Send</span></span>

<span data-ttu-id="14b4a-311">TLS 세션이 시작되면 애플리케이션은 \***nx_secure_tls_session_send** _ 서비스를 사용하여 데이터를 보낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-311">Once the TLS session has started, the application may send data using the \***nx_secure_tls_session_send** _ service.</span></span> <span data-ttu-id="14b4a-312">보내기 서비스는 _*_nx_tcp_socket_send_*_ 서비스와 동일하며 송신되는 데이터가 포함된 _*_NX_PACKET_*_ 데이터 구조를 사용합니다. 이 데이터만 송신되기 전에 NX Secure TLS 스택에 의해 암호화되며 _\*_nx_secure_tls_packet_allocate_\*\*를 사용하여 패킷이 할당되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-312">The send service is identical in use to the _*_nx_tcp_socket_send_*_ service, taking an _*_NX_PACKET_*_ data structure containing the data being sent, only that data will be encrypted by the NX Secure TLS stack before being sent, and the packet must be allocated using _\*_nx_secure_tls_packet_allocate_\*\*.</span></span>

### <a name="tls-session-receive"></a><span data-ttu-id="14b4a-313">TLS 세션 받기</span><span class="sxs-lookup"><span data-stu-id="14b4a-313">TLS Session Receive</span></span>

<span data-ttu-id="14b4a-314">TLS 세션이 시작되면 애플리케이션은 \***nx_secure_tls_session_receive** _ 서비스를 사용하여 데이터를 받기 시작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-314">Once the TLS session has started, the application may begin receiving data using the \***nx_secure_tls_session_receive** _ service.</span></span> <span data-ttu-id="14b4a-315">TLS 세션 보내기와 마찬가지로 이 서비스는 동일하게 _\*_nx_tcp_socket_receive_\*\*를 사용합니다. 단, 수신 데이터는 패킷 구조로 반환되기 전에 TLS 스택에 의해 해독되고 확인됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-315">Like the TLS Session send, this service is identical in use to _\*_nx_tcp_socket_receive_\*\*, except that the incoming data is decrypted and verified by the TLS stack before being returned in the packet structure.</span></span>

### <a name="tls-session-close"></a><span data-ttu-id="14b4a-316">TLS 세션 닫기</span><span class="sxs-lookup"><span data-stu-id="14b4a-316">TLS Session Close</span></span>

<span data-ttu-id="14b4a-317">TLS 세션이 완료되면 TLS 클라이언트와 서버는 서로에 CloseNotify 경고를 보내서 세션을 종료해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-317">Once a TLS session is complete, both the TLS client and server must send a CloseNotify alert to the other side to shut down the session.</span></span> <span data-ttu-id="14b4a-318">양쪽 모두 경고를 수신하고 처리해야만 세션이 성공적으로 종료됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-318">Both sides must receive and process the alert to ensure a successful session shutdown.</span></span>

<span data-ttu-id="14b4a-319">원격 호스트가 CloseNotify 경고를 보내면 ***nx_secure_tls_session_receive** _ 서비스에 대한 호출은 경고를 처리하고 해당 경고를 원격 호스트에 돌려보내고 _*_NX_SECURE_TLS_SESSION_CLOSED_\*\* 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-319">If the remote host sends a CloseNotify alert, any calls to the ***nx_secure_tls_session_receive** _ service will process the alert, send the corresponding alert back to the remote host, and return a value of _*_NX_SECURE_TLS_SESSION_CLOSED_\*\*.</span></span> <span data-ttu-id="14b4a-320">세션이 닫힌 후에는 이 TLS 세션을 사용하여 데이터를 보내거나 받으려는 시도가 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-320">Once the session is closed, any further attempts to send or receive data with that TLS session will fail.</span></span>

<span data-ttu-id="14b4a-321">애플리케이션이 TLS 세션을 닫으려면 \***nx_secure_tls_session_end** _ 서비스를 호출해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-321">If the application wishes to close the TLS session, the \***nx_secure_tls_session_end** _ service must be called.</span></span> <span data-ttu-id="14b4a-322">서비스는 CloseNotify 경고를 보내고 응답 CloseNotify를 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-322">The service will send the CloseNotify alert and process the response CloseNotify.</span></span> <span data-ttu-id="14b4a-323">응답을 받지 못하면 오류 값 _ \*_NX_SECURE_TLS_SESSION_CLOSE_FAIL_\*\*이 반환되어 TLS 세션이 완전히 종료되지 않았음을 나타냅니다. 이것은 보안 위반 가능성을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-323">If the response is not received, an error value of _ *_NX_SECURE_TLS_SESSION_CLOSE_FAIL_*\* will be returned, indicating that the TLS session was not cleanly shutdown, a possible security breach.</span></span>

### <a name="tls-alerts"></a><span data-ttu-id="14b4a-324">TLS 경고</span><span class="sxs-lookup"><span data-stu-id="14b4a-324">TLS Alerts</span></span>

<span data-ttu-id="14b4a-325">TLS는 최대 보안을 제공하도록 설계되었기 때문에 프로토콜에 이상 동작이 있으면 잠재적 보안 위반으로 간주됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-325">TLS is designed to provide maximum security, so any errant behavior in the protocol is considered a potential security breach.</span></span> <span data-ttu-id="14b4a-326">이러한 이유로 인해 메시지 처리 또는 암호화/암호 해독에 오류가 있으면 치명적인 오류로 간주되어 핸드셰이크 또는 세션이 즉시 종료됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-326">For this reason, any errors in message processing or encryption/decryption are considered fatal errors that terminate the handshake or session immediately.</span></span>

<span data-ttu-id="14b4a-327">로컬 애플리케이션에서 오류를 처리하는 것은 비교적 간단하지만, 원격 호스트는 상황을 올바르게 처리하고 추가로 발생할 수 있는 보안 위반을 방지하려면 오류가 발생한 사실을 알아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-327">While handling errors in a local application is relatively straightforward, the remote host needs to know that an error has occurred in order to properly handle the situation and prevent any further possible security breaches.</span></span> <span data-ttu-id="14b4a-328">이러한 이유로 TLS는 오류 발생 시 원격 호스트에 경고(*Alert*) 메시지를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-328">For this reason, TLS will send an *Alert* message to the remote host upon any error.</span></span>

<span data-ttu-id="14b4a-329">경고는 다른 TLS 메시지와 동일한 방식으로 처리되며 세션 중에 암호화되어 제공된 유형의 경고에서 공격자가 정보를 수집하지 못하도록 방지합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-329">Alerts are treated in the same manner as any other TLS messages and are encrypted during the session to prevent an attacker from gathering information from the type of alert provided.</span></span> <span data-ttu-id="14b4a-330">핸드셰이크 중에 전송되는 경고는 잠재적인 공격자가 얻을 수 있는 정보의 양을 제한하기 위해 범위가 제한됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-330">During the handshake, the alerts sent are limited in scope to limit the amount of information that could be obtained by a potential attacker.</span></span>

<span data-ttu-id="14b4a-331">TLS 세션을 닫는 데 사용되는 CloseNotify 경고는 유일하게 치명적이지 않은 경고입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-331">The CloseNotify alert, used to close the TLS session, is the only non-fatal alert.</span></span> <span data-ttu-id="14b4a-332">CloseNotify는 경고로 간주되고 경고 메시지의 형태로 송신되지만, 오류가 발생했음을 알리지 않는다는 점에서 다른 경고와는 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-332">While it is considered an alert and sent as an alert message, a CloseNotify is unlike other alerts in that it does not indicate an error has occurred.</span></span>

<span data-ttu-id="14b4a-333">경고 값과 "수준"(수준은 "경고(warning)" 및 "치명적(fatal)"이며 대부분의 TLS 경고는 "치명적"임)은 TLS RFC에 정의되어 있으며 발생한 오류 유형을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-333">The alert value and "level" (levels are "warning" and "fatal" – most TLS alerts are "fatal") are defined in the TLS RFCs and indicate the type of error that occurred.</span></span> <span data-ttu-id="14b4a-334">CloseNotify 이외의 대부분의 TLS 경고는 잠재적인 보안 문제를 나타내는 것으로 간주될 수 있으며, 이로 인해 TLS 세션 또는 핸드셰이크가 중단됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-334">Most TLS Alerts other than CloseNotify can be considered an indication of a potential security issue and will result in the TLS session or handshake being aborted.</span></span> <span data-ttu-id="14b4a-335">TLS API 호출이 **NX_SECURE_TLS_ALERT_RECEIVED** (0x114)를 반환하면 API 서비스 **_nx_secure_tls_session_alert_value_get_**(NetX Secure TLS 버전 5.12의 신규 서비스)을 사용하여 애플리케이션이 보안 문제에 대한 응답과 관련된 결정에 사용할 TLS 경고 값 및 수준을 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-335">If any TLS API call returns **NX_SECURE_TLS_ALERT_RECEIVED** (0x114), the API service **_nx_secure_tls_session_alert_value_get_** (new in NetX Secure TLS version 5.12) may be used to retrieve the TLS alert value and level for the application to use for any decisions regarding responses to security issues.</span></span> <span data-ttu-id="14b4a-336">대부분의 경우 원격 호스트에서 받은 모든 경고는 CloseNotify를 제외하고 치명적인 오류로 간주되어야 합니다. 단, 일부 예외가 있으며 자세한 내용은 TLS RFC를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="14b4a-336">In most cases, any alert received from the remote host other than CloseNotify should be considered a fatal error, though there are some excptions – see the TLS RFCs for more information.</span></span>

### <a name="tls-session-renegotiation"></a><span data-ttu-id="14b4a-337">TLS 세션 재협상</span><span class="sxs-lookup"><span data-stu-id="14b4a-337">TLS Session Renegotiation</span></span>

<span data-ttu-id="14b4a-338">TLS는 기존 TLS 세션의 컨텍스트 내에서 TLS 세션 매개 변수를 재협상하는 "재협상"이라는 개념을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-338">TLS supports the notion of "renegotiation" which is simply a renegotiation of the TLS session parameters within the context of an existing TLS session.</span></span> <span data-ttu-id="14b4a-339">즉, 새로운 핸드셰이크 메시지가 기존 세션을 사용하여 암호화되고 인증된다는 의미입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-339">What this means in practice is that the new handshake messages are encrypted and authenticated using the existing session.</span></span> <span data-ttu-id="14b4a-340">재협상은 TLS 호스트가 기존 세션을 완료하지 않고도 새 세션 매개 변수를 생성(예: 새 TLS 세션 키를 생성)하려고 할 때 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-340">Renegotiation is used when a TLS host wants to generate new session parameters (e.g. generate new TLS session keys) without having to complete the existing session.</span></span> <span data-ttu-id="14b4a-341">예를 들어, 애플리케이션에 대한 보안 정책에 따라 제한된 시간 동안만 세션 키가 사용되는데 그 시간 이후에도 TLS 세션이 활성 상태로 유지되는 경우에는 재협상이 바람직할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-341">For example, renegotiation may be desirable when security policies for an application dictate that session keys are only used for a limited time but a TLS session remains active beyond that time.</span></span>

<span data-ttu-id="14b4a-342">세션 재협상과 관련된 한 가지 문제는 TLS를 특정 중간자(man-in-the-middle) 공격에 취약하게 만든다는 것입니다. 이것은 서버가 새로운 매개 변수로 재협상을 시작하도록 유도하여 공격자가 TLS 세션을 가로챌 수 있도록 하는 공격입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-342">One issue with session renegotiation is that is makes TLS vulnerable to a specific Man-in-the-Middle attack where an attacker can convince a server to initiate a renegotiation with new parameters, thus allowing the attacker to hijack the TLS session.</span></span> <span data-ttu-id="14b4a-343">이 문제를 완화하기 위해 보안 재협상 표시 확장이 도입되었습니다(**오류! 참조 소스를 찾을 수 없습니다.**</span><span class="sxs-lookup"><span data-stu-id="14b4a-343">To mitigate this issue, the Secure Renegotiation Indication extension was introduced (see section **Error! Reference source not found.**</span></span> <span data-ttu-id="14b4a-344">섹션 참조).</span><span class="sxs-lookup"><span data-stu-id="14b4a-344">section).</span></span>

<span data-ttu-id="14b4a-345">NetX Secure TLS는 세션 재협상 및 보안 재협상 표시 확장을 완벽하게 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-345">NetX Secure TLS completely supports session renegotiation and the Secure Renegotiation Indication extension.</span></span>

<span data-ttu-id="14b4a-346">원격 호스트에서 데이터를 받을 때 재협상(및 확장)은 애플리케이션 상호 작용 없이 자동으로 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-346">When receiving data from a remote host, renegotations (and the extension) are handled automatically without application interaction.</span></span> <span data-ttu-id="14b4a-347">세션 재협상에 대한 알림이 필요한 경우 *nx_secure_tls_session_renegotiate_callback_set* 서비스를 통해 재협상 콜백을 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-347">If notification about session renegotiations is desired, a renegotiation callback may be supplied with the *nx_secure_tls_session_renegotiate_callback_set* service.</span></span> <span data-ttu-id="14b4a-348">원격 호스트가 재협상을 요청할 때마다 콜백이 호출되고 필요한 경우 애플리케이션이 조치를 취할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-348">The callback will be invoked whenever a renegotiation is requested by the remote host, allowing the application to take action if desired.</span></span>

<span data-ttu-id="14b4a-349">활성 TLS 세션에서 재협상을 시작하려면 필요한 TLS 세션에서 *nx_secure_tls_session_renegotiate* 서비스를 호출하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-349">To initiate a renegotiation from an active TLS session, simply invoke the *nx_secure_tls_session_renegotiate* service on the desired TLS session.</span></span>

### <a name="tls-session-resumption"></a><span data-ttu-id="14b4a-350">TLS 세션 재개</span><span class="sxs-lookup"><span data-stu-id="14b4a-350">TLS Session Resumption</span></span>

<span data-ttu-id="14b4a-351">TLS 세션 재개는 세션 재협상과 비슷한 점이 있지만 혼동해서는 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-351">TLS session resumption should not be confused with session renegotiation, despite some similarities.</span></span> <span data-ttu-id="14b4a-352">세션 재협상은 기존 TLS 세션 내에서 새 핸드셰이크를 시작하는 반면, 세션 재개는 TLS 핸드셰이크를 완전히 수행하지 않고 닫힌 TLS 세션을 다시 시작하며 전적으로 선택적 기능입니다. </span><span class="sxs-lookup"><span data-stu-id="14b4a-352">Where session *renegotiation* involves starting a new handshake within an existing TLS session, session *resumption* is a purely optional feature that involves restarting a closed TLS session without performing a complete TLS handshake.</span></span> <span data-ttu-id="14b4a-353">이를 위해 TLS 구현은 세션 매개 변수 및 키를 캐시하여 원래 핸드셰이크에서 제공된 고유 식별자인 세션 ID와 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-353">To achieve this, a TLS implementation may cache the session parameters and keys, associating them with a *session ID,* a unique identifier supplied in the original handshake.</span></span> <span data-ttu-id="14b4a-354">TLS 서버에 세션 ID를 제공함으로써 클라이언트는 호스트 간의 이전 TLS 세션이 존재했고 과거에 완료되었으며 핸드셰이크가 줄어든 세션을 다시 설정할 수 있는 상태를 클라이언트가 여전히 보유하고 있음을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-354">By supplying a session ID to a TLS server, a client indicates that a previous TLS session between the hosts existed and completed some time in the past, and that the client still possesses the state to re-establish the session with a reduced handshake.</span></span> <span data-ttu-id="14b4a-355">세션 키는 이론적으로 아직 비밀이고 통신 중인 두 호스트만 알고 있기 때문에 서버는 새 TLS 세션을 시작하면서 대부분의 정상적인 핸드셰이크를 우회할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-355">Since the session keys are theoretically still secret and only known by the two communicating host, the server can start a new TLS session and bypass most of the normal handshake.</span></span>

<span data-ttu-id="14b4a-356">세션 재개는 키 생성 마스터 비밀을 공유하고 인증서 서명을 확인하는 데 사용하는 잠재적으로 비용이 많이 드는 공개 키 작업을 방지하는 데 유용할 수 있지만, 가능한 모든 세션에 대해(적어도 구성 가능 기간 동안) 세션 매개 변수, 키, 암호화 상태가 메모리에 유지되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-356">Session resumption can be useful to avoid the potentially expensive public-key operations used to share the key generation master secret and verify certificate signatures, but it also requires that the session parameters, keys, and crypotgraphic state be maintained in memory for all possible sessions (at least for a configurable time window).</span></span>

<span data-ttu-id="14b4a-357">현재 버전의 NetX Secure TLS는 세션 재개를 지원하지 않습니다. 세션 ID는 TLS 서버에서 간단히 무시되며 TLS 클라이언트는 항상 NULL 세션 ID를 제공하여 서버가 완전한 핸드셰이크를 수행하도록 요청합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-357">The current version of NetX Secure TLS does not support session resumption – the session ID is simply ignored by TLS servers and TLS clients always supply a NULL session ID which prompts the server to perform a complete handshake.</span></span> <span data-ttu-id="14b4a-358">세션 재개가 부족해도 상호 운용성 문제는 발생하지 않습니다. 전적으로 선택적인 기능이기 때문입니다. 세션 ID가 NULL이거나 인식되지 않으면 모든 TLS 구현이 기본적으로 완전한 핸드셰이크로 설정되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-358">The lack of session resumption should cause no inter-operability issues as it is a completely optional feature and all TLS implementations must default to a complete handshake should the session ID be NULL or unrecognized.</span></span>

### <a name="protocol-layering"></a><span data-ttu-id="14b4a-359">프로토콜 계층화</span><span class="sxs-lookup"><span data-stu-id="14b4a-359">Protocol Layering</span></span>

<span data-ttu-id="14b4a-360">TLS 프로토콜은 전송 계층(예: TCP)과 애플리케이션 계층 사이의 네트워킹 스택에 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-360">The TLS protocol fits into the networking stack between the transport layer (e.g. TCP) and the application layer.</span></span> <span data-ttu-id="14b4a-361">TLS는 경우에 따라 전송 계층 프로토콜(따라서 *전송 계층* 보안)로 간주되지만, 기본 네트워크 프로토콜(예: TCP)과 관련하여 애플리케이션으로 작동하기 때문에 애플리케이션 계층으로 그룹화되는 경우도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-361">TLS is sometimes considered a transport-layer protocol (hence *Transport Layer* Security) but because it acts as an application with regard to the underlying network protocols (such as TCP) it is sometimes grouped into the application layer.</span></span>

<span data-ttu-id="14b4a-362">TLS에는 순차적 전달 및 무손실 전달을 지원하는 전송 계층 프로토콜(예: TCP)이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-362">TLS requires a transport layer protocol that supports in-order and lossless delivery, such as TCP.</span></span> <span data-ttu-id="14b4a-363">이러한 요구 사항 때문에 TLS는 UDP 위에서 실행할 수 없습니다. UDP는 데이터그램 전달을 보장하지 않기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-363">Due to this requirement, TLS cannot run on top of UDP since UDP does not guarantee delivery of datagrams.</span></span> <span data-ttu-id="14b4a-364">TLS의 수정 버전인 *DTLS* 라는 별도의 프로토콜은 UDP와 같은 데이터그램 프로토콜을 통해 TLS 보안이 필요한 애플리케이션에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-364">A separate protocol called *DTLS,* which is a modified version of TLS, is used for applications that need the security of TLS over a datagram protocol like UDP.</span></span> <span data-ttu-id="14b4a-365">NetX Secure는 DTLS를 지원하지만 DTLS에 대한 설명서는 이 문서와는 별개입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-365">NetX Secure supports DTLS, but documentation for DTLS is separate from this document.</span></span>

![TCP/IP 및 TLS 프로토콜 계층의 다이어그램입니다.](media/image6.png)

<span data-ttu-id="14b4a-367">그림 5- TCP/IP 및 TLS 프로토콜 계층</span><span class="sxs-lookup"><span data-stu-id="14b4a-367">Figure 5- TCP/IP and TLS protocol layers</span></span>

## <a name="network-communications-security"></a><span data-ttu-id="14b4a-368">네트워크 통신 보안</span><span class="sxs-lookup"><span data-stu-id="14b4a-368">Network Communications Security</span></span>

<span data-ttu-id="14b4a-369">공용 네트워크와 인터넷을 통한 통신 보안은 매우 중요한 토픽이며 다수의 서적, 기사 및 솔루션의 주제입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-369">Securing communications over public networks and the Internet is a critically important topic and the subject of vast numbers of books, articles, and solutions.</span></span> <span data-ttu-id="14b4a-370">이 토픽은 매우 복잡하지만, 의도한 대상만 정보에 액세스하거나 정보를 변경할 수 있도록 네트워크를 통해 정보 보내기라는 간단한 개념으로 정리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-370">The topic is mind-bogglingly complex, but can be reduced to a simple idea: sending information over a network so that only the intended target can access or change that information.</span></span> <span data-ttu-id="14b4a-371">이 개념은 다시 비밀 유지, 무결성 및 인증이라는 세 가지 중요한 개념으로 나뉩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-371">This breaks down into three important concepts: secrecy, integrity, and authentication.</span></span> <span data-ttu-id="14b4a-372">TLS 프로토콜은 세 가지 모두에 대한 솔루션을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-372">The TLS protocol provides solutions for all three.</span></span>

### <a name="secrecy"></a><span data-ttu-id="14b4a-373">비밀 유지</span><span class="sxs-lookup"><span data-stu-id="14b4a-373">Secrecy</span></span>

<span data-ttu-id="14b4a-374">네트워크를 통해 데이터를 전송하는 경우 악의적인 엔터티가 데이터를 손에 넣을 수 없도록 하는 것이 중요한 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-374">When sending data over a network, it is often important that the data cannot be obtained by a malicious entity.</span></span> <span data-ttu-id="14b4a-375">TCP/IP 연결을 통해 데이터를 전송하는 경우에는 네트워크에 액세스할 수 있는 사람이라면 누구나 쉽게 사용 가능한 네트워킹 도구를 사용하여 해당 데이터를 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-375">If data is sent over a TCP/IP connection, anyone with access to the network will be able to read that data using easily-available networking tools.</span></span> <span data-ttu-id="14b4a-376">해당 데이터를 손에 넣지 못하도록 하려면 의도한 대상을 제외하고 아무도 읽을 수 없도록 인코딩해야 합니다. 이것이 비밀 유지입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-376">To prevent that data from being obtained, it must be encoded such that it cannot be read except by the intended target – this is *secrecy.*</span></span> <span data-ttu-id="14b4a-377">TLS에서는 RSA, AES와 같은 암호화 알고리즘이 보안을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-377">In TLS, encryption algorithms such as RSA and AES provide secrecy.</span></span>

### <a name="integrity"></a><span data-ttu-id="14b4a-378">무결성</span><span class="sxs-lookup"><span data-stu-id="14b4a-378">Integrity</span></span>

<span data-ttu-id="14b4a-379">때로는 비밀 유지만으로는 네트워크를 통해 이동하는 데이터를 보호하기가 충분하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-379">Sometimes, secrecy is not enough to protect data travelling over a network.</span></span> <span data-ttu-id="14b4a-380">경우에 따라 악의적인 엔터티가 패킷에 포함된 내용을 몰라도 TCP 패킷의 콘텐츠를 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-380">In some cases, it may be possible for a malicious entity to alter the contents of a TCP packet without needing to know what that packet contains.</span></span> <span data-ttu-id="14b4a-381">암호화된 데이터를 변경하여 해독을 무효화하거나 메시지 매개 변수를 변경하여 공격자가 원하는 결과를 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-381">Encrypted data can be altered, rendering the decryption invalid or changing the parameters of the message leading to whatever result the attacker may be interested in achieving.</span></span> <span data-ttu-id="14b4a-382">네트워크에서 전송 중인 데이터를 공격자가 변경하는 것을 막을 수는 없어도 데이터가 변경되었는지 여부를 알 수 있는 메커니즘은 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-382">On the network, we cannot prevent an attacker from changing data in transit, but we can provide a mechanism to know whether or not the data has been changed.</span></span> <span data-ttu-id="14b4a-383">전송 중에 데이터가 변경되면 알 수 있고 데이터를 거부할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-383">When data is changed in transit, it will be known and the data can be rejected.</span></span> <span data-ttu-id="14b4a-384">이 개념이 무결성입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-384">This concept is *integrity*.</span></span> <span data-ttu-id="14b4a-385">TLS에서 무결성은 해시 함수라고 알려진 암호화 루틴 클래스에 의해 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-385">In TLS, integrity is provided by a class of cryptographic routines known as *hash functions*.</span></span> <span data-ttu-id="14b4a-386">해시 함수의 예는 MD5 및 SHA-1입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-386">Some examples of hash functions are MD5 and SHA-1.</span></span>

### <a name="authentication"></a><span data-ttu-id="14b4a-387">인증</span><span class="sxs-lookup"><span data-stu-id="14b4a-387">Authentication</span></span>

<span data-ttu-id="14b4a-388">네트워크 통신 보안에서 세 번째로 중요한 개념은, 의도한 대상에게만 데이터가 전달되어야 한다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-388">The third important concept in network communications security is the idea that data should only be communicated to the intended target.</span></span> <span data-ttu-id="14b4a-389">공격자는 다른 호스트를 대상으로 하는 데이터를 수신하기 위해 진짜 엔터티로 가장하려고 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-389">An attacker may attempt to pose as a legitimate entity to receive data intended for another host.</span></span> <span data-ttu-id="14b4a-390">비밀 유지 및 무결성 메커니즘을 사용하여 데이터가 전송되더라도, 공격자는 이러한 속임수를 통해 원하는 결과(보안 통신의 손상)를 달성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-390">Even if the data is being sent with secrecy and integrity mechanisms in place, the attacker may still be able to achieve the desired result (a compromise of secure communications) through this deception.</span></span> <span data-ttu-id="14b4a-391">이를 방지하려면 중요한 데이터를 보내기 전에 원격 호스트의 ID를 증명하는 메커니즘이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-391">To prevent this, a mechanism is needed to prove the identity of a remote host before any sensitive data is sent.</span></span> <span data-ttu-id="14b4a-392">원격 호스트의 ID를 증명하는 프로세스가 인증입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-392">The process of proving the identity of a remote host is *authentication.*</span></span> <span data-ttu-id="14b4a-393">TLS에서 인증은 디지털 인증서, 해시 함수 및 공개 키 암호화 속성을 활용하는 디지털 서명이라는 메커니즘을 사용하여 제공됩니다(아래 설명 참조).</span><span class="sxs-lookup"><span data-stu-id="14b4a-393">In TLS, authentication is provided using digital certificates, hash functions, and a mechanism called *digital signatures* which utilizes a property of public-key encryption (described below).</span></span> <span data-ttu-id="14b4a-394">제한적이지만 유용한 인증 형식은 PSK(미리 공유한 키)를 통해 제공될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-394">A limited but useful form of authentication can also be provided with a *pre-shared key* (PSK).</span></span>

## <a name="tls-encryption"></a><span data-ttu-id="14b4a-395">TLS 암호화</span><span class="sxs-lookup"><span data-stu-id="14b4a-395">TLS Encryption</span></span>

<span data-ttu-id="14b4a-396">TLS 프로토콜은 암호화를 사용하여 인터넷을 통해 보안 네트워크 통신을 제공하기 위한 프레임워크입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-396">The TLS protocol is a framework for providing secure network communications over the Internet utilizing encryption.</span></span> <span data-ttu-id="14b4a-397">암호화는 일반적으로 키 없이는 원래 데이터(또는 해당 데이터에 대한 정보)를 얻는 것이 매우 어렵도록 데이터를 인코딩하는 프로세스로 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-397">Encryption is generally defined as the process of encoding data in such a way that obtaining the original data (or information about that data) is exceedingly difficult without a *key*.</span></span> <span data-ttu-id="14b4a-398">컴퓨터 시스템에서 암호화는 유한 필드와 같은 복잡한 수학을 기반으로 하며 프라이빗 키(또는 대칭 암호화)와 공개 키(또는 비대칭 암호화)라는 두 가지 유형으로 분류될 수 있습니다.   </span><span class="sxs-lookup"><span data-stu-id="14b4a-398">In computer systems encryption is based on complex mathematics such as finite fields and can be classified into two types: *private key* (or *symmetric encryption*) and *public key* (or *asymmetric encryption*).</span></span> <span data-ttu-id="14b4a-399">프라이빗 키 암호화의 예로는 AES(Advanced Encryption Standard)와 RC4(Rivest Cipher 4)가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-399">Examples of private key encryption are AES (Advanced Encryption Standard) and RC4 (Rivest Cipher 4).</span></span> <span data-ttu-id="14b4a-400">공개 키 암호화의 예로는 RSA(Rivest, Shamir, Adleson) 및 Diffie-Hellman 암호가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-400">Examples of public-key encryption are the RSA (Rivest, Shamir, Adleson) and Diffie-Hellman ciphers.</span></span>

<span data-ttu-id="14b4a-401">TLS 프로토콜은 성능, 보안 및 유연성의 균형을 유지하기 위해 프라이빗 키와 공개 키 암호화 루틴을 모두 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-401">The TLS protocol makes use of both private key and public key encryption routines to provide a balance of performance, security, and flexibility.</span></span>

### <a name="private-key-encryption"></a><span data-ttu-id="14b4a-402">프라이빗 키 암호화</span><span class="sxs-lookup"><span data-stu-id="14b4a-402">Private-Key Encryption</span></span>

<span data-ttu-id="14b4a-403">프라이빗 키 암호화는 수천 년간 사용되어 왔습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-403">Private-key encryption has been in use for thousands of years.</span></span> <span data-ttu-id="14b4a-404">기본 대체 암호(문자나 단어가 관련 없는 다른 문자나 단어로 대체됨)는 가장 먼저 알려진 암호화의 예이지만 정보화 시대의 도래로 인해 프라이빗 키 암호화가 크게 향상되었습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-404">Basic substitution ciphers (where a letter or word is replaced by another unrelated letter or word) are the earliest known examples of encryption, but with the advent of the information age private key encryption has significantly improved.</span></span>

<span data-ttu-id="14b4a-405">프라이빗 키 암호는 "키"를 사용합니다. 이 키는 데이터를 인코딩하는 데 사용되는 값(일반적으로 단어, 문구 또는 숫자일 수 있음)이며, 이 키에 액세스할 수 있는 엔터티만 의미 있는 방식으로 데이터를 디코딩할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-405">A private key cipher uses a "key" which is simply a value (which could be a word, phrase, or number in the general case) that is used to somehow encode some data so that only an entity that had access to that key could decode the data in a meaningful way.</span></span> <span data-ttu-id="14b4a-406">이 키는 데이터 암호화 및 암호 해독 모두에 사용되기 때문에 대칭 암호화라는 다른 이름이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-406">The key is used for both encryption and decryption of the data, hence the other name *symmetric encryption*.</span></span>

<span data-ttu-id="14b4a-407">프라이빗 키 암호는 포함된 수학이 매우 복잡하더라도 일반적으로 빠르고 간단하게 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-407">Private key ciphers are generally fast and fairly simple to implement, even if the mathematics involved are exceedingly complex.</span></span> <span data-ttu-id="14b4a-408">그래서 TLS는 보안 통신의 대부분에 프라이빗 키 암호를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-408">For this reason, TLS uses private key ciphers for the bulk of secure communications.</span></span>

<span data-ttu-id="14b4a-409">하지만 프라이빗 키 암호화를 일반 컴퓨터 네트워크 통신에 적용하려고 할 때는 문제가 있습니다. 통신하려는 두 컴퓨터 사이에 키를 공유해야 한다는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-409">However, private key encryption has a problem when we try to apply it to general computer network communications: the key must be shared between both machines trying to communicate.</span></span> <span data-ttu-id="14b4a-410">인터넷 상의 두 컴퓨터 사이에 프라이빗 키를 안전하게 주고받는 것은 일반적으로 비현실적이며 불가능한 경우가 많습니다. 네트워크 트래픽이 인터넷을 통해 라우팅될 때 데이터가 거치는 다양한 곳에서 여러 엔터티가 데이터를 손에 넣는 것이 가능하다고 생각할 수 있기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-410">In the general case, it is impractical and often impossible to communicate a private key securely between two machines on the Internet, as it can be assumed that the network traffic can be obtained by any number of entities in the various hops that data takes when being routed through the Internet.</span></span> <span data-ttu-id="14b4a-411">악의적인 엔터티가 키를 확보하면 이 키를 사용하여 암호화된 모든 데이터는 손상됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-411">If the key is obtained by a malicious entity, all data encrypted using that key is compromised.</span></span> <span data-ttu-id="14b4a-412">인터넷 상의 대부분의 컴퓨터에는 네트워크 연결만 있고 통신을 위한 다른 보안 채널이 없기 때문에 네트워크를 통해 키를 보내는 것은 암호화되지 않은 데이터를 보내는 것과 마찬가지이며 보안이 제공되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-412">As most machines on the Internet have only a network connection and not another secure channel for communications, sending keys over the network is tantamount to sending the data unencrypted – it provides no security.</span></span>

<span data-ttu-id="14b4a-413">따라서, 프라이빗 키 암호화는 범용 네트워크 통신 보안 프로토콜을 구현하기에 충분하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-413">For this reason, private key encryption is not sufficient to implement a general-purpose network communications security protocol.</span></span> <span data-ttu-id="14b4a-414">이 경우 공개 키 암호화가 도움이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-414">This is where Public Key encryption can help.</span></span>

<span data-ttu-id="14b4a-415">NetX Secure TLS는 AES 프라이빗 키 암호화를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-415">NetX Secure TLS supports AES private-key encryption.</span></span>

### <a name="public-key-encryption"></a><span data-ttu-id="14b4a-416">공개 키 암호화</span><span class="sxs-lookup"><span data-stu-id="14b4a-416">Public-Key Encryption</span></span>

<span data-ttu-id="14b4a-417">프라이빗 키 암호화와 달리 공개 키 암호화는 상당히 새로운 개념으로, 1970년에 개발되었습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-417">Unlike private key encryption, public key encryption is a fairly new concept, having been developed in the 1970's.</span></span> <span data-ttu-id="14b4a-418">수학의 "트랩 도어 함수"라는 개념을 사용하여, 암호화된 데이터의 보안을 손상시키지 않으면서 네트워크를 통해 키를 공유할 수 있는 방법이 있음을 발견했습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-418">Using a concept known as "trap-door functions" in mathematics, it was discovered that there was a way to share a key over a network without compromising the security of then encrypted data.</span></span>

<span data-ttu-id="14b4a-419">공개 키 암호화가 작동하는 방식은 키(위에 설명된 프라이빗 키 암호화에서의 의미)가 프라이빗 키와 공개 키라는 두 부분으로 분할되고, 공개 키 암호화가 이름을 가져오는 것입니다. </span><span class="sxs-lookup"><span data-stu-id="14b4a-419">The way public key encryption works is that the key (in the private-key encryption sense described above) is split into two parts, a *private key* and a *public key*, from where public key encryption gets its name.</span></span> <span data-ttu-id="14b4a-420">이러한 키 중 하나(일반적으로 공개 키)가 암호화에 사용되고 다른 하나는 암호 해독에 사용된다는 개념입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-420">The concept is that one of these keys (typically the public key) is used for encryption, while the other is used for decryption.</span></span> <span data-ttu-id="14b4a-421">키의 비대칭으로 인해 공개 키 암호화의 다른 이름은 비대칭 암호화입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-421">This asymmetry of keys is the reason for the other name for public key encryption: *asymmetric encryption*.</span></span>

<span data-ttu-id="14b4a-422">공개 키 암호화 이면의 수학은 상당히 복잡하지만, 그 개념은 공개 키는 암호화에만 사용될 수 있고 이 키를 확보해도 암호화된 데이터를 확보할 수는 없다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-422">The mathematics behind public key encryption are fairly complex, but the idea is that the public key can *only* be used for encryption, and obtaining that key does not allow encrypted data to be obtained.</span></span> <span data-ttu-id="14b4a-423">공개 키를 사용하여 암호화된 데이터를 해독하는 유일한 방법은 프라이빗 키입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-423">The private key, in turn, is the only way to decrypt data encrypted using the public key.</span></span> <span data-ttu-id="14b4a-424">따라서 프라이빗 키를 비밀로 유지하면, 프라이빗 키의 소유자와 안전하게 통신하려는 사람은 프라이빗 키를 소유한 사람만 보안 데이터를 확보할 수 있다는 것을 알고 해당 공개 키로 데이터를 암호화하기만 하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-424">Thus, by keeping the private key secret, anyone wishing to communicate securely with the owner of that private key need only encrypt their data with the corresponding public key with the knowledge that only someone in possession of that private key can obtain the secure data.</span></span>

<span data-ttu-id="14b4a-425">NetX Secure TLS는 RSA 공개 키 암호화를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-425">NetX Secure TLS supports RSA public-key encryption.</span></span>

> [!IMPORTANT] 
> <span data-ttu-id="14b4a-426">소프트웨어 RSA 구현이 사용되는 경우 RSA는 프로세서 사용량이 매우 많은 작업입니다. 키 크기가 클수록 필요한 처리 능력이 제곱 비율로 증가합니다. 즉, 키 크기가 2배 증가하면 속도는 4배 느려집니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-426">*RSA is a very processor-intensive operation if the software RSA implementation is used. Larger key sizes increase the processing power required by a square factor – 4X slower for a 2X increase in key size.*</span></span>

### <a name="public-key-authentication"></a><span data-ttu-id="14b4a-427">공개 키 인증</span><span class="sxs-lookup"><span data-stu-id="14b4a-427">Public-Key Authentication</span></span>

<span data-ttu-id="14b4a-428">공개 키 암호화 개념의 흥미로운 부작용은 반대로(프라이빗 키를 사용하여 암호화하고 공개 키를 사용하여 해독) 작업을 수행하여 인증은 물론 암호화를 제공하는 데 사용할 수 있다는 것입니다. </span><span class="sxs-lookup"><span data-stu-id="14b4a-428">An interesting side-effect of the public-key encryption concept is that it can be used to provide authentication as well as encryption by doing the operation in reverse: encrypting using the *private* key and decrypting using the *public* key.</span></span> <span data-ttu-id="14b4a-429">이 작업을 수행하는 실제 메커니즘은 사용되는 공개 키 알고리즘에 따라 달라지지만 개념은 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-429">The actual mechanism for doing this depends on the public key algorithm being used, but the concept is the same.</span></span>

<span data-ttu-id="14b4a-430">공개 키 인증을 사용하여 인증하기 위해 프라이빗 키 소유자는 프라이빗 키를 사용하여 일부 데이터(일반적으로 인증 받을 데이터의 암호화 해시)를 암호화합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-430">To authenticate using public key authentication, the owner of a private key encrypts some piece of data (typically a cryptographic hash of the data to be authenticated) using that private key.</span></span> <span data-ttu-id="14b4a-431">그런 다음, 데이터가 프라이빗 키 소유자로부터 왔음을 인증하려는 사람은 연결된 공개 키를 사용하여 데이터를 해독합니다. 해독에 성공하면(이 사용자가 공개 키의 유효성을 신뢰했다고 가정하고) 이 사용자는 데이터가 프라이빗 키 소유자로부터 왔다는 것을 확신할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-431">Then, someone wishing to authenticate that the data came from the owner of the private key uses the associated public key to decrypt the data – if the decryption is successful, and assuming the user trusted the validity of that public key, then the user can be certain that the data came from the owner of the private key.</span></span>

<span data-ttu-id="14b4a-432">TLS에서 공개 키 인증은 신뢰할 수 있는 인증서 저장소의 공개 키를 사용하여 TLS 서버(및 선택적으로 TLS 클라이언트)가 제공한 디지털 인증서의 유효성을 확인하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-432">In TLS, public key authentication is used to verify the validity of a digital certificate provided by a TLS server (and optionally the TLS client) using public keys from the trusted certificate store.</span></span> <span data-ttu-id="14b4a-433">인증서는 저장소의 공개 키와 비교하여 확인되며 인증서의 데이터는 서버의 ID를 확인하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-433">The certificate is checked against a public key in the store and the data in the certificate is used to check the identity of the server.</span></span>

<span data-ttu-id="14b4a-434">NetX Secure TLS는 RSA 인증을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-434">NetX Secure TLS supports RSA authentication.</span></span>

### <a name="cryptographic-hashing"></a><span data-ttu-id="14b4a-435">암호화 해시</span><span class="sxs-lookup"><span data-stu-id="14b4a-435">Cryptographic Hashing</span></span>

<span data-ttu-id="14b4a-436">암호화(encryption)는 TLS에서 사용되는 유일한 암호화(cryptographic) 작업이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-436">Encryption is not the only cryptographic operation used in TLS.</span></span> <span data-ttu-id="14b4a-437">TLS 세션 중에 메시지 무결성을 제공하려면 메시지 내용이 변조되지 않았는지 확인하는 체크섬이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-437">In order to provide message integrity during a TLS session, a checksum is needed to ensure that the message contents have not been tampered with.</span></span> <span data-ttu-id="14b4a-438">하지만 간단한 체크섬(TCP에서 사용됨)만으로는 적합한 수준의 무결성을 보장할 수 없습니다. 지식이 풍부한 공격자가 쉽게 손상시킬 수 있기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-438">However, a simple checksum (as is used in TCP) is insufficient to guarantee an acceptable level of integrity as it can be easily subverted by a knowledgeable attacker.</span></span> <span data-ttu-id="14b4a-439">TLS에서 메시지 무결성을 제공하는 데 사용하는 메커니즘을 암호화 해시라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-439">The mechanism used by TLS to provide message integrity is known as a *cryptographic hash*.</span></span>

<span data-ttu-id="14b4a-440">암호화는 1:1 인코딩입니다. 즉, 암호화된 데이터에서 원본 데이터 전체를 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-440">Encryption is a 1:1 encoding – that is, the entirety of the original data can be obtained from the encrypted data.</span></span> <span data-ttu-id="14b4a-441">하지만 해시는 임의의 크기인 데이터를 체크섬처럼 고정된 크기 값에 매핑합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-441">However, a hash maps an arbitrary amount of data into a fixed size value, just like a checksum.</span></span> <span data-ttu-id="14b4a-442">간단한 체크섬과 달리 해시는 다른 입력 데이터가 동일한 출력을 생성하는 충돌을 줄이기 위해 특별히 설계되었습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-442">Unlike a simple checksum, a hash is specifically designed to reduce *collisions*, where different input data result in the same output.</span></span> <span data-ttu-id="14b4a-443">간단한 체크섬에서 비트가 1에서 0으로, 또 다른 비트가 0에서 1로 바뀌면 체크섬은 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-443">In a simple checksum, if a bit is flipped from 1 to 0 and another bit from 0 to 1, the checksum is the same.</span></span> <span data-ttu-id="14b4a-444">암호화 해시를 사용하면 출력이 상당히 달라지기 때문에 공격자가 해시된 데이터를 변경하고 변경된 데이터에 해시 작업을 수행하여 여전히 동일한 값을 얻기(따라서 해당 데이터의 무결성을 거짓으로 확인하기)가 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-444">With a cryptographic hash, the output would differ significantly, making it difficult for an attacker to change the hashed data and have the hash operation on the changed data still result in the same value (and thus falsely verifying the integrity of that data).</span></span>

<span data-ttu-id="14b4a-445">TLS는 다양한 해시 알고리즘을 사용하여 메시지(애플리케이션 메시지와 TLS 제어 메시지 모두)의 무결성을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-445">TLS uses a number of different hash algorithms to provide integrity for messages, both application messages and TLS control messages.</span></span> <span data-ttu-id="14b4a-446">여기에는 MD5, SHA-1 및 SHA-256이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-446">These include MD5, SHA-1 and SHA-256.</span></span>

<span data-ttu-id="14b4a-447">NetX Secure TLS는 MD5, SHA-1 및 SHA-256 해시를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-447">NetX Secure TLS supports MD5, SHA-1, and SHA-256 hashing.</span></span>

## <a name="tls-extensions"></a><span data-ttu-id="14b4a-448">TLS 확장</span><span class="sxs-lookup"><span data-stu-id="14b4a-448">TLS Extensions</span></span>

<span data-ttu-id="14b4a-449">TLS는 특정 애플리케이션에 대한 추가 기능이 포함된 여러 확장을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-449">TLS provides a number of extensions that provide additional functionality for certain applications.</span></span> <span data-ttu-id="14b4a-450">이러한 확장은 일반적으로 ClientHello 또는 ServerHello 메시지의 일부로 전송되며, 확장을 사용해야 한다고 원격 호스트에 알리거나 보안 TLS 세션을 설정하는 데 사용할 추가 세부 정보를 원격 호스트에 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-450">These extensions are typically sent as part of the ClientHello or ServerHello messages, indicating to a remote host the desire to use an extension or providing additional details for use in establishing the secure TLS session.</span></span>

<span data-ttu-id="14b4a-451">일반적으로 확장은 진행 작업을 안내하는 핸드셰이크 시작 부분에서 TLS에 선택적 매개 변수를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-451">In general, extensions provide optional parameters to TLS at the beginning of the handshake that guide the proceeding operations.</span></span> <span data-ttu-id="14b4a-452">일부 확장에는 애플리케이션 입력 또는 의사 결정이 필요하고 다른 확장은 자동으로 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-452">Some extensions require application input or decision making, while others are handled automatically.</span></span>

<span data-ttu-id="14b4a-453">다음 표에서는 현재 NetX Secure TLS에서 지원하는 TLS 확장에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-453">The following table describes the TLS extensions currently supported by NetX Secure TLS:</span></span>

| <span data-ttu-id="14b4a-454">**Extension Name**</span><span class="sxs-lookup"><span data-stu-id="14b4a-454">**Extension Name**</span></span>              | <span data-ttu-id="14b4a-455">**설명**</span><span class="sxs-lookup"><span data-stu-id="14b4a-455">**Description**</span></span>              |
| ------------------------------- |----------------------------- |
| <span data-ttu-id="14b4a-456">보안 재협상 표시</span><span class="sxs-lookup"><span data-stu-id="14b4a-456">Secure Renegotiation Indication</span></span> | <span data-ttu-id="14b4a-457">이 확장은 재협상 핸드셰이크 중에 발생할 수 있는 중간자(man-in-the-middle) 공격 취약점을 완화합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-457">This extension mitigates a Man-in-the-Middle attack vulnerability that could occur during a renegotiation handshake.</span></span>|
| <span data-ttu-id="14b4a-458">서버 이름 표시</span><span class="sxs-lookup"><span data-stu-id="14b4a-458">Server Name Indication</span></span>          | <span data-ttu-id="14b4a-459">이 확장을 통해 TLS 클라이언트는 특정 DNS 이름을 TLS 서버에 제공하여 서버가 올바른 자격 증명을 선택할 수 있습니다(서버에 여러 ID 인증서와 네트워크 진입점이 있다고 가정).</span><span class="sxs-lookup"><span data-stu-id="14b4a-459">This extension allows a TLS Client to supply a specific DNS name to a TLS Server, allowing the server to select the correct credentials (assumes the server has multiple identity certificates and network entrypoints).</span></span> |
| <span data-ttu-id="14b4a-460">서명 알고리즘</span><span class="sxs-lookup"><span data-stu-id="14b4a-460">Signature Algorithms</span></span>            | <span data-ttu-id="14b4a-461">이 확장을 통해 TLS 클라이언트는 허용되는 서명 및 해시 알고리즘 목록을 TLS 서버에 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-461">This extension enables a TLS Client to provide a list of acceptable signature and hash algorithms to a TLS Server.</span></span> |

<span data-ttu-id="14b4a-462">지원되는 TLS 확장 개요</span><span class="sxs-lookup"><span data-stu-id="14b4a-462">Overview of supported TLS Extensions</span></span>

### <a name="secure-renegotiation-indication"></a><span data-ttu-id="14b4a-463">보안 재협상 표시</span><span class="sxs-lookup"><span data-stu-id="14b4a-463">Secure Renegotiation Indication</span></span>

<span data-ttu-id="14b4a-464">TLS는 기존 TLS 세션 내에서 핸드셰이크를 수행하는 개념을 지원하므로 설정된 세션을 사용하여 핸드셰이크 메시지를 암호화합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-464">TLS supports the notion of performing a handshake within an existing TLS session, thereby using the established session to encrypt the handshake messages.</span></span> <span data-ttu-id="14b4a-465">이 프로세스를 통해 TLS 세션을 종료하지 않고 암호화 세션 키를 다시 설정할 수 있습니다("TLS 세션 재협상" 섹션 참조).</span><span class="sxs-lookup"><span data-stu-id="14b4a-465">This process allows the cryptographic session keys to be re-established without ending the TLS session (see section "TLS Session Renegotiation").</span></span>

<span data-ttu-id="14b4a-466">유감스럽게도 TLS가 한동안 재협상을 사용한 후, 재협상 기능을 악용한 중간자(man-in-the-middle) 공격에 대한 취약성이 있다는 것을 알게 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-466">Unfortunately, after TLS had been using renegotiation for some time, it was discovered that there was a vulnerability to a Man-in-the-Middle attack that exploited the renegotiation feature.</span></span> <span data-ttu-id="14b4a-467">이러한 취약성을 해소하기 위해 보안 재협상 표시라는 확장이 도입되었습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-467">To close the vulnerability, the Secure Renegotiation Indication extension was introduced.</span></span> <span data-ttu-id="14b4a-468">기본적으로 보안 재협상 확장은 설정된 연결의 Finished 메시지 해시를 사용하여 원래 호스트가 재협상 핸드셰이크에 참여 중인지 확인합니다. 기본적으로 해시는 공격자가 해시를 위조할 수 없다는 가정 하에 확인 토큰으로 사용됩니다(세션 키에 대한 액세스가 필요함).</span><span class="sxs-lookup"><span data-stu-id="14b4a-468">Essentially, the Secure Renegotiation extension uses the Finished message hash from the established connection to verify that the original hosts are participating in the renegotiation handshake – essentially the hash is used as a verification token under the assumption that an attacker would not be able to forge the hash (which would require access to the session keys).</span></span>

<span data-ttu-id="14b4a-469">NetX Secure TLS는 재협상을 자동으로 처리하며 기본적으로 보안 재협상 확장을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-469">NetX Secure TLS handles renegotiation automatically and uses the Secure Renegotiation Extension by default.</span></span> <span data-ttu-id="14b4a-470">애플리케이션 상호 작용이 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-470">No application interaction is required.</span></span>

### <a name="server-name-indication"></a><span data-ttu-id="14b4a-471">서버 이름 표시</span><span class="sxs-lookup"><span data-stu-id="14b4a-471">Server Name Indication</span></span>

<span data-ttu-id="14b4a-472">TLS 핸드셰이크 중에 TLS 클라이언트는 클라이언트가 서버를 인증할 수 있도록 원격 서버가 ID 인증서를 제공할 것으로 예상합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-472">During the TLS handshake, a TLS Client expects a remote server to provide an identity certificate so the client can authenticate the server.</span></span> <span data-ttu-id="14b4a-473">하지만 한 서버가 각각 고유한 ID를 가진 서로 다른 "가상" 서버로 여러 가지 서비스를 제공하는 경우가 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-473">However, there may be some cases where a server will provide multiple different services with different "virtual" servers each having unique identities.</span></span> <span data-ttu-id="14b4a-474">여러 ID가 있는 단일 서버의 경우 TLS 클라이언트는 서버가 적절한 자격 증명을 선택하는 데 사용할 특정 DNS 이름을 제공할 수 있습니다. 이 이름을 제공하는 메커니즘이 SNI(서버 이름 표시) 확장입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-474">In the case of a single server with multiple identities, a TLS client can supply a specific DNS name that the server will use to select the proper credentials – the mechanism for supplying this name is the Server Name Indication (SNI) extension.</span></span>

<span data-ttu-id="14b4a-475">SNI 확장을 사용하는 애플리케이션에는 몇 가지 상호 작용이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-475">For an application using the SNI extension, some interaction is required.</span></span> <span data-ttu-id="14b4a-476">TLS 클라이언트의 경우 애플리케이션은 원격 서버에 보낼 DNS 이름을 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-476">For TLS Clients, the application must supply a DNS name to be sent to the remote server.</span></span> <span data-ttu-id="14b4a-477">TLS 서버의 경우 애플리케이션은 확장에서 DNS 이름을 읽고 클라이언트에 돌려보낼 적절한 인증서를 선택해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-477">For TLS Servers, the application must read the DNS name from the extension and select an appropriate certificate to send back to the client.</span></span>

<span data-ttu-id="14b4a-478">다음 섹션에는 NetX Secure TLS에서 SNI 확장을 사용하는 방법에 대한 자세한 내용이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-478">The following sections provide more detail on how to use the SNI extension in NetX Secure TLS.</span></span>

### <a name="sni-extension--tls-client"></a><span data-ttu-id="14b4a-479">SNI 확장 – TLS 클라이언트</span><span class="sxs-lookup"><span data-stu-id="14b4a-479">SNI Extension – TLS Client</span></span>

<span data-ttu-id="14b4a-480">SNI 확장을 사용하려는 NetX Secure TLS 클라이언트는 핸드셰이크 중에 제공할 DNS 이름을 TLS에 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-480">A NetX Secure TLS Client wishing to use the SNI extension must provide a DNS name to TLS to be supplied during the handshake.</span></span> <span data-ttu-id="14b4a-481">이 이름은 TLS 세션을 시작하기 전에 초기화되고 제공되어 야합니다. 확장은 핸드셰이크 프로세스를 시작하는 ClientHello 메시지에 포함되어 전송되기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-481">This name must be initialized and supplied prior to starting a TLS session since the extension is sent in the ClientHello message which starts the handshake process.</span></span>

<span data-ttu-id="14b4a-482">다음 코드 조각은 확장을 사용하는 방법을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-482">The following code snippet illustrates the use of the extension.</span></span> <span data-ttu-id="14b4a-483">먼저 NX_SECURE_X509_DNS_NAME 개체가 원하는 서버 이름으로 초기화됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-483">First, a NX_SECURE_X509_DNS_NAME object is initialized with the desired server name.</span></span> <span data-ttu-id="14b4a-484">그런 다음, TLS 세션을 시작하기 전에 SNI 확장 API를 사용하여 TLS에 이름이 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-484">Then, prior to starting the TLS session, the name is provided to TLS using the SNI extension API.</span></span> <span data-ttu-id="14b4a-485">이름이 설정되면 추가 작업이 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-485">Once the name is set, no further action is required.</span></span> <span data-ttu-id="14b4a-486">챕터 4의 API 참조를 확인하세요.</span><span class="sxs-lookup"><span data-stu-id="14b4a-486">See the API reference in Chapter 4</span></span>  
  
<span data-ttu-id="14b4a-487">개별 함수에 대한 자세한 내용은 NetX Secure 서비스에 대한 설명을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="14b4a-487">Description of NetX Secure Services for more information on the individual functions.</span></span>

```C
/* The dns_name variable will contain our desired server name. */
UINT status;
NX_SECURE_X509_DNS_NAME dns_name;

/* Initialize the server DNS name. */
status = nx_secure_x509_dns_name_initialize(&dns_name, "www.example.com", 
                                            strlen("www.example.com"));


/* Initialize SNI extension in previously-initialized TLS Session. */
status = nx_secure_tls_session_sni_extension_set(&client_tls_session, &dns_name);

/* Now start the TLS session, starting with establishing the TCP connection – if 
   TLS is started before initializing the SNI extension, the extension will not be 
   sent in the ClientHello message! */
status = nx_tcp_client_socket_connect(&client_socket, IP_ADDRESS(1, 2, 3, 4), 443, 
                                      5 * NX_IP_PERIODIC_RATE);

status = nx_secure_tls_session_start(&client_tls_session, &client_socket, 
                                     NX_WAIT_FOREVER);
```
### <a name="sni-extension--tls-server"></a><span data-ttu-id="14b4a-488">SNI 확장 – TLS 서버</span><span class="sxs-lookup"><span data-stu-id="14b4a-488">SNI Extension – TLS Server</span></span>

<span data-ttu-id="14b4a-489">TLS 서버 측에서 SNI 확장은 핸드셰이크 중에 원격 클라이언트에 제공할 적절한 자격 증명(예 : 인증서)을 선택하기 위해 애플리케이션에서 처리될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-489">On the TLS Server side, the SNI extension may be processed by the application in order to select proper credentials (e.g. certificate) to provide to the remote client during the handshake.</span></span> <span data-ttu-id="14b4a-490">그러려면 애플리케이션은 ClientHello 메시지 수신 후 호출되는 세션 콜백을 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-490">To do this, the application must supply a session callback which is invoked following the receipt of a ClientHello message.</span></span>

<span data-ttu-id="14b4a-491">nx_secure_tls_session_server_callback_set API(122 페이지 참조)에 대한 예제 코드는 서버 콜백을 사용한 수신 SNI 확장의 구문 분석을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-491">The example code for the nx_secure_tls_session_server_callback_set API  (see page 122) illustrates the parsing of an incoming SNI extension using a server callback.</span></span> <span data-ttu-id="14b4a-492">기본적으로 TLS 서버는 ClientHello를 수신하고 콜백을 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-492">Essentially, the TLS Server receives a ClientHello and invokes the callback.</span></span> <span data-ttu-id="14b4a-493">그런 다음, 애플리케이션은 *nx_secure_tls_session_sni_extension_parse* API를 사용하여 콜백에 제공된 확장 데이터를 구문 분석하여 SNI 확장을 찾고 제공된 DNS 이름을 반환합니다(확장은 단일 DNS 이름만 지원함).</span><span class="sxs-lookup"><span data-stu-id="14b4a-493">Then the application uses the *nx_secure_tls_session_sni_extension_parse* API to parse the extension data provided to the callback to find the SNI extension and return the supplied DNS name (note that the extension only supports a single DNS name).</span></span> <span data-ttu-id="14b4a-494">이름을 얻으면 애플리케이션은 그 이름을 사용하여 적절한 서버 ID 인증서(및 해당되는 경우 발급자 체인)를 찾아서 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-494">Once the name is obtained, the application uses it to find and send the appropriate server identity certificate (and issuer chain if applicable).</span></span>

### <a name="signature-algorithms-extension"></a><span data-ttu-id="14b4a-495">서명 알고리즘 확장</span><span class="sxs-lookup"><span data-stu-id="14b4a-495">Signature Algorithms Extension</span></span>

<span data-ttu-id="14b4a-496">이 확장은 TLS 1.2에만 해당되며 TLS 클라이언트가 디지털 서명을 생성 및 확인하는 데 사용할 수 있는 허용되는 서명 및 해시 알고리즘 쌍 목록을 제공할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-496">This extension is specific to TLS 1.2 and allows a TLS Client to provide a list of acceptable signature and hash algorithm pairs that are acceptable for use in generating and verifying digital signatures.</span></span> <span data-ttu-id="14b4a-497">이 목록은 *nx_secure_tls_session_create* 에 제공된 암호 테이블을 사용하여 TLS 클라이언트용 NetX Secure TLS에 의해 자동으로 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-497">The list is generated automatically by NetX Secure TLS for TLS Clients using the cipher table supplied to *nx_secure_tls_session_create*.</span></span> <span data-ttu-id="14b4a-498">애플리케이션 상호 작용이 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-498">No application interaction is required.</span></span>

## <a name="authentication-methods"></a><span data-ttu-id="14b4a-499">인증 방법</span><span class="sxs-lookup"><span data-stu-id="14b4a-499">Authentication Methods</span></span>

<span data-ttu-id="14b4a-500">TLS는 안전하지 않은 네트워크를 통해 두 디바이스 간에 보안 연결을 설정할 수 있는 프레임워크를 제공하지만, 해당 연결의 반대쪽 끝에 있는 디바이스 ID를 알아야 한다는 문제가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-500">TLS provides the framework for establishing a secure connection between two devices over an insecure network, but part of the problem is knowing the identity of the device on the other end of that connection.</span></span> <span data-ttu-id="14b4a-501">원격 호스트의 ID를 인증하는 메커니즘이 없으면 공격자는 신뢰할 수 있는 디바이스로 손쉽게 가장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-501">Without a mechanism for authenticating the identity of remote hosts, it becomes a trivial operation for an attacker to pose as a trusted device.</span></span>

<span data-ttu-id="14b4a-502">처음에는 IP 주소, 하드웨어 MAC 주소 또는 DNS를 사용하면 네트워크에서 호스트를 식별하는 데 비교적 높은 수준의 신뢰도를 제공하는 것처럼 보일 수 있지만, TCP/IP 기술의 특성과 주소를 쉽게 스푸핑할 수 있고 DNS 항목이 손상(예: DNS 캐시 중독을 통해)될 수 있다는 점을 고려할 때 TLS에는 사기성 ID를 차단하기 위한 추가 보호 계층이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-502">Initially, it may seem that using IP addresses, hardware MAC addresses, or DNS would provide a relatively high level of confidence for identifying hosts on a network, but given the nature of TCP/IP technology and the ease with which addresses can be spoofed and DNS entries corrupted (e.g. through DNS cache poisoning), it becomes clear that TLS needs an additional layer of protection against fraudulent identities.</span></span>

<span data-ttu-id="14b4a-503">TLS에 이와 같은 추가 인증 계층을 제공할 수 있는 다양한 메커니즘이 있지만, 가장 일반적인 방법은 *디지털 인증서* 입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-503">There are various mechanisms that can provide this extra layer of authentication for TLS, but the most common is the *digital certificate.*</span></span> <span data-ttu-id="14b4a-504">기타 메커니즘으로는 PSK(미리 공유한 키) 및 암호 체계가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-504">Other mechanisms include Pre-Shared Keys (PSK) and password schemes.</span></span>

### <a name="digital-cerificates"></a><span data-ttu-id="14b4a-505">디지털 인증서</span><span class="sxs-lookup"><span data-stu-id="14b4a-505">Digital Cerificates</span></span>

<span data-ttu-id="14b4a-506">디지털 인증서는 TLS에서 원격 호스트를 인증하는 가장 일반적인 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-506">Digital certificates are the most common method for authenticating a remote host in TLS.</span></span> <span data-ttu-id="14b4a-507">기본적으로 디지털 인증서는 컴퓨터 네트워크 상의 디바이스에 대한 ID 정보를 제공하는 특정 형식의 문서입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-507">Essentially, a digital certificate is a document with specific formatting that provides identity information for a device on a computer network.</span></span>

<span data-ttu-id="14b4a-508">TLS는 일반적으로 International Telecommunication Union에서 개발한 표준인 X.509 형식을 사용하지만, 사용하려는 형식을 TLS 호스트가 동의할 수 있다면 다른 형식의 인증서를 사용해도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-508">TLS normally uses a format called X.509, a standard developed by the International Telecommunication Union, though other formats of certificates may be used if the TLS hosts can agree on the format being used.</span></span> <span data-ttu-id="14b4a-509">X.509는 디지털 문서를 작성하는 데 사용할 수 있는 다양한 인코딩 및 인증서의 형식을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-509">X.509 defines a specific format for certificates and various encodings that can be used to produce a digital document.</span></span> <span data-ttu-id="14b4a-510">TLS에 사용되는 대부분의 X.509 인증서는 다른 통신 표준의 변형인 ASN.1을 사용하여 인코딩됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-510">Most X.509 certificates used with TLS are encoded using a variant of ASN.1, another telecommunications standard.</span></span> <span data-ttu-id="14b4a-511">ASN.1에는 다양한 디지털 인코딩이 포함되어 있지만, TLS 인증서에 사용되는 가장 일반적인 인코딩은 DER(Distinguished Encoding Rules) 표준입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-511">Within ASN.1 there are various digital encodings, but the most common encoding for TLS certificates is the Distinguished Encoding Rules (DER) standard.</span></span> <span data-ttu-id="14b4a-512">DER은 구문 분석을 쉽게 수행할 수 있도록 분명하게 설계된 ASN.1 BER(Basic Encoding Rules)의 간소화된 하위 세트입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-512">DER is a simplified subset of the ASN.1 Basic Encoding Rules (BER) that is designed to be unambiguous, making parsing easier.</span></span> <span data-ttu-id="14b4a-513">네트워크를 통해 TLS 인증서는 일반적으로 이진 DER로 인코딩되며, 이 형식은 NetX Secure에서 X.509 인증서에 요구하는 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-513">Over the wire, TLS certificates are usually encoded in binary DER, and this is the format that NetX Secure expects for X.509 certificates.</span></span>

<span data-ttu-id="14b4a-514">DER 형식의 이진 인증서는 실제 TLS 프로토콜에 사용되지만 .pem, .crt, .p12 등의 파일 확장명을 사용하여 다양한 인코딩으로 생성하고 저장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-514">Though DER-formatted binary certificates are used in the actual TLS protocol, they may be generated and stored in a number of different encodings, with file extensions such as .pem, .crt, and .p12.</span></span> <span data-ttu-id="14b4a-515">여러 제조업체의 다양한 애플리케이션에서 다양한 변형이 사용되지만, 일반적으로 널리 제공되는 도구를 사용하여 DER로 변환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-515">The different variants are used by different applications from different manufacturers, but generally all can be converted into DER using widely available tools.</span></span>

<span data-ttu-id="14b4a-516">가장 일반적인 대체 인증서 인코딩은 PEM입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-516">The most common of the alternative certificate encodings is PEM.</span></span> <span data-ttu-id="14b4a-517">Privacy Enhanced Mail의 PEM 형식은 base-64로 인코딩된 DER 인코딩 버전으로, 인코딩 결과가 이메일 또는 웹 기반 프로토콜을 사용하여 쉽게 보낼 수 있는 인쇄 가능한 텍스트로 생성되기 때문에 자주 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-517">The PEM format (from Privacy-Enhanced Mail) is a base-64 encoded version of the DER encoding that is often used because the encoding results in printable text that can be easily sent using email or web-based protocols.</span></span>

<span data-ttu-id="14b4a-518">NetX Secure 애플리케이션의 인증서 생성은 일반적으로 이 설명서의 범위를 벗어나지만, OpenSSL 명령줄 도구([www.openssl.org](http://www.openssl.org))는 광범위하게 사용할 수 있으며 대부분의 형식을 변환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-518">Generating a certificate for your NetX Secure application is generally outside the scope of this manual, but the OpenSSL command-line tool ([www.openssl.org](http://www.openssl.org)) is widely available and can convert between most formats.</span></span>

<span data-ttu-id="14b4a-519">애플리케이션에 따라 사용자 고유의 인증서를 생성할 수도 있고, 제조업체 또는 정부 기관에서 인증서를 제공할 수도 있고, 상용 인증 기관에서 인증서를 구매할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-519">Depending on your application, you may generate your own certificates, be provided certificates by a  manufacturer or government organization, or purchase certificates from a commercial certificate authority.</span></span>

<span data-ttu-id="14b4a-520">NetX Secure 애플리케이션에서 디지털 인증서를 사용하려면 먼저 인증서를 이진 DER 형식으로 변환하고, 필요에 따라 연결된 프라이빗 키(예: RSA의 경우 "프라이빗 지수")를 이진 형식(일반적으로 PKCS#1 형식의 DER로 인코딩된 RSA 키 또는 DER로 인코딩된 ECC 키)으로 변환해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-520">To use a digital certificate in your NetX Secure application, you must first convert your certificate into a binary DER format and, optionally, convert the associated private key (the "private exponent" for RSA, for example) into a binary format, typically a PKCS#1-formatted, DER-encoded RSA key or a DER-encoded ECC key.</span></span> <span data-ttu-id="14b4a-521">변환이 완료되면 디바이스에 인증서 및 프라이빗 키를 로드해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-521">Once the conversion is complete, it is up to you to load the certificate and private key onto the device.</span></span> <span data-ttu-id="14b4a-522">선택 가능한 옵션으로는 플래시 기반 파일 시스템을 사용하거나, 데이터에서 C 배열을 생성하고(Linux의 "xxd" 같은 도구를 사용하여) 인증서와 키를 애플리케이션에 상수 데이터로 컴파일하는 방법이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-522">Possible options include using a flash-based file system or generating a C array from the data (using a tool such as "xxd" from Linux) and compiling the certificate and key into your application as constant data.</span></span>

<span data-ttu-id="14b4a-523">인증서가 디바이스에 로드되면 TLS API를 사용하여 인증서를 TLS 세션과 연결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-523">Once your certificate is loaded onto the device, the TLS API can be used to associate your certificate with a TLS session.</span></span>

<span data-ttu-id="14b4a-524">NetX Secure TLS에서 X.509 인증서를 사용하는 방법에 대한 자세한 내용과 예제는 "NetX Secure로 X.509 인증서 가져오기" 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="14b4a-524">For details and examples on how to use X.509 certificates with NetX Secure TLS, see the section "Importing X.509 certificates into NetX Secure".</span></span>

<span data-ttu-id="14b4a-525">자세한 내용은 API 참조에서 다음 TLS 서비스를 확인하세요.</span><span class="sxs-lookup"><span data-stu-id="14b4a-525">Refer to the following TLS services in the API reference for more information:</span></span>

- <span data-ttu-id="14b4a-526">nx_secure_x509_certificate_initialize</span><span class="sxs-lookup"><span data-stu-id="14b4a-526">nx_secure_x509_certificate_initialize</span></span>
- <span data-ttu-id="14b4a-527">nx_secure_tls_local_certificate_add</span><span class="sxs-lookup"><span data-stu-id="14b4a-527">nx_secure_tls_local_certificate_add</span></span>
- <span data-ttu-id="14b4a-528">nx_secure_tls_local_certificate_remove</span><span class="sxs-lookup"><span data-stu-id="14b4a-528">nx_secure_tls_local_certificate_remove</span></span>
- <span data-ttu-id="14b4a-529">nx_secure_tls_remote_certificate_allocate</span><span class="sxs-lookup"><span data-stu-id="14b4a-529">nx_secure_tls_remote_certificate_allocate</span></span>
- <span data-ttu-id="14b4a-530">nx_secure_tls_trusted_certificate_add</span><span class="sxs-lookup"><span data-stu-id="14b4a-530">nx_secure_tls_trusted_certificate_add</span></span>
- <span data-ttu-id="14b4a-531">nx_secure_trusted_certificate_remove</span><span class="sxs-lookup"><span data-stu-id="14b4a-531">nx_secure_trusted_certificate_remove</span></span>

### <a name="tls-client-certificate-specifics"></a><span data-ttu-id="14b4a-532">TLS 클라이언트 인증서 세부 정보</span><span class="sxs-lookup"><span data-stu-id="14b4a-532">TLS Client Certificate Specifics</span></span>

<span data-ttu-id="14b4a-533">일반적으로 TLS 클라이언트를 구현할 때 "로컬" 인증서<sup>14</sup>를 디바이스에 로드하지 않아도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-533">TLS Client implementations generally do not require a "local" certificate<sup>14</sup> to be loaded onto the device.</span></span> <span data-ttu-id="14b4a-534">클라이언트 인증서 인증을 사용하도록 설정된 경우에는 예외지만, 전혀 일반적인 상황은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-534">The exception to this is when Client Certificate Authentication is enabled, but this is far less common.</span></span>

<span data-ttu-id="14b4a-535">TLS 클라이언트를 사용하려면 "신뢰할 수 있는" 인증서<sup>15</sup>를 하나 이상 로드해야 하며(필요한 경우 더 많이 로드할 수 있음) "원격" 인증서<sup>16</sup>를 할당할 공간이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-535">A TLS Client requires at least one "trusted" certificate<sup>15</sup> to be loaded (more may be loaded if required), and space for a "remote" certificate<sup>16</sup> to be allocated.</span></span>

<span data-ttu-id="14b4a-536">신뢰할 수 있는 인증서를 추가하고 원격 인증서의 공간을 할당하는 방법에 대한 자세한 내용은 nx_secure_tls_remote_certificate_allocate, nx_secure_tls_trusted_certificate_add 서비스의 TLS API 참조를 확인하세요.</span><span class="sxs-lookup"><span data-stu-id="14b4a-536">For more information on adding trusted certificates and allocating space for remote certificates, see the TLS API reference for the following services: nx_secure_tls_remote_certificate_allocate, nx_secure_tls_trusted_certificate_add.</span></span>

14. <span data-ttu-id="14b4a-537">"로컬" 인증서는 로컬 디바이스를 식별하는 인증서입니다. 즉, TLS 애플리케이션이 로드되는 디바이스에 대한 ID 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-537">A “local” certificate is a certificate that identifies the local device – that is, it provides identity information for the device upon which the TLS application is loaded.</span></span>

15. <span data-ttu-id="14b4a-538">"신뢰할 수 있는" 인증서는 직접 또는 PKI(공개 키 인프라)를 통해 원격 디바이스의 신뢰와 인증을 위한 기반을 제공하는 인증서입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-538">A “trusted” certificate is a certificate that provides a basis for trust and authentication of the remote device, either directly or through a Public Key Infrastructure (PKI).</span></span> <span data-ttu-id="14b4a-539">신뢰 체인의 루트를 일반적으로 “인증 기관” 또는 CA 인증서라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-539">The root of the chain of trust is usually called a “Certification Authority” or CA certificate.</span></span>

16. <span data-ttu-id="14b4a-540">"원격" 인증서는 TLS 핸드셰이크 중에 원격 호스트가 보낸 인증서를 말합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-540">A “remote” certificate refers to the certificate sent by the remote host during the TLS handshake.</span></span> <span data-ttu-id="14b4a-541">해당 원격 호스트의 ID를 제공하며, 로컬 디바이스의 "신뢰할 수 있는" 인증서와 비교하여 인증됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-541">It provides identity for that remote host and is authenticated by comparing it to a “trusted” certificate on the local device.</span></span>

### <a name="tls-server-certificate-specifics"></a><span data-ttu-id="14b4a-542">TLS 서버 인증서 세부 정보</span><span class="sxs-lookup"><span data-stu-id="14b4a-542">TLS Server Certificate Specifics</span></span>

<span data-ttu-id="14b4a-543">일반적으로 TLS 서버를 구현할 때 "신뢰할 수 있는" 인증서를 디바이스에 로드하거나 원격 인증서를 할당할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-543">TLS Server implementations generally do not require "trusted" certificates to be loaded onto the device or remote certificates to be allocated.</span></span> <span data-ttu-id="14b4a-544">클라이언트 인증서 인증을 사용하도록 설정된 경우에는 예외입니다(일반적이지 않음).</span><span class="sxs-lookup"><span data-stu-id="14b4a-544">The exception to this being when Client Certificate Authentication is enabled (this is less common).</span></span>

<span data-ttu-id="14b4a-545">TLS 서버의 경우 TLS 핸드셰이크 중에 원격 클라이언트에 인증서를 제공하여 서버를 클라이언트에 인증할 수 있도록 "로컬"(또는 "ID") 인증서를 로드해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-545">A TLS Server requires a "local" certificate to be loaded so the server can provide it to the remote client during the TLS handshake to authenticate the server to the client.</span></span>

<span data-ttu-id="14b4a-546">NetX TLS 서버 애플리케이션에 사용할 로컬 인증서를 로드하는 방법에 대한 자세한 내용은 API 참조에서 다음 서비스를 확인하세요.</span><span class="sxs-lookup"><span data-stu-id="14b4a-546">For more information about loading local certificates for use with NetX TLS server applications, see the API reference for the following services:</span></span> 
- <span data-ttu-id="14b4a-547">nx_secure_tls_local_certificate_add,</span><span class="sxs-lookup"><span data-stu-id="14b4a-547">nx_secure_tls_local_certificate_add,</span></span> 
- <span data-ttu-id="14b4a-548">nx_secure_tls_local_certificate_remove.</span><span class="sxs-lookup"><span data-stu-id="14b4a-548">nx_secure_tls_local_certificate_remove.</span></span>

### <a name="pre-shared-keys-psk"></a><span data-ttu-id="14b4a-549">PSK(미리 공유한 키)</span><span class="sxs-lookup"><span data-stu-id="14b4a-549">Pre-Shared Keys (PSK)</span></span>

<span data-ttu-id="14b4a-550">TLS에서 식별 인증을 제공하는 또 다른 메커니즘은 PSK(미리 공유한 키)라는 개념입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-550">An alternative mechanism for providing identification authentication in TLS is the notion of Pre-Shared Keys (PSK).</span></span> <span data-ttu-id="14b4a-551">PSK ciphersuite를 사용하면 프로세서 사용량이 많은 공개 키 암호화 작업을 수행할 필요가 없으므로 리소스가 제한적인 임베디드 디바이스에 요긴합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-551">Using a PSK ciphersuite removes the need to do the processor-intensive public-key encryption operations, a boon for resource-constrained embedded devices.</span></span> <span data-ttu-id="14b4a-552">PSK는 TLS 핸드셰이크의 인증서를 대체하며 TLS 세션 키 생성을 위해 암호화된 Pre-Master Secret 대신 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-552">The PSK replaces the certificate in the TLS handshake and is used in place of the encrypted Pre-Master Secret for TLS session key generation.</span></span>

<span data-ttu-id="14b4a-553">PSK ciphersuite는 TLS 세션을 설정하려면 두 디바이스 모두에 공유 비밀이 있어야 한다는 점에서 제한적입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-553">The PSK ciphersuites are limited in the sense that that a shared secret must be present on both devices before a TLS session can be established.</span></span> <span data-ttu-id="14b4a-554">즉, TLS PSK 연결이 아닌 다른 안전한 방법으로 해당 비밀을 디바이스에 로드해야 합니다. PSK는 TLS PSK 연결을 통해 업데이트할 수 있지만, 디바이스는 반드시 다른 메커니즘을 통해 로드된 PSK를 사용하여 시작해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-554">This means that the devices must have been loaded with that secret using some secure means other than a TLS PSK connection - PSKs may be updated over a TLS PSK connection, but the device must necessarily start with a PSK that is loaded through some other mechanism.</span></span> <span data-ttu-id="14b4a-555">예를 들어 출하 전에 공장에서 PSK를 사용하여 센서 디바이스와 게이트웨이 디바이스를 로드하거나, 표준 TLS 연결(인증서 포함)을 사용하여 PSK를 로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-555">For example, a sensor device and its gateway device could be loaded with PSKs in the factory before shipping, or a standard TLS connection (with a certificate) could be used to load the PSK.</span></span>

<span data-ttu-id="14b4a-556">PSK ciphersuite는 RFC 4279에 설명된 두 가지 형태로 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-556">PSK ciphersuites come in a couple of forms, described in RFC 4279.</span></span> <span data-ttu-id="14b4a-557">첫 번째 형식은 표준 TLS 핸드셰이크의 인증서에 포함되어 전송된 공개 키와 동일한 방식으로 사용되는 RSA 또는 Diffie-Hellman 키를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-557">The first uses RSA or Diffie-Hellman keys which are used in the same manner as the public keys transmitted in the certificate in standard TLS handshakes.</span></span> <span data-ttu-id="14b4a-558">리소스가 제한적인 환경에서 더 많이 사용되는 두 번째 형식은 세션 키(예를 들어, AES에서 사용할)를 직접 생성하는 데 사용되는 PSK를 사용하며, 비용이 많이 드는 RSA 또는 Diffie-Hellman 작업의 사용을 방지합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-558">The second form, which is of more use in a resource-constrained environment, uses a PSK that is used to directly generate the session keys (for use by AES, for example), avoiding the use of the expensive RSA or Diffie-Hellman operations.</span></span>

<span data-ttu-id="14b4a-559">NetX Secure는 애플리케이션에서 모든 공개 키 암호화 코드 및 메모리를 사용하지 않도록 두 번째 형태의 PSK ciphersuite를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-559">NetX Secure supports the second form of PSK ciphersuites, enabling applications to remove all public-key cryptography code and memory usage.</span></span> <span data-ttu-id="14b4a-560">PSK 자체는 AES 키가 아니지만 실제 키가 생성되는 암호와 비슷한 것으로 간주할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-560">The PSK itself is not an AES key, but can be considered as being more like a password from which the actual keys are generated.</span></span> <span data-ttu-id="14b4a-561">PSK 값에는 몇 가지 제한 사항이 있지만, 암호와 마찬가지로 값이 길수록 강력한 보안을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-561">There are few restrictions on what the PSK value can be, though longer values will provide more security (same as with passwords).</span></span>

<span data-ttu-id="14b4a-562">NetX Secure 애플리케이션에서 PSK를 사용하려면 먼저 글로벌 매크로 **NX_SECURE_ENABLE_PSK_CIPHERSUITES** 를 정의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-562">To use PSK with your NetX Secure application, you must first define the global macro **NX_SECURE_ENABLE_PSK_CIPHERSUITES**.</span></span> <span data-ttu-id="14b4a-563">이 작업은 일반적으로 컴파일러 설정을 통해 수행되지만 nx_secure_tls.h 헤더 파일에 정의를 배치할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-563">This is usually done through your compiler settings, but the definition can also be placed in the nx_secure_tls.h header file.</span></span> <span data-ttu-id="14b4a-564">매크로가 정의되면 PSK ciphersuite 지원이 NetX Secure TLS 애플리케이션으로 컴파일됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-564">With the macro defined, PSK ciphersuite support will be compiled into your NetX Secure TLS application.</span></span>

<span data-ttu-id="14b4a-565">PSK 지원을 사용하도록 설정한 후에는 TLS API를 사용하여 애플리케이션에 대한 PSK를 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-565">With PSK support enabled, you can then use the TLS API to set up PSKs for your application.</span></span> <span data-ttu-id="14b4a-566">각 PSK에는 PSK 값(실제 비밀 "키" – 안전하게 보관해야 함), 특정 PSK를 식별하는 데 사용되는 "ID" 값, 그리고 TLS 서버에서 특정 PSK 값을 선택하는 데 사용하는 "ID 힌트"가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-566">Each PSK will require a PSK value (the actual secret "key" – keep this value safe), an "identity" value used to identify the specific PSK, and an "identity hint" that is used by a TLS server to choose a particular PSK value.</span></span>

<span data-ttu-id="14b4a-567">PSK 자체는 네트워크 연결을 통해 전송되지 않으므로 임의의 이진 값일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-567">The PSK itself can be any binary value as it is never sent over a network connection.</span></span> <span data-ttu-id="14b4a-568">PSK의 최대 길이는 64바이트입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-568">The PSK can be any value up to 64 bytes in length.</span></span>

<span data-ttu-id="14b4a-569">ID 및 힌트는 UTF-8을 사용하여 형식이 지정된 인쇄 가능한 문자열이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-569">The identity and hint must be printable character strings formatted using UTF-8.</span></span> <span data-ttu-id="14b4a-570">ID 및 힌트 값의 최대 길이는 128바이트입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-570">The identity and hint values may be any length up to 128 bytes.</span></span>

<span data-ttu-id="14b4a-571">ID 및 PSK는 서로 통신해야 하는 네트워크 상의 모든 디바이스에 로드되는 고유한 쌍을 형성합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-571">The identity and PSK form a unique pair that is loaded onto every device in the network that need to communicate with one another.</span></span>

<span data-ttu-id="14b4a-572">"힌트"는 PSK를 함수 또는 서비스별로 그룹화하는 애플리케이션 프로필을 정의하는 데 주로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-572">The "hint" is primarily used for defining specific application profiles to group PSKs by function or service.</span></span> <span data-ttu-id="14b4a-573">이러한 값은 미리 합의해야 하며 애플리케이션에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-573">These values must be agreed upon in advance and are application dependent.</span></span> <span data-ttu-id="14b4a-574">예를 들어 PSK를 사용하도록 설정된 OpenSSL 명령줄 서버 애플리케이션은 TLS 핸드셰이크를 계속하려면 TLS 클라이언트에서 제공해야 하는 기본 문자열인 "Client_identity"를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-574">As an example, the OpenSSL command-line server application (with PSK enabled) uses the default string "Client_identity", which must be provided by a TLS client in order to continue with the TLS handshake.</span></span>

<span data-ttu-id="14b4a-575">PSK에 대한 자세한 내용은 nx_secure_tls_client_psk_set, nx_secure_tls_psk_add 서비스에 대한 NetX Secure API 참조를 확인하세요.</span><span class="sxs-lookup"><span data-stu-id="14b4a-575">For more information on PSKs, see the NetX Secure API reference for the following services: nx_secure_tls_client_psk_set, nx_secure_tls_psk_add.</span></span>

## <a name="importing-x509-certificates-into-netx-secure"></a><span data-ttu-id="14b4a-576">NetX Secure로 X.509 인증서 가져오기</span><span class="sxs-lookup"><span data-stu-id="14b4a-576">Importing X.509 certificates into NetX Secure</span></span>

<span data-ttu-id="14b4a-577">디지털 인증서는 인터넷에서 이루어지는 대부분의 TLS 연결에 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-577">Digital certificates are required for most TLS connections on the Internet.</span></span> <span data-ttu-id="14b4a-578">인증서는 일반적으로 *CA(인증 기관)* 라고 하는 신뢰할 수 있는 중개자를 사용하여 인터넷을 통해 이전에는 알 수 없었던 호스트를 인증하는 방법을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-578">Certificates provide a method for authenticating previously unknown hosts over the Internet through the use of trusted intermediaries, usually called *Certificate Authorities* or CAs.</span></span> <span data-ttu-id="14b4a-579">NetX Secure 디바이스를 상용 클라우드 서비스(예: Amazon Web Services)와 연결하려면 인증서를 디바이스에 로드하여 인증서를 애플리케이션으로 가져와야 합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-579">To connect your NetX Secure device with a commercial cloud service (such as Amazon Web Services), you will need to import certificates into your application by loading them onto your device.</span></span>

<span data-ttu-id="14b4a-580">인증서와 함께 인증서와 연결된 *프라이빗 키* 가 필요할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-580">Along with certificates, you will also sometimes need a *private key* that is associated with your certificate.</span></span> <span data-ttu-id="14b4a-581">일부 애플리케이션(예: 클라이언트 인증서 인증을 사용하지 않는 경우 TLS 클라이언트)에서는 인증서 하나로 충분하지만, 인증서를 사용하여 디바이스를 식별하는 경우에는 프라이빗 키가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-581">In some applications (such as TLS Client when Client Certificate Authentication is not being used) the certificate alone will be sufficient, but if your certificate is being used to identify your device you will need a private key.</span></span> <span data-ttu-id="14b4a-582">프라이빗 키는 일반적으로 인증서를 만들 때 생성되고 별도의 파일에 저장되며, 이러한 파일은 종종 암호로 암호화됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-582">Private keys are typically generated when you create your certificate and are stored in a separate file, often encrypted with a password.</span></span>

### <a name="certificate-types"></a><span data-ttu-id="14b4a-583">인증서 종류</span><span class="sxs-lookup"><span data-stu-id="14b4a-583">Certificate Types</span></span>

<span data-ttu-id="14b4a-584">디지털 인증서는 일반적으로 네트워크의 엔터티를 식별하는 데 사용되지만 애플리케이션에 따라 약간 다른 속성을 갖습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-584">Digital certificates are generally used to identify entities on a network, but depending on what their application they will have slightly different properties.</span></span>

### <a name="local-certificates"></a><span data-ttu-id="14b4a-585">로컬 인증서</span><span class="sxs-lookup"><span data-stu-id="14b4a-585">Local Certificates</span></span>

<span data-ttu-id="14b4a-586">이 문서에서는 "로컬 인증서"를 로컬 디바이스에 대한 ID를 제공하는 인증서라고 합니다(다른 가능한 이름은 "디바이스 인증서"일 수 있음).</span><span class="sxs-lookup"><span data-stu-id="14b4a-586">For the purposes of this documentation, we will refer to "local certificates" as those certificates which provide an identity for our local device (another possible name could be "device certificate").</span></span> <span data-ttu-id="14b4a-587">이러한 인증서는 원격 호스트가 로컬 디바이스를 인증하려고 할 때 원격 호스트에 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-587">These certificates will be provided to a remote host when the remote host desires to authenticate the local device.</span></span>

### <a name="remote-certificates"></a><span data-ttu-id="14b4a-588">원격 인증서</span><span class="sxs-lookup"><span data-stu-id="14b4a-588">Remote Certificates</span></span>

<span data-ttu-id="14b4a-589">이 설명서에서 "원격 인증서"는 해당하는 경우 TLS 핸드셰이크 중 원격 호스트가 제공한 인증서를 말합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-589">In this documentation, "remote certificates" refers to those certificates provided by a remote host during the TLS handshake when applicable.</span></span> <span data-ttu-id="14b4a-590">이러한 인증서를 위한 공간을 할당해야 합니다. 그렇지 않으면 NetX Secure는 인증서를 구문 분석할 수 없고 TLS 핸드셰이크를 완료할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-590">Space for these certificates must be allocated or NetX Secure will not be able to parse them and complete the TLS handshake.</span></span>

### <a name="signing-certificates"></a><span data-ttu-id="14b4a-591">서명 인증서</span><span class="sxs-lookup"><span data-stu-id="14b4a-591">Signing Certificates</span></span>

<span data-ttu-id="14b4a-592">"서명 인증서"는 인증을 위해 다른 인증서 또는 데이터에 디지털 서명하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-592">A "signing certificate" is used to digitally sign other certificates or data for the purpose of authentication.</span></span> <span data-ttu-id="14b4a-593">이러한 인증서는 PKI(공개 키 인프라) 내의 중간 또는 루트 인증서일 수 있으며 일반적으로 개별 디바이스나 호스트를 식별하는 데 사용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-593">These certificates may be either intermediate or root certificates within a Public Key Infrastructure (PKI) and are generally not used to identify individual devices or hosts.</span></span>

### <a name="root-ca-certificates"></a><span data-ttu-id="14b4a-594">루트 CA 인증서</span><span class="sxs-lookup"><span data-stu-id="14b4a-594">Root CA Certificates</span></span>

<span data-ttu-id="14b4a-595">"루트 CA 인증서"는 PKI의 기반을 제공하고 다른 서명 인증서로 서명되지 않고 자체 서명된 서명 인증서입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-595">"Root CA certificates" are signing certificates that provide the basis of a PKI and are self-signed, rather than being signed by another signing certificate.</span></span> <span data-ttu-id="14b4a-596">TLS 클라이언트가 원격 서버를 확인하려면 일반적으로 하나 이상의 루트 CA 인증서가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-596">At least one Root CA certificate is typically required for a TLS Client to verify remote servers.</span></span>

### <a name="certificate-formats"></a><span data-ttu-id="14b4a-597">인증서 형식</span><span class="sxs-lookup"><span data-stu-id="14b4a-597">Certificate formats</span></span>

<span data-ttu-id="14b4a-598">디지털 인증서는 ASN.1 구문을 사용하여 인코딩된 정형 데이터를 포함하는 간단한 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-598">Digital certificates are simply files containing structured data encoded using the ASN.1 syntax.</span></span> <span data-ttu-id="14b4a-599">하지만, 인증서를 저장할 수 있는 다양한 형식이 있으며 NetX Secure 애플리케이션에 인증서를 로드하기 전에 올바른 형식을 갖는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-599">However, there are various formats in which certificates may be stored and it is important to have the right format before loading a certificate into a NetX Secure application.</span></span>

<span data-ttu-id="14b4a-600">인증서에 가장 일반적인 형식은 DER 및 PEM입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-600">The most common formats for certificates are DER and PEM.</span></span> <span data-ttu-id="14b4a-601">DER(*Distinguished Encoding Rules* 의 경우 ASN.1 형식)은 초기 핸드셰이크를 수행할 때 TLS에서 사용하는 이진 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-601">DER (for *Distinguished Encoding Rules*, an ASN.1 format) is the binary format used by TLS when performing the initial handshake.</span></span> <span data-ttu-id="14b4a-602">PEM(*Privacy Enhanced Mail*)은 웹에서 HTTP를 통해 보내거나 이메일을 보내는 데 적합한 DER 형식의 Base-64 인코딩 버전입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-602">PEM (from *Privacy Enhanced Mail*) is a base-64 encoded version of the DER format which is suitable for emailing or sending over HTTP on the web.</span></span> <span data-ttu-id="14b4a-603">공급 업체마다 인증서에 대해 다른 파일 이름 확장명을 사용합니다. PEM 인증서의 경우 ".pem" 또는 ".crt", DER 인증서의 경우 ".der"입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-603">Different vendors use different filename extensions for certificates, such as ".pem" or ".crt" for PEM certificates, and ".der" for DER certificates.</span></span> <span data-ttu-id="14b4a-604">인증서가 있고 사용되는 형식이 명확하지 않은 경우에는 텍스트 편집기에서 파일을 열면 유형을 확인할 수 있습니다. DER 파일은 인코딩된 이진 파일이고 PEM 파일은 "----- BEGIN CERTIFICATE -----" 헤더로 시작하는 일반 ASCII 텍스트이기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-604">If you have a certificate and it is not clear what format is used, opening the file in a text editor will allow you to determine the type since DER files are encoded  binary, and PEM files are regular ASCII text that start with the header "-----BEGIN CERTIFICATE-----".</span></span>

<span data-ttu-id="14b4a-605">NetX Secure에서는 인증서가 이진 DER 형식이어야 하므로 인증서를 가져오기 전에 DER 형식으로 변환해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-605">NetX Secure requires that your certificate be in binary DER format, so you will need to convert your certificate into DER format before importing.</span></span> <span data-ttu-id="14b4a-606">이 작업은 OpenSSL과 같이 쉽게 사용할 수 있는 도구로 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-606">This can be done with readily available tools such as OpenSSL.</span></span>

<span data-ttu-id="14b4a-607">애플리케이션에 프라이빗 키가 필요한 경우 키 파일은 특정 형식(RSA의 경우 PKCS # 1, ECC의 경우 RFC 5915)의 PEM 또는 DER을 사용하여 인코딩됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-607">If you need a private key for your application, the key file will be encoded using PEM or DER in a specific format (PKCS#1 for RSA, RFC 5915 for ECC).</span></span> <span data-ttu-id="14b4a-608">프라이빗 키 파일은 가져오기 전에 DER로 변환해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-608">The private key file will need to be converted into DER before being imported.</span></span>

<span data-ttu-id="14b4a-609">다음 OpenSSL 명령은 인증서 및 RSA 키 파일을 NetX Secure에 필요한 DER 형식으로 변환하는 예입니다(ECC는 유사함 - OpenSSL 설명서 참조).</span><span class="sxs-lookup"><span data-stu-id="14b4a-609">The following OpenSSL commands are given as an example for converting certificates and RSA key files into the DER format required by NetX Secure (ECC is similar – refer to the OpenSSL documentation).</span></span>

```C
openssl x509 -inform PEM -in <certificate> -outform DER -out cert.der
openssl x509 -inform PEM -in <root CA cert> -outform DER -out CA_cert.der
openssl rsa -inform PEM -in <private key> -outform DER -out private.key
```
### <a name="private-keys-and-certificates"></a><span data-ttu-id="14b4a-610">프라이빗 키 및 인증서</span><span class="sxs-lookup"><span data-stu-id="14b4a-610">Private Keys and Certificates</span></span>

<span data-ttu-id="14b4a-611">디바이스를 식별하는 인증서의 경우, 연결된 프라이빗 키는 인증서와 함께 로드되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-611">For certificates that identify a device, the associated private key must be loaded along with the certificate.</span></span> <span data-ttu-id="14b4a-612">프라이빗 키(RSA, Diffie-Hellman 또는 Elliptic-Curve Cryptography와 같은 공개 키 알고리즘 중 하나일 수 있음)는 TLS 서버가 TLS 클라이언트에서 들어오는 키 자료("pre-master secret")를 해독하는 데 사용되어 클라이언트에 대해 자신을 인증합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-612">The private key (which may be for one of the public-key algorithms such as RSA, Diffie-Hellman, or Elliptic-Curve Cryptography) is used by a TLS server to decrypt the incoming key material (the "pre-master secret") from a TLS client, thereby authenticating itself to the client.</span></span> <span data-ttu-id="14b4a-613">TLS 클라이언트의 경우 ID 인증서(연결된 프라이빗 키가 있는 인증서)가 제공되고 서버가 클라이언트 인증서를 요청하면 프라이빗 키가 클라이언트를 인증하는 데 사용됩니다. RSA의 경우 클라이언트는 프라이빗 키를 사용하여 토큰을 암호화한 다음, 서버가 클라이언트 인증서에 제공된 클라이언트의 공개 키를 사용하여 해독합니다.(Diffie-Hellman 및 ECC 인증은 비슷한 방식으로 발생하지만 세부 사항은 약간 다릅니다.)</span><span class="sxs-lookup"><span data-stu-id="14b4a-613">For a TLS Client, if an identity certificate (a certificate with its associated private key) is provided and a server requests a client certificate, the private key is used to authenticate the client – in the case of RSA the client  encrypts a token using the private key which the server then decrypts using the client's public key, provided in the client certificate (Diffie-Hellman and ECC authentication happens in a similar fashion but the details are a bit different).</span></span>

<span data-ttu-id="14b4a-614">NetX Secure 에서 *nx_secure_x509_certificate_initialize* 서비스는 X.509 인증서를 초기화하고(자세한 내용은 "디바이스에 인증서 로드" 섹션 참조) 선택적으로 이 인증서와 프라이빗 키를 연결하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-614">In NetX secure, the service *nx_secure_x509_certificate_initialize* is used to initialize an X.509 certificate (see section "Loading certificates onto your device" for more information) and optionally associate a private key with that certificate.</span></span>

<span data-ttu-id="14b4a-615">프라이빗 키가 제공되면 인증서는 디바이스를 식별하는 데 사용되는 "ID" 인증서로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-615">If a private key is supplied, the certificate is marked as being the "identity" certificate used to identify the device.</span></span> <span data-ttu-id="14b4a-616">키는 연속 이진 Blob 및 길이로 전달되며 연결된 키 형식이 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-616">The key is passed as a contiguous binary blob and a length, with an associated key type.</span></span> <span data-ttu-id="14b4a-617">키 유형은 키의 유형(예: RSA, ECC 등) 및 형식(예: PKCS#1 DER)에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-617">The key type depends on the type of key (e.g. RSA, ECC, etc.) and the format (e.g. PKCS#1 DER).</span></span> <span data-ttu-id="14b4a-618">키가 제공되지 않으면 NX_SECURE_X509_KEY_TYPE_NONE(값 0x0) 값을 전달하여 키가 제공되지 않은 것을 나타낼 수 있습니다.(길이 0 및 데이터 매개 변수에 대한 NX_NULL 포인터는 동일한 효과를 냅니다.)</span><span class="sxs-lookup"><span data-stu-id="14b4a-618">If no key is supplied, the value NX_SECURE_X509_KEY_TYPE_NONE (value 0x0) can be passed to indicate no key is being supplied (a length of 0 and a NX_NULL pointer for the data parameter will achieve the same effect).</span></span>

<span data-ttu-id="14b4a-619">다음 표는 NetX Secure에 알려진 키 유형과 *nx_secure_x509_certificate_initialize* 에 전달될 연결된 유형 식별자를 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-619">The following table shows the key types known to NetX Secure and the associated type identifier to be passed into *nx_secure_x509_certificate_initialize*.</span></span> <span data-ttu-id="14b4a-620">NetX Secure에 암호화 알고리즘이 더 많이 추가되면 키 유형이 더 추가될 예정입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-620">Additional key types will be added as more encryption algorithms are added to NetX Secure.</span></span>

| <span data-ttu-id="14b4a-621">ID</span><span class="sxs-lookup"><span data-stu-id="14b4a-621">Identifier</span></span>                              | <span data-ttu-id="14b4a-622">알고리즘</span><span class="sxs-lookup"><span data-stu-id="14b4a-622">Algorithm</span></span> | <span data-ttu-id="14b4a-623">서식</span><span class="sxs-lookup"><span data-stu-id="14b4a-623">Format</span></span>   | <span data-ttu-id="14b4a-624">Encoding</span><span class="sxs-lookup"><span data-stu-id="14b4a-624">Encoding</span></span> | <span data-ttu-id="14b4a-625">값</span><span class="sxs-lookup"><span data-stu-id="14b4a-625">Value</span></span> |
| --------------------------------------- | --------- | -------- | -------- | ----- |
| <span data-ttu-id="14b4a-626">NX_SECURE_X509_KEY_TYPE_NONE</span><span class="sxs-lookup"><span data-stu-id="14b4a-626">NX_SECURE_X509_KEY_TYPE_NONE</span></span>            | <span data-ttu-id="14b4a-627">None</span><span class="sxs-lookup"><span data-stu-id="14b4a-627">None</span></span>      | <span data-ttu-id="14b4a-628">N/A</span><span class="sxs-lookup"><span data-stu-id="14b4a-628">N/A</span></span>      | <span data-ttu-id="14b4a-629">N/A</span><span class="sxs-lookup"><span data-stu-id="14b4a-629">N/A</span></span>      | <span data-ttu-id="14b4a-630">0x0</span><span class="sxs-lookup"><span data-stu-id="14b4a-630">0x0</span></span>   |
| <span data-ttu-id="14b4a-631">NX_SECURE_X509_KEY_TYPE_RSA_PKCS1_DER</span><span class="sxs-lookup"><span data-stu-id="14b4a-631">NX_SECURE_X509_KEY_TYPE_RSA_PKCS1_DER</span></span>   | <span data-ttu-id="14b4a-632">RSA</span><span class="sxs-lookup"><span data-stu-id="14b4a-632">RSA</span></span>       | <span data-ttu-id="14b4a-633">PKCS#1</span><span class="sxs-lookup"><span data-stu-id="14b4a-633">PKCS#1</span></span>   | <span data-ttu-id="14b4a-634">DER</span><span class="sxs-lookup"><span data-stu-id="14b4a-634">DER</span></span>      | <span data-ttu-id="14b4a-635">0x1</span><span class="sxs-lookup"><span data-stu-id="14b4a-635">0x1</span></span>   |
| <span data-ttu-id="14b4a-636">NX_SECURE_X509_KEY_TYPE_EC_DER</span><span class="sxs-lookup"><span data-stu-id="14b4a-636">NX_SECURE_X509_KEY_TYPE_EC_DER</span></span>          | <span data-ttu-id="14b4a-637">ECDSA</span><span class="sxs-lookup"><span data-stu-id="14b4a-637">ECDSA</span></span>     | <span data-ttu-id="14b4a-638">RFC 5915</span><span class="sxs-lookup"><span data-stu-id="14b4a-638">RFC 5915</span></span> | <span data-ttu-id="14b4a-639">DER</span><span class="sxs-lookup"><span data-stu-id="14b4a-639">DER</span></span>      | <span data-ttu-id="14b4a-640">0x2</span><span class="sxs-lookup"><span data-stu-id="14b4a-640">0x2</span></span>   |

### <a name="user-defined-private-key-types"></a><span data-ttu-id="14b4a-641">사용자 정의 프라이빗 키 유형</span><span class="sxs-lookup"><span data-stu-id="14b4a-641">User-defined private key types</span></span>

<span data-ttu-id="14b4a-642">*nx_secure_x509_certificate_initialize* 서비스의 키 유형 식별자 값은 프라이빗 키가 제공될 때 수행되는 작업을 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-642">The values of the key type identifiers for the *nx_secure_x509_certificate_initialize* service govern the actions taken when the private key is supplied.</span></span> <span data-ttu-id="14b4a-643">알려진 유형의 경우 값은 0x0000 0000 – 0x0000 FFFF(부호 없는 32비트 정수의 맨 아래 16비트) 범위에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-643">For known types, the values are in the range 0x0000 0000 – 0x0000 FFFF (bottom 16 bits of a 32-bit unsigned integer).</span></span> <span data-ttu-id="14b4a-644">사용자 지정 키 유형<sup>17</sup>인(일부 하드웨어 기반 암호화 엔진의 경우와 마찬가지로) 플랫폼의 경우 0x0000 1000-0xFFFF FFFF(상위 16비트 0이 아님) 범위의 사용자 정의 키 유형이 키 유형으로 전달될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-644">For platforms with custom key types<sup>17</sup> (as is the case for some hardware-based encryption engines), a user-defined key type in the range 0x0000 1000-0xFFFF FFFF (top 16 bits non-zero) may be passed as the key type.</span></span> <span data-ttu-id="14b4a-645">키 유형의 상위 16비트 중 하나가 설정되면 프라이빗 키 데이터는 TLS ciphersuite 테이블에 제공된 적절한 암호화 루틴(예: RSA)으로 직접 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-645">If any of the top 16 bits of the key type are set, then the private key data is passed directly to the appropriate cryptographic routine (e.g. RSA) supplied in the TLS ciphersuite table.</span></span> <span data-ttu-id="14b4a-646">사용자 정의 키 유형은 암호화 루틴으로 전달되기 전에 구문 분석되거나 달리 처리되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-646">User-defined key types are not parsed or otherwise processed before being passed to the cryptographic routine.</span></span> <span data-ttu-id="14b4a-647">또한 사용자 정의 키 유형도 해당 수준에서 적절한 처리가 가능하도록 암호화 루틴으로 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-647">In addition, the user-defined key type will also be passed to the cryptographic routine so that any appropriate processing can be handled at that level.</span></span>

<span data-ttu-id="14b4a-648">사용자 정의 키 유형은 일반적으로 사용자 지정(암호화되었을 수 있음) 키 데이터를 활용하는 특정 하드웨어 플랫폼에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-648">Note that user-defined key types are generally used for specific hardware platforms that utilize custom (possibly encrypted) key data.</span></span> <span data-ttu-id="14b4a-649">일반적으로 이것은 하드웨어 공급업체에 해당하는 특정 메커니즘(또는 PKCS#11과 같은 표준의 경우 특정 표준)을 사용하여 키 데이터가 생성되거나 인코딩된다는 의미입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-649">Generally this implies that the key data is generated or encoded using a mechanism specific to that hardware vendor (or in the case of a standard like PKCS#11, a specific standard).</span></span> <span data-ttu-id="14b4a-650">자세한 내용은 하드웨어 플랫폼 설명서를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="14b4a-650">Consult your hardware platform documentation for more information.</span></span>

17. <span data-ttu-id="14b4a-651">사용자 정의 키 유형에는 사용자 지정 키 형식을 처리하기 위한 해당 사용자 지정 암호화 루틴이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-651">User-defined key types require a corresponding custom cryptographic routine to handle the custom key format.</span></span> <span data-ttu-id="14b4a-652">암호화 루틴에는 일치하는 알고리즘(예: RSA)이 있어야 하며 ciphersuite 테이블의 TLS로 전달되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-652">The cryptographic routine must have a matching algorithm (e.g. RSA) and be passed into TLS in the ciphersuite table.</span></span> 

### <a name="loading-certificates-onto-your-device"></a><span data-ttu-id="14b4a-653">디바이스에 인증서 로드</span><span class="sxs-lookup"><span data-stu-id="14b4a-653">Loading certificates onto your device</span></span>

<span data-ttu-id="14b4a-654">디바이스에 파일을 로드하는 방법이면 인증서를 가져오는 데 충분합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-654">Any method for loading a file onto your device will be sufficient to import your certificates.</span></span>

<span data-ttu-id="14b4a-655">인증서를 로드하는 가장 간단한 방법은 이진 DER로 인코딩된 데이터를 C 배열로 변환하고 이것을 애플리케이션에 상수로 컴파일하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-655">The simplest method for loading a certificate is to convert the binary DER-encoded data into a C array and compile it into your application as a constant.</span></span> <span data-ttu-id="14b4a-656">Linux에서 "xxd"와 같은 도구를 사용하면("-i" 옵션 사용) 쉽게 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-656">This can be easily done with tools such as "xxd" in Linux (with the "-i" option).</span></span>

<span data-ttu-id="14b4a-657">또는 인증서 데이터에 대한 포인터를 NetX Secure API에 전달할 수 있기만 하면, 인증서를 플래시 파일 시스템이나 기타 스토리지 옵션에 로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-657">Alternatively, you can load your certificate into a flash filesystem or other storage options as long as you can pass a pointer to the certificate data into the NetX Secure API.</span></span>

### <a name="certificate-files-needed-for-netx-secure"></a><span data-ttu-id="14b4a-658">NetX Secure에 필요한 인증서 파일</span><span class="sxs-lookup"><span data-stu-id="14b4a-658">Certificate files needed for NetX Secure</span></span>

<span data-ttu-id="14b4a-659">가져와야 하는 인증서 파일은 애플리케이션에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-659">The certificate files you will need to import depends on your application.</span></span> <span data-ttu-id="14b4a-660">일반적으로 TLS 서버는 디바이스를 식별하는 인증서가 필요하고 TLS 클라이언트는 원격 서버를 인증하기 위한 신뢰할 수 있는 인증서가 하나 이상 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-660">In general, TLS Servers require a certificate to identify the device, and TLS Clients require one or more *Trusted Certificates* to authenticate remote servers.</span></span> <span data-ttu-id="14b4a-661">다음 표에서는 몇 가지 다른 TLS 애플리케이션에 필요한 인증서를 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-661">The following table illustrates certificates needed for some different TLS applications.</span></span>

| <span data-ttu-id="14b4a-662">**TLS 기능/옵션**</span><span class="sxs-lookup"><span data-stu-id="14b4a-662">**TLS functionality/options**</span></span>                     | <span data-ttu-id="14b4a-663">**필요한 인증서/키(최소)**</span><span class="sxs-lookup"><span data-stu-id="14b4a-663">**Certificates/keys needed (minimum)**</span></span>              |
| ------------------------------------------------- | --------------------------------------------------- |
| <span data-ttu-id="14b4a-664">TLS 클라이언트</span><span class="sxs-lookup"><span data-stu-id="14b4a-664">TLS Client</span></span>                                        | <span data-ttu-id="14b4a-665">루트 CA 인증서</span><span class="sxs-lookup"><span data-stu-id="14b4a-665">Root CA certificate</span></span>                                 |
| <span data-ttu-id="14b4a-666">TLS 서버</span><span class="sxs-lookup"><span data-stu-id="14b4a-666">TLS Server</span></span>                                        | <span data-ttu-id="14b4a-667">로컬 인증서, 이 인증서의 프라이빗 키</span><span class="sxs-lookup"><span data-stu-id="14b4a-667">Local certificate, private key for that certificate</span></span> |
| <span data-ttu-id="14b4a-668">클라이언트 인증서 인증을 사용하는 TLS 서버</span><span class="sxs-lookup"><span data-stu-id="14b4a-668">TLS Server with Client Certificate Authentication</span></span> | <span data-ttu-id="14b4a-669">로컬 인증서, 프라이빗 키, 루트 CA</span><span class="sxs-lookup"><span data-stu-id="14b4a-669">Local certificate, private key, Root CA</span></span>             |
| <span data-ttu-id="14b4a-670">클라이언트 인증서 인증을 사용하는 TLS 클라이언트</span><span class="sxs-lookup"><span data-stu-id="14b4a-670">TLS Client with Client Certificate Authentication</span></span> | <span data-ttu-id="14b4a-671">로컬 인증서, 프라이빗 키, 루트 CA</span><span class="sxs-lookup"><span data-stu-id="14b4a-671">Local certificate, private key, Root CA</span></span>             |
| <span data-ttu-id="14b4a-672">미리 공유한 키만 있는 TLS 클라이언트 또는 서버</span><span class="sxs-lookup"><span data-stu-id="14b4a-672">TLS Client or Server with Pre-Shared Keys only</span></span>    | <span data-ttu-id="14b4a-673">없음(인증서 대신 PSK가 사용됨)</span><span class="sxs-lookup"><span data-stu-id="14b4a-673">None (PSK used instead of certificates)</span></span>             |

<span data-ttu-id="14b4a-674">인증서 로드와 관련된 서비스는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-674">The relevant services for loading certificates are as follows:</span></span>

| <span data-ttu-id="14b4a-675">**API 이름**</span><span class="sxs-lookup"><span data-stu-id="14b4a-675">**API Name**</span></span>                                   | <span data-ttu-id="14b4a-676">**용도**</span><span class="sxs-lookup"><span data-stu-id="14b4a-676">**Purpose**</span></span>                                            |
| ---------------------------------------------- |------------------------------------------------------- |
| <span data-ttu-id="14b4a-677">nx_secure_x509_certificate_initialize</span><span class="sxs-lookup"><span data-stu-id="14b4a-677">nx_secure_x509_certificate_initialize</span></span>      | <span data-ttu-id="14b4a-678">NX_SECURE_X509_CERT 구조를 인증서 데이터 및 프라이빗 키로 채우려면 모든 인증서에 대해 호출해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-678">Must be called for all certificates to populate the NX_SECURE_X509_CERT structure with your certificate data and private key.</span></span> |
| <span data-ttu-id="14b4a-679">nx_secure_tls_local_certificate_add</span><span class="sxs-lookup"><span data-stu-id="14b4a-679">nx_secure_tls_local_certificate_add</span></span>       | <span data-ttu-id="14b4a-680">디바이스를 식별하기 위해 TLS 세션에 로컬 인증서를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-680">Add a local certificate to a TLS session to identify your device.</span></span>                                                                |
| <span data-ttu-id="14b4a-681">nx_secure_tls_local_certificate_remove</span><span class="sxs-lookup"><span data-stu-id="14b4a-681">nx_secure_tls_local_certificate_remove</span></span>    | <span data-ttu-id="14b4a-682">TLS 세션에서 로컬 인증서를 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-682">Remove a local certificate from a TLS session.</span></span>                                                                                   |
| <span data-ttu-id="14b4a-683">nx_secure_tls_remote_certificate_allocate</span><span class="sxs-lookup"><span data-stu-id="14b4a-683">nx_secure_tls_remote_certificate_allocate</span></span> | <span data-ttu-id="14b4a-684">원격 인증서를 위한 공간을 할당합니다(초기화되지 않은 NX_SECURE_X509_CERT를 사용하여 호출됨).</span><span class="sxs-lookup"><span data-stu-id="14b4a-684">Allocate space for a remote certificate (called with an uninitialized NX_SECURE_X509_CERT).</span></span>                                   |
| <span data-ttu-id="14b4a-685">nx_secure_tls_trusted_certificate_add</span><span class="sxs-lookup"><span data-stu-id="14b4a-685">nx_secure_tls_trusted_certificate_add</span></span>     | <span data-ttu-id="14b4a-686">인증서를 TLS 세션에 원격 호스트를 인증하는 신뢰할 수 있는 인증서로 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-686">Add a certificate to a TLS Session as a Trusted Certificate for authenticating remote hosts.</span></span>                                     |
| <span data-ttu-id="14b4a-687">nx_secure_tls_trusted_certificate_remove</span><span class="sxs-lookup"><span data-stu-id="14b4a-687">nx_secure_tls_trusted_certificate_remove</span></span>  | <span data-ttu-id="14b4a-688">신뢰할 수 있는 인증서를 TLS 세션에서 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-688">Remove a trusted certificate from a TLS Session.</span></span>                                                                                 |

### <a name="working-with-aws-iot-certificates"></a><span data-ttu-id="14b4a-689">AWS IoT 인증서 작업</span><span class="sxs-lookup"><span data-stu-id="14b4a-689">Working with AWS IoT Certificates</span></span>

<span data-ttu-id="14b4a-690">Amazon Web Services IoT 인터페이스의 사이드바 메뉴에서 "보안"을 선택하고 "인증서"를 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-690">In the Amazon Web Services IoT interface, select "Security" from the sidebar menu and select "Certificates".</span></span> <span data-ttu-id="14b4a-691">새 인증서를 만들고 지침에 따라 새 디바이스 인증서를 다운로드합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-691">Create a new certificate and follow the instructions to download your new device certificate.</span></span>

<span data-ttu-id="14b4a-692">인증서를 다운로드한 후에는 OpenSSL 또는 유사한 유틸리티를 사용하여 DER 형식으로 변환해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-692">Once you have downloaded your certificates, you will need to convert them into DER format using OpenSSL or a similar utility.</span></span>

<span data-ttu-id="14b4a-693">참고: AWS는 공개 키 파일도 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-693">NOTE: AWS will also provide a public key file.</span></span> <span data-ttu-id="14b4a-694">로컬 디바이스 인증서에 공개 키가 포함되어 있으므로 애플리케이션으로 가져올 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-694">The public key is contained within the local device certificate so it does not need to be imported into your application.</span></span>

<span data-ttu-id="14b4a-695">예를 들어 로컬 디바이스 인증서와 해당 프라이빗 키를 NetX Secure에서 사용하기 위해 DER 형식으로 변환하는 명령은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-695">As an example, here are the commands to convert the local device certificate and its private key into DER format for use with NetX Secure:</span></span>

```C
openssl x509 -inform PEM -in <certificate> -outform DER -out cert.der
openssl x509 -inform PEM -in <root CA cert> -outform DER -out CA_cert.der
openssl rsa -inform PEM -in <private key> -outform DER -out private.key
```
<span data-ttu-id="14b4a-696">위의 지침에 따라 변환된 파일을 애플리케이션으로 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-696">The converted files can be imported into your application following the above instructions.</span></span>

## <a name="x509-certificate-validation-in-netx-secure"></a><span data-ttu-id="14b4a-697">NetX Secure에서 X.509 인증서 유효성 검사</span><span class="sxs-lookup"><span data-stu-id="14b4a-697">X.509 Certificate Validation in NetX Secure</span></span> 

<span data-ttu-id="14b4a-698">호스트 식별 및 확인을 위해 X.509 인증서에 TLS를 사용하는 경우 해당 인증서가 실제로 검증되는 방식을 이해하는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-698">When using TLS with X.509 certificates for host identification and verification, it is important to understand how those certificates are actually validated.</span></span> <span data-ttu-id="14b4a-699">TLS 사양은 인증서 유효성 검사 방법에 대한 자세한 지침을 제공하지 않지만 X.509 사양(RFC 5280)을 참조합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-699">While the TLS specification does not provide detailed instructions on how to validate a certificate, it does refer to the X.509 specification (RFC 5280).</span></span> <span data-ttu-id="14b4a-700">일반적으로 TLS는 들어오는 인증서(TLS 핸드셰이크 중 원격 호스트가 제공한 인증서)에 대해 최소한 기본 유효성 검사를 수행해야 하며 NetX Secure TLS도 다르지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-700">In general, it is expected that TLS will perform at least basic validation on incoming certificates (those certificates supplied by the remote host during the TLS handshake), and NetX Secure TLS is no different.</span></span>

### <a name="basic-x509-validation"></a><span data-ttu-id="14b4a-701">기본 X.509 유효성 검사</span><span class="sxs-lookup"><span data-stu-id="14b4a-701">Basic X.509 Validation</span></span>

<span data-ttu-id="14b4a-702">들어오는 인증서에 대해 NetX Secure TLS는 기본 X.509 경로 유효성 검사를 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-702">For any incoming certificate, NetX Secure TLS will perform basic X.509 path validation.</span></span> <span data-ttu-id="14b4a-703">이 프로세스에는 각 인증서의 디지털 서명을 원격 호스트가 제공하거나 신뢰할 수 있는 인증서 저장소에 있는 발급자 인증서와 대조하여 검사하는 작업이 포함됩니다.(신뢰할 수 있는 인증서 가져오기에 대한 자세한 내용은 "NetX Secure로 X.509 인증서 가져오기"를 참조하세요.)</span><span class="sxs-lookup"><span data-stu-id="14b4a-703">The process involves checking each certificate's digital signature against its issuer certificate, which may be provided by the remote host or be located in the trusted certificate store (see the section "Importing X.509 certificates into NetX Secure" for more information on importing trusted certificates).</span></span> <span data-ttu-id="14b4a-704">유효성 검사 프로세스는 신뢰할 수 있는 인증서에 도달하거나 체인이 끝날 때까지(자체 서명된 인증서 또는 누락된 발급자 인증서로) 발급자 인증서에서 재귀적으로 반복됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-704">The validation process is recursively repeated on the issuer certificates until a trusted certificate is reached or the chain ends (with a self-signed certificate or a missing issuer certificate).</span></span> <span data-ttu-id="14b4a-705">신뢰할 수 있는 인증서에 도달하면 인증서가 확인되고 그렇지 않으면 거부됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-705">If a trusted certificate is reached, the certificate is verified, otherwise it is rejected.</span></span> <span data-ttu-id="14b4a-706">또한 확인 프로세스의 각 단계에서 각 인증서의 만료 날짜를 애플리케이션 타임스탬프 함수가 제공한 시간과 대조하여 확인합니다.(자세한 내용은 "nx_secure_tls_session_time_function_set" 서비스를 참조하세요.)</span><span class="sxs-lookup"><span data-stu-id="14b4a-706">Additionally, at each stage in the verification process the expiration date of each certificate is checked against the time provided by the application timestamp function (see the service "nx_secure_tls_session_time_function_set" for more information).</span></span>

<span data-ttu-id="14b4a-707">X.509 사양은 경로 유효성 검사 중에 확인할 수 있는 X.509 확장에 있는 식별자인 "정책"을 지원하는 알고리즘도 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-707">The X.509 specification also provides an algorithm for supporting "policies", which are identifiers that are present in an X.509 extension that can be checked during path validation.</span></span> <span data-ttu-id="14b4a-708">NetX Secure는 현재 X.509 인증서를 "anyPolicy" 옵션이 정의된 것처럼 처리합니다. 즉, 모든 정책이 허용되고 선택적 정책 검사가 수행되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-708">NetX Secure currently treats X.509 certificates as though the "anyPolicy" option is defined – that is, all policies are acceptable and the optional policy checking is not performed.</span></span> <span data-ttu-id="14b4a-709">NetX Secure X.509 구현은 향후 릴리스에서 이 기능으로 보강될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-709">The NetX Secure X.509 implementation may be augmented with this feature in a future release.</span></span> <span data-ttu-id="14b4a-710">현재는 *nx_secure_x509_extension_find* API를 사용하여 인증서에서 정책 확장을 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-710">For now, the policy extension may be obtained from a certificate using the *nx_secure_x509_extension_find* API.</span></span>

<span data-ttu-id="14b4a-711">기본 경로 유효성 검사가 완료되면 TLS는 *nx_secure_tls_session_certificate_callback_set* API를 사용하여 애플리케이션이 제공하는 인증서 확인 콜백을 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-711">Once the basic path validation is complete, TLS will invoke the certificate verification callback supplied by the application using the *nx_secure_tls_session_certificate_callback_set* API.</span></span> <span data-ttu-id="14b4a-712">콜백이 제공되지 않으면 인증서는 성공적인 경로 유효성 검사에 따라 신뢰할 수 있는 것으로 간주됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-712">If no callback is supplied, the certificate is considered to be trusted following successful path validation.</span></span> <span data-ttu-id="14b4a-713">콜백이 제공되면 콜백은 애플리케이션에 필요한 인증서에 대해 추가 유효성 검사를 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-713">If a callback is supplied, the callback will perform any additional validation of the certificate required by the application.</span></span> <span data-ttu-id="14b4a-714">콜백의 반환 값은 TLS 핸드셰이크를 계속할지 아니면 유효성 검사 실패로 인해 핸드셰이크를 중단할지 결정하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-714">The return value from the callback is used to determine whether to continue with the TLS handshake or to abort the handshake due to a validation failure.</span></span>

<span data-ttu-id="14b4a-715">콜백은 관련 TLS 세션에 대한 포인터 및 유효성을 검사할 인증서에 대한 NX_SECURE_X509_CERT 포인터를 사용하여 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-715">The callback is invoked with a pointer to the relevant TLS session and an NX_SECURE_X509_CERT pointer to the certificate to be validated.</span></span> <span data-ttu-id="14b4a-716">TLS 세션과 인증서 사이에는 애플리케이션이 추가 확인 검사를 수행하기 위해 TLS에서 필요한 모든 데이터가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-716">Between the TLS session and the certificate, the application has all of the data it needs from TLS to perform additional verification checks.</span></span>

<span data-ttu-id="14b4a-717">추가 유효성 검사에 도움이 되도록, NetX Secure는 DNS 유효성 검사 및 인증서 해지 목록 검사를 비롯한 몇 가지 일반적인 유효성 검사 작업에 대한 X.509 루틴을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-717">To help with the additional validation, NetX Secure provides X.509 routines for some common validation operations, including DNS validation and Certificate Revocation List checking.</span></span> <span data-ttu-id="14b4a-718">이러한 모든 루틴은 인증서 확인 콜백 내에서 사용하기에 적합하지만 X.509 인증서의 오프라인 검사를 수행하는데 사용할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-718">All of these routines are suitable for use within the certificate verification callback but may also be used to perform off-line checking of X.509 certificates.</span></span>

<span data-ttu-id="14b4a-719">다음 표에는 X.509 인증서 처리에 사용할 수 있는 도우미 함수가 요약되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-719">The following table summarizes the available helper functions for X.509 certificate processing.</span></span> <span data-ttu-id="14b4a-720">작업에 대한 자세한 설명은 다음 섹션과 챕터 4의 API 참조에서 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-720">More detailed explanations for the operations can be found in the following sections and the API reference in Chapter 4</span></span>  
  
<span data-ttu-id="14b4a-721">NetX Secure 서비스에 대한 설명에는 특정 루틴에 대한 추가 세부 정보가 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-721">Description of NetX Secure Services provides additional details on the specific routines.</span></span>

| <span data-ttu-id="14b4a-722">**API 이름**</span><span class="sxs-lookup"><span data-stu-id="14b4a-722">**API Name**</span></span>                             | <span data-ttu-id="14b4a-723">**설명**</span><span class="sxs-lookup"><span data-stu-id="14b4a-723">**Description**</span></span>                               |
| ---------------------------------------- | -------------------------------------- |
| <span data-ttu-id="14b4a-724">nx_secure_x509_common_name_dns_check</span><span class="sxs-lookup"><span data-stu-id="14b4a-724">nx_secure_x509_common_name_dns_check</span></span>               | <span data-ttu-id="14b4a-725">X.509 주체 일반 이름 및 SubjectAltName을 예상되는 DNS 이름과 대조하여 확인</span><span class="sxs-lookup"><span data-stu-id="14b4a-725">Check the X.509 subject Common Name and SubjectAltName against an expected DNS name</span></span> |
| <span data-ttu-id="14b4a-726">nx_secure_x509_crl_revocation_check</span><span class="sxs-lookup"><span data-stu-id="14b4a-726">nx_secure_x509_crl_revocation_check</span></span>                 | <span data-ttu-id="14b4a-727">X.509 CRL(인증서 해지 목록)에서 해지된 인증서 확인</span><span class="sxs-lookup"><span data-stu-id="14b4a-727">Check for a revoked certificate in an X.509 Certificate Revocation List (CRL)</span></span>       |
| <span data-ttu-id="14b4a-728">nx_secure_x509_extended_key_usage_extension_parse</span><span class="sxs-lookup"><span data-stu-id="14b4a-728">nx_secure_x509_extended_key_usage_extension_parse</span></span> | <span data-ttu-id="14b4a-729">인증서의 특정 확장 키 사용 OID를 구문 분석 및 찾기</span><span class="sxs-lookup"><span data-stu-id="14b4a-729">Parse and find a specific extended key usage OID in a certificate</span></span>                   |
| <span data-ttu-id="14b4a-730">nx_secure_x509_key_usage_extension_parse</span><span class="sxs-lookup"><span data-stu-id="14b4a-730">nx_secure_x509_key_usage_extension_parse</span></span>           | <span data-ttu-id="14b4a-731">인증서의 키 사용 비트 필드를 구문 분석 및 반환</span><span class="sxs-lookup"><span data-stu-id="14b4a-731">Parse and return the key usage bitfield in a certificate</span></span>                            |
| <span data-ttu-id="14b4a-732">nx_secure_x509_extension_find</span><span class="sxs-lookup"><span data-stu-id="14b4a-732">nx_secure_x509_extension_find</span></span>                        | <span data-ttu-id="14b4a-733">특정 확장에 대한 DER로 인코딩된 원시 ASN.1 데이터를 찾아서 반환</span><span class="sxs-lookup"><span data-stu-id="14b4a-733">Find and return the raw DER-encoded ASN.1 data for a specific extension.</span></span>            |

<span data-ttu-id="14b4a-734">인증서 확인 콜백에 사용할 X.509 도우미 함수</span><span class="sxs-lookup"><span data-stu-id="14b4a-734">X.509 helper functions for use in the certificate verification callback</span></span>

### <a name="x509-extensions"></a><span data-ttu-id="14b4a-735">X.509 확장</span><span class="sxs-lookup"><span data-stu-id="14b4a-735">X.509 Extensions</span></span>

<span data-ttu-id="14b4a-736">X.509 사양에는 인증서를 확인하는 데 사용 가능한 추가 정보를 제공하는 데 사용할 수 있는 여러 가지 "확장"이 설명되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-736">The X.509 specification describes a number of "extensions" that can be used to supply additional information that can be utilized in the verification of certificates.</span></span> <span data-ttu-id="14b4a-737">대부분의 경우 이러한 확장은 선택 사항이며 신뢰할 수 있는 루트 인증서와 대조하여 디지털 인증서의 보안 유효성을 검사하는 데 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-737">For the most part, these extensions are optional and are not required for secure validation of a digital certificate against a trusted root certificate.</span></span> <span data-ttu-id="14b4a-738">하지만 NetX Secure는 몇 가지 기본 확장을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-738">However, NetX Secure does support some basic extensions.</span></span> <span data-ttu-id="14b4a-739">추가 확장에 대한 지원은 이후 릴리스에서 추가될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-739">Support for additional extensions may be added in future releases.</span></span>

<span data-ttu-id="14b4a-740">현재 지원되는 확장은 다음 표에 나와 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-740">The currently supported extensions are listed in the following table:</span></span>

| <span data-ttu-id="14b4a-741">확장 이름</span><span class="sxs-lookup"><span data-stu-id="14b4a-741">Extension Name</span></span>           | <span data-ttu-id="14b4a-742">Description</span><span class="sxs-lookup"><span data-stu-id="14b4a-742">Description</span></span>                                                                   | <span data-ttu-id="14b4a-743">관련 API</span><span class="sxs-lookup"><span data-stu-id="14b4a-743">Relevant API</span></span>                                             |
| ------------------------ | ----------------------------------------------------------------------------- | -------------------------------------------------------- |
| <span data-ttu-id="14b4a-744">키 사용</span><span class="sxs-lookup"><span data-stu-id="14b4a-744">Key Usage</span></span>                | <span data-ttu-id="14b4a-745">비트 필드의 인증서 공개 키에 대해 허용되는 사용 제공</span><span class="sxs-lookup"><span data-stu-id="14b4a-745">Provides acceptable uses for a certificate's public key in a bitfield</span></span>         | <span data-ttu-id="14b4a-746">nx_secure_x509_key_usage_extension_parse</span><span class="sxs-lookup"><span data-stu-id="14b4a-746">nx_secure_x509_key_usage_extension_parse</span></span>           |
| <span data-ttu-id="14b4a-747">확장 키 사용</span><span class="sxs-lookup"><span data-stu-id="14b4a-747">Extended Key Usage</span></span>       | <span data-ttu-id="14b4a-748">OID를 사용하는 인증서의 공개 키에 추가로 허용되는 사용 제공</span><span class="sxs-lookup"><span data-stu-id="14b4a-748">Provides additional acceptable uses for a certificate's public key using OIDs</span></span> | <span data-ttu-id="14b4a-749">nx_secure_x509_extended_key_usage_extension_parse</span><span class="sxs-lookup"><span data-stu-id="14b4a-749">nx_secure_x509_extended_key_usage_extension_parse</span></span> |
| <span data-ttu-id="14b4a-750">주체 대체 이름</span><span class="sxs-lookup"><span data-stu-id="14b4a-750">Subject Alternative Name</span></span> | <span data-ttu-id="14b4a-751">인증서로도 표시되는 대체 DNS 이름 제공</span><span class="sxs-lookup"><span data-stu-id="14b4a-751">Provides alternative DNS names that are also represented by the certificate</span></span>   | <span data-ttu-id="14b4a-752">nx_secure_x509_common_name_dns_check</span><span class="sxs-lookup"><span data-stu-id="14b4a-752">nx_secure_x509_common_name_dns_check</span></span>               |

### <a name="unsupported-x509-extensions"></a><span data-ttu-id="14b4a-753">지원되지 않는 X.509 확장</span><span class="sxs-lookup"><span data-stu-id="14b4a-753">Unsupported X.509 Extensions</span></span>

<span data-ttu-id="14b4a-754">NetX Secure의 X.509 구현은 지원되지 않는 확장을 추출하는 서비스도 제공합니다(*nx_secure_x509_extension_find*).</span><span class="sxs-lookup"><span data-stu-id="14b4a-754">NetX Secure's X.509 implemenation does provide a service to extract unsupported extensions as well: *nx_secure_x509_extension_find*.</span></span> <span data-ttu-id="14b4a-755">이 API는 고급 사용자용입니다. 반환된 데이터를 구문 분석하려면 DER로 인코딩된 ASN.1에 대한 지식이 필요하기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-755">This API is intended for advanced users as it requires knowledge of DER-encoded ASN.1 in order to parse the data returned.</span></span> <span data-ttu-id="14b4a-756">내부적으로 지원되는 확장을 추출하는 데 사용되지만, X.509 확장에 대한 사용자 지정 지원을 개발하는 편의를 위해 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-756">It it used internally to extract supported extensions but is supplied for convenience in developing customized support for X.509 extensions.</span></span>

<span data-ttu-id="14b4a-757">nx_secure_x509_extension_find를 사용하기 위해 알려진 확장 유형에 대한 가변 길이 OID 문자열의 정수 표현인 확장 ID 및 인증서와 함께 NX_SECURE_X509_EXTENSION이 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-757">To use nx_secure_x509_extension_find, a NX_SECURE_X509_EXTENSION is passed in, along with the certificate and an extension ID, which is an integer representation of the variable-length OID string for a known extension type.</span></span> <span data-ttu-id="14b4a-758">X.509 확장에 대해 지원되는 OID의 전체 목록은 nx_secure_x509_extension_find에 대한 API 참조에 제공됩니다(178 페이지).</span><span class="sxs-lookup"><span data-stu-id="14b4a-758">A complete list of supported OIDs for X.509 extensions is provided in the API reference for nx_secure_x509_extension_find on page 178.</span></span>

<span data-ttu-id="14b4a-759">NX_SECURE_X509_EXTENSION 구조는 다음과 같이 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-759">The NX_SECURE_X509_EXTENSION structure is defined as follows:</span></span>

```C
typedef struct NX_SECURE_X509_EXTENSION_STRUCT
{
    /* Identifier (maps to OID) for this extension. */
    USHORT nx_secure_x509_extension_id;

    /* Critical flag - boolean value. */
    USHORT nx_secure_x509_extension_critical;

    /* Pointer to DER-encoded extension data. */
    const UCHAR *nx_secure_x509_extension_data;
    ULONG        nx_secure_x509_extension_data_length;
} NX_SECURE_X509_EXTENSION;
```
<span data-ttu-id="14b4a-760">서비스가 성공적으로 반환되면 구조는 인증서의 관련 데이터로 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-760">When the service returns successfully, the structure will be populated with the relevant data from the certificate.</span></span> <span data-ttu-id="14b4a-761">nx_secure_x509_extension_id 필드는 일반적으로 내부 용도로 사용되지만 관련 OID 정수 표현으로 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-761">The nx_secure_x509_extension_id field is generally used for internal purposes but will be populated with the relevant OID integer representation.</span></span> <span data-ttu-id="14b4a-762">nx_secure_x509_extension_critical 필드는 X.509 중요 확장 플래그 값(Boolean)을 노출합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-762">The nx_secure_x509_extension_critical field exposes the X.509 critical extension flag value (Boolean).</span></span> <span data-ttu-id="14b4a-763">nx_secure_x509_extension_data 및 nx_secure_x509_extension_data_length 필드에는 확장의 DER로 인코딩된 ASN.1 데이터에 대한 포인터와 이 데이터의 길이가 각각 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-763">The nx_secure_x509_extension_data and nx_secure_x509_extension_data_length fields contain a pointer to the DER-encoded ASN.1 data for the extension, and the length of that data, respectively.</span></span>

<span data-ttu-id="14b4a-764">확장 ASN.1 데이터의 실제 구문 분석은 이 문서에서 다루지 않지만 NetX Secure TLS 소스에 대한 액세스 권한이 있으면 지원되는 확장에 대해 nx_secure_x509_extension_find가 호출될 때마다 구문 분석이 수행되는 방식을 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-764">Actual parsing of the extension ASN.1 data is beyond the scope of this document, but if you have access to the NetX Secure TLS source you can see how the parsing is done wherever nx_secure_x509_extension_find is called for supported extensions.</span></span>

### <a name="x509-dns-validation"></a><span data-ttu-id="14b4a-765">X.509 DNS 유효성 검사</span><span class="sxs-lookup"><span data-stu-id="14b4a-765">X.509 DNS Validation</span></span>

<span data-ttu-id="14b4a-766">TLS의 일반적인 인증서 유효성 검사 작업에는 원격 호스트의 TLD(최상위 도메인) 이름을 TLS 핸드셰이크 중에 호스트가 제공한 X.509 인증서와 대조하여 확인하는 작업이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-766">A common certificate validation operation in TLS involves checking the Top-Level Domain (TLD) name of a remote host against the X.509 certificate provided by that host during the TLS handshake.</span></span> <span data-ttu-id="14b4a-767">이 작업은 DNS 조회를 신뢰할 수 있다는 가정하에 인증서가 인증서를 제공한 호스트 서버와 실제로 일치하는지 확인하는 데 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-767">This operation helps to ensure that the certificate does indeed match the host server that provided it, assuming the DNS lookup can be trusted.</span></span> <span data-ttu-id="14b4a-768">NetX Secure TLS에서 이 기능은 **nx_secure_x509_common_name_dns_check** 서비스가 제공합니다. 이 서비스는 호스트에 액세스하는 데 사용되는 URL의 TLD 부분을 포함하는 문자열과 인증서를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-768">In NetX Secure TLS, this functionality is provided by the service **nx_secure_x509_common_name_dns_check**, which takes the certificate and a string containing the TLD portion of the URL used to access the host.</span></span> <span data-ttu-id="14b4a-769">TLD는 인증서의 일반 이름 필드와 비교되며 일치하면 NX_SUCCESS가 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-769">The TLD is compared to the certificate's Common Name field and if it matches, NX_SUCCESS is returned.</span></span> <span data-ttu-id="14b4a-770">일반 이름이 일치하지 않으면 루틴은 X.509 인증서 확장 *subjectAltName* 이 있는지도 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-770">If the Common Name does not match, the routine will also check for the existence of the X.509 certificate extension *subjectAltName*.</span></span> <span data-ttu-id="14b4a-771">subjectAltName이 있으면 확장의 모든 DNSName 항목도 제공된 TLD와 대조하여 확인됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-771">If a subjectAltName is present, any DNSName entries in the extension are also checked against the provided TLD.</span></span> <span data-ttu-id="14b4a-772">마찬가지로, 일치하는 항목이 있으면 NX_SUCCESS가 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-772">Again, if any match, NX_SUCCESS is returned.</span></span> <span data-ttu-id="14b4a-773">일치하는 항목이 없으면 인증서 유효성 검사 콜백에서 반환하기 적합한 오류가 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-773">If no match is found, an error suitable for returning from the certificate validation callback is returned.</span></span>

### <a name="x509-key-usage-and-extended-key-usage-extensions"></a><span data-ttu-id="14b4a-774">X.509 키 사용 및 EKU(확장 키 사용) 확장</span><span class="sxs-lookup"><span data-stu-id="14b4a-774">X.509 Key Usage and Extended Key Usage Extensions</span></span>

<span data-ttu-id="14b4a-775">X.509 키 사용 및 EKU(확장 키 사용) 확장은 인증서를 인증할 때 인증서의 공개 키를 사용할 수 있는 방법에 대한 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-775">The X.509 Key Usage and Extended Key Usage extensions provide information on how a certificate's public key may be used when authenticating that certificate.</span></span> <span data-ttu-id="14b4a-776">키 사용은 인증서가 서명되고 발급될 때 인증서 발급자가 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-776">The key usage is supplied by the certificate's issuer when the certificate is signed and issued.</span></span> <span data-ttu-id="14b4a-777">키 사용은 원격 TLS 호스트를 인증하고 다른 작업을 수행하는 데 인증서를 사용할 권한이 있는지 확인하기 위해 TLS 호스트가 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-777">The key usage may be used by a TLS host to check that the certificate is authorized to be used to authenticate a remote TLS host and perform other operations.</span></span>

<span data-ttu-id="14b4a-778">키 사용 확장은 각 비트가 특정 키 사용을 나타내는 간단한 비트 필드로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-778">The Key Usage extension consists of a simple bitfield where each of the bits represents a specific key usage.</span></span> <span data-ttu-id="14b4a-779">이러한 값의 전체 목록은 *nx_secure_x509_key_usage_extension_parse* 에 대한 API 참조에 제공됩니다(183 페이지).</span><span class="sxs-lookup"><span data-stu-id="14b4a-779">A complete list of these values is provided in the API reference for *nx_secure_x509_key_usage_extension_parse* on page 183.</span></span> <span data-ttu-id="14b4a-780">키 사용 비트와 그 의미에 대한 자세한 내용은 RFC 5280의 4.2.1.3 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="14b4a-780">For a more complete description of the key usage bits and their meanings, refer to RFC 5280, section 4.2.1.3.</span></span>

<span data-ttu-id="14b4a-781">EKU(확장 키 사용) 확장은 키 사용 확장과 마찬가지로 허용되는 키 사용 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-781">The Extended Key Usage extension, like the Key Usage extension, provides acceptable key use information.</span></span> <span data-ttu-id="14b4a-782">하지만 임의 사용을 지원하기 위해 EKU(확장 키 사용) 확장은 비트 필드 대신 OID를 활용합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-782">However, in order to support arbitrary usages, the Extended Key Usage extension utilizes OIDs instead of a bitfield.</span></span> <span data-ttu-id="14b4a-783">NetX Secure X.509에서 EKU(확장 키 사용) 확장을 구문 분석할 때 OID를 나타내는 정수가 애플리케이션에서 제공됩니다. 그런 다음, *nx_secure_x509_extended_key_usage_extension_parse* 서비스는 해당 OID가 있는지 여부를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-783">When parsing an Extended Key Usage extension in NetX Secure X.509, an integer representing the OID is supplied by the application – the *nx_secure_x509_extended_key_usage_extension_parse* service will then return whether that OID is present.</span></span> <span data-ttu-id="14b4a-784">EKU(확장 키 사용)에 지원되는 OID의 전체 목록은 *nx_secure_x509_extended_key_usage_extension_parse* 에 대한 API 참조에 제공됩니다(175 페이지).</span><span class="sxs-lookup"><span data-stu-id="14b4a-784">A complete list of supported OIDs for Extended Key usage is provided in the API reference for *nx_secure_x509_extended_key_usage_extension_parse* on page 175.</span></span> <span data-ttu-id="14b4a-785">OID 및 그 의미에 대한 자세한 설명은 RFC 5280에서 4.2.1.12 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="14b4a-785">For a more complete description of the OIDs and their meanings, refer to RFC 5280, section 4.2.1.12.</span></span>

### <a name="x509-crl-revocation-status-checking"></a><span data-ttu-id="14b4a-786">X.509 CRL 해지 상태 확인</span><span class="sxs-lookup"><span data-stu-id="14b4a-786">X.509 CRL Revocation Status Checking</span></span>

<span data-ttu-id="14b4a-787">X.509는 디지털 인증서 서명 기관이 서명한 인증서의 유효성을 취소할 수 있는 CRL(인증서 해지 목록)이라는 메커니즘을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-787">X.509 provides a mechanism called the *Certificate Revocation List* (CRL) that allows a digital certificate signing authority to revoke the validity of certificates it has signed.</span></span> <span data-ttu-id="14b4a-788">서명 기관의 인증서를 확인해야 하는 애플리케이션은 CRL을 확보하고 해당 기관(발급자)이 서명한 인증서를 CRL과 비교하여 어떤 이유로든(예: 프라이빗 키 손상) 상태가 해지되었는지 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-788">Any application that needs to verify certificates from a signing authority can obtain a CRL and compare any certificates signed by that authority (issuer) against the CRL to see if they have had their status revoked for some reason (such as compromised private key).</span></span> <span data-ttu-id="14b4a-789">이러한 방식으로 애플리케이션은 다른 인증서 유효성 검사를 통과한 잠재적으로 위험한 인증서를 사용하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-789">In this way, the application can avoid using potentially dangerous certificates that pass other certificate validation checks.</span></span>

<span data-ttu-id="14b4a-790">CRL 확보는 애플리케이션에서 수행됩니다. 미리 정의된 서버에서 또는 다른 수단을 통해 DER로 인코딩된 목록을 다운로드하여 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-790">Obtaining a CRL is done by an application by downloading the DER-encoded list from a pre-defined server or through some other means.</span></span> <span data-ttu-id="14b4a-791">실제 설정은 발급자마다 다르기 때문에 NetX Secure는 CRL을 확보하는 메커니즘은 제공하지 않고 CRL과 대조하여 인증서를 확인하는 루틴(**nx_secure_x509_crl_revocation_check**)을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-791">The actual setup varies from issuer to issuer so NetX Secure does not provide a mechanism for obtaining CRLs, but it does provide a routine to check a certificate against a CRL, **nx_secure_x509_crl_revocation_check**.</span></span>

<span data-ttu-id="14b4a-792">API는 DER로 인코딩된 CRL, 확인 시 대조할 인증서 저장소(예: TLS 세션의 저장소) 및 확인할 인증서를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-792">The API takes a DER-encoded CRL, a certificate store (such as the one in a TLS session) to check against, and the certificate to be checked.</span></span> <span data-ttu-id="14b4a-793">루틴은 먼저 신뢰할 수 있는 저장소(애플리케이션이 제공하는 인증서 저장소의 일부)와 대조하여 CRL 자체의 유효성을 검사합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-793">The routine first validates the CRL itself against the trusted store (part of the certificate store provided by the application).</span></span> <span data-ttu-id="14b4a-794">이 작업은 서비스 거부 공격에 사용되는 사기성 CRL로부터 보호하고 CRL이 실제로 적절한 발급자로부터 온 것인지를 입증하는 데 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-794">This is important to protect against fraudulent CRLs being used for Denial-of-Service attacks and establishes that the CRL is actually from the proper issuer.</span></span> <span data-ttu-id="14b4a-795">CRL 유효성 검사 후에는 발급자가 확인됩니다. CRL 발급자가 인증서 발급자와 일치하지 않으면 해당 인증서에 대해 CRL이 유효하지 않으며 오류가 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-795">Following the CRL validation, the issuer is checked – if the issuer of the CRL does not match the issuer of the certificate, then the CRL is not valid for that certificate and an error is returned.</span></span> <span data-ttu-id="14b4a-796">이 시점에서 TLS 핸드셰이크를 계속할 수 있을지 여부는 애플리케이션에 달려 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-796">It is up to the application to determine whether the TLS handshake can continue at this point.</span></span> <span data-ttu-id="14b4a-797">발급자가 일치하면 유효성이 검사되는 인증서의 일련 번호를 CRL에서 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-797">If the issuers do match, then the CRL is searched for the serial number of the certificate being validated.</span></span> <span data-ttu-id="14b4a-798">목록에 일련 번호가 있으면 인증서가 해지되었음을 나타내는 오류가 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-798">If the serial number is present in the list, an error indicating that the certificate has been revoked is returned.</span></span> <span data-ttu-id="14b4a-799">일치 항목이 없으면 NX_SUCCESS가 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-799">If no match is found, NX_SUCCESS is returned.</span></span>

## <a name="client-certificate-authentication-in-netx-secure-tls"></a><span data-ttu-id="14b4a-800">NetX Secure TLS의 클라이언트 인증서 인증</span><span class="sxs-lookup"><span data-stu-id="14b4a-800">Client Certificate Authentication in NetX Secure TLS</span></span>

<span data-ttu-id="14b4a-801">X.509 인증서 인증을 사용하는 경우 TLS 프로토콜을 사용하려면 TLS 서버 인스턴스에서 식별용 인증서를 제공해야 하지만, 기본적으로 TLS 클라이언트 인스턴스는 다른 형태의 인증(예: 사용자 이름/암호 조합)을 사용하여 인증용 인증서를 제공할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-801">When using X.509 certificate authentication, the TLS protocol requires that the TLS Server instance provide a certificate for identification, but by default the TLS Client instance does not need to provide a certificate for authentication, using another form of authentication instead (e.g. a username/password combination).</span></span> <span data-ttu-id="14b4a-802">따라서 인터넷의 웹 사이트에서 가장 일반적으로 사용되는 TLS에 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-802">This matches the most common use of TLS on the Internet for Web sites.</span></span> <span data-ttu-id="14b4a-803">예를 들어 온라인 소매점 사이트는 웹 브라우저를 사용하는 잠재 고객에게 서버가 합법적이라는 것을 증명해야 하지만 사용자는 로그인/암호를 사용하여 특정 계정에 액세스합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-803">For example, an online retail site must prove to a potential customer using a web browser that the server is legitimate, but the user will use a login/password to access a specific account.</span></span>

<span data-ttu-id="14b4a-804">그러나 기본 사례가 항상 바람직한 것은 아니므로 TLS는 상황에 따라 TLS 서버 인스턴스가 원격 클라이언트의 인증서를 요청하는 것을 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-804">However, the default case is not always desirable, so TLS optionally allows for the TLS Server instance to request a certificate from the remote Client.</span></span> <span data-ttu-id="14b4a-805">이 기능을 사용하면 TLS 서버는 핸드셰이크 중에 CertificateRequest 메시지를 TLS 클라이언트에 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-805">When this feature is enabled, the TLS Server will send a CertificateRequest message to the TLS Client during the handshake.</span></span> <span data-ttu-id="14b4a-806">클라이언트는 자체 인증서 및 이 인증서와 연결된 일치하는 프라이빗 키를 소유하고 있음을 증명하는 암호화 토큰이 포함된 CertificateVerify 메시지로 응답해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-806">The Client must respond with a certificate of its own and a CertificateVerify message which contains a cryptographic token proving that the Client owns the matching private key associated with that certificate.</span></span> <span data-ttu-id="14b4a-807">확인이 실패하거나 인증서가 서버의 신뢰할 수 있는 인증서에 연결되어 있지 않으면 TLS 핸드셰이크가 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-807">If the verification fails or the certificate is not connected to a trusted certificate on the Server, the TLS handshake fails.</span></span>

<span data-ttu-id="14b4a-808">TLS의 클라이언트 인증서 인증에는 두 가지 경우가 있으며, 다음 섹션에 두 경우가 모두 설명되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-808">There are two separate cases for Client Certificate Authentication in TLS – the following sections cover both cases.</span></span>

### <a name="client-certificate-authentication-for-tls-clients"></a><span data-ttu-id="14b4a-809">TLS 클라이언트용 클라이언트 인증서 인증</span><span class="sxs-lookup"><span data-stu-id="14b4a-809">Client Certificate Authentication for TLS Clients</span></span>

<span data-ttu-id="14b4a-810">TLS 클라이언트는 클라이언트 인증을 위해 인증서를 요청하는 서버에 연결을 시도할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-810">A TLS Client may attempt a connection to a server that requests a certificate for client authentication.</span></span> <span data-ttu-id="14b4a-811">이 경우 클라이언트는 서버에 인증서를 제공하고 인증서와 일치하는 프라이빗 키를 소유하고 있는지 확인해야 합니다. 그렇지 않으면 서버가 TLS 핸드셰이크를 종료합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-811">In this case the Client must provide a certificate to the server and verify that it owns the matching private key or the Server will terminate the TLS handshake.</span></span>

<span data-ttu-id="14b4a-812">NetX Secure TLS에는 이 기능을 지원하는 특별한 구성이 없지만 애플리케이션에서 *nx_secure_tls_local_certificate_add* 서비스를 사용하여 TLS 클라이언트 인스턴스에 대한 로컬 식별 인증서를 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-812">In NetX Secure TLS, there is no special configuration to support this feature but the application will have to provide a local identification certificate for the TLS Client instance using the *nx_secure_tls_local_certificate_add* service.</span></span> <span data-ttu-id="14b4a-813">애플리케이션이 인증서를 제공하지 않았는데 원격 서버가 클라이언트 인증서 인증을 사용 중이고 인증서를 요청하면 TLS 핸드셰이크가 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-813">If no certificate is provided by the application but the remote server is using Client Certificate Authentication and requests a certificate, the TLS handshake will fail.</span></span> <span data-ttu-id="14b4a-814">TLS 핸드셰이크를 완료하려면 *nx_secure_tls_local_certificate_add* 를 사용하여 TLS 세션에 제공된 인증서를 원격 서버에서 인식해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-814">The certificate provided to the TLS Session with *nx_secure_tls_local_certificate_add* must be recognized by the remote server in order to complete the TLS handshake.</span></span>

### <a name="client-certificate-authentication-for-tls-servers"></a><span data-ttu-id="14b4a-815">TLS 서버용 클라이언트 인증서 인증</span><span class="sxs-lookup"><span data-stu-id="14b4a-815">Client Certificate Authentication for TLS Servers</span></span>

<span data-ttu-id="14b4a-816">클라이언트 인증서 인증을 위한 TLS 서버 사례는 기능이 선택 사항이기 때문에 TLS 클라이언트 사례보다 약간 더 복잡합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-816">The TLS Server case for Client Certificate Authentication is slightly more complex than the TLS Client case due to the feature being optional.</span></span> <span data-ttu-id="14b4a-817">이 경우 TLS 서버는 원격 TLS 클라이언트에서 인증서를 구체적으로 요청한 다음, CertificateVerify 메시지를 처리하여 원격 클라이언트가 일치하는 프라이빗 키를 소유하고 있는지 확인해야 합니다. 그 후 서버에서는 클라이언트가 제공한 인증서를 신뢰할 수 있는 로컬 인증서 저장소의 인증서까지 추적할 수 있는지 확인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-817">In this case, the TLS Server needs to specifically request a certificate from the remote TLS Client, then process the CertificateVerify message to verify that the remote Client owns the matching private key, and then the Server must check that the certificate provided by the Client can be traced to a certificate in the local trusted certificate store.</span></span>

<span data-ttu-id="14b4a-818">NetX Secure TLS 서버 인스턴스에서 클라이언트 인증서 인증은</span><span class="sxs-lookup"><span data-stu-id="14b4a-818">In NetX Secure TLS Server instances, Client Certificate Authentication is controlled by</span></span> <br>
<span data-ttu-id="14b4a-819">*nx <span class="underline"> _</span>secure <span class="underline">_</span>tls <span class="underline"> _</span>session <span class="underline">_</span>client <span class="underline"> _</span>verify<span class="underline">_</span>enable* 및</span><span class="sxs-lookup"><span data-stu-id="14b4a-819">the *nx <span class="underline">_</span>secure <span class="underline">_</span>tls <span class="underline">_</span>session <span class="underline">_</span>client <span class="underline">_</span>verify<span class="underline">_</span>enable* and</span></span><br>
<span data-ttu-id="14b4a-820">*nx <span class="underline"> _</span>secure <span class="underline">_</span>tls <span class="underline"> _</span>session <span class="underline">_</span>client <span class="underline"> _</span>verify<span class="underline">_</span>disable* 서비스에 의해 제어됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-820">*nx <span class="underline">_</span>secure <span class="underline">_</span>tls <span class="underline">_</span>session <span class="underline">_</span>client <span class="underline">_</span>verify<span class="underline">_</span>disable* services.</span></span>

<span data-ttu-id="14b4a-821">클라이언트 인증서 인증을 활성화하려면 애플리케이션이</span><span class="sxs-lookup"><span data-stu-id="14b4a-821">To enable Client Certificate Authentication, an application must call</span></span><br>
<span data-ttu-id="14b4a-822">*nx_secure_tls_session_start* 를 호출하기 전에 TLS 서버 세션 인스턴스를 사용하여 *nx <span class="underline"> _</span>secure <span class="underline">_</span>tls <span class="underline"> _</span>session <span class="underline">_</span>client <span class="underline"> _</span>verify<span class="underline">_</span>enable* 을 호출해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-822">*nx <span class="underline">_</span>secure <span class="underline">_</span>tls <span class="underline">_</span>session <span class="underline">_</span>client <span class="underline">_</span>verify <span class="underline">_</span>enable* with the TLS Server session instance before calling *nx_secure_tls_session_start*.</span></span> <span data-ttu-id="14b4a-823">TLS 클라이언트 연결에 사용되는 TLS 세션에서 이 서비스를 호출해도 아무런 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-823">Note that calling this service on a TLS Session that is used for TLS Client connections will have no effect.</span></span>

<span data-ttu-id="14b4a-824">클라이언트 인증서 인증을 사용하면 TLS 서버는 TLS 핸드셰이크 중에 원격 TLS 클라이언트의 인증서를 요청합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-824">When Client Certificate Authentication is enabled, the TLS Server will request a certificate from the remote TLS Client during the TLS handshake.</span></span> <span data-ttu-id="14b4a-825">NetX Secure TLS 서버에서 클라이언트 인증서는 X.509 발급자 체인 후 *nx <span class="underline"> _</span>secure_tls <span class="underline">_</span>trusted <span class="underline"> _</span>certificate<span class="underline">_</span>add* 를 사용하여 생성된 신뢰할 수 있는 인증서의 저장소와 대조하여 확인됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-825">In NetX Secure TLS Server, the Client certificate is checked against the store of trusted certificates created with *nx <span class="underline">_</span>secure_tls <span class="underline">_</span>trusted <span class="underline">_</span>certificate<span class="underline">_</span>add* following the X.509 issuer chain.</span></span> <span data-ttu-id="14b4a-826">원격 클라이언트는 자체 ID 인증서를 신뢰할 수 있는 저장소의 인증서에 연결하는 체인을 제공해야 합니다. 그렇지 않으면 TLS 핸드셰이크가 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-826">The remote Client must provide a chain that connects its identity certificate to a certificate in the trusted store or the TLS handshake will fail.</span></span> <span data-ttu-id="14b4a-827">또한 CertificateVerify 메시지 처리가 실패하면 TLS 핸드셰이크도 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-827">Additionally, if the CertificateVerify message processing fails, the TLS handshake will also fail.</span></span>

<span data-ttu-id="14b4a-828">CertificateVerify 메서드에 사용되는 서명 메서드는 TLS 버전 1.0 및 TLS 버전 1.1용으로 수정되었으며, TLS 버전 1.2의 TLS 서버에서 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-828">The signature methods used for the CertificateVerify method are fixed for TLS version 1.0 and TLS version 1.1, and are specified by the TLS Server in TLS version 1.2.</span></span> <span data-ttu-id="14b4a-829">TLS 1.2의 경우 지원되는 서명 메서드는 일반적으로 암호화 메서드 테이블에 제공된 관련 메서드를 따르지만, 일반적으로 SHA-256과 함께 RSA를 사용합니다. 암호화 메서드로 TLS를 초기화하는 방법에 대한 자세한 내용은 "NetX Secure TLS의 암호화" 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="14b4a-829">For TLS 1.2, the signature methods supported generally follow the relevant methods supplied in the cryptographic method table, but typically RSA with SHA-256 (see the section "Cryptography in NetX Secure TLS" for more information on initializing TLS with cryptographic methods).</span></span>

## <a name="cryptography-in-netx-secure-tls"></a><span data-ttu-id="14b4a-830">NetX Secure TLS의 암호화</span><span class="sxs-lookup"><span data-stu-id="14b4a-830">Cryptography in NetX Secure TLS</span></span>

<span data-ttu-id="14b4a-831">TLS는 암호화를 사용하여 네트워크 통신을 보호할 수 있는 프로토콜을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-831">TLS defines a protocol in which cryptography can be used to secure network communications.</span></span> <span data-ttu-id="14b4a-832">따라서 실제 암호화를 TLS 사용자에게 매우 광범위하게 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-832">As such, it leaves the actual cryptography to be used fairly wide open for TLS users.</span></span> <span data-ttu-id="14b4a-833">이 사양에서는 단일 ciphersuite를 구현하기만 하면 됩니다. TLS 1.2의 경우에는 해당 ciphersuite는 TLS_RSA_WITH_AES_128_CBC_SHA입니다. 즉, 공개 키 작업에는 RSA를 사용하고, 세션 암호화에는 128비트 키를 사용하여 AES를 CBC 모드로 사용하고, 메시지 인증 해시에는 SHA-1을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-833">The specification only requires a single ciphersuite to be implemented – in the case of TLS 1.2, that ciphersuite is TLS_RSA_WITH_AES_128_CBC_SHA, indicating the use of RSA for public-key operations, AES in CBC mode with 128-bit keys for session encryption, and SHA-1 for message authentication hashes.</span></span>

<span data-ttu-id="14b4a-834">TLS 1.2 규격을 준수하는 NetX Secure는 기본적으로 필수 TLS_RSA_WITH_AES_128_CBC_SHA ciphersuite를 활성화하지만, 하드웨어 기능과 기타 고려 사항으로 인해 각 암호화 메서드에 대해 가능한 구현 수를 고려하여 NetX Secure는 사용자가 TLS에서 사용할 암호화 메서드를 지정할 수 있는 일반 암호화 API를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-834">Being TLS 1.2-compliant, NetX Secure enables the mandatory TLS_RSA_WITH_AES_128_CBC_SHA ciphersuite by default, but given the number of possible implementations for each of the cryptographic methods due to hardware capabilities and other considerations, NetX Secure provides a generic cryptographic API that allows a user to specify which cryptographic methods to use with TLS.</span></span>

<span data-ttu-id="14b4a-835">참고: 일반 암호화 API 메커니즘을 사용하면 사용자가 자체 ciphersuite를 구현할 수 있지만, TLS ciphersuite 및 확장에 익숙한 고급 사용자만 이 메커니즘을 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-835">NOTE: The generic cryptographic API mechanism also allows users to implement their own ciphersuites, but this is recommended for advanced users who are familiar with the TLS ciphersuites and extensions.</span></span> <span data-ttu-id="14b4a-836">자체 ciphersuite를 지원하려면 Express Logic 담당자에게 문의하세요.</span><span class="sxs-lookup"><span data-stu-id="14b4a-836">Please contact your Express Logic representative if you are interested in supporting your own ciphersuites.</span></span>

### <a name="cryptographic-methods"></a><span data-ttu-id="14b4a-837">암호화 메서드</span><span class="sxs-lookup"><span data-stu-id="14b4a-837">Cryptographic Methods</span></span>

<span data-ttu-id="14b4a-838">NetX Secure TLS는 특정 하드웨어 플랫폼용 하드웨어 드라이버가 있는 소프트웨어에서 DES, 3DES, AES, MD5, HMAC-MD5, SHA-1, HMAC-SHA1, SHA-256, HMAC-SHA256, RSA 및 ECC(선택된 곡선)를 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-838">NetX Secure TLS implements DES, 3DES, AES, MD5, HMAC-MD5, SHA-1, HMAC-SHA1, SHA-256, HMAC-SHA256, RSA, and ECC (selected curves) in software with hardware drivers for certain hardware platforms.</span></span> <span data-ttu-id="14b4a-839">애플리케이션은 NetX Secure와 함께 제공되는 암호화 루틴을 사용하거나 최종 사용자 또는 제3자가 제공한 사용자 지정 루틴을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-839">An application may use the cryptographic routines provided with NetX Secure, or use custom routines provided by the end user or third parties.</span></span>

<span data-ttu-id="14b4a-840">*NX_CRYPTO_METHOD* 는 애플리케이션이 NetX Secure TLS에 사용할 암호화 알고리즘의 특정 구현을 설명하도록 설계된 제어 블록입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-840">The *NX_CRYPTO_METHOD* is a control block designed for an application to describe a particular implementation of a cryptographic algorithm to be used with NetX Secure TLS.</span></span> <span data-ttu-id="14b4a-841">*NX_CRYPTO_METHOD* 를 통해 애플리케이션은 자체 암호화 구현을 NetX Secure에 쉽게 통합할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-841">With the *NX_CRYPTO_METHOD,* an application can easily integrate their own crypto implementation into NetX Secure.</span></span> <span data-ttu-id="14b4a-842">*NX_CRYPTO_METHOD* 구조체는 다음과 같이 선언됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-842">The *NX_CRYPTO_METHOD* structure is declared as:</span></span>

```C
typedef struct NX_CRYPTO_METHOD_STRUCT
{
    /* Symbolic name of the algorithm. */
    USHORT nx_crypto_algorithm;

    /* Size of the key, in bits. */
    USHORT nx_crypto_key_size_in_bits;

    /* Size of the IV block, in bits, used for encryption. */
    USHORT nx_crypto_IV_size_in_bits;

    /* Size of the ICV block, in bits, used for authentication. */
    USHORT nx_crypto_ICV_size_in_bits;

    /* Size of the crypto block, in bytes. */
    ULONG nx_crypto_block_size_in_bytes;

    /* Size of the metadata area. */
    ULONG nx_crypto_metadata_size;

    /* nx_crypto_init function initializes the crypto method with the
        "secret key" or other state  information. The initialization 
        routine should return a handle to the caller.  This handle is 
        used in subsequent crypto operations to identify the session.  
        */

    UINT (*nx_crypto_init) (NX_CRYPTO_METHOD     *method,
                            UCHAR               *key, 
                            NX_CRYPTO_KEY_SIZE   key_size_in_bits,
                            VOID               **handler,
                            VOID                *crypto_metadata,
                            VOID                 crypto_metadata_size);

    /* NetX Secure calls the nx_crypto_cleanup routine when a TLS
       session is to be deleted (or updated).  Resources allocated 
       during the crypto operation should be released in this routine.  
       */
    UINT (*nx_crypto_cleanup) (VOID *handler);

    /* nx_crypto_operation is the actual crypto or hash operation. Note 
       that both input and output buffers are prepared by the caller. 
       For encryption or decryption operations, the crypto operation 
       routine uses the output buffer for encrypted or decrypted data. 
       For authentication operations, the authentication routine shall 
       use the output buffer for the digest. */
    UINT (*nx_crypto_operation)(UINT  op, 
                  VOID              *handler, 
                  NX_CRYPTO_METHOD  *method,
                  UCHAR             *key,
                  NX_CRYPTO_KEY_SIZE key_size_in_bits,
                  UCHAR             *input,
                  ULONG              input_length_in_byte,
                  UCHAR             *iv_ptr,
                  UCHAR             *output,
                  ULONG              output_length_in_byte,
                  VOID              *crypto_metadata,
                  VOID               crypto_metadata_size,
                  NX_PACKET*         packet_ptr,
                  VOID (*nx_crypto_hw_process_callback(NX_PACKET 
                                                       *packet_ptr, 
                                                        UINT status);
} NX_CRYPTO_METHOD;
```

<span data-ttu-id="14b4a-843">다음은 *NX_CRYPTO_METHOD* 구조체에 있는 각 요소에 대한 설명입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-843">Below is the description of each element in the *NX_CRYPTO_METHOD* structure:</span></span>

- <span data-ttu-id="14b4a-844">nx_crypto_algorithm: 이 필드는 변수 메서드에 설명된 알고리즘을 식별합니다. NetX Secure TLS의 일부 유효한 값은 다음과 같습니다(특정 값은 nx_crypto_const.h 참조).</span><span class="sxs-lookup"><span data-stu-id="14b4a-844">nx_crypto_algorithm: This field identifies the algorithm described in the variable *method* Some valid values for NetX Secure TLS are as follows (refer to nx_crypto_const.h for specific values):</span></span>
    
  - <span data-ttu-id="14b4a-845">NX_CRYPTO_NONE</span><span class="sxs-lookup"><span data-stu-id="14b4a-845">NX_CRYPTO_NONE</span></span>    
  - <span data-ttu-id="14b4a-846">NX_CRYPTO_ENCRYPTION_NULL</span><span class="sxs-lookup"><span data-stu-id="14b4a-846">NX_CRYPTO_ENCRYPTION_NULL</span></span>    
  - <span data-ttu-id="14b4a-847">NX_CRYPTO_ENCRYPTION_AES_CBC</span><span class="sxs-lookup"><span data-stu-id="14b4a-847">NX_CRYPTO_ENCRYPTION_AES_CBC</span></span>    
  - <span data-ttu-id="14b4a-848">NX_CRYPTO_AUTHENTICATION_NONE</span><span class="sxs-lookup"><span data-stu-id="14b4a-848">NX_CRYPTO_AUTHENTICATION_NONE</span></span>    
  - <span data-ttu-id="14b4a-849">TLS_HASH_SHA_1</span><span class="sxs-lookup"><span data-stu-id="14b4a-849">TLS_HASH_SHA_1</span></span>    
  - <span data-ttu-id="14b4a-850">TLS_HASH_SHA_256</span><span class="sxs-lookup"><span data-stu-id="14b4a-850">TLS_HASH_SHA_256</span></span>    
  - <span data-ttu-id="14b4a-851">TLS_HASH_MD5</span><span class="sxs-lookup"><span data-stu-id="14b4a-851">TLS_HASH_MD5</span></span>    
  - <span data-ttu-id="14b4a-852">TLS_CIPHER_RSA</span><span class="sxs-lookup"><span data-stu-id="14b4a-852">TLS_CIPHER_RSA</span></span>    
  - <span data-ttu-id="14b4a-853">TLS_CIPHER_NULL</span><span class="sxs-lookup"><span data-stu-id="14b4a-853">TLS_CIPHER_NULL</span></span>

- <span data-ttu-id="14b4a-854">nx_crypto_key_size_in_bits: 이 필드는 메서드에 사용되는 비밀 키의 크기를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-854">nx_crypto_key_size_in_bits: this field specifies the size of the secret key used by the method.</span></span>

- <span data-ttu-id="14b4a-855">nx_crypto_IV_size_in_bits: 이 필드는 IV(Initialization Vector)의 크기를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-855">nx_crypto_IV_size_in_bits: this field specifies the size of the Initialization Vector (IV).</span></span> <span data-ttu-id="14b4a-856">대부분의 경우 IV 블록은 암호화/암호 해독 알고리즘에만 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-856">Note that in most cases the IV block is only used for encryption/decryption algorithms.</span></span> <span data-ttu-id="14b4a-857">인증 및 확인 알고리즘은 이 필드를 거의 사용하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-857">Authentication and verification algorithms rarely use this field.</span></span>

- <span data-ttu-id="14b4a-858">nx_crypto_ICV_size_in_bits: 이 필드는 ICV(무결성 검사 값) 블록의 크기를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-858">nx_crypto_ICV_size_in_bits: this field specifies the size of the Integrity Check Value (ICV) block.</span></span> <span data-ttu-id="14b4a-859">참고: 이 블록은 IPsec 사용을 위한 것이며 TLS에서 사용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-859">NOTE: This block is for IPsec usage and is unused in TLS.</span></span> <span data-ttu-id="14b4a-860">자세한 내용은 NetX Duo IPsec을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="14b4a-860">See NetX Duo IPsec for more information.</span></span>

- <span data-ttu-id="14b4a-861">nx_crypto_block_size_in_bytes: 이 필드는 블록 기반 암호에 대한 암호화 알고리즘 블록의 크기(바이트)를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-861">nx_crypto_block_size_in_bytes: this field specifies the size of the cryptographic algorithm block for block-based ciphers, in bytes.</span></span> <span data-ttu-id="14b4a-862">대부분의 경우 암호화 루틴에서 사용되며 인증 루틴에서는 거의 사용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-862">In most cases this is used by encryption routines and rarely by authentication routines.</span></span>

- <span data-ttu-id="14b4a-863">nx_crypto_metadata_area_size: 이 필드는 이 메서드에 필요한 메타데이터 영역의 크기를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-863">nx_crypto_metadata_area_size: this field specifies the size of the metadata area this method requires.</span></span> <span data-ttu-id="14b4a-864">각 구현에는 상태 정보를 저장하거나 중간 데이터(예: 키 변환 자료)를 저장하거나 스크래치 영역으로 사용하기 위한 특정 메모리가 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-864">Each implementation may require certain memory to store its state information, or to store intermediate data (such as key transformation material), or to use as a scratch area.</span></span> <span data-ttu-id="14b4a-865">구현에 필요한 공간이 이 필드에 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-865">The amount of space required by an implementation is specified in this field.</span></span> <span data-ttu-id="14b4a-866">애플리케이션은 TLS 세션을 만들 때 메모리 공간을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-866">The application provides the memory space when creating a TLS session.</span></span> <span data-ttu-id="14b4a-867">암호화 함수는 이 메타데이터 영역을 관리하는 일을 담당합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-867">The cryptographic function is responsible for managing this metadata area.</span></span>

- <span data-ttu-id="14b4a-868">nx_crypto_init: 암호화 알고리즘에 대한 초기화 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-868">nx_crypto_init: This is the initialization function for the cryptographic algorithm.</span></span> <span data-ttu-id="14b4a-869">초기화 루틴이 필요하지 않은 구현의 경우 이 필드를 NX_NULL로 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-869">For an implementation that does not need an initialization routine, this field may be set to NX_NULL.</span></span> <span data-ttu-id="14b4a-870">초기화 함수는 일반적으로 알고리즘의 내부 데이터 구조를 초기화하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-870">A typical use of an initialization function is to initialize the internal data structure for the algorithm.</span></span> <span data-ttu-id="14b4a-871">NetX Secure TLS는 내부적으로 이 함수를 호출하여 암호화 루틴의 초기화를 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-871">NetX Secure TLS will handle initialization of the cryptographic routine by calling this function internally.</span></span>

<span data-ttu-id="14b4a-872">초기화 함수의 프로토타입은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-872">The prototype for the initialization function is:</span></span>

```C
UINT crypto_init_function(NX_CRYPTO_METHOD *method, 
                          UCHAR *key, 
                          UINT  key_size_in_bits, 
                          VOID  **handle, 
                          VOID  *crypto_metadata_area, 
                          ULONG crypto_metadata_area_size);
```

  - <span data-ttu-id="14b4a-873">method는 암호화 메서드 제어 블록에 대한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-873">method is a pointer to the crypto method control block.</span></span>

  - <span data-ttu-id="14b4a-874">key는 데이터 패킷을 처리하는 비밀 키 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-874">key is the secret key string for processing the data packets.</span></span>

  - <span data-ttu-id="14b4a-875">key_size_in_bits는 비밀 키의 크기(비트)를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-875">key_size_in_bits defines the size of the secret key, in bits.</span></span>

  - <span data-ttu-id="14b4a-876">handle은 특정 암호화 세션을 식별하는 구현 정의 항목입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-876">handle is an implementation-defined item that identifies a particular crypto session.</span></span> <span data-ttu-id="14b4a-877">값은 초기화 루틴에 의해 생성되고 호출자에게 다시 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-877">The value is generated by the initialization routine, and is passed back to the caller.</span></span> <span data-ttu-id="14b4a-878">후속 암호화 작업 또는 정리 루틴은 이 핸들을 사용하여 세션을 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-878">The subsequent crypto operation or clean up routine use this handle to identify the session.</span></span>

  - <span data-ttu-id="14b4a-879">crypto_metadata는 이 알고리즘의 구현에 필요한 메타데이터 영역에 대한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-879">crypto_metadata is a pointer to the metadata area required by the implementation of this algorithm.</span></span> <span data-ttu-id="14b4a-880">메타데이터 영역이 필요 없는 알고리즘의 경우 이 필드는 NX_NULL로 설정되고 초기화 루틴은 메타데이터 영역에 액세스하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-880">For algorithms that do not need a metadata area this field is set to NX_NULL and the initialization routine must not access the metadata area.</span></span>

  - <span data-ttu-id="14b4a-881">crypto_metadata_size는 메타데이터 영역의 크기를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-881">crypto_metadata_size specifies the size of the metadata area.</span></span> <span data-ttu-id="14b4a-882">메타데이터 영역 없이 생성된 SA의 경우 이 필드는 0으로 설정되고 초기화 루틴은 메타데이터 영역에 액세스해서는 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-882">For SAs created without metadata area, this field is set to zero, and the initialization routine must not access the metadata area.</span></span>

  - <span data-ttu-id="14b4a-883">초기화 프로세스가 성공하면 이 루틴은 *NX_SUCCESS* 를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-883">This routine shall return *NX_SUCCESS* if the initialization process is successful.</span></span> <span data-ttu-id="14b4a-884">다른 반환 값은 호출자가 실패로 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-884">The caller treats any other return value as failure.</span></span>

- <span data-ttu-id="14b4a-885">nx_crypto_cleanup: 암호화 알고리즘 구현을 위해 정의된 정리 루틴입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-885">nx_crypto_cleanup: This is the cleanup routine defined for the implementation of a crypto algorithm.</span></span> <span data-ttu-id="14b4a-886">TLS 세션이 삭제되거나 다시 시작될 때 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-886">It is invoked when a TLS session is deleted or restarted.</span></span>

<span data-ttu-id="14b4a-887">정리 함수의 프로토타입은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-887">The prototype for the cleanup function is:</span></span>

```C
UINT crypto_cleanup_function(VOID *handle);
```
- <span data-ttu-id="14b4a-888">handle은 호출자에 의해 정리 함수로 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-888">handle is passed to the cleanup function by the caller.</span></span> <span data-ttu-id="14b4a-889">이 핸들은 암호화 초기화 루틴에 의해 초기화되고 암호화 알고리즘 상태를 식별하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-889">The handle is initialized by the crypto initialization routine and used to identify cryptographic algorithm state.</span></span>

- <span data-ttu-id="14b4a-890">정리 프로세스가 성공하면 이 루틴은 *NX_SUCCESS* 를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-890">This routine shall return *NX_SUCCESS* if the cleanup process is successful.</span></span> <span data-ttu-id="14b4a-891">다른 반환 값은 호출자가 실패로 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-891">The caller treats any other return value as failure.</span></span>

- <span data-ttu-id="14b4a-892">nx_crypto_operation: 실제 암호화, 암호 해독 및 인증 서비스를 수행하는 루틴입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-892">nx_crypto_operation: This is the routine that performs the actual encryption, decryption, and authentication services.</span></span> <span data-ttu-id="14b4a-893">작업 루틴의 함수 프로토타입은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-893">The function prototype of the operation routine is:</span></span>

```C
UINT crypto_operation_function(UINT   op,
          VOID  *handle,  
          NX_CRYPTO_METHOD* method,
          UCHAR *key,
          UCHAR  key_size_in_bits,
          UCHAR* input,
          ULONG  input_length_in_byte,
          UCHAR* iv_ptr,
          UCHAR* output,
          ULONG  output_length_in_byte,
          VOID *crypto_metadata,
          ULONG crypto_metadata_size,
          NX_PACKET *packet_ptr,
          VOID (*nx_crypto_hw_process_callback)(NX_PACKET 
                          *packet_ptr, UINT status));
```

- <span data-ttu-id="14b4a-894">op는 이 루틴이 수행할 것으로 예상되는 작업의 유형을 나타냅니다. 유효한 값은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-894">op indicates the type of operation this routine is expected to carry out. Valid values are:</span></span>
    
    - <span data-ttu-id="14b4a-895">NX_CRYPTO_ENCRYPT</span><span class="sxs-lookup"><span data-stu-id="14b4a-895">NX_CRYPTO_ENCRYPT</span></span>
    - <span data-ttu-id="14b4a-896">NX_CRYPTO_DECRYPT</span><span class="sxs-lookup"><span data-stu-id="14b4a-896">NX_CRYPTO_DECRYPT</span></span>
    - <span data-ttu-id="14b4a-897">NX_CRYPTO_AUTHENTICATE</span><span class="sxs-lookup"><span data-stu-id="14b4a-897">NX_CRYPTO_AUTHENTICATE</span></span>
    - <span data-ttu-id="14b4a-898">NX_CRYPTO_VERIFY</span><span class="sxs-lookup"><span data-stu-id="14b4a-898">NX_CRYPTO_VERIFY</span></span>

- <span data-ttu-id="14b4a-899">handle은 호출자에 의해 작업 함수로 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-899">handle is passed to the operation function by the caller.</span></span> <span data-ttu-id="14b4a-900">암호화 초기화 루틴에 의해 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-900">It is generated by the crypto initialization routine.</span></span>
- <span data-ttu-id="14b4a-901">method는 암호화 메서드 제어 블록을 가리킵니다</span><span class="sxs-lookup"><span data-stu-id="14b4a-901">method points to the crypto method control block</span></span>
- <span data-ttu-id="14b4a-902">key는 이 작업에 사용된 비밀 키를 가리킵니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-902">key points to the secret key used for this operation</span></span>
- <span data-ttu-id="14b4a-903">key_size_in_bits는 비밀 키의 크기(비트)입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-903">key_size_in_bits is the size of the secret key in bits</span></span>
- <span data-ttu-id="14b4a-904">input은 연산이 적용될 메시지의 시작에 대한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-904">input is a pointer to the beginning of the message to be operated on.</span></span>
- <span data-ttu-id="14b4a-905">input_length_in_byte는 연산이 적용될 메시지의 크기를 나타내기 위해 호출자가 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-905">input_length_in_byte is passed by the caller to indicate the size of the message to be operated on.</span></span>
- <span data-ttu-id="14b4a-906">iv_ptr은 IV 블록의 시작을 가리키도록 호출자가 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-906">iv_ptr is setup by the caller to point to the beginning of an IV block.</span></span> <span data-ttu-id="14b4a-907">IV 블록에 대한 메모리는 호출자가 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-907">Note that the memory for the IV block is provided by the caller.</span></span> <span data-ttu-id="14b4a-908">암호화를 위해서는 작업 함수가 IV 정보를 이 메모리 블록에 기록해야 하고, 암호 해독을 위해서는 작업 함수가 이 메모리 블록에서 IV 정보를 검색해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-908">For encryption, the operation function should write the IV information into this memory block; for decryption, the operation function should retrieve the IV information from this memory block.</span></span> <span data-ttu-id="14b4a-909">인증 및 확인 작업을 위한 알고리즘은 일반적으로 초기화 벡터를 사용하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-909">Algorithms for authentication and verification operation typically do not use the initialization vector.</span></span>
- <span data-ttu-id="14b4a-910">output은 출력 버퍼를 가리키도록 호출자가 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-910">output is setup by the caller to point to an output buffer.</span></span> <span data-ttu-id="14b4a-911">출력 버퍼의 메모리는 호출자가 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-911">Note that the memory for the output buffer is provided by the caller.</span></span> <span data-ttu-id="14b4a-912">암호화를 위해서는 작업 함수가 출력 버퍼에 암호 텍스트를 작성해야 합니다. 암호 해독을 위해서는 작업 함수가 해독된 텍스트(일반 텍스트)를 출력 버퍼에 기록해야 합니다. 인증을 위해서는 해시 값이 출력 버퍼에 기록됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-912">For encryption, the operation function should write the cipher text to the output buffer; for decryption, the operation should write the deciphered text (clear text) to the output buffer; for authentication, the hash value shall be written to the output buffer.</span></span> <span data-ttu-id="14b4a-913">검증을 위해 출력 버퍼는 해시 정보를 저장하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-913">For verification, the output buffer is used to store hash information.</span></span>
- <span data-ttu-id="14b4a-914">output_length_in_byte는 출력 버퍼의 크기를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-914">output_length_in_byte indicates the size of the output buffer</span></span>
- <span data-ttu-id="14b4a-915">crypto_metadata는 암호화 작업에 사용될 메타데이터 영역을 가리킵니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-915">crypto_metadata points to the metadata area to be used by this crypto operation.</span></span> <span data-ttu-id="14b4a-916">암호화 메타데이터 영역은 일반적으로 crypto_init_function에 의해 초기화됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-916">The crypto metadata area is typically initialized by crypto_init_function.</span></span>
- <span data-ttu-id="14b4a-917">crypto_metadata_size는 메타데이터 영역의 크기를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-917">crypto_metadata_size indicates the size of the metadata area.</span></span>
- <span data-ttu-id="14b4a-918">작업 프로세스가 성공하면 이 루틴은 *NX_SUCCESS* 를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-918">This routine shall return *NX_SUCCESS* if the operation process is successful.</span></span> <span data-ttu-id="14b4a-919">다른 반환 값은 호출자가 실패로 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-919">The caller treats any other return value as failure.</span></span>
- <span data-ttu-id="14b4a-920">packet_ptr: 처리되는 데이터가 포함된 패킷입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-920">packet_ptr: The packet that contains the data being processed.</span></span> <span data-ttu-id="14b4a-921">참고: 이 매개 변수는 TLS에서 사용되지 않으며 NX_NULL로 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-921">NOTE: This parameter is unused by TLS and should be set to NX_NULL.</span></span>
- <span data-ttu-id="14b4a-922">nx_crypto_hw_process_callback: 암호화 메서드가 제공하는 콜백 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-922">nx_crypto_hw_process_callback: A callback function provided by the encryption method.</span></span> <span data-ttu-id="14b4a-923">암호화 함수가 하드웨어에서 제공되고 콜백 루틴이 필요한 경우 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-923">This is used if the crypto function is provided by hardware and requires a callback routine.</span></span>

<span data-ttu-id="14b4a-924">NetX Secure TLS는 다음과 같은 암호화 메서드를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-924">NetX Secure TLS provides the following encryption methods:</span></span>

- <span data-ttu-id="14b4a-925">*AES*</span><span class="sxs-lookup"><span data-stu-id="14b4a-925">*AES*</span></span>  
- <span data-ttu-id="14b4a-926">*RSA*</span><span class="sxs-lookup"><span data-stu-id="14b4a-926">*RSA*</span></span>  
- <span data-ttu-id="14b4a-927">*NULL*</span><span class="sxs-lookup"><span data-stu-id="14b4a-927">*NULL*</span></span>

<span data-ttu-id="14b4a-928">NetX Secure TLS는 다음과 같은 인증 메서드를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-928">NetX Secure TLS provides the following authentication methods:</span></span>

- <span data-ttu-id="14b4a-929">*HMAC-MD5*</span><span class="sxs-lookup"><span data-stu-id="14b4a-929">*HMAC-MD5*</span></span>  
- <span data-ttu-id="14b4a-930">*HMAC-SHA1*</span><span class="sxs-lookup"><span data-stu-id="14b4a-930">*HMAC-SHA1*</span></span>  
- <span data-ttu-id="14b4a-931">*HMAC-SHA256*</span><span class="sxs-lookup"><span data-stu-id="14b4a-931">*HMAC-SHA256*</span></span>

<span data-ttu-id="14b4a-932">다음 예는 NetX Duo IPsec에서 제공하는 암호화 및 인증 메서드를 사용하도록 *NX_CRYPTO_METHOD* 구조체를 구성하는 방법을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-932">The following examples illustrate how to configure the *NX_CRYPTO_METHOD* structure to use the encryption and authentication methods provided by NetX Duo IPsec.</span></span>

<span data-ttu-id="14b4a-933">***AES:***</span><span class="sxs-lookup"><span data-stu-id="14b4a-933">***AES:***</span></span>

```C
/* AES-CBC 128. */
NX_CRYPTO_METHOD crypto_method_aes_cbc_128 = 
{
    /* AES crypto algorithm                             */
    NX_CRYPTO_ENCRYPTION_AES_CBC,                       

    /* Key size in bits. For AES-128 this value is 128  */
    NX_CRYPTO_AES_128_KEY_LEN_IN_BITS,              
   
    /* IV size in bits.  For AES-128 this value is 128  */
    NX_CRYPTO_AES_IV_LEN_IN_BITS,

    /* ICV size in bits, not used.                      */
    0,                                              

    /* Block size in bytes.  For AES this value is 16   */
    (NX_CRYPTO_AES_BLOCK_SIZE_IN_BITS >> 3),        

    /* Metadata size in bytes, for AES this value is 262*/
    sizeof(NX_CRYPTO_AES),              

    /* AES-CBC initialization routine.                  */
    _nx_secure_crypto_method_aes_init,               

    /* AES-CBC cleanup routine, not used.               */
    NX_NULL,                                        

    /* AES-CBC operation                                */
    _nx_secure_crypto_method_aes_operation           
};

/* RSA. */
NX_CRYPTO_METHOD crypto_method_rsa = 
{
    /* RSA crypto algorithm                             */
    TLS_CIPHER_RSA,                       

    /* Key size. RSA key sizes vary, so set to 0.         */
    0,              
   
    /* IV size in bits.  RSA does not use an IV.         */
    0,

    /* ICV size in bits, not used.                      */
    0,                                              

    /* Block size in bytes.  RSA does not have a block size. */
    0,        

    /* Metadata size in bytes, for RSA use the control block. */
    sizeof(NX_CRYPTO_RSA),              

    /* RSA initialization routine.                  */
    _nx_secure_crypto_method_rsa_init,               

    /* Cleanup routine, not used.                    */
    NX_NULL,                                        

    /* RSA operation                                */
    _nx_secure_crypto_method_rsa_operation           

};
```
<span data-ttu-id="14b4a-934">***NULL***</span><span class="sxs-lookup"><span data-stu-id="14b4a-934">***NULL***</span></span>

```C
/* NULL encryption method. */
NX_CRYPTO_METHOD crypto_method_null = 
{
    NX_CRYPTO_ENCRYPTION_NULL,/* Name of the crypto algorithm  */
    0,                        /* Key size in bits, not used    */
    0,                        /* IV size in bits, not used     */
    0,                        /* ICV size in bits, not used    */
    4,                        /* Block size in bytes           */
    0,                        /* Metadata size in bytes        */
    NX_NULL,                  /* Initialization routine,unused */
    NX_NULL,                  /* Cleanup routine, not used     */
    _nx_secure_crypto_method_null_operation  /* NULL operation  
*/
}; 
```
<span data-ttu-id="14b4a-935">***HMAC-SHA1***</span><span class="sxs-lookup"><span data-stu-id="14b4a-935">***HMAC-SHA1***</span></span>
```C
NX_CRYPTO_METHOD crypto_method_hmac_sha1 = 
{
    /* HMAC SHA1 algorithm                               */
    TLS_HASH_SHA1,            


    /* Key size in bits. For HMAC-SHA1 this value is 160 */ 
    NX_CRYPTO_HMAC_SHA1_KEY_LEN_IN_BITS,              

    /* IV size in bits, not used                         */
    0,                                            

    /* Transmitted ICV size in bits. Unused.             */
    0, 

    /* Block size in bytes, not used                     */
    0,                                            

    /* Metadata size in bytes                            */
    sizeof(NX_SHA1_HMAC),                                            

    /* Initialization routine, not used                  */
    NX_NULL,                                      

    /* Cleanup routine, not used                         */
    NX_NULL,                                          

    /* HMAC SHA1 operation                               */
    _nx_secure_crypto_method_hmac_sha1_operation   
};
```
<span data-ttu-id="14b4a-936">***NONE***</span><span class="sxs-lookup"><span data-stu-id="14b4a-936">***NONE***</span></span>

<span data-ttu-id="14b4a-937">특수 메서드 **NX_CRYPTO_NONE** 은 암호화 또는 인증 서비스가 필요하지 않다고 IPsec 모듈에 알리는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-937">A special method **NX_CRYPTO_NONE** is used to signal the IPsec module that the encryption or the authentication service is not required.</span></span> <span data-ttu-id="14b4a-938">다음과 같이 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-938">It is configured as follows:</span></span>

```C
/* NX_CRYPTO_NONE means encryption or authentication
   method is not needed.  */
NX_CRYPTO_METHOD crypto_method_none = 
{
    NX_CRYPTO_NONE,       /* Name of the crypto algorithm */
    0,                    /* Key size in bits, not used   */
    0,                    /* IV size in bits, not used    */
    0,                    /* ICV size in bits, not used   */
    0,                    /* Block size in bytes          */
    0,                    /* Metadata size in bytes       */
    NX_NULL,              /* Initialization routine, not used */
    NX_NULL,              /* Cleanup routine, not used    */
    NX_NULL               /* NULL operation               */
};                                               
```
### <a name="initializing-tls-with-cryptographic-methods"></a><span data-ttu-id="14b4a-939">암호화 메서드로 TLS 초기화</span><span class="sxs-lookup"><span data-stu-id="14b4a-939">Initializing TLS with Cryptographic Methods</span></span>

<span data-ttu-id="14b4a-940">이전 섹션에서 설명한 암호화 메서드 서명을 따르는 암호화 루틴을 만든 후에는 NX_SECURE_TLS_SESSION 제어 블록을 초기화할 때 TLS에 전달해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-940">Once you have created your cryptographic routines conforming to the cryptographic method signatures described in the previous section, you will need to pass them into TLS when you initialize an NX_SECURE_TLS_SESSION control block.</span></span> <span data-ttu-id="14b4a-941">이 작업은 TLS 서비스 nx_secure_tls_session_create에서 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-941">This is done in the TLS service nx_secure_tls_session_create:</span></span>

```C
UINT  nx_secure_tls_session_create(
              NX_SECURE_TLS_SESSION*     session_ptr,
              const NX_SECURE_TLS_CRYPTO*    tls_cipher_table,
              VOID*                encryption_metadata_area,
              ULONG                 encryption_metadata_size
);
```
- <span data-ttu-id="14b4a-942">session_pointer는 NX_SECURE_TLS_SESSION 제어 블록에 대한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-942">session_pointer is a pointer to your NX_SECURE_TLS_SESSION control block.</span></span>
- <span data-ttu-id="14b4a-943">tls_cipher_table은 NX_SECURE_TLS_CRYPTO 제어 블록(아래에 설명됨)에 대한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-943">tls_cipher_table is a pointer to an NX_SECURE_TLS_CRYPTO control block, described below.</span></span>
- <span data-ttu-id="14b4a-944">encryption_metadata_area는 TLS의 암호화 루틴이 사용하는 공간을 가리킵니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-944">encryption_metadata_area points to space used by cryptographic routines in TLS.</span></span>
- <span data-ttu-id="14b4a-945">encryption_metadata_size는 메타데이터 영역의 크기(바이트)입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-945">encryption_metadata_size is the size of the metadata area in bytes.</span></span>

### <a name="elliptic-curve-cryptography-ecc-in-netx-secure-tls"></a><span data-ttu-id="14b4a-946">NetX Secure TLS의 ECC(타원 곡선 암호화)</span><span class="sxs-lookup"><span data-stu-id="14b4a-946">Elliptic Curve Cryptography (ECC) in NetX Secure TLS</span></span>

<span data-ttu-id="14b4a-947">ECC(타원 곡선 암호화)는 RSA 대신 사용할 수 있는 공개 키 암호화 체계를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-947">Elliptic Curve Cryptography (ECC) provides a public-key cryptography scheme that can be used instead of RSA.</span></span> <span data-ttu-id="14b4a-948">ECC는 일반적으로 더 빠르며 RSA보다 작은 키를 사용하므로 임베디드 TLS에 유용한 옵션이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-948">ECC is typically faster and uses smaller keys than RSA so it can be a valuable option for embedded TLS.</span></span> <span data-ttu-id="14b4a-949">Azure RTOS 6.0 이전의 X-Ware 버전에는 ECC가 추가 기능으로 제공되어 프로젝트에 ECC 소스 코드를 설치해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-949">In X-Ware versions prior to Azure RTOS 6.0, ECC was shipped as an add-on, requiring installation of the ECC source code into your project.</span></span> <span data-ttu-id="14b4a-950">Azure RTOS 6.0은 ECC를 주류 코드베이스에 통합하기 때문에 더 이상 ECC 파일을 설치할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-950">Azure RTOS 6.0 integrated ECC into the mainline codebase so installation of the ECC files is no longer necessary.</span></span> <span data-ttu-id="14b4a-951">하지만 ECC에는 이전 버전과 동일한 초기화가 여전히 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-951">However, ECC still requires the same initialization as those previous versions.</span></span>

### <a name="supported-ecc-curves"></a><span data-ttu-id="14b4a-952">지원되는 ECC 곡선</span><span class="sxs-lookup"><span data-stu-id="14b4a-952">Supported ECC curves</span></span>

<span data-ttu-id="14b4a-953">NetX Secure는 <http://www.secg.org/sec2-v2.pdf>에 따라 곡선의 일부를 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-953">NetX Secure implements parts of the curves as per <http://www.secg.org/sec2-v2.pdf>.</span></span> <span data-ttu-id="14b4a-954">다음 곡선이 지원됩니다<sup>18</sup>.</span><span class="sxs-lookup"><span data-stu-id="14b4a-954">Thefollowing curves are supported<sup>18</sup>:</span></span>

  - <span data-ttu-id="14b4a-955">secp256r1</span><span class="sxs-lookup"><span data-stu-id="14b4a-955">secp256r1</span></span> 
  - <span data-ttu-id="14b4a-956">secp384r1</span><span class="sxs-lookup"><span data-stu-id="14b4a-956">secp384r1</span></span> 
  - <span data-ttu-id="14b4a-957">secp521r1</span><span class="sxs-lookup"><span data-stu-id="14b4a-957">secp521r1</span></span> 

<span data-ttu-id="14b4a-958">다른 ECC 곡선이 사용되면 *nx_secure_tls_session_start()* 루틴은 지원되지 않는 곡선이 사용되었음을 나타내는 NX_SECURE_TLS_NO_SUPPORTED_CIPHERS 오류를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-958">If other ECC curves are used, the *nx_secure_tls_session_start()* routine will return the error NX_SECURE_TLS_NO_SUPPORTED_CIPHERS indicating that unsupported curves were used.</span></span>

<span data-ttu-id="14b4a-959">TLS 인증서 체인은 ECC 알고리즘으로도 암호화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-959">Note that TLS certificate chain may be encrypted by ECC-algorithms as well.</span></span> <span data-ttu-id="14b4a-960">TLS 클라이언트가 제공한 곡선이 지원되더라도 인증서 체인에 사용된 ECC 곡선이 지원되지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-960">Even though the curves provided by the TLS Client are supported, it is possible that the ECC curve used in the certificate chain is not supported.</span></span> <span data-ttu-id="14b4a-961">이 경우 *nx_secure_tls_session_start* 루틴은 NX_SECURE_TLS_UNSUPPORTED_PUBLIC_CIPHER를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-961">In this case, *nx_secure_tls_session_start* routine returns NX_SECURE_TLS_UNSUPPORTED_PUBLIC_CIPHER.</span></span>

<span data-ttu-id="14b4a-962">ECC에 대한 기본 ciphersuite 테이블 예제는 nx_crypto_generic_ciphersuites.c에 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-962">A default ciphersuite table example for ECC is provided in nx_crypto_generic_ciphersuites.c.</span></span> <span data-ttu-id="14b4a-963">ciphersuite 테이블에 대한 자세한 내용은 "TLS 암호화 암호 테이블" 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="14b4a-963">See section "TLS Cryptographic Cipher Table" for more information on ciphersuite tables.</span></span>

18. <span data-ttu-id="14b4a-964">secp192r1 및 secp224r1 곡선에 대한 구현은 레거시 애플리케이션에도 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-964">Note that implementations for the curves secp192r1 and secp224r1are also provided for legacy applications.</span></span> <span data-ttu-id="14b4a-965">단, 이러한 곡선은 이제 약하기 때문에 새로운 애플리케이션 개발에 사용해서는 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-965">However these curves are now considered weak and SHOULD NOT be used for new application development.</span></span>

### <a name="crypto-methods-for-ecc"></a><span data-ttu-id="14b4a-966">ECC의 암호화 메서드</span><span class="sxs-lookup"><span data-stu-id="14b4a-966">Crypto Methods for ECC</span></span>

<span data-ttu-id="14b4a-967">타원 곡선 그룹의 암호화 메서드:</span><span class="sxs-lookup"><span data-stu-id="14b4a-967">Crypto methods for Elliptic Curve groups:</span></span>

- <span data-ttu-id="14b4a-968">NX_CRYPTO_METHOD crypto_method_ec_secp192<sup>15</sup>;</span><span class="sxs-lookup"><span data-stu-id="14b4a-968">NX_CRYPTO_METHOD crypto_method_ec_secp192<sup>15</sup>;</span></span>  
- <span data-ttu-id="14b4a-969">NX_CRYPTO_METHOD crypto_method_ec_secp224<sup>15</sup>;</span><span class="sxs-lookup"><span data-stu-id="14b4a-969">NX_CRYPTO_METHOD crypto_method_ec_secp224<sup>15</sup>;</span></span>  
- <span data-ttu-id="14b4a-970">NX_CRYPTO_METHOD crypto_method_ec_secp256;</span><span class="sxs-lookup"><span data-stu-id="14b4a-970">NX_CRYPTO_METHOD crypto_method_ec_secp256;</span></span>  
- <span data-ttu-id="14b4a-971">NX_CRYPTO_METHOD crypto_method_ec_secp384;</span><span class="sxs-lookup"><span data-stu-id="14b4a-971">NX_CRYPTO_METHOD crypto_method_ec_secp384;</span></span>  
- <span data-ttu-id="14b4a-972">NX_CRYPTO_METHOD crypto_method_ec_secp521;</span><span class="sxs-lookup"><span data-stu-id="14b4a-972">NX_CRYPTO_METHOD crypto_method_ec_secp521;</span></span>

<span data-ttu-id="14b4a-973">ECC 곡선의 암호화 메서드는 nx_crypto_generic_ciphersuites.c에 정의되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-973">The crypto methods for ECC curves are defined in nx_crypto_generic_ciphersuites.c.</span></span>

<span data-ttu-id="14b4a-974">ECDHE의 암호화 메서드:</span><span class="sxs-lookup"><span data-stu-id="14b4a-974">Crypto method for ECDHE:</span></span>

- <span data-ttu-id="14b4a-975">NX_CRYPTO_METHOD crypto_method_ecdhe;</span><span class="sxs-lookup"><span data-stu-id="14b4a-975">NX_CRYPTO_METHOD crypto_method_ecdhe;</span></span>

<span data-ttu-id="14b4a-976">ECDSA의 암호화 메서드:</span><span class="sxs-lookup"><span data-stu-id="14b4a-976">Crypto method for ECDSA:</span></span>

- <span data-ttu-id="14b4a-977">NX_CRYPTO_METHOD crypto_method_ecdsa;</span><span class="sxs-lookup"><span data-stu-id="14b4a-977">NX_CRYPTO_METHOD crypto_method_ecdsa;</span></span>

<span data-ttu-id="14b4a-978">ECDSA 및 ECDHE 암호화 메서드는 nx_crypto_generic_ciphersuites.c에 정의되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-978">ECDSA and ECDHE crypto methods are defined in nx_crypto_generic_ciphersuites.c.</span></span>

<span data-ttu-id="14b4a-979">RSA, SHA, AES와 같은 다른 암호화 메서드와 결합하여, ciphersuite 조회 테이블의 기본 구성 요소로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-979">Combined with other crypto methods such as RSA, SHA, AES, they can be used as building blocks for the ciphersuite lookup table.</span></span>

### <a name="enabling-ecc-support-for-tls"></a><span data-ttu-id="14b4a-980">TLS에 대한 ECC 지원 사용</span><span class="sxs-lookup"><span data-stu-id="14b4a-980">Enabling ECC Support for TLS</span></span>

<span data-ttu-id="14b4a-981">ECC는 TLS에 대해 기본적으로 사용하도록 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-981">ECC is enabled by default for TLS.</span></span> <span data-ttu-id="14b4a-982">ECC 지원을 사용하지 않도록 설정하려면 NX_SECURE_DISABLE_ECC_CIPHERSUITE 기호를 정의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-982">To disable ECC support, the symbol NX_SECURE_DISABLE_ECC_CIPHERSUITE must be defined.</span></span>

<span data-ttu-id="14b4a-983">변경 내용을 적용하려면 NetX Secure 라이브러리와 이 라이브러리를 사용하는 모든 애플리케이션을 다시 작성해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-983">For the change to take effect, you will need to rebuild the NetX Secure Library and all applications that use that library.</span></span>

<span data-ttu-id="14b4a-984">애플리케이션 코드에서 TLS 세션이 만들어진 후 API n *x_secure_tls_ecc_initialize()* 를 호출해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-984">In the application code, the API n *x_secure_tls_ecc_initialize()* must be called after the TLS session is created.</span></span> <span data-ttu-id="14b4a-985">이 API는 TLS 키 교환 작업 및 인증서 확인에 사용할 곡선 유형을 TLS 세션에 알립니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-985">This API notifies the TLS session of the type of curves to be used for TLS key exchange operations and certificate verification.</span></span> <span data-ttu-id="14b4a-986">TLS 핸드셰이크 단계 중 ECC 알고리즘이 선택되면 클라이언트와 서버는 사용할 곡선을 결정하기 위해 ECC 곡선 관련 매개 변수를 교환합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-986">During the TLS handshake phase, if an ECC algorithm is selected the client and server exchange ECC curve-related parameters to decide which curve to use.</span></span>

<span data-ttu-id="14b4a-987">다음 코드 세그먼트는 API 사용 방법을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-987">The following code segment illustrates how to use the API.</span></span> <span data-ttu-id="14b4a-988">인수(*nx_crypto_ecc_supported_groups, nx_crypto_ecc_supported_groups_size, nx_crypto_ecc_curves)* 는 모두 *nx_crypto_generic_ciphersuites.c* 에 정의되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-988">Note that the arguments (*nx_crypto_ecc_supported_groups, nx_crypto_ecc_supported_groups_size, and nx_crypto_ecc_curves)* are all defined in *nx_crypto_generic_ciphersuites.c*.</span></span> <span data-ttu-id="14b4a-989">따라서 이러한 기호를 직접 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-989">Therefore these symbols can be used directly.</span></span>

```C
status = nx_secure_tls_ecc_initialize(&tls_session,     
                    nx_crypto_ecc_supported_groups,      
                    nx_crypto_ecc_supported_groups_size,     
                    nx_crypto_ecc_curves);
```
<span data-ttu-id="14b4a-990">nx_crypto_generic_ciphersuites.c의 예제 구성에는 ECC가 활성화된 경우 사용되는 ECC ciphersuite 조회 테이블이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-990">The example configuration in nx_crypto_generic_ciphersuites.c contains an ECC ciphersuite lookup table that is used when ECC is enabled.</span></span> <span data-ttu-id="14b4a-991">ECC를 사용하려면 nx_secure_tls_session_create를 사용하여 TLS 세션을 생성할 때 nx_crypto_tls_ciphers_ecc를 ciphersuite 테이블 매개 변수로 전달하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-991">To use ECC, simply pass nx_crypto_tls_ciphers_ecc as the ciphersuite table parameter when creating TLS sessions with nx_secure_tls_session_create.</span></span> <span data-ttu-id="14b4a-992">예제 테이블에는 ECC 및 비ECC ciphersuite가 모두 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-992">The example table contains both ECC and non-ECC ciphersuites.</span></span>

### <a name="tls-cryptographic-cipher-table"></a><span data-ttu-id="14b4a-993">TLS 암호화 암호 테이블</span><span class="sxs-lookup"><span data-stu-id="14b4a-993">TLS Cryptographic Cipher Table</span></span>

<span data-ttu-id="14b4a-994">NX_SECURE_TLS_CRYPTO 구조체는 다음과 같이 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-994">The NX_SECURE_TLS_CRYPTO structure is defined as:</span></span>

```C
typedef struct NX_SECURE_METHODS_STRUCT
{
    /* Table that maps ciphersuites to crypto methods. */
    NX_SECURE_TLS_CIPHERSUITE_INFO* nx_secure_tls_ciphersuite_lookup_table;
    USHORT nx_secure_tls_ciphersuite_lookup_table_size;

    /* Table that maps X.509 cipher identifiers to crypto methods. */
    NX_SECURE_X509_CRYPTO *nx_secure_tls_x509_cipher_table;
    USHORT nx_secure_tls_x509_cipher_table_size;

    /* Specific routines needed for specific TLS versions. */
#if (NX_SECURE_TLS_TLS_1_0_ENABLED || NX_SECURE_TLS_TLS_1_1_ENABLED)
    NX_CRYPTO_METHOD *nx_secure_tls_handshake_hash_md5_method;
    NX_CRYPTO_METHOD *nx_secure_tls_handshake_hash_sha1_method;
    NX_CRYPTO_METHOD *nx_secure_tls_prf_1_method;
#endif

#if (NX_SECURE_TLS_TLS_1_2_ENABLED)
    NX_CRYPTO_METHOD *nx_secure_tls_handshake_hash_sha256_method;
    NX_CRYPTO_METHOD *nx_secure_tls_prf_sha256_method;
#endif

#if (NX_SECURE_TLS_TLS_1_3_ENABLED)
    const NX_CRYPTO_METHOD *nx_secure_tls_hkdf_method;
    const NX_CRYPTO_METHOD *nx_secure_tls_hmac_method;
    const NX_CRYPTO_METHOD *nx_secure_tls_ecdhe_method;
#endif

} NX_SECURE_TLS_CRYPTO;
```
<span data-ttu-id="14b4a-995">테이블은 NetX Secure TLS 프로젝트 내에 있는 정적 상수에(일반적으로 암호화 루틴 및 모듈과 함께 있음) 이 구조체의 항목을 채워서 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-995">The table is created by filling in the entries for this structure in a static constant located within the NetX Secure TLS project, usually located with the cryptographic routines and modules.</span></span>

<span data-ttu-id="14b4a-996">예를 들어 NetX Secure와 함께 제공되는 소프트웨어 전용("일반") 암호화 라이브러리에는 다음과 같은 테이블 정의가 포함되어 있습니다(비 ECC ciphersuite 지원용<sup>19</sup>).</span><span class="sxs-lookup"><span data-stu-id="14b4a-996">As an example, the software-only ("generic") cryptographic library provided with NetX Secure contains the following table definition (for non-ECC ciphersuite support<sup>19</sup>):</span></span>

```C
/* Define the cipher table object we can pass into TLS. */
const NX_SECURE_TLS_CRYPTO nx_crypto_tls_ciphers =
{
    /* TLS Ciphersuite lookup table and size. */
    _nx_crypto_ciphersuite_lookup_table,
    sizeof(_nx_crypto_ciphersuite_lookup_table) / 
    sizeof(NX_SECURE_TLS_CIPHERSUITE_INFO),

    /* X.509 certificate cipher table and size. */
    _nx_crypto_x509_cipher_lookup_table,
    sizeof(_nx_crypto_x509_cipher_lookup_table) / sizeof(NX_SECURE_X509_CRYPTO),

    /* TLS version-specific methods. */
#if (NX_SECURE_TLS_TLS_1_0_ENABLED || NX_SECURE_TLS_TLS_1_1_ENABLED)
    &crypto_method_md5,
    &crypto_method_sha1,
    &crypto_method_tls_prf_1,
#endif

#if (NX_SECURE_TLS_TLS_1_2_ENABLED)
    &crypto_method_sha256,
    &crypto_method_tls_prf_sha_256
#endif

#if (NX_SECURE_TLS_TLS_1_3_ENABLED)
    &crypto_method_hkdf,
    &crypto_method_hmac,
    &crypto_method_ecdhe,
#endif
};
```
<span data-ttu-id="14b4a-997">구조체에서 첫 번째 엔트리는 TLS ciphersuite 테이블입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-997">In the structure, the first entry is the TLS ciphersuite table.</span></span> <span data-ttu-id="14b4a-998">NX_SECURE_TLS_CIPHERSUITE_INFO 구조체는 암호화 루틴(NX_CRYPTO_METHOD 포인터 형태)을 TLS 사양에 정의된 특정 ciphersuite에 매핑합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-998">The NX_SECURE_TLS_CIPHERSUITE_INFO structure maps cryptographic routines (in the form of NX_CRYPTO_METHOD pointers) to specific ciphersuites as defined in the TLS specifications.</span></span> <span data-ttu-id="14b4a-999">두 번째 값은 첫 번째 필드가 가리키는 테이블의 항목 수입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-999">The second value is the number of entries in the table pointed to by the first field.</span></span>

<span data-ttu-id="14b4a-1000">다음 필드는 디지털 인증서를 처리할 때 X.509에 사용되는 루틴 테이블을 가리키며 NX_SECURE_X509_CRYPTO 구조체의 형태는 NX_SECURE_TLS_CIPHERSUITE_INFO와 유사합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-1000">The next field points to a table of routines used by X.509 when processing digital certificates and the structure NX_SECURE_X509_CRYPTO is similar in form to NX_SECURE_TLS_CIPHERSUITE_INFO.</span></span> <span data-ttu-id="14b4a-1001">다음 필드는 테이블의 항목 수입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-1001">The following field is the number of entries in the table.</span></span>

<span data-ttu-id="14b4a-1002">조회 테이블 다음에는 특정 버전의 TLS에 필요한 여러 루틴이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-1002">Following the lookup table are a number of routines needed for specific versions of TLS.</span></span> <span data-ttu-id="14b4a-1003">예를 들어 TLS 버전 1.2 이전에는 키 생성 및 핸드셰이크 해시 루틴이 SHA-1과 MD5의 조합을 사용하도록 고정되었습니다. 이러한 루틴용 메서드는 특정 ciphersuite에 묶여 있지 않기 때문에 특별히 암호 구조체로 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-1003">For example, prior to TLS version 1.2, the key generation and handshake hashing routines were fixed to use a combination of SHA-1 and MD5 – the methods for these routines are called out specifically in the cipher structure since they are not tied to specific ciphersuites.</span></span> <span data-ttu-id="14b4a-1004">TLS 버전 1.2에서는 키 생성 및 해시 루틴이 ciphersuite에 의해 선택되지만 사용할 루틴을 지정하지 않는 ciphersuite의 경우 SHA-256 해시 메서드가 사용되며 암호 구조체는 해당 루틴을 명확하게 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-1004">In TLS version 1.2, the key generation and hashing routines are chosen by the ciphersuite, but for ciphersuites which do not specify the routines to use, the SHA-256 hash method is used, and the cipher structure calls out that routine specifically.</span></span>

<span data-ttu-id="14b4a-1005">TLS 1.3에는 다양한 작업을 위해 몇 가지 추가 특정 암호가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-1005">TLS 1.3 requires a few extra specific ciphers for various operations.</span></span>

19. <span data-ttu-id="14b4a-1006">TLS 1.3 지원에는 ECC가 필요합니다. TLS 1.3이 활성화된 경우 nx_crypto_tls_ciphers_ecc를 사용하십시오.</span><span class="sxs-lookup"><span data-stu-id="14b4a-1006">Note that TLS 1.3 support requires ECC – use nx_crypto_tls_ciphers_ecc if TLS 1.3 is enabled.</span></span>

### <a name="tls-ciphersuite-lookup-table"></a><span data-ttu-id="14b4a-1007">TLS Ciphersuite 조회 테이블</span><span class="sxs-lookup"><span data-stu-id="14b4a-1007">TLS Ciphersuite Lookup Table</span></span>

<span data-ttu-id="14b4a-1008">TLS에 대한 암호 테이블을 채우려면 암호화 루틴을 특정 ciphersuite 식별자에 매핑하는 ciphersuite 조회 테이블도 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-1008">To fill in the cipher table for TLS, you will also need to create a ciphersuite lookup table that maps cryptographic routines to specific ciphersuite identifiers.</span></span> <span data-ttu-id="14b4a-1009">식별자는 보편적인 IANA 등록 값입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-1009">The identifiers are IANA-registered values that are universal.</span></span> <span data-ttu-id="14b4a-1010">자세한 내용은 TLS RFC를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="14b4a-1010">See the TLS RFCs for more information.</span></span> <span data-ttu-id="14b4a-1011">루틴은 각 ciphersuite에 사용되는 5가지 개별 메서드인 공개 암호, 공개 키 인증, 세션 암호, 세션 해시 루틴, TLS PRF(Pseudo-Random Function)를 나타냅니다(일부 ciphersuite는 5가지를 모두 사용하지 않을 수 있음).</span><span class="sxs-lookup"><span data-stu-id="14b4a-1011">The routines represent the 5 separate methods used in each ciphersuite (some ciphersuites may not use all 5): public cipher, public-key authentication, session cipher, session hash routine, and TLS Pseudo-Random Function (PRF).</span></span> <span data-ttu-id="14b4a-1012">다음 표에는 5가지 메서드 각각에 대한 설명이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-1012">The following table explains each of the 5 methods:</span></span>

| <span data-ttu-id="14b4a-1013">**루틴 범주**</span><span class="sxs-lookup"><span data-stu-id="14b4a-1013">**Routine category**</span></span>      | <span data-ttu-id="14b4a-1014">**설명**</span><span class="sxs-lookup"><span data-stu-id="14b4a-1014">**Description**</span></span>                                                                                       | <span data-ttu-id="14b4a-1015">**예제 알고리즘**</span><span class="sxs-lookup"><span data-stu-id="14b4a-1015">**Example algorithms**</span></span>                                            |
| ------------------------- | ----------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------- |
| <span data-ttu-id="14b4a-1016">공개 암호</span><span class="sxs-lookup"><span data-stu-id="14b4a-1016">Public cipher</span></span>             | <span data-ttu-id="14b4a-1017">TLS 핸드셰이크 중 키를 교환하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-1017">Used to exchange keys during the TLS handshake</span></span>                                                        | <span data-ttu-id="14b4a-1018">RSA, Diffie-Hellman, ECC</span><span class="sxs-lookup"><span data-stu-id="14b4a-1018">RSA, Diffie-Hellman, ECC</span></span>                                          |
| <span data-ttu-id="14b4a-1019">공개 키 인증</span><span class="sxs-lookup"><span data-stu-id="14b4a-1019">Public-key authentication</span></span> | <span data-ttu-id="14b4a-1020">TLS 핸드셰이크 중 데이터를 인증하거나 서명하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-1020">Used to authenticate or sign data during the TLS handshake</span></span>                                            | <span data-ttu-id="14b4a-1021">RSA, DSS</span><span class="sxs-lookup"><span data-stu-id="14b4a-1021">RSA, DSS</span></span>                                                          |
| <span data-ttu-id="14b4a-1022">세션 암호</span><span class="sxs-lookup"><span data-stu-id="14b4a-1022">Session cipher</span></span>            | <span data-ttu-id="14b4a-1023">TLS 세션 중 애플리케이션 데이터를 암호화하는 데 사용되는 대칭 키 알고리즘</span><span class="sxs-lookup"><span data-stu-id="14b4a-1023">Symmetric-key algorithm used to encrypt application data during the TLS session</span></span>                       | <span data-ttu-id="14b4a-1024">AES, RC4</span><span class="sxs-lookup"><span data-stu-id="14b4a-1024">AES, RC4</span></span>                                                          |
| <span data-ttu-id="14b4a-1025">세션 해시</span><span class="sxs-lookup"><span data-stu-id="14b4a-1025">Session hash</span></span>              | <span data-ttu-id="14b4a-1026">TLS 세션 중 메시지의 무결성을 유지하는 데 사용됨(데이터가 변경되지 않도록 보장)</span><span class="sxs-lookup"><span data-stu-id="14b4a-1026">Used to preserve the integrity of messages during the TLS session (assures that data has not changed)</span></span> | <span data-ttu-id="14b4a-1027">SHA-1, SHA-256</span><span class="sxs-lookup"><span data-stu-id="14b4a-1027">SHA-1, SHA-256</span></span>                                                    |
| <span data-ttu-id="14b4a-1028">TLS PRF</span><span class="sxs-lookup"><span data-stu-id="14b4a-1028">TLS PRF</span></span>                   | <span data-ttu-id="14b4a-1029">TLS 핸드셰이크의 핸드셰이크 해시에서 키 자료를 생성하는 데 사용</span><span class="sxs-lookup"><span data-stu-id="14b4a-1029">Used to generate key material and in the handshake hash in the TLS handshake</span></span>                          | <span data-ttu-id="14b4a-1030">PRF는 해시 루틴(SHA-1 + MD5, SHA-256, SHA-512)을 기반으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-1030">The PRF is based on hash routines – SHA-1 + MD5, SHA-256, SHA-512</span></span> |

<span data-ttu-id="14b4a-1031">NX_SECURE_TLS_CIPHERSUITE_INFO 구조체는 다음과 같이 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-1031">The NX_SECURE_TLS_CIPHERSUITE_INFO structure is defined as follows:</span></span>

```C
typedef struct NX_SECURE_TLS_CIPHERSUITE_INFO_struct
{
    /* The IANA value of the ciphersuite as defined by the TLS spec.*/
    USHORT nx_secure_tls_ciphersuite;

    /* The Public Key operation in this suite - RSA or DH. */
    NX_CRYPTO_METHOD *nx_secure_tls_public_cipher;

    /* The Public Authentication method used for signing data. */
    NX_CRYPTO_METHOD *nx_secure_tls_public_auth;

    /* The session cipher being used - AES, RC4, etc. */
    NX_CRYPTO_METHOD *nx_secure_tls_session_cipher;

    /* The size of the initialization vectors for the session cipher (bytes).*/
    USHORT nx_secure_tls_iv_size;

    /* The key size for the session cipher (bytes). */
    UCHAR nx_secure_tls_session_key_size;

    /* The hash being used - MD5, SHA-1, SHA-256, etc. */
    NX_CRYPTO_METHOD *nx_secure_tls_hash;

    /* The size of the hash being used. SHA-1 is 20 bytes, MD5 is 16 bytes.*/
    USHORT nx_secure_tls_hash_size;

    /* The TLS PRF being used – this is only for TLSv1.2. */
    NX_CRYPTO_METHOD *nx_secure_tls_prf;

} NX_SECURE_TLS_CIPHERSUITE_INFO;
```
<span data-ttu-id="14b4a-1032">nx_secure_tls_ciphersuite 필드는 IANA ciphersuite 값을 포함하며 NX_CRYPTO_METHOD 포인터는 이 ciphersuite에 사용되는 5가지 메서드를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-1032">The nx_secure_tls_ciphersuite field contains the IANA ciphersuite value, and the NX_CRYPTO_METHOD pointers represent the 5 methods used by that ciphersuite.</span></span> <span data-ttu-id="14b4a-1033">스칼라 값(nx_secure_tls_iv_size, nx_secure_tls_key_size 및 nx_secure_tls_hash_size)은 정보 제공용이며, NX_CRYPTO_METHOD 항목에서 사용하지 못할 수 있는 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-1033">The scalar values (nx_secure_tls_iv_size, nx_secure_tls_key_size, and nx_secure_tls_hash_size) are informational, providing information that might not be available in the NX_CRYPTO_METHOD entries.</span></span>

<span data-ttu-id="14b4a-1034">예를 들어, RSA, 128비트 키가 있는 AES-CBC, 세션 해시용 SHA-1 사용을 지정하는 TLS, TLS_RSA_WITH_AES_128_CBC_SHA에 대한 기본 ciphersuite를 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-1034">As an example, we will look at the default ciphersuite for TLS, TLS_RSA_WITH_AES_128_CBC_SHA, which specifies the use of RSA, AES-CBC with 128-bit keys, and SHA-1 for session hashing.</span></span> <span data-ttu-id="14b4a-1035">ciphersuite에는 TLS PRF가 지정되지 않기 때문에 TLSv1.2 모드에서는 기본 SHA-256 PRF를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-1035">No TLS PRF is specified for this ciphersuite, so in TLSv1.2 mode, it will use the default SHA-256 PRF.</span></span> <span data-ttu-id="14b4a-1036">모든 ciphersuite는 테이블에 지정된 PRF와 상관없이 TLS 1.0 및 1.1에 SHA-1+MD5 PRF를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-1036">Note that all ciphersuites use the SHA-1+MD5 PRF in TLS 1.0 and 1.1, regardless of the PRF specified in the table.</span></span>

<span data-ttu-id="14b4a-1037">일반 암호화 라이브러리에 있는 NX_SECURE_TLS_CIPHERSUITE_INFO 테이블의 엔트리는 다음과 같이 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-1037">The entry in the NX_SECURE_TLS_CIPHERSUITE_INFO table in the generic cryptographic library is defined as follows:</span></span>

```C
{ 
  TLS_RSA_WITH_AES_128_CBC_SHA,     /* Ciphersuite identifier */
  &crypto_method_rsa,               /* Public-key cipher (NX_CRYPTO_METHOD)*/
  &crypto_method_rsa,               /* Authentication method(NX_CRYPTO_METHOD)*/
  &crypto_method_aes_cbc_128,       /* Session cipher method(NX_CRYPTO_METHOD)*/
  16,                               /* Session cipher IV size in bytes */
  16,                               /* Session cipher key size in bytes */
  &crypto_method_hmac_sha1,         /* Session hash routine(NX_CRYPTO_METHOD) */
  20,                               /* Session hash output size in bytes */
  &crypto_method_tls_prf_sha_256    /* TLSv1.2 PRF */
},
```

<span data-ttu-id="14b4a-1038">세션 암호의 경우 키 크기가 ciphersuite에 의해 결정되지만, 공개 키 메서드의 경우 핸드셰이크 중에 교환되는 디지털 인증서에 공개 키가 포함되어 있기 때문에 TLS 핸드셰이크가 진행될 때까지 키 크기를 알 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-1038">Note that for the session cipher the key size is determined by the ciphersuite, but for the public-key methods the key size is not known until the TLS handshake is underway since the public keys are contained in the digital certificates exchanged during the handshake.</span></span>

### <a name="x509-cipher-lookup-table"></a><span data-ttu-id="14b4a-1039">X.509 암호화 조회 테이블</span><span class="sxs-lookup"><span data-stu-id="14b4a-1039">X.509 Cipher Lookup Table</span></span>

<span data-ttu-id="14b4a-1040">NX_SECURE_TLS_CIPHERSUITE_INFO 테이블과 마찬가지로 NX_SECURE_X509_CRYPTO 구조체는 암호화 루틴을 알려진 값에 매핑합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-1040">Like the NX_SECURE_TLS_CIPHERSUITE_INFO table, the NX_SECURE_X509_CRYPTO structure maps cryptographic routines to known values.</span></span> <span data-ttu-id="14b4a-1041">X.509의 경우 식별자는 실제로 X.509에 의해 정의되고 ISO 및 ITU 표준 기관에 등록된 OID입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-1041">In the case of X.509, the identifiers are actually OIDs defined by X.509 and registered with the ISO and ITU standards bodies.</span></span> <span data-ttu-id="14b4a-1042">OID는 디지털 인증서에 사용되는 암호화 루틴을 포함한 다양한 통신 표준에서 다양한 정보를 고유하게 식별하도록 설계된 가변 길이 멀티바이트 값입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-1042">OIDs are variable-length multi-byte values designed to uniquely identify various information in various telecommunication standards, including cryptographic routines used in digital certificates.</span></span> <span data-ttu-id="14b4a-1043">OID가 가변 길이라는 사실 때문에 NetX Secure TLS는 공식 OID 값을 내부적으로 사용되는 고정 길이 상수에 매핑합니다(nx_secure_x509.h 참조).</span><span class="sxs-lookup"><span data-stu-id="14b4a-1043">Due to the fact that OIDs are variable length, NetX Secure TLS maps the official OID values to fixed-length constants that are used internally (see nx_secure_x509.h).</span></span> <span data-ttu-id="14b4a-1044">이러한 상수는 NX_SECURE_X509_CRYPTO 구조체에서 사용되며 다음과 같이 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-1044">These constants are used in the NX_SECURE_X509_CRYPTO structure, which is defined as follows:</span></span>

```C
/* Structure to hold X.509 cryptographic routine information. */
typedef struct NX_SECURE_X509_CRYPTO_struct
{
    /* Internal NetX Secure identifier for certificate "ciphersuite" which consists
       of a hash and a public key operation. These can be mapped to OIDs in X.509.
        */
    USHORT nx_secure_x509_crypto_identifier;

    /* Public-Key Cryptographic method used by certificates. */
    NX_CRYPTO_METHOD *nx_secure_x509_public_cipher_method;

    /* Hash method used by certificates. */
    NX_CRYPTO_METHOD *nx_secure_x509_hash_method;
} NX_SECURE_X509_CRYPTO;
```

<span data-ttu-id="14b4a-1045">첫 번째 필드 *nx_secure_x509_crypto_identifier* 는 NetX Secure에 사용되는 내부 OID 표현입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-1045">The first field, *nx_secure_x509_crypto_identifier*, is the internal OID representation used by NetX Secure.</span></span>

<span data-ttu-id="14b4a-1046">두 번째 및 세 번째 필드는 해시 루틴과 쌍을 이루는 공개 키 작업인 OID로 식별되는 암호화 메서드를 나타내는 NX_CRYPTO_METHOD 개체를 가리킵니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-1046">The second and third fields point to NX_CRYPTO_METHOD objects that represent the cryptographic methods identified by the OID, a public-key operation paired with a hash routine.</span></span> <span data-ttu-id="14b4a-1047">각 디지털 인증서에는 암호화 루틴에 대해 둘 이상의 OID가 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-1047">Note that each digital certificate may have more than one OID for cryptographic routines.</span></span>

<span data-ttu-id="14b4a-1048">X.509의 메서드 테이블은 ciphersuite 조회 테이블과 같은 방식으로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-1048">The method table for X.509 is constructed in the same manner as the ciphersuite lookup table.</span></span> <span data-ttu-id="14b4a-1049">예를 들어 RSA_SHA1의 OID를 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-1049">As an example, we will look at the OID for RSA_SHA1.</span></span> <span data-ttu-id="14b4a-1050">RSA_SHA1의 실제 OID는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-1050">The actual OID for RSA_SHA1 is as follows:</span></span>

```C
{iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs-1(1) sha1-with-rsa-
signature(5)}
```
<span data-ttu-id="14b4a-1051">OID는 ASN.1 구문으로 표시되며 숫자 값 1.2.840.113549.1.1.5를 갖습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-1051">The OID is represented in ASN.1 syntax and has a numeric value of 1.2.840.113549.1.1.5.</span></span> <span data-ttu-id="14b4a-1052">이 값은 이진 형식으로 인코딩되어 다음 바이트를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-1052">This value is then encoded in binary format, creating the following bytes:</span></span>

```C
UCHAR RSA_SHA1_OID = { 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05 };
```
<span data-ttu-id="14b4a-1053">ASN.1에서 이진 형식으로 실제 변환하는 내용은 이 문서에서 다루지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-1053">The actual conversion from ASN.1 to the binary format is beyond the scope of this document.</span></span> <span data-ttu-id="14b4a-1054">자세한 내용은 OID의 ASN.1 인코딩을 검색하십시오.</span><span class="sxs-lookup"><span data-stu-id="14b4a-1054">Search for ASN.1 encodings for OIDs for more information.</span></span> <span data-ttu-id="14b4a-1055">NetX Secure에서 지원하는 OID의 이진 표현은 *nx_secure_x509.c* 파일에서 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-1055">The binary representation of the OIDs supported by NetX Secure can be found in the file *nx_secure_x509.c*.</span></span>

<span data-ttu-id="14b4a-1056">실제 OID를 내부적으로 인식되는 상수에 매핑하면 NX_SECURE_X509_CRYPTO 테이블에서 RSA_SHA1에 대한 항목을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-1056">Once we have a mapping of the actual OID to an internally-recognized constant, we can create an entry for RSA_SHA1 in the NX_SECURE_X509_CRYPTO table:</span></span>

```C
{ 
    NX_SECURE_TLS_X509_TYPE_RSA_SHA_1,    /* Internal OID constant. */
    &crypto_method_rsa,                   /* RSA method (NX_CRYPTO_METHOD). */ 
    &crypto_method_sha1                   /* SHA-1 method (NX_CRYPTO_METHOD). */
}, 
```
### <a name="default-tls-routines"></a><span data-ttu-id="14b4a-1057">기본 TLS 루틴</span><span class="sxs-lookup"><span data-stu-id="14b4a-1057">Default TLS Routines</span></span>

<span data-ttu-id="14b4a-1058">위에서 언급했듯이 TLS에는 핸드셰이크 중 키 생성 및 메시지 확인을 위한 몇 가지 기본 루틴이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-1058">As mentioned above, TLS requires some default routines for key generation and message verification during the handshake.</span></span> <span data-ttu-id="14b4a-1059">기본 루틴은 TLS PRF(Pseudo-Random Function)입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-1059">The primary routine is the TLS Pseudo-Random Function, or PRF.</span></span> <span data-ttu-id="14b4a-1060">PRF는 해시 루틴을 기반으로 하며, 키 생성 또는 기타 목적을 위해 임의의 크기인 의사 난수 데이터<sup>20</sup>를 생성하는 데 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-1060">The PRF is based on hash routines and can be used to generate an arbitrary amount of pseudo-random data<sup>20</sup> for key generation or other purposes.</span></span>

<span data-ttu-id="14b4a-1061">PRF 외에도 각 TLS 버전은 제공해야 하는 기본 해시 루틴을 활용합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-1061">In addition to the PRF, each version of TLS utilizes default hash routines that also need to be provided.</span></span> <span data-ttu-id="14b4a-1062">TLS 버전 1.0 및 1.1의 경우 해시 루틴은 MD5 및 SHA-1입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-1062">For TLS versions 1.0 and 1.1, those hash routines are MD5 and SHA-1.</span></span> <span data-ttu-id="14b4a-1063">TLS 버전 1.2에는 SHA-256만 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-1063">TLS version 1.2 requires only SHA-256.</span></span>

<span data-ttu-id="14b4a-1064">NX_SECURE_TLS_CRYPTO 구조체에는 MD5, SHA-1, SHA-256, TLS 버전 1.0/1.1 PRF 및 기본 TLS 1.2 PRF에 대한 NX_CRYPTO_METHOD 포인터가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-1064">In the NX_SECURE_TLS_CRYPTO structure, there are NX_CRYPTO_METHOD pointers for MD5, SHA-1, SHA-256, the TLS version 1.0/1.1 PRF, and the default TLS 1.2 PRF.</span></span>

<span data-ttu-id="14b4a-1065">TLS 1.3 지원은 HKDF(키 생성), HMAC(핸드셰이크 중 사용되는 특정 해시 작업용) 및 ECDHE(TLS 1.3 기능에 필요)에 대한 필드를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-1065">TLS 1.3 support adds fields for HKDF (key generation), HMAC (for specific hashing operations used during the handshake) and ECDHE (required for TLS 1.3 functionality).</span></span>

<span data-ttu-id="14b4a-1066">일반 소프트웨어 암호화 라이브러리에는 TLS PRF의 소프트웨어 버전이 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-1066">Provided in the generic software cryptography library are software versions of the TLS PRF.</span></span> <span data-ttu-id="14b4a-1067">TLS 1.0/1.1의 경우 이 함수를 *nx_crypto_tls_prf_1* 이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-1067">For TLS 1.0/1.1, this function is called *nx_crypto_tls_prf_1*.</span></span> <span data-ttu-id="14b4a-1068">TLS 1.2에서는 이 함수를 *nx_secure_tls_prf_sha256* 이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-1068">For TLS 1.2, the function is called *nx_secure_tls_prf_sha256*.</span></span> <span data-ttu-id="14b4a-1069">접미사 "1"은 레거시 TLS 1.0 PRF를 나타내고 "sha256" 접미사는 TLS 1.2 기본 PRF가 SHA-256에 기반한다는 사실을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-1069">The suffix "1" represents the legacy TLS 1.0 PRF, and the "sha256" suffix refers to the fact that the TLS 1.2 default PRF is based on SHA-256.</span></span> <span data-ttu-id="14b4a-1070">다른 PRF 루틴에 대한 지원이 필요한 경우 해당 루틴의 접미사에는 사용된 해시 메서드가 반영됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-1070">When support for other PRF routines is needed, the suffix for those routines will reflect the hash method used.</span></span> <span data-ttu-id="14b4a-1071">PRF 루틴은 해시 메서드에 기반하기 때문에 기본 해시 루틴은 다른 대상 플랫폼에서 독립적으로 하드웨어 가속이 가능할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-1071">Since the PRF routines are based on hash methods, the underlying hash routines may be hardware-accelerated independently on different target platforms.</span></span>

<span data-ttu-id="14b4a-1072">TLS ciphersuite 및 X.509 조회 테이블 외에도 기본 PRF 및 NX_SECURE_TLS_CRYPTO에 채워진 해시 루틴을 사용하여 구조체를 채우고 TLS 세션을 초기화하는 데 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-1072">In addition to the TLS ciphersuite and X.509 lookup tables, with the default PRF and hash routines filled in the NX_SECURE_TLS_CRYPTO structure can be populated and used to initialize a TLS session.</span></span>

20. <span data-ttu-id="14b4a-1073">“의사 난수”란 PRF가 결정적이라는 사실을 의미합니다. 즉, 동일한 입력이 주어지면 항상 동일한 출력을 생성하지만 출력을 예측할 수 없다는 점에서 무작위입니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-1073">“Pseudo-random” refers to the fact that the PRF is deterministic, meaning it will always produce the same output given the same input, but random in the fact that the output is not predictable.</span></span> <span data-ttu-id="14b4a-1074">TLS는 PRF의 이 속성을 사용하여 RSA와 같은 공개 키 암호를 사용하여 핸드셰이크 중에 교환된 마스터 비밀과 결합된 다양한 공개 데이터에서 세션 키를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-1074">TLS uses this property of the PRF to generate the session keys from various public data combined with the master secret exchanged during the handshake using a public-key cipher like RSA.</span></span>

### <a name="cryptographic-metadata"></a><span data-ttu-id="14b4a-1075">암호화 메타데이터</span><span class="sxs-lookup"><span data-stu-id="14b4a-1075">Cryptographic Metadata</span></span>

<span data-ttu-id="14b4a-1076">NX_SECURE_TLS_CRYPTO 테이블을 사용하여 TLS 세션을 초기화하기 전에 암호화 루틴 메타데이터를 위한 버퍼 공간을 할당해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-1076">Before we can initialize the TLS session with the NX_SECURE_TLS_CRYPTO table, we need to allocate buffer space for the cryptographic routine metadata.</span></span> <span data-ttu-id="14b4a-1077">메타데이터는 제어 블록으로 표시되는 특정 루틴과 관련된 모든 상태를 저장하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-1077">The metadata is used to store all the state associated with a particular routine, represented by its control block.</span></span> <span data-ttu-id="14b4a-1078">각 NX_CRYPTO_METHOD의 *nx_crypto_metadata_area_size* 필드는 해당 루틴과 관련된 제어 구조체의 크기로 설정되어야 합니다. 그렇지 않으면 TLS 초기화가 필요한 공간을 제대로 처리하지 못하여 버퍼 오버런 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-1078">The *nx_crypto_metadata_area_size* field of each NX_CRYPTO_METHOD must be set to the size of the control structure associated with that routine or the TLS initialization will fail to properly account for the space needed, possibly causing buffer overrun issues.</span></span>

<span data-ttu-id="14b4a-1079">TLS 세션이 만들어지기 전에 메타데이터 버퍼를 할당해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-1079">Before the TLS session is created, the metadata buffer must be allocated.</span></span> <span data-ttu-id="14b4a-1080">버퍼는 nx_secure_tls_session_create에 의해 자동으로 분할되며, 암호화 메서드 테이블에 제공되는 각 루틴에 대해 공간이 예약됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-1080">The buffer is automatically divided up by nx_secure_tls_session_create and space is reserved for each of the routines that are provided in the cryptographic method table.</span></span> <span data-ttu-id="14b4a-1081">TLS 세션에서 ciphersuite는 한 번에 하나만 활성이기 때문에 지원되는 ciphersuite의 수는 필요한 메타데이터 공간에 영향을 주지 않습니다. ciphersuite 조회 테이블의 해당 범주에 대한 최대 제어 블록 크기를 사용하여 ciphersuite 루틴 5개 각각에 대한 공간이 예약됩니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-1081">Note that since only one ciphersuite is active at a time in a TLS session, the number of supported ciphersuites does not affect the needed metadata space – space is reserved for each of the 5 ciphersuite routines using the maximum control block size for that category in the ciphersuite lookup table.</span></span>

<span data-ttu-id="14b4a-1082">메타데이터 버퍼 크기를 쉽게 계산하기 위해 *nx_secure_metadata_size_calculate* 서비스는 nx_secure_tls_session_create와 동일한 계산을 수행하지만 필요한 총 메타데이터 버퍼 크기(바이트)만 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="14b4a-1082">In order to make calculating the metadata buffer size easy, the service *nx_secure_metadata_size_calculate* performs the same calculations as nx_secure_tls_session_create but simply returns the total required metadata buffer size in bytes.</span></span>

### <a name="initializing-the-tls-session"></a><span data-ttu-id="14b4a-1083">TLS 세션 초기화</span><span class="sxs-lookup"><span data-stu-id="14b4a-1083">Initializing the TLS session</span></span>

<span data-ttu-id="14b4a-1084">NX_CRYPTO_METHOD 및 NX_SECURE_TLS_CRYPTO 개체가 생성되고 메타데이터 영역이 예약되면, 다음과 같이 TLS 세션을 초기화할 수 있습니다(값은 위 예에서 가져옴).</span><span class="sxs-lookup"><span data-stu-id="14b4a-1084">Once the NX_CRYPTO_METHOD and NX_SECURE_TLS_CRYPTO objects are created and the metadata area reserved, we can initialize a TLS session as follows (values taken from the above examples):</span></span>

```C
/* Pointer to the platform-specific cipher table. */
extern nx_crypto_tls_ciphers;

/* Cryptographic routine metadata buffer. Size is determined by calling 
nx_secure_tls_metadata_size_calculate with the nx_crypto_tls_ciphers table referenced 
above. */
UCHAR crypto_metadata[4500];

/* Initialize our TLS session using our cipher table and metadata area. Note that we can 
use sizeof for the metadata array because the size parameter expects the size in bytes.*/

nx_secure_tls_session_create(
    &tls_session,            /* Pointer to TLS session.      */
    &nx_crypto_tls_ciphers,  /* Pointer to cipher table.     */
    crypto_metadata,         /* Cryptography metadata buffer.*/
    sizeof(crypto_metadata), /* Size of metadata buffer.     */
);
```
