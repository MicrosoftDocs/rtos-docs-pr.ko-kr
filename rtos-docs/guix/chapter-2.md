---
title: 2장 - GUIX 설치 및 사용
description: 이 장에는 고성능 사용자 인터페이스 제품 GUIX의 설치, 설정 및 사용과 관련된 다양한 문제에 대한 설명이 포함되어 있습니다.
author: philmea
ms.author: philmea
ms.date: 05/19/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 6527227062fc667b3f527a798d6621914c374c5c
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/22/2021
ms.locfileid: "104811208"
---
# <a name="chapter-2---installation-and-use-of-guix"></a>2장 - GUIX 설치 및 사용

이 장에는 고성능 사용자 인터페이스 제품 GUIX의 설치, 설정 및 사용과 관련된 다양한 문제에 대한 설명이 포함되어 있습니다.  

## <a name="host-considerations"></a>호스트 고려 사항

임베디드 개발은 일반적으로 Windows 또는 Linux(Unix) 호스트 컴퓨터에서 수행됩니다. 애플리케이션이 컴파일되고 연결된 후 호스트에서 실행 파일이 생성되면 실행을 위해 대상 하드웨어로 다운로드됩니다.

일반적으로 대상 다운로드는 개발 도구의 디버거 내에서 수행됩니다. 다운로드 후 디버거는 대상 실행 제어(이동, 중지, 중단점 등) 뿐만 아니라 메모리 및 프로세서 레지스터에 대한 액세스를 제공합니다.

대부분의 개발 도구 디버거는 JTAG(IEEE 1149.1) 및 BDM(백그라운드 디버그 모드)과 같은 OCD(온-칩 디버그) 연결을 통해 대상 하드웨어와 통신합니다. 또한 디버거는 ICE(회로 내 에뮬레이션) 연결을 통해 대상 하드웨어와 통신합니다. OCD와 ICE 연결은 모두 대상 상주 소프트웨어에 대한 최소 침입으로 강력한 솔루션을 제공합니다.

호스트에서 사용되는 리소스의 경우에는 GUXI에 대한 소스 코드를 ASCII 형식으로 전달하고 호스트 컴퓨터의 하드 디스크에 약 30MB의 공간이 필요합니다.

## <a name="target-considerations"></a>대상 고려 사항

GUIX에는 대상에서 5KB ~ 80KB의 ROM(읽기 전용 메모리)이 필요합니다. GUIX 스레드 스택 및 기타 글로벌 데이터 구조에는 대상에서 5 ~ 10KB의 RAM(Random Access Memory)이 필요합니다.

또한 GUIX를 사용하려면 ThreadX 타이머와 ThreadX 뮤텍스 개체를 사용해야 합니다. 이러한 기능은 GUIX 내의 정기적인 처리 요구 사항 및 스레드 보호에 사용됩니다.

## <a name="product-distribution"></a>제품 배포

Azure RTOS GUIX는 <https://github.com/azure-rtos/guix/>에 있는 공용 소스 코드 리포지토리에서 가져올 수 있습니다.

다음은 대부분의 제품 배포에 공통적인 중요한 파일 목록입니다.

| 파일 이름&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Description   |
| ----------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| gx_api.h        | 이 C 헤더 파일에는 모든 시스템 등식, 데이터 구조 및 서비스 프로토타입이 포함됩니다. |
| gx_port.h       | 이 C 헤더 파일에는 모든 대상별 및 개발 도구별 데이터 정의 및 구조가 포함되어 있습니다.                                                                                                                                         |
| gx.a(또는 gx.lib) | GUIX C 라이브러리의 이진 버전입니다. 이는 일반적으로 제공된 GUIX 라이브러리 원본 파일을 컴파일하고 보관하여 빌드되지만, 이 라이브러리는 하드웨어 대상과 라이선스 유형에 따라 미리 작성된 형태로 제공될 수 있습니다. |
|

> [!IMPORTANT]
> *모든 파일은 소문자이므로 명령을 Linux(Unix) 개발 플랫폼으로 쉽게 변환할 수 있습니다.*

## <a name="guix-installation"></a>GUIX 설치

GUIX는 GitHub 리포지토리를 로컬 머신에 복제하여 설치됩니다. 다음은 PC에서 GUIX 리포지토리의 복제본을 만드는 일반적인 구문입니다.

```c
    git clone https://github.com/azure-rtos/guix
```

또는 GitHub 기본 페이지의 다운로드 단추를 사용하여 리포지토리의 복사본을 다운로드할 수 있습니다.

또한 온라인 리포지토리의 프런트 페이지에서 GUIX 라이브러리를 빌드하기 위한 지침을 찾을 수 있습니다.

>[!NOTE]  
> *애플리케이션 소프트웨어는 일반적으로 **gx.a**(또는 **gx.lib**)라고 하는 GUIX 라이브러리 파일과 C 포함 파일(**gx_api.h** 및 **gx_port.h**)에 액세스해야 합니다. 이는 개발 도구에 대한 적절한 경로를 설정하거나 애플리케이션 개발 영역에 이러한 파일을 복사하여 수행됩니다.*

## <a name="using-guix"></a>GUIX 사용

GUIX를 사용하는 것은 쉽습니다. 기본적으로 애플리케이션 코드는 컴파일하는 동안 ***gx_api.h** _를 포함해야 하며 GUIX 라이브러리 _*_gx.a_*_(또는 _ *_gx.lib_*)*와 연결되어야 합니다.

GUIX 애플리케이션을 빌드하는 데 필요한 네 가지 간단한 단계가 있습니다.

| 단계   | Description    |
| ------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 1&nbsp;단계: | GUIX 서비스 또는 데이터 구조를 사용하는 모든 애플리케이션 파일에 ***gx_api.h*** 파일을 포함합니다.                                                               |
| 2&nbsp;단계: | _ *_tx_application_define_** 함수 또는 애플리케이션 스레드에서 ***gx_system_initialize** _를 호출하여 GUIX 시스템을 초기화합니다.                       |
| 3&nbsp;단계: | 표시 인스턴스를 만들고, 표시할 캔버스를 만든 후, 루트 창 및 필요한 다른 모든 창이나 위젯을 만듭니다.                                 |
| 4&nbsp;단계: | 애플리케이션 소스를 컴파일하고 GUIX 런타임 라이브러리 ***gx.a** _(또는 _*_gx.lib_**)와 연결합니다. 결과 이미지를 대상에 다운로드하여 실행할 수 있습니다. |

## <a name="troubleshooting"></a>문제 해결

각 GUIX 포트는 특정 디스플레이 하드웨어에서 실행되는 데모 애플리케이션과 함께 제공됩니다. 모든 버전의 GUIX와 함께 동일한 기본 데모가 제공됩니다. 항상 데모 시스템을 먼저 실행하는 것이 좋습니다.

데모 시스템이 제대로 실행되지 않으면 다음 작업을 수행하여 문제의 범위를 좁힙니다.

1. 데모가 어느 정도 실행되고 있는지 확인합니다.

2. 컴파일 시간 상수 **GX_THREAD_STACK_SIZE** 를 변경하고 GUIX 라이브러리를 다시 컴파일하여 GUIX 스레드의 스택 크기를 늘립니다.

3. 구성 옵션 섹션에 나열된 적절한 디버그 옵션을 사용하여 GUIX 라이브러리를 다시 컴파일합니다.

4. 모든 API 호출에서 반환 상태를 검사합니다.

5. ***_gx_system_error_process*** 함수에서 중단점을 설정하여 내부 시스템 오류가 있는지 확인합니다. 오류 코드와 호출자는 무엇이 잘못되고 있는지 알 수 있는 단서를 제공해야 합니다.

6. 최근 변경 내용을 일시적으로 무시하여 문제가 사라지거나 변경되는지 확인합니다. 이러한 정보는 Microsoft 지원 엔지니어에게 유용합니다.

“제공할 사항” 섹션에 설명된 절차에 따라 문제 해결 단계에서 수집한 정보를 보냅니다.

## <a name="configuration-options"></a>구성 옵션

GUIX를 사용하여 GUIX 라이브러리 및 애플리케이션을 빌드할 때 몇 가지 구성 옵션이 있습니다. 이러한 옵션은 애플리케이션 요구 사항에 가장 적합하도록 라이브러리 크기와 기능 세트를 조정하는 데 사용됩니다. 예를 들어 애플리케이션에 GUIX API 서비스를 활용하는 스레드가 하나만 있는 경우 여러 스레드에 의한 선점에서 중요한 코드 섹션을 보호하는 것과 관련된 오버 헤드를 없애기 위해 구성 플래그 **GX_DISABLE_MULTITHREAD_SUPPORT** 를 정의해야 합니다. 애플리케이션 소스, 명령줄 또는 **_gx_user.h_** 포함 파일 내에서 다양한 구성 플래그를 정의할 수 있습니다.

GUIX 라이브러리 구성 플래그가 수정될 때마다 구성 변경 내용이 적용되도록 GUIX 라이브러리와 애플리케이션 모듈을 모두 다시 빌드해야 합니다.

구성 플래그의 전체 목록은 부록 H: GUIX 빌드 시간 구성 플래그에 설명되어 있습니다.

## <a name="guix-version-id"></a>GUIX 버전 ID

GUIX의 현재 버전은 런타임 중에 사용자와 애플리케이션 소프트웨어에서 모두 사용할 수 있습니다. 프로그래머는 ***gx_port.h** _ 파일을 검사하여 GUIX 버전을 가져올 수 있습니다. 또한 이 파일에는 해당 포트 애플리케이션 소프트웨어의 버전 기록도 포함되어 있습니다. _*_gx_port.h_**의 글로벌 문자열 _ *_ _gx_version_id_* _를 검사하여 GUIX 버전을 가져올 수 있습니다.

애플리케이션 소프트웨어는 ***gx_api.h***에 정의된 아래에 표시된 상수에서 릴리스 정보를 가져올 수도 있습니다. 이러한 상수는 이름 및 제품 주 버전과 부 버전을 기준으로 현재 제품 릴리스를 식별합니다.

```C
#define __PRODUCT_GUIX__

#define __GUIX_MAJOR_VERSION__

#define __GUIX_MINOR_VERSION__
```
