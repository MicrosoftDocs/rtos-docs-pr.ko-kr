---
title: 1장 - Azure RTOS ThreadX 소개
description: 이 장에는 Azure RTOS ThreadX에 대한 소개와 해당 애플리케이션 및 혜택에 대한 설명이 포함되어 있습니다.
author: philmea
ms.author: philmea
ms.date: 05/19/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 83718ddf5469238e2429855908be2ea5d405f874
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/22/2021
ms.locfileid: "104811395"
---
# <a name="chapter-1---introduction-to-azure-rtos-threadx"></a><span data-ttu-id="13917-103">1장 - Azure RTOS ThreadX 소개</span><span class="sxs-lookup"><span data-stu-id="13917-103">Chapter 1 - Introduction to Azure RTOS ThreadX</span></span>

<span data-ttu-id="13917-104">Azure RTOS ThreadX는 포함된 애플리케이션을 위해 특별히 설계된 고성능 실시간 커널입니다.</span><span class="sxs-lookup"><span data-stu-id="13917-104">Azure RTOS ThreadX is a high-performance real-time kernel designed specifically for embedded applications.</span></span> <span data-ttu-id="13917-105">이 장에는 해당 제품에 대한 소개와 해당 애플리케이션 및 혜택에 대한 설명이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13917-105">This chapter contains an introduction to the product and a description of its applications and benefits.</span></span>

## <a name="threadx-unique-features"></a><span data-ttu-id="13917-106">ThreadX 고유 기능</span><span class="sxs-lookup"><span data-stu-id="13917-106">ThreadX Unique Features</span></span>

<span data-ttu-id="13917-107">다른 실시간 커널과 달리 ThreadX는 강력한 CISC, RISC 및 DSP 프로세서를 사용하는 애플리케이션을 통해 소규모 마이크로컨트롤러 기반 애플리케이션에서 쉽게 스케일링 가능하도록 다재 다능하게 설계되었습니다.</span><span class="sxs-lookup"><span data-stu-id="13917-107">Unlike other real-time kernels, ThreadX is designed to be versatile—easily scaling among small microcontroller-based applications through those that use powerful CISC, RISC, and DSP processors.</span></span>

<span data-ttu-id="13917-108">ThreadX는 기본 아키텍처에 따라 스케일링이 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="13917-108">ThreadX is scalable based on its underlying architecture.</span></span> <span data-ttu-id="13917-109">ThreadX 서비스는 C 라이브러리로 구현되기 때문에 애플리케이션에서 실제로 사용하는 서비스만 런타임 이미지로 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="13917-109">Because ThreadX services are implemented as a C library, only those services actually used by the application are brought into the run-time image.</span></span> <span data-ttu-id="13917-110">따라서 ThreadX의 실제 크기는 애플리케이션에 의해 완전히 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="13917-110">Hence, the actual size of ThreadX is completely determined by the application.</span></span> <span data-ttu-id="13917-111">대부분의 애플리케이션에서 ThreadX 범위의 명령 이미지는 2KB이고, 크기는 15KB 사이입니다.</span><span class="sxs-lookup"><span data-stu-id="13917-111">For most applications, the instruction image of ThreadX ranges between 2 KBytes and 15 KBytes in size.</span></span>

### <a name="picokerneltrade-architecture"></a><span data-ttu-id="13917-112">*&trade;피코커널 아키텍처*</span><span class="sxs-lookup"><span data-stu-id="13917-112">*picokernel&trade; Architecture*</span></span>

<span data-ttu-id="13917-113">기존 마이크로커널 아키텍처와 같이 커널 함수를 서로 계층화하는 대신, ThreadX 서비스는 해당 코어에 직접 연결됩니다.</span><span class="sxs-lookup"><span data-stu-id="13917-113">Instead of layering kernel functions on top of each other like traditional *microkernel* architectures, ThreadX services plug directly into its core.</span></span> <span data-ttu-id="13917-114">이로 인해 컨텍스트 전환이 빨라지고 서비스 호출 성능이 개선됩니다.</span><span class="sxs-lookup"><span data-stu-id="13917-114">This results in the fastest possible context switching and service call performance.</span></span> <span data-ttu-id="13917-115">이러한 비계층화 디자인을 피코커널이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="13917-115">We call this non-layering design a *picokernel* architecture.</span></span>

### <a name="ansi-c-source-code"></a><span data-ttu-id="13917-116">ANSI C 소스 코드</span><span class="sxs-lookup"><span data-stu-id="13917-116">ANSI C Source Code</span></span>

<span data-ttu-id="13917-117">ThreadX는 주로 ANSI C로 작성됩니다. 커널 크기를 기본 대상 프로세서에 맞게 조정하려면 약간의 어셈블리 언어가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="13917-117">ThreadX is written primarily in ANSI C. A small amount of assembly language is needed to tailor the kernel to the underlying target processor.</span></span> <span data-ttu-id="13917-118">이러한 디자인을 통해 아주 짧은 시간 안에, 일반적으로 몇 주 안에 ThreadX를 새 프로세서 제품군으로 이식할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13917-118">This design makes it possible to port ThreadX to a new processor family in a very short time—usually within weeks!</span></span>

### <a name="advanced-technology"></a><span data-ttu-id="13917-119">고급 기술</span><span class="sxs-lookup"><span data-stu-id="13917-119">Advanced Technology</span></span>

<span data-ttu-id="13917-120">다음은 ThreadX 고급 기술의 주요 특징입니다.</span><span class="sxs-lookup"><span data-stu-id="13917-120">The following are highlights of the ThreadX advanced technology.</span></span>
- <span data-ttu-id="13917-121">간단한 피코커널 아키텍처</span><span class="sxs-lookup"><span data-stu-id="13917-121">Simple *picokernel* architecture</span></span>
- <span data-ttu-id="13917-122">자동 크기 조정(작은 공간)</span><span class="sxs-lookup"><span data-stu-id="13917-122">Automatic scaling (small footprint)</span></span>
- <span data-ttu-id="13917-123">결정적 처리</span><span class="sxs-lookup"><span data-stu-id="13917-123">Deterministic processing</span></span>
- <span data-ttu-id="13917-124">빠른 실시간 성능</span><span class="sxs-lookup"><span data-stu-id="13917-124">Fast real-time performance</span></span>
- <span data-ttu-id="13917-125">선점형 일정 및 협조적 일정</span><span class="sxs-lookup"><span data-stu-id="13917-125">Preemptive and cooperative scheduling</span></span>
- <span data-ttu-id="13917-126">유연한 스레드 우선 순위 지원</span><span class="sxs-lookup"><span data-stu-id="13917-126">Flexible thread priority support</span></span>
- <span data-ttu-id="13917-127">동적 시스템 개체 만들기</span><span class="sxs-lookup"><span data-stu-id="13917-127">Dynamic system object creation</span></span>
- <span data-ttu-id="13917-128">시스템 개체 수 제한 없음</span><span class="sxs-lookup"><span data-stu-id="13917-128">Unlimited number of system objects</span></span>
- <span data-ttu-id="13917-129">최적화된 인터럽트 처리</span><span class="sxs-lookup"><span data-stu-id="13917-129">Optimized interrupt handling</span></span>
- <span data-ttu-id="13917-130">선점 임계값&trade;</span><span class="sxs-lookup"><span data-stu-id="13917-130">Preemption-threshold&trade;</span></span>
- <span data-ttu-id="13917-131">우선 순위 상속</span><span class="sxs-lookup"><span data-stu-id="13917-131">Priority inheritance</span></span>
- <span data-ttu-id="13917-132">이벤트 체인&trade;</span><span class="sxs-lookup"><span data-stu-id="13917-132">Event-chaining&trade;</span></span>
- <span data-ttu-id="13917-133">빠른 소프트웨어 타이머</span><span class="sxs-lookup"><span data-stu-id="13917-133">Fast software timers</span></span>
- <span data-ttu-id="13917-134">런타임 메모리 관리</span><span class="sxs-lookup"><span data-stu-id="13917-134">Run-time memory management</span></span>
- <span data-ttu-id="13917-135">런타임 성능 모니터링</span><span class="sxs-lookup"><span data-stu-id="13917-135">Run-time performance monitoring</span></span>
- <span data-ttu-id="13917-136">런타임 스택 분석</span><span class="sxs-lookup"><span data-stu-id="13917-136">Run-time stack analysis</span></span>
- <span data-ttu-id="13917-137">기본 제공 시스템 추적</span><span class="sxs-lookup"><span data-stu-id="13917-137">Built-in system trace</span></span>
- <span data-ttu-id="13917-138">방대한 프로세서 지원</span><span class="sxs-lookup"><span data-stu-id="13917-138">Vast processor support</span></span>
- <span data-ttu-id="13917-139">방대한 개발 도구 지원</span><span class="sxs-lookup"><span data-stu-id="13917-139">Vast development tool support</span></span>
- <span data-ttu-id="13917-140">완전한 endian 중립</span><span class="sxs-lookup"><span data-stu-id="13917-140">Completely endian neutral</span></span>

### <a name="not-a-black-box"></a><span data-ttu-id="13917-141">블랙 박스가 아님</span><span class="sxs-lookup"><span data-stu-id="13917-141">Not A Black Box</span></span>

<span data-ttu-id="13917-142">대부분의 ThreadX 배포에는 전체 C 소스 코드와 프로세서별 어셈블리 언어가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="13917-142">Most distributions of ThreadX include the complete C source code as well as the processor-specific assembly language.</span></span> <span data-ttu-id="13917-143">따라서 많은 상용 커널에서 발생하는 “블랙 박스” 문제를 없앨 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13917-143">This eliminates the "black-box" problems that occur with many commercial kernels.</span></span> <span data-ttu-id="13917-144">ThreadX를 사용하면 애플리케이션 개발자는 GUIX를 사용하여 커널이 수행하는 작업을 정확하게 파악할 수 있기 때문에 모든 것이 명확합니다!</span><span class="sxs-lookup"><span data-stu-id="13917-144">With ThreadX, application developers can see exactly what the kernel is doing—there are no mysteries!</span></span>

<span data-ttu-id="13917-145">또한 소스 코드를 사용하여 애플리케이션 관련 수정을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13917-145">The source code also allows for application specific modifications.</span></span> <span data-ttu-id="13917-146">권장되지는 않지만 반드시 필요한 경우 커널을 수정하는 기능을 제공한 것은 확실히 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="13917-146">Although not recommended, it is certainly beneficial to have the ability to modify the kernel if it is absolutely required.</span></span>

<span data-ttu-id="13917-147">해당 특징은 자체 *사내 커널* 로 작업하는 데 익숙한 개발자에게 특히 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="13917-147">These features are especially comforting to developers accustomed to working with their own *in-house kernels*.</span></span> <span data-ttu-id="13917-148">이들에게는 소스 코드와 커널을 수정할 수 있는 기능이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="13917-148">They expect to have source code and the ability to modify the kernel.</span></span> <span data-ttu-id="13917-149">ThreadX는 이러한 개발자를 위한 최고의 커널입니다.</span><span class="sxs-lookup"><span data-stu-id="13917-149">ThreadX is the ultimate kernel for such developers.</span></span>

### <a name="the-rtos-standard"></a><span data-ttu-id="13917-150">RTOS 표준</span><span class="sxs-lookup"><span data-stu-id="13917-150">The RTOS Standard</span></span>

<span data-ttu-id="13917-151">이러한 다양성, 고성능 피코커널 아키텍처, 고급 기술 및 시연된 이식성 때문에 ThreadX는 현재 20억 개 이상의 디바이스에 배포되고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13917-151">Because of its versatility, high-performance *picokernel* architecture, advanced technology, and demonstrated portability, ThreadX is deployed in more than two-billion devices today.</span></span> <span data-ttu-id="13917-152">이를 통해 ThreadX는 긴밀하게 포함된 애플리케이션에 대한 RTOS 표준이 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="13917-152">This effectively makes ThreadX the RTOS standard for deeply embedded applications.</span></span>

## <a name="safety-certifications"></a><span data-ttu-id="13917-153">안전 인증</span><span class="sxs-lookup"><span data-stu-id="13917-153">Safety Certifications</span></span>

### <a name="tv-certification"></a><span data-ttu-id="13917-154">TÜV 인증</span><span class="sxs-lookup"><span data-stu-id="13917-154">TÜV Certification</span></span>

<span data-ttu-id="13917-155">ThreadX는 IEC61508 및 IEC-62304에 따라 안전이 중요한 시스템에서 사용하도록 SG-TÜV Saar에서 인증되었습니다.</span><span class="sxs-lookup"><span data-stu-id="13917-155">ThreadX has been certified by SGS-TÜV Saar for use in safety-critical systems, according to IEC61508 and IEC-62304.</span></span> <span data-ttu-id="13917-156">이 인증은 "전기, 전자 및 프로그램 가능한 전자 안전 관련 시스템의 기능적 안전”에 대한 최고 수준의 IEC(International Electrotechnical Commission) 61508 및 IEC 62304의 안전 무결성 등급에 따라, ThreadX를 보안 관련 소프트웨어의 개발에 사용할 수 있음을 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="13917-156">The certification confirms that ThreadX can be used in the  development of safety related software for the highest safety integrity levels of the International Electrotechnical Commission (IEC) 61508 and IEC 62304, for the "Functional Safety of electrical, electronic, and programmable electronic safety-related systems."</span></span> <span data-ttu-id="13917-157">독일 SGSGroup 및 TÜV Saarland의 공동 벤처인 SGS-TÜV Saar는 세계적으로 안전 관련 시스템용 포함 소프트웨어를 테스트, 감사, 확인 및 검증하는 최고 권위의 독립 기업으로 자리했습니다.</span><span class="sxs-lookup"><span data-stu-id="13917-157">SGS-TÜV Saar, formed through a joint venture of Germany's SGSGroup and TÜV Saarland, has become the leading accredited, independent company for testing, auditing, verifying, and certifying embedded software for safety-related systems worldwide.</span></span> <span data-ttu-id="13917-158">산업 보안 표준 IEC 61508과, 거기에서 파생된 모든 표준(IEC 62304 포함)은 전기, 전자 및 프로그래밍 가능한 전자 안전 관련 의료 장비, 공정 제어 시스템, 산업용 기계, 철도 제어 시스템의 기능 안전을 보장하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="13917-158">The industrial safety standard IEC 61508, and all standards that are derived from it, including IEC 62304, are used to assure the functional safety of electrical, electronic, and programmable electronic safety-related medical devices, process control systems, industrial machinery, and railway control systems.</span></span>

<span data-ttu-id="13917-159">SG-TÜV Saar에는 ISO 26262 표준에 따라 안전이 중요한 자동차 시스템에서 ThreadX를 사용할 수 있도록 인증했습니다.</span><span class="sxs-lookup"><span data-stu-id="13917-159">SGS-TÜV Saar has certified ThreadX to be used in safety-critical automotive systems, according to the ISO 26262 standard.</span></span> <span data-ttu-id="13917-160">또한 ThreadX는 최고 수준의 ISO 26262 인증을 나타내는 ASIL(자동차 안전 무결성 수준) D로 인증되었습니다.</span><span class="sxs-lookup"><span data-stu-id="13917-160">Furthermore, ThreadX is certified to Automotive Safety Integrity Level (ASIL) D, which represents the highest level of ISO 26262 certification.</span></span>

<span data-ttu-id="13917-161">또한 SG TÜV Saar는 안전이 중요한 철도 응용 분야에서 ThreadX를 사용할 수 있도록 인증했으며 SW-SIL 4까지 EN 50128 표준을 충족하는 것으로 확인했습니다.</span><span class="sxs-lookup"><span data-stu-id="13917-161">In addition, SGS-TÜV Saar has certified ThreadX to be used in safety-critical railway applications, meeting to the EN 50128 standard up to SW-SIL 4.</span></span>

![TÜV 인증](./media/overview-threadx/partener-logo-sgs-tuv-saar-2.png)

* <span data-ttu-id="13917-163">최대 SIL 4의 IEC 61508</span><span class="sxs-lookup"><span data-stu-id="13917-163">IEC 61508 up to SIL 4</span></span>

* <span data-ttu-id="13917-164">최대 SW 안전 클래스 C의 IEC 62304</span><span class="sxs-lookup"><span data-stu-id="13917-164">IEC 62304 up to SW safety Class C</span></span>

* <span data-ttu-id="13917-165">ISO 26262 ASIL D</span><span class="sxs-lookup"><span data-stu-id="13917-165">ISO 26262 ASIL D</span></span>

* <span data-ttu-id="13917-166">EN 50128 SW-SIL 4</span><span class="sxs-lookup"><span data-stu-id="13917-166">EN 50128 SW-SIL 4</span></span>

> [!NOTE]
> <span data-ttu-id="13917-167">*TÜV에서 인증한 ThreadX 버전 또는 테스트 보고서, 인증서 및 관련 설명서의 가용성에 대한 자세한 내용은 Microsoft에 문의하세요.*</span><span class="sxs-lookup"><span data-stu-id="13917-167">*Please contact us for more information on which version(s) of ThreadX have been certified by TÜV or for the availability of test reports, certificates, and associated documentation.*</span></span>

### <a name="misra-c-compliant"></a><span data-ttu-id="13917-168">MISRA C 규격</span><span class="sxs-lookup"><span data-stu-id="13917-168">MISRA C Compliant</span></span>

<span data-ttu-id="13917-169">MISRA C는 C 프로그래밍 언어를 사용하는 중요 시스템에 대한 프로그래밍 지침입니다.</span><span class="sxs-lookup"><span data-stu-id="13917-169">MISRA C is a set of programming guidelines for critical systems using the C programming language.</span></span> <span data-ttu-id="13917-170">원래의 MISRA C 지침은 주로 자동차 분야를 대상으로 했지만, MISRA C는 이제 모든 안전 중요 분야에 적용할 수 있는 것으로 널리 인식되고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13917-170">The original MISRA C guidelines were primarily targeted toward automotive applications; however, MISRA C is now widely recognized as being applicable to any safety critical application.</span></span> <span data-ttu-id="13917-171">ThreadX는 MISRA-C:2004 및 MISRA C:2012의 모든 "필수" 및 "의무" 규칙을 준수합니다.</span><span class="sxs-lookup"><span data-stu-id="13917-171">ThreadX is compliant with all "required" and "mandatory" rules of MISRA-C:2004 and MISRA C:2012.</span></span> <span data-ttu-id="13917-172">ThreadX는 세 가지 "권고" 규칙을 제외한 모든 규칙을 준수합니다.</span><span class="sxs-lookup"><span data-stu-id="13917-172">ThreadX is also compliant with all but three "advisory" rules.</span></span> <span data-ttu-id="13917-173">자세한 내용은 ***ThreadX_MISRA_Compliance.pdf*** 문서를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="13917-173">Refer to the ***ThreadX_MISRA_Compliance.pdf*** document for more details.</span></span>

### <a name="ul-certification"></a><span data-ttu-id="13917-174">UL 인증</span><span class="sxs-lookup"><span data-stu-id="13917-174">UL Certification</span></span>

<span data-ttu-id="13917-175">UL은 ThreadX가 프로그래밍 가능한 구성 요소에서의 소프트웨어에 대한 UL 60730-1 부칙 H, CSA E60730-1 부칙 H, IEC 60730-1 부칙 H, UL 60335-1 부칙 R, IEC 60335-1 부칙 R 및 UL 1998 안전 표준의 규정을 준수한다고 인증했습니다.</span><span class="sxs-lookup"><span data-stu-id="13917-175">ThreadX has been certified by UL for compliance with UL 60730-1 Annex H, CSA E60730-1 Annex H, IEC 60730-1 Annex H, UL 60335-1 Annex R, IEC 60335-1 Annex R, and UL 1998 safety standards for software in programmable components.</span></span> <span data-ttu-id="13917-176">IEC 60335-1 표준에서는 해당 부록 H에 포함된 "소프트웨어를 사용하여 제어"에 대한 요구 사항이 있는 IEC/UL 60730-1과 함께, 부록 R의 "프로그래밍 가능 전자 회로"에 대한 요구 사항을 설명합니다. IEC 60730 부록 H 및 IEC 60335-1 부록 R은 세탁기, 식기세척기, 건조기, 냉장고, 냉동고 및 오븐과 같은 어플라이언스에서 사용되는 MCU 하드웨어 및 소프트웨어의 안전을 다룹니다.</span><span class="sxs-lookup"><span data-stu-id="13917-176">Along with IEC/UL 60730-1, which has requirements for "Controls Using Software" in its Annex H, the IEC 60335-1 standard describes the requirements for "Programmable Electronic Circuits" in its Annex R. IEC 60730 Annex H and IEC 60335-1 Annex R address the safety of MCU hardware and software used in appliances such as washing machines, dishwashers, dryers, refrigerators, freezers, and ovens.</span></span>

![UL 인증](./media/overview-threadx/partener-logo-c-ru-us-2.png)

<span data-ttu-id="13917-178">*UL/IEC 60730, UL/IEC 60335, UL 1998*</span><span class="sxs-lookup"><span data-stu-id="13917-178">*UL/IEC 60730, UL/IEC 60335, UL 1998*</span></span>

> [!NOTE]
> <span data-ttu-id="13917-179">*TÜV에서 인증한 ThreadX 버전 또는 테스트 보고서, 인증서 및 관련 설명서의 가용성에 대한 자세한 내용은 Microsoft에 문의하세요.*</span><span class="sxs-lookup"><span data-stu-id="13917-179">*Please contact Microsoft for more information on which version(s) of ThreadX have been certified by TÜV or for the availability of test reports, certificates, and associated documentation.*</span></span>

### <a name="certification-pack"></a><span data-ttu-id="13917-180">인증 팩</span><span class="sxs-lookup"><span data-stu-id="13917-180">Certification Pack</span></span>

<span data-ttu-id="13917-181">ThreadX 인증 팩&trade;은 ThreadX 기반 제품이 안전이 중요한 항공, 의료 및 산업용 시스템에 필요한 최대 안정성 및 중요도 수준임을 인증하거나 이러한 제품을 성공적으로 제출하는 데 필요한 모든 ThreadX 증거를 제공하는 100% 완전한 턴키, 산업용 독립 실행형 패키지입니다.</span><span class="sxs-lookup"><span data-stu-id="13917-181">The ThreadX Certification Pack&trade; is a 100% complete, turnkey, industry-specific, stand-alone package that provides all of the ThreadX evidence needed to certify or successfully submit the ThreadX-based product to the highest reliability and criticality levels required for safety-critical Aviation, Medical, and Industrial systems.</span></span> <span data-ttu-id="13917-182">지원되는 인증에는 178B, 12B, DO-278, FDA510 (k), IEC62304, IEC-60601, ISO-14971, UL-1998, IEC-61508, CENELEC EN50128, BS50128 및 49CFR236이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="13917-182">Certifications supported include DO-178B, ED-12B, DO-278, FDA510(k), IEC62304, IEC-60601, ISO-14971, UL-1998, IEC-61508, CENELEC EN50128, BS50128, and 49CFR236.</span></span> <span data-ttu-id="13917-183">인증 팩에 대한 자세한 내용은 Microsoft에 문의하세요.</span><span class="sxs-lookup"><span data-stu-id="13917-183">Please contact Microsoft for more information on Certification Pack.</span></span>

## <a name="embedded-applications"></a><span data-ttu-id="13917-184">포함된 애플리케이션</span><span class="sxs-lookup"><span data-stu-id="13917-184">Embedded Applications</span></span>

<span data-ttu-id="13917-185">포함된 애플리케이션은 무선 통신 디바이스, 자동차 엔진, 레이저 프린터, 의료 디바이스 등의 제품 내에 장착되어 있는 마이크로프로세서에서 실행됩니다. 포함된 애플리케이션의 또 다른 차이점은 소프트웨어 및 하드웨어 각각에 전용 용도가 있다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="13917-185">Embedded applications execute on microprocessors buried within products such as wireless communication devices, automobile engines, laser printers, medical devices, etc. Another distinction of embedded applications is that their software and hardware have a dedicated purpose.</span></span>

### <a name="real-time-software"></a><span data-ttu-id="13917-186">실시간 소프트웨어</span><span class="sxs-lookup"><span data-stu-id="13917-186">Real-time Software</span></span>

<span data-ttu-id="13917-187">시간 제약 조건이 애플리케이션 소프트웨어에 적용되는 경우 이것을 실시간 소프트웨어라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="13917-187">When time constraints are imposed on the application software, it is called the *real-time* software.</span></span> <span data-ttu-id="13917-188">포함된 애플리케이션은 본질적으로 외부 이벤트와 상호 작용하기 때문에 거의 항상 실시간입니다.</span><span class="sxs-lookup"><span data-stu-id="13917-188">Embedded applications are almost always real-time because of their inherent interaction with external events.</span></span>

### <a name="multitasking"></a><span data-ttu-id="13917-189">멀티태스킹</span><span class="sxs-lookup"><span data-stu-id="13917-189">Multitasking</span></span>

<span data-ttu-id="13917-190">앞서 언급했듯이 포함된 애플리케이션에는 전용 용도가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13917-190">As mentioned, embedded applications have a dedicated purpose.</span></span> <span data-ttu-id="13917-191">이러한 목적을 달성하기 위해 소프트웨어에서는 다양한 작업을 수행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="13917-191">To fulfill this purpose, the software must perform a variety of *tasks*.</span></span> <span data-ttu-id="13917-192">작업은 특정 업무를 수행하는 애플리케이션의 부분적으로 독립된 부분입니다.</span><span class="sxs-lookup"><span data-stu-id="13917-192">A task is a semi-independent portion of the application that carries out a specific duty.</span></span> <span data-ttu-id="13917-193">일부 작업이 다른 작업보다 더 중요한 경우도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13917-193">It is also the case that some tasks are more important than others.</span></span> <span data-ttu-id="13917-194">포함된 애플리케이션에서 발생하는 주요 문제 중 하나는 다양한 애플리케이션 작업 간에 프로세서를 할당하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="13917-194">One of the major difficulties in an embedded application is the allocation of the processor between the various application tasks.</span></span> <span data-ttu-id="13917-195">경쟁 작업 간의 이러한 처리 할당이 ThreadX의 주요 목적입니다.</span><span class="sxs-lookup"><span data-stu-id="13917-195">This allocation of processing between competing tasks is the primary purpose of ThreadX.</span></span>

### <a name="tasks-vs-threads"></a><span data-ttu-id="13917-196">작업 및 스레드</span><span class="sxs-lookup"><span data-stu-id="13917-196">Tasks vs. Threads</span></span>

<span data-ttu-id="13917-197">작업의 또 다른 차이점은 *작업* 은 다양한 방법으로 사용된다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="13917-197">Another distinction about tasks is that the term *task* is used in a variety of ways.</span></span> <span data-ttu-id="13917-198">경우에 따라 별도로 로드 가능한 프로그램을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="13917-198">It sometimes means a separately loadable program.</span></span> <span data-ttu-id="13917-199">내부 프로그램 세그먼트를 나타내는 경우도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13917-199">In other instances, it may refer to an internal program segment.</span></span> <span data-ttu-id="13917-200">따라서 최신 운영 체제에서는 프로세스 및 스레드라는 두 용어가 사용됩니다. 프로세스가 작업 대신 더 많이 사용되고 스레드는 덜 사용됩니다. </span><span class="sxs-lookup"><span data-stu-id="13917-200">Therefore, in contemporary operating systems, there are two terms that more or less replace the use of task: *process* and *thread*.</span></span> <span data-ttu-id="13917-201">프로세스는 자체 주소 공간이 있는 완전히 독립적인 프로그램이지만 스레드는 프로세스 내에서 실행되는 부분 독립적 프로그램 세그먼트입니다.</span><span class="sxs-lookup"><span data-stu-id="13917-201">A *process* is a completely independent program that has its own address space, while a *thread* is a semi-independent program segment that executes within a process.</span></span> <span data-ttu-id="13917-202">스레드는 동일한 프로세스 주소 공간을 공유합니다.</span><span class="sxs-lookup"><span data-stu-id="13917-202">Threads share the same process address space.</span></span> <span data-ttu-id="13917-203">스레드 관리와 관련된 오버헤드는 최소화됩니다.</span><span class="sxs-lookup"><span data-stu-id="13917-203">The overhead associated with thread management is minimal.</span></span>

<span data-ttu-id="13917-204">대부분의 포함된 애플리케이션은 완전한 프로세스 지향 운영 체제와 연결된 오버헤드(메모리 및 성능 모두)를 수용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="13917-204">Most embedded applications cannot afford the overhead (both memory and performance) associated with a full-blown process-oriented operating system.</span></span> <span data-ttu-id="13917-205">또한 작은 마이크로프로세서에는 진정한 프로세스 기반 운영 체제를 지원하기 위한 하드웨어 아키텍처가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="13917-205">In addition, smaller microprocessors don't have the hardware architecture to support a true process-oriented operating system.</span></span> <span data-ttu-id="13917-206">이러한 이유로 ThreadX는 대부분의 실시간 포함 애플리케이션에서 매우 효율적이고 실용적인 스레드 모델을 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="13917-206">For these reasons, ThreadX implements a thread model, which is both extremely efficient and practical for most real-time embedded applications.</span></span>

<span data-ttu-id="13917-207">혼동을 피하기 위해 ThreadX는 용어 작업을 사용하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="13917-207">To avoid confusion, ThreadX does not use the term *task*.</span></span> <span data-ttu-id="13917-208">대신 더 설명적이고 현대적인 이름인 스레드를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="13917-208">Instead, the more descriptive and contemporary name *thread* is used.</span></span>

## <a name="threadx-benefits"></a><span data-ttu-id="13917-209">ThreadX의 이점</span><span class="sxs-lookup"><span data-stu-id="13917-209">ThreadX Benefits</span></span>

<span data-ttu-id="13917-210">ThreadX를 사용하면 포함된 애플리케이션에 많은 이점이 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13917-210">Using ThreadX provides many benefits to embedded applications.</span></span> <span data-ttu-id="13917-211">물론, 주요 이점은 포함된 애플리케이션 스레드에 처리 시간을 할당하는 방식에 달려 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13917-211">Of course, the primary benefit rests in how embedded application threads are allocated processing time.</span></span>

### <a name="improved-responsiveness"></a><span data-ttu-id="13917-212">향상된 응답성</span><span class="sxs-lookup"><span data-stu-id="13917-212">Improved Responsiveness</span></span>

<span data-ttu-id="13917-213">ThreadX와 같은 실시간 커널이 사용되기 전에, 대부분의 포함된 애플리케이션은 일반적으로 C *main* 함수 내에서 간단한 제어 루프를 사용하여 처리 시간을 할당했습니다.</span><span class="sxs-lookup"><span data-stu-id="13917-213">Prior to real-time kernels like ThreadX, most embedded applications allocated processing time with a simple control loop, usually from within the C *main* function.</span></span> <span data-ttu-id="13917-214">이 방법은 매우 작거나 간단한 애플리케이션에서 계속 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="13917-214">This approach is still used in very small or simple applications.</span></span> <span data-ttu-id="13917-215">그러나 복잡한 대규모 애플리케이션에서는 이벤트에 대한 응답 시간이 제어 루프를 1번 통과할 때를 나타내는 최악의 처리 시간 함수이기 때문에 이 방법이 실용적이지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="13917-215">However, in large or complex applications, it is not practical because the response time to any event is a function of the worst case processing time of one pass through the control loop.</span></span> 

<span data-ttu-id="13917-216">설상가상으로 제어 루프를 수정할 때마다 애플리케이션의 타이밍 특성이 변경되게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="13917-216">Making matters worse, the timing characteristics of the application change whenever modifications are made to the control loop.</span></span> <span data-ttu-id="13917-217">이로 인해 애플리케이션은 기본적으로 불안정해지고 유지 관리 및 개선하기 어려워집니다.</span><span class="sxs-lookup"><span data-stu-id="13917-217">This makes the application inherently unstable and difficult to maintain and improve on.</span></span>

<span data-ttu-id="13917-218">ThreadX는 중요한 외부 이벤트에 대해 빠르고 결정적인 응답 시간을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="13917-218">ThreadX provides fast and deterministic response times to important external events.</span></span> <span data-ttu-id="13917-219">ThreadX는 우선 순위가 높은 스레드가 실행하는 우선 순위가 낮은 스레드 실행을 선점할 수 있는 선점형 우선 순위 기반 일정 알고리즘을 통해 이를 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="13917-219">ThreadX accomplishes this through its preemptive, priority based scheduling algorithm, which allows a higher priority thread to preempt an executing lower-priority thread.</span></span> <span data-ttu-id="13917-220">결과적으로 최악의 응답 시간은 컨텍스트 전환을 수행하는 데 필요한 시간에 가까워집니다.</span><span class="sxs-lookup"><span data-stu-id="13917-220">As a result, the worst-case response time approaches the time required to perform a context switch.</span></span> <span data-ttu-id="13917-221">이것은 결정적일 뿐만 아니라 매우 빠릅니다.</span><span class="sxs-lookup"><span data-stu-id="13917-221">This is not only deterministic, but it is also extremely fast.</span></span>

### <a name="software-maintenance"></a><span data-ttu-id="13917-222">소프트웨어 유지 관리</span><span class="sxs-lookup"><span data-stu-id="13917-222">Software Maintenance</span></span>

<span data-ttu-id="13917-223">ThreadX 커널을 사용하면 애플리케이션 개발자는 애플리케이션의 다른 영역에 대한 타이밍 변경에 대해 걱정할 필요 없이 애플리케이션 스레드의 특정 요구 사항에 집중할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13917-223">The ThreadX kernel enables application developers to concentrate on specific requirements of their application threads without having to worry about changing the timing of other areas of the application.</span></span> <span data-ttu-id="13917-224">이 기능을 통해 ThreadX를 활용하는 애플리케이션을 훨씬 더 쉽게 복구하거나 개선할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13917-224">This feature also makes it much easier to repair or enhance an application that utilizes ThreadX.</span></span>

### <a name="increased-throughput"></a><span data-ttu-id="13917-225">향상된 처리량</span><span class="sxs-lookup"><span data-stu-id="13917-225">Increased Throughput</span></span>

<span data-ttu-id="13917-226">제어 루프 응답 시간 문제에 대한 가능한 해결 방법은 폴링을 더 추가하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="13917-226">A possible work-around to the control loop response time problem is to add more polling.</span></span> <span data-ttu-id="13917-227">이로 인해 응답성이 향상되지만 여전히 일관된 최악의 응답 시간이 보장되지 않으며 애플리케이션의 향후 수정을 개선하기 위한 어떤 작업도 진행되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="13917-227">This improves the responsiveness, but it still doesn't guarantee a constant worst-case response time and does nothing to enhance future modification of the application.</span></span> <span data-ttu-id="13917-228">또한 프로세서는 추가 폴링으로 인해 불필요한 처리를 좀 더 수행하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="13917-228">Also, the processor is now performing even more unnecessary processing because of the extra polling.</span></span> <span data-ttu-id="13917-229">이러한 불필요한 처리는 시스템의 전반적인 처리량을 줄입니다.</span><span class="sxs-lookup"><span data-stu-id="13917-229">All of this unnecessary processing reduces the overall throughput of the system.</span></span>

<span data-ttu-id="13917-230">오버헤드와 관련된 흥미로운 점은 많은 개발자가 ThreadX와 같은 다중 스레드 환경으로 인해 오버헤드가 증가하며 전체 시스템 처리량에 부정적인 영향을 미치는 것으로 간주한다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="13917-230">An interesting point regarding overhead is that many developers assume that multithreaded environments like ThreadX increase overhead and have a negative impact on total system throughput.</span></span> <span data-ttu-id="13917-231">하지만 경우에 따라 다중 스레딩이 실제로 제어 루프 환경에서 발생하는 모든 중복 폴링을 제거하여 오버헤드를 줄이게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="13917-231">But in some cases, multithreading actually reduces overhead by eliminating all of the redundant polling that occurs in control loop environments.</span></span> <span data-ttu-id="13917-232">다중 스레드 커널에 연결된 오버헤드는 일반적으로 컨텍스트 전환에 필요한 시간의 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="13917-232">The overhead associated with multithreaded kernels is typically a function of the time required for context switching.</span></span> <span data-ttu-id="13917-233">컨텍스트 전환 시간이 폴링 프로세스보다 낮으면 ThreadX는 오버헤드를 줄이고 처리량을 높일 수 있는 솔루션을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="13917-233">If the context switch time is less than the polling process, ThreadX provides a solution with the potential of less overhead and more throughput.</span></span> <span data-ttu-id="13917-234">이를 통해 ThreadX는 다양한 복잡성이나 크기를 갖는 애플리케이션에 적합한 선택 옵션입니다.</span><span class="sxs-lookup"><span data-stu-id="13917-234">This makes ThreadX an obvious choice for applications that have any degree of complexity or size.</span></span>

### <a name="processor-isolation"></a><span data-ttu-id="13917-235">프로세서 격리</span><span class="sxs-lookup"><span data-stu-id="13917-235">Processor Isolation</span></span>

<span data-ttu-id="13917-236">ThreadX는 애플리케이션과 기본 프로세서 간에 프로세서와 관련이 없는 강력한 인터페이스를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="13917-236">ThreadX provides a robust processor-independent interface between the application and the underlying processor.</span></span> <span data-ttu-id="13917-237">이를 통해 개발자는 많은 시간을 할애해서 하드웨어 세부 정보를 학습하는 대신, 애플리케이션에 집중할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13917-237">This allows developers to concentrate on the application rather than spending a significant amount of time learning hardware details.</span></span>

### <a name="dividing-the-application"></a><span data-ttu-id="13917-238">애플리케이션 분할</span><span class="sxs-lookup"><span data-stu-id="13917-238">Dividing the Application</span></span>

<span data-ttu-id="13917-239">제어 루프 기반 애플리케이션에서 각 개발자는 전체 애플리케이션의 런타임 동작 및 요구 사항에 대해 잘 알고 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="13917-239">In control loop-based applications, each developer must have an intimate knowledge of the entire application's run-time behavior and requirements.</span></span> <span data-ttu-id="13917-240">프로세서 할당 논리가 전체 애플리케이션에 분산되어 있기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="13917-240">This is because the processor allocation logic is dispersed throughout the entire application.</span></span> <span data-ttu-id="13917-241">애플리케이션의 크기나 복잡성이 증가함에 따라 모든 개발자가 전체 애플리케이션의 정확한 처리 요구 사항을 기억할 수는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="13917-241">As an application increases in size or complexity, it becomes impossible for all developers to remember the precise processing requirements of the entire application.</span></span>

<span data-ttu-id="13917-242">ThreadX는 개발자들이 프로세서 할당과 관련된 문제에 신경쓰지 않으면서 포함된 애플리케이션의 특정 부분에 집중할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="13917-242">ThreadX frees each developer from the worries associated with processor allocation and allows them to concentrate on their specific piece of the embedded application.</span></span> <span data-ttu-id="13917-243">또한 ThreadX는 강제로 애플리케이션이 명확하게 정의된 스레드로 분할되도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="13917-243">In addition, ThreadX forces the application to be divided into clearly defined threads.</span></span> <span data-ttu-id="13917-244">이와 같이 애플리케이션을 스레드로 분할하면서 개발이 훨씬 더 간단해집니다.</span><span class="sxs-lookup"><span data-stu-id="13917-244">By itself, this division of the application into threads makes development much simpler.</span></span>

### <a name="ease-of-use"></a><span data-ttu-id="13917-245">사용 편의성</span><span class="sxs-lookup"><span data-stu-id="13917-245">Ease of Use</span></span>

<span data-ttu-id="13917-246">ThreadX는 애플리케이션 개발자를 고려해서 설계되었습니다.</span><span class="sxs-lookup"><span data-stu-id="13917-246">ThreadX is designed with the application developer in mind.</span></span> <span data-ttu-id="13917-247">ThreadX 아키텍처 및 서비스 호출 인터페이스는 쉽게 이해할 수 있도록 설계되었습니다.</span><span class="sxs-lookup"><span data-stu-id="13917-247">The ThreadX architecture and service call interface are designed to be easily understood.</span></span> <span data-ttu-id="13917-248">결과적으로 ThreadX 개발자는 고급 기능을 신속하게 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13917-248">As a result, ThreadX developers can quickly use its advanced features.</span></span>

### <a name="improve-time-to-market"></a><span data-ttu-id="13917-249">출시 시간 개선</span><span class="sxs-lookup"><span data-stu-id="13917-249">Improve Time-to-market</span></span>

<span data-ttu-id="13917-250">ThreadX의 모든 이점은 소프트웨어 개발 프로세스를 가속화합니다.</span><span class="sxs-lookup"><span data-stu-id="13917-250">All of the benefits of ThreadX accelerate the software development process.</span></span> <span data-ttu-id="13917-251">ThreadX는 대부분의 프로세서 문제와 가장 일반적인 안전 인증을 처리하므로 이러한 작업을 개발 일정에 포함할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="13917-251">ThreadX takes care of most processor issues and the most common safety certifications, thereby removing this effort from the development schedule.</span></span> <span data-ttu-id="13917-252">이로 인해 출시 시간이 단축됩니다.</span><span class="sxs-lookup"><span data-stu-id="13917-252">All of this results in a faster time to market!</span></span>

### <a name="protecting-the-software-investment"></a><span data-ttu-id="13917-253">소프트웨어 투자 보호</span><span class="sxs-lookup"><span data-stu-id="13917-253">Protecting the Software Investment</span></span>

<span data-ttu-id="13917-254">이러한 아키텍처 때문에 ThreadX는 새 프로세서 및/또는 개발 도구 환경으로 쉽게 이식됩니다.</span><span class="sxs-lookup"><span data-stu-id="13917-254">Because of its architecture, ThreadX is easily ported to new processor and/or development tool environments.</span></span> <span data-ttu-id="13917-255">이러한 특성은 ThreadX가 기본 프로세서의 세부 정보에서 애플리케이션을 분리한다는 사실과 결합되어 ThreadX 애플리케이션의 이식성을 높이는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="13917-255">This, coupled with the fact that ThreadX insulates applications from details of the underlying processors, makes ThreadX applications highly portable.</span></span> <span data-ttu-id="13917-256">따라서 애플리케이션의 마이그레이션 경로가 보장되고 원래 개발 투자가 보호됩니다.</span><span class="sxs-lookup"><span data-stu-id="13917-256">As a result, the application's migration path is guaranteed, and the original development investment is protected.</span></span>
