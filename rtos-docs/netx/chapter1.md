---
title: 1장 - Azure RTOS NetX 소개
description: 이 장에는 Azure RTOS NetX에 대한 소개와 해당 애플리케이션 및 혜택에 대한 설명이 포함되어 있습니다.
author: philmea
ms.author: philmea
ms.date: 05/19/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 48be6a7ecddc53b36b3cc1a9ecfb50a11e285881
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/22/2021
ms.locfileid: "104811707"
---
# <a name="chapter-1---introduction-to-azure-rtos-netx"></a><span data-ttu-id="ef476-103">1장 - Azure RTOS NetX 소개</span><span class="sxs-lookup"><span data-stu-id="ef476-103">Chapter 1 - Introduction to Azure RTOS NetX</span></span>

<span data-ttu-id="ef476-104">Azure RTOS NetX는 포함된 ThreadX 기반 애플리케이션 전용으로 설계된 TCP/IP 표준의 고성능 실시간 구현입니다.</span><span class="sxs-lookup"><span data-stu-id="ef476-104">Azure RTOS NetX is a high-performance real-time implementation of the TCP/IP standards designed exclusively for embedded ThreadX-based applications.</span></span> <span data-ttu-id="ef476-105">이 장에는 NetX에 대한 소개와 해당 애플리케이션 및 혜택에 대한 설명이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ef476-105">This chapter contains an introduction to NetX and a description of its applications and benefits.</span></span>

## <a name="netx-unique-features"></a><span data-ttu-id="ef476-106">NetX 고유 기능</span><span class="sxs-lookup"><span data-stu-id="ef476-106">NetX Unique Features</span></span>

<span data-ttu-id="ef476-107">다른 TCP/IP 구현과 달리 NetX는 다용도로 설계되어 소규모 마이크로 컨트롤러 기반 애플리케이션에서 강력한 RISC와 DSP 프로세서를 사용하는 애플리케이션으로 쉽게 스케일링할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ef476-107">Unlike other TCP/IP implementations, NetX is designed to be versatile—easily scaling from small microcontroller-based applications to those that use powerful RISC and DSP processors.</span></span> <span data-ttu-id="ef476-108">이는 원래 워크스테이션 환경에 맞춰 고안된 후 포함된 설계에 갇혀 버린 퍼블릭 도메인 또는 기타 상용 구현과는 확실히 대비됩니다.</span><span class="sxs-lookup"><span data-stu-id="ef476-108">This is in sharp contrast to public domain or other commercial implementations originally intended for workstation environments but then squeezed into embedded designs.</span></span>

### <a name="piconettrade-architecture"></a><span data-ttu-id="ef476-109">Piconet&trade; 아키텍처</span><span class="sxs-lookup"><span data-stu-id="ef476-109">Piconet&trade; Architecture</span></span>

<span data-ttu-id="ef476-110">NetX의 뛰어난 스케일링과 성능의 기반에는 포함된 시스템용으로 특별히 설계된 소프트웨어인 ‘Piconet’이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ef476-110">Underlying the superior scalability and performance of NetX is *Piconet*, a software architecture especially designed for embedded systems.</span></span> <span data-ttu-id="ef476-111">Piconet 아키텍처는 NetX 서비스를 C 라이브러리로 구현하여 스케일링을 극대화합니다.</span><span class="sxs-lookup"><span data-stu-id="ef476-111">Piconet architecture maximizes scalability by implementing NetX services as a C library.</span></span> <span data-ttu-id="ef476-112">이러한 방식으로 애플리케이션에서 실제로 사용하는 서비스만 최종 런타임 이미지로 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="ef476-112">In this way, only those services actually used by the application are brought into the final runtime image.</span></span> <span data-ttu-id="ef476-113">따라서 NetX의 실제 크기는 애플리케이션에 의해 완전히 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="ef476-113">Hence, the actual size of NetX is completely determined by the application.</span></span> <span data-ttu-id="ef476-114">대부분의 애플리케이션의 경우 NetX의 이미지 크기 요구 사항은 5KB~30KB 사이로 크기입니다.</span><span class="sxs-lookup"><span data-stu-id="ef476-114">For most applications, the image size requirements of NetX ranges between 5 KBytes and 30 KBytes in size.</span></span>

<span data-ttu-id="ef476-115">NetX는 반드시 필요한 경우에만 내부 구성 요소 함수 호출을 계층화하여 뛰어난 네트워크 성능을 얻습니다.</span><span class="sxs-lookup"><span data-stu-id="ef476-115">NetX achieves superior network performance by layering internal component function calls only when it is absolutely necessary.</span></span> <span data-ttu-id="ef476-116">또한 대부분의 NetX 처리는 온라인으로 직접 수행되므로 과거에 임베디드 디자인에서 사용되던 워크스테이션 네트워크 소프트웨어보다 더 나은 성능상의 이점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ef476-116">In addition, much of NetX processing is done directly in-line, resulting in outstanding performance advantages over the workstation network software that was often used in embedded designs in the past.</span></span></th>

### <a name="zero-copy-implementation"></a><span data-ttu-id="ef476-117">복사 없는 구현</span><span class="sxs-lookup"><span data-stu-id="ef476-117">Zero-copy Implementation</span></span>

<span data-ttu-id="ef476-118">NetX는 TCP/IP의 패킷 기반의 ‘복사 없는’ 구현을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="ef476-118">NetX provides a packet-based, *zero-copy* implementation of TCP/IP.</span></span> <span data-ttu-id="ef476-119">복사 없는 구현은 애플리케이션의 패킷 버퍼에 있는 데이터가 NetX 내에 절대 복사되지 않는다는 것을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="ef476-119">Zero copy means that data in the application's packet buffer are never copied inside NetX.</span></span> <span data-ttu-id="ef476-120">이렇게 하면 성능이 아주 크게 향상되고 포함된 애플리케이션에 매우 가치 있는 프로세서 주기가 확보됩니다.</span><span class="sxs-lookup"><span data-stu-id="ef476-120">This greatly improves performance and frees up valuable processor cycles to the application, which is extremely important in embedded applications.</span></span>

### <a name="udp-fast-pathtrade-technology"></a><span data-ttu-id="ef476-121">UDP Fast Path&trade; Technology</span><span class="sxs-lookup"><span data-stu-id="ef476-121">UDP Fast Path&trade; Technology</span></span>

<span data-ttu-id="ef476-122">*UDP Fast Path Technology* 을 사용하여 NetX는 가능한 가장 빠른 UDP 처리를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="ef476-122">With *UDP Fast Path Technology*, NetX provides the fastest possible UDP processing.</span></span> <span data-ttu-id="ef476-123">송신 측에서는 선택적 UDP 체크섬을 비롯한 UDP 처리가 ***nx_udp_socket_send*** 서비스에 완전히 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ef476-123">On the sending side, UDP processing—including the optional UDP checksum—is completely contained within the ***nx_udp_socket_send*** service.</span></span> <span data-ttu-id="ef476-124">내부 NetX IP 전송 루틴을 통해 패킷을 전송할 준비가 될 때까지 추가 함수 호출이 수행되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ef476-124">No additional function calls are made until the packet is ready to be sent via the internal NetX IP send routine.</span></span> <span data-ttu-id="ef476-125">이 루틴은 또한 플랫이므로(즉, 함수 호출 중첩이 최소임) 패킷이 애플리케이션의 네트워크 드라이버로 신속하게 디스패치됩니다.</span><span class="sxs-lookup"><span data-stu-id="ef476-125">This routine is also flat (i.e., its function call nesting is minimal) so the packet is quickly dispatched to the application's network driver.</span></span> <span data-ttu-id="ef476-126">UDP 패킷이 수신되면 NetX 패킷 수신 처리는 해당 UDP 소켓의 수신 큐에 직접 패킷을 배치하거나 일시 중단되어 UDP 소켓의 수신 큐에서 수신 패킷을 대기하는 첫 번째 스레드에 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="ef476-126">When the UDP packet is received, the NetX packet-receive processing places the packet directly on the appropriate UDP socket's receive queue or gives it to the first thread suspended waiting for a receive packet from the UDP socket's receive queue.</span></span> <span data-ttu-id="ef476-127">추가 ThreadX 컨텍스트 전환은 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ef476-127">No additional ThreadX context switches are necessary.</span></span>

### <a name="ansi-c-source-code"></a><span data-ttu-id="ef476-128">ANSI C 소스 코드</span><span class="sxs-lookup"><span data-stu-id="ef476-128">ANSI C Source Code</span></span>

<span data-ttu-id="ef476-129">NetX는 완전히 ANSI C로 작성되었으며 ANSI C 컴파일러와 ThreadX를 지원하는 모든 프로세서 아키텍처에 실제로 즉시 이식할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ef476-129">NetX is written completely in ANSI C and is portable immediately to virtually any processor architecture that has an ANSI C compiler and ThreadX support.</span></span>

### <a name="not-a-black-box"></a><span data-ttu-id="ef476-130">블랙 박스가 아님</span><span class="sxs-lookup"><span data-stu-id="ef476-130">Not A Black Box</span></span>

<span data-ttu-id="ef476-131">대부분의 NetX 배포판에는 전체 C 소스 코드가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="ef476-131">Most distributions of NetX include the complete C source code.</span></span> <span data-ttu-id="ef476-132">따라서 많은 상용 네트워크 스택에서 발생하는 “블랙 박스” 문제를 없앨 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ef476-132">This eliminates the "black-box" problems that occur with many commercial network stacks.</span></span> <span data-ttu-id="ef476-133">애플리케이션 개발자는 NetX를 사용하여 네트워크 스택이 수행하는 작업을 정확하게 파악할 수 있기 때문에 모든 것이 명확합니다!</span><span class="sxs-lookup"><span data-stu-id="ef476-133">By using NetX, applications developers can see exactly what the network stack is doing—there are no mysteries!</span></span>
  
<span data-ttu-id="ef476-134">소스 코드가 있기 때문에 애플리케이션 관련 수정이 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="ef476-134">Having the source code also allows for application-specific modifications.</span></span> <span data-ttu-id="ef476-135">권장되지는 않지만 필요한 경우 네트워크 스택을 수정하는 기능을 제공한 것은 확실히 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="ef476-135">Although not recommended, it is certainly beneficial to have the ability to modify the network stack if it is required.</span></span>  

<span data-ttu-id="ef476-136">해당 특징은 사내 또는 퍼블릭 도메인 네트워크 스택으로 작업하는 데 익숙한 개발자에게 특히 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="ef476-136">These features are especially comforting to developers accustomed to working with in-house or public domain network stacks.</span></span> <span data-ttu-id="ef476-137">이들에게는 소스 코드와 소스 코드를 수정할 수 있는 기능이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="ef476-137">They expect to have source code and the ability to modify it.</span></span> <span data-ttu-id="ef476-138">NetX는 이러한 개발자를 위한 최종 네트워크 소프트웨어입니다.</span><span class="sxs-lookup"><span data-stu-id="ef476-138">NetX is the ultimate network software for such developers.</span></span>

### <a name="bsd-compatible-socket-api"></a><span data-ttu-id="ef476-139">BSD 호환 소켓 API</span><span class="sxs-lookup"><span data-stu-id="ef476-139">BSD-Compatible Socket API</span></span>

<span data-ttu-id="ef476-140">레거시 애플리케이션의 경우 NetX는 아래의 고성능 NetX API를 호출하는 BSD 호환 소켓 인터페이스를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="ef476-140">For legacy applications, NetX provides a BSD compatible socket interface that makes calls to the high-performance NetX API underneath.</span></span> <span data-ttu-id="ef476-141">이를 통해 기존 네트워크 애플리케이션 코드를 NetX로 마이그레이션하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ef476-141">This helps in migrating existing network application code to NetX.</span></span>

## <a name="rfcs-supported-by-netx"></a><span data-ttu-id="ef476-142">NetX에서 지원하는 RFC</span><span class="sxs-lookup"><span data-stu-id="ef476-142">RFCs Supported by NetX</span></span>

<span data-ttu-id="ef476-143">기본 네트워크 프로토콜을 설명하는 RFC의 NetX 지원에는 다음 네트워크 프로토콜이 포함되지만 이에 국한되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ef476-143">NetX support of RFCs describing basic network protocols includes but is not limited to the following network protocols.</span></span> <span data-ttu-id="ef476-144">NetX는 작은 메모리 사용 공간과 효율적인 실행으로 실시간 운영 체제의 제약 조건 내에서 모든 일반 권장 사항 및 기본 요구 사항을 따릅니다.</span><span class="sxs-lookup"><span data-stu-id="ef476-144">NetX follows all general recommendations and basic requirements within the constraints of a real-time operating system with small memory footprint and efficient execution.</span></span>

| <span data-ttu-id="ef476-145">RFC</span><span class="sxs-lookup"><span data-stu-id="ef476-145">RFC</span></span>      | <span data-ttu-id="ef476-146">Description</span><span class="sxs-lookup"><span data-stu-id="ef476-146">Description</span></span>                                            |
|----------|--------------------------------------------------------|
| <span data-ttu-id="ef476-147">RFC 1112</span><span class="sxs-lookup"><span data-stu-id="ef476-147">RFC 1112</span></span> | <span data-ttu-id="ef476-148">IGMPv1(IP 멀티캐스팅을 위한 호스트 확장)</span><span class="sxs-lookup"><span data-stu-id="ef476-148">Host Extensions for IP Multicasting (IGMPv1)</span></span>           |
| <span data-ttu-id="ef476-149">RFC 1122</span><span class="sxs-lookup"><span data-stu-id="ef476-149">RFC 1122</span></span> | <span data-ttu-id="ef476-150">인터넷 호스트에 대한 요구 사항 - 통신 계층</span><span class="sxs-lookup"><span data-stu-id="ef476-150">Requirements for Internet Hosts - Communication Layers</span></span> |
| <span data-ttu-id="ef476-151">RFC 2236</span><span class="sxs-lookup"><span data-stu-id="ef476-151">RFC 2236</span></span> | <span data-ttu-id="ef476-152">Internet Group Management Protocol, 버전 2</span><span class="sxs-lookup"><span data-stu-id="ef476-152">Internet Group Management Protocol, Version 2</span></span>          |
| <span data-ttu-id="ef476-153">RFC 768</span><span class="sxs-lookup"><span data-stu-id="ef476-153">RFC 768</span></span>  | <span data-ttu-id="ef476-154">UDP(User Datagram Protocol)</span><span class="sxs-lookup"><span data-stu-id="ef476-154">User Datagram Protocol (UDP)</span></span>                           |
| <span data-ttu-id="ef476-155">RFC 791</span><span class="sxs-lookup"><span data-stu-id="ef476-155">RFC 791</span></span>  | <span data-ttu-id="ef476-156">IP(인터넷 프로토콜)</span><span class="sxs-lookup"><span data-stu-id="ef476-156">Internet Protocol (IP)</span></span>                                 |
| <span data-ttu-id="ef476-157">RFC 792</span><span class="sxs-lookup"><span data-stu-id="ef476-157">RFC 792</span></span>  | <span data-ttu-id="ef476-158">ICMP(Internet Control Message Protocol)</span><span class="sxs-lookup"><span data-stu-id="ef476-158">Internet Control Message Protocol (ICMP)</span></span>               |
| <span data-ttu-id="ef476-159">RFC 793</span><span class="sxs-lookup"><span data-stu-id="ef476-159">RFC 793</span></span>  | <span data-ttu-id="ef476-160">TCP(Transmission Control Protocol)</span><span class="sxs-lookup"><span data-stu-id="ef476-160">Transmission Control Protocol (TCP)</span></span>                    |
| <span data-ttu-id="ef476-161">RFC 826</span><span class="sxs-lookup"><span data-stu-id="ef476-161">RFC 826</span></span>  | <span data-ttu-id="ef476-162">이더넷 ARP(주소 확인 프로토콜)</span><span class="sxs-lookup"><span data-stu-id="ef476-162">Ethernet Address Resolution Protocol (ARP)</span></span>             |
| <span data-ttu-id="ef476-163">RFC 903</span><span class="sxs-lookup"><span data-stu-id="ef476-163">RFC 903</span></span>  | <span data-ttu-id="ef476-164">RARP(역주소 확인 프로토콜)</span><span class="sxs-lookup"><span data-stu-id="ef476-164">Reverse Address Resolution Protocol (RARP)</span></span>             |
|          |                                                        |

## <a name="embedded-network-applications"></a><span data-ttu-id="ef476-165">포함된 네트워크 애플리케이션</span><span class="sxs-lookup"><span data-stu-id="ef476-165">Embedded Network Applications</span></span>

<span data-ttu-id="ef476-166">포함된 네트워크 애플리케이션은 네트워크에 액세스해야 하며 휴대폰, 통신 장비, 자동차 엔진, 레이저 프린터, 의료 디바이스 등의 제품 내에서 숨겨진 마이크로프로세서에서 실행되는 애플리케이션입니다.</span><span class="sxs-lookup"><span data-stu-id="ef476-166">Embedded network applications are applications that need network access and execute on microprocessors hidden inside products such as cellular phones, communication equipment, automotive engines, laser printers, medical devices, and so forth.</span></span> <span data-ttu-id="ef476-167">이와 같은 애플리케이션에는 거의 항상 몇 가지 메모리와 성능 제약 조건이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ef476-167">Such applications almost always have some memory and performance constraints.</span></span> <span data-ttu-id="ef476-168">포함된 네트워크 애플리케이션의 또 다른 차이점은 소프트웨어와 하드웨어에 전용 용도가 있다는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="ef476-168">Another distinction of embedded network applications is that their software and hardware have a dedicated purpose.</span></span>

### <a name="real-time-network-software"></a><span data-ttu-id="ef476-169">실시간 네트워크 소프트웨어</span><span class="sxs-lookup"><span data-stu-id="ef476-169">Real-time Network Software</span></span>  

<span data-ttu-id="ef476-170">기본적으로 정확한 시간 내에 처리를 수행해야 하는 네트워크 소프트웨어를 ‘실시간’ ‘네트워크’ 소프트웨어라고 하며, 시간 제약 조건이 네트워크 애플리케이션에 적용되는 경우에는 실시간 애플리케이션으로 분류됩니다.</span><span class="sxs-lookup"><span data-stu-id="ef476-170">Basically, network software that must perform its processing within an exact period of time is called *real-time* *network* software, and when time constraints are imposed on network applications, they are classified as real-time applications.</span></span> <span data-ttu-id="ef476-171">포함된 네트워크 애플리케이션은 본질적으로 외부와 상호 작용하기 때문에 거의 항상 실시간입니다.</span><span class="sxs-lookup"><span data-stu-id="ef476-171">Embedded network applications are almost always real-time because of their inherent interaction with the external world.</span></span>

## <a name="netx-benefits"></a><span data-ttu-id="ef476-172">NetX의 이점</span><span class="sxs-lookup"><span data-stu-id="ef476-172">NetX Benefits</span></span>

<span data-ttu-id="ef476-173">포함된 애플리케이션에 NetX를 사용할 경우의 주요 이점은 고속 인터넷 연결 및 매우 작은 메모리 요구 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="ef476-173">The primary benefits of using NetX for embedded applications are high-speed Internet connectivity and very small memory requirements.</span></span> <span data-ttu-id="ef476-174">또한 NetX는 뛰어난 성능을 자랑하는 멀티태스킹 ThreadX 실시간 운영 체제와 완전히 통합됩니다.</span><span class="sxs-lookup"><span data-stu-id="ef476-174">NetX is also completely integrated with the high-performance, multitasking ThreadX real-time operating system.</span></span>

### <a name="improved-responsiveness"></a><span data-ttu-id="ef476-175">향상된 응답성</span><span class="sxs-lookup"><span data-stu-id="ef476-175">Improved Responsiveness</span></span>  

<span data-ttu-id="ef476-176">고성능 NetX 프로토콜 스택을 사용하면 포함된 네트워크 애플리케이션이 이전보다 더 빠르게 응답할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ef476-176">The high-performance NetX protocol stack enables embedded network applications to respond faster than ever before.</span></span> <span data-ttu-id="ef476-177">이러한 특성은 단일 패킷에 상당한 양의 네트워크 트래픽이나 엄격한 처리 요구 사항을 발생하는 포함된 애플리케이션에 특히 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="ef476-177">This is especially important for embedded applications that either have a significant volume of network traffic or stringent processing requirements on a single packet.</span></span>

### <a name="software-maintenance"></a><span data-ttu-id="ef476-178">소프트웨어 유지 관리</span><span class="sxs-lookup"><span data-stu-id="ef476-178">Software Maintenance</span></span>

<span data-ttu-id="ef476-179">NetX를 사용하면 개발자는 포함된 애플리케이션의 네트워크 측면을 쉽게 분할할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ef476-179">Using NetX allows developers to easily partition the network aspects of their embedded application.</span></span> <span data-ttu-id="ef476-180">분할을 통해 전체 개발 프로세스를 쉽게 진행하고 향후 소프트웨어 유지 관리를 크게 개선할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ef476-180">This partitioning makes the entire development process easy and significantly enhances future software maintenance.</span></span>

### <a name="increased-throughput"></a><span data-ttu-id="ef476-181">향상된 처리량.</span><span class="sxs-lookup"><span data-stu-id="ef476-181">Increased Throughput</span></span>

<span data-ttu-id="ef476-182">NetX는 사용 가능한 최고 성능 네트워킹을 제공하며, 이러한 이점은 최소 패킷 처리 오버헤드를 통해 구현됩니다.</span><span class="sxs-lookup"><span data-stu-id="ef476-182">NetX provides the highest-performance networking available, which is achieved by minimal packet processing overhead.</span></span> <span data-ttu-id="ef476-183">이를 통해 처리량을 높일 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ef476-183">This also enables increased throughput.</span></span>

### <a name="processor-isolation"></a><span data-ttu-id="ef476-184">프로세서 격리</span><span class="sxs-lookup"><span data-stu-id="ef476-184">Processor Isolation</span></span>

<span data-ttu-id="ef476-185">NetX는 애플리케이션, 기본 프로세서, 네트워크 하드웨어 간에 프로세서와 관련이 없는 강력한 인터페이스를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="ef476-185">NetX provides a robust, processor-independent interface between the application and the underlying processor and network hardware.</span></span> <span data-ttu-id="ef476-186">이를 통해 개발자는 네트워킹에 직접적으로 영향을 주는 하드웨어 문제를 처리하는 데 불필요한 시간을 낭비하지 않고, 애플리케이션의 네트워크 측면에 집중할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ef476-186">This allows developers to concentrate on the network aspects of the application rather than spending extra time dealing with hardware issues directly affecting networking.</span></span>

### <a name="ease-of-use"></a><span data-ttu-id="ef476-187">사용 편의성</span><span class="sxs-lookup"><span data-stu-id="ef476-187">Ease of Use</span></span>

<span data-ttu-id="ef476-188">NetX는 애플리케이션 개발자를 염두에 두고 설계되었습니다.</span><span class="sxs-lookup"><span data-stu-id="ef476-188">NetX is designed with the application developer in mind.</span></span> <span data-ttu-id="ef476-189">NetX 아키텍처와 서비스 호출 인터페이스는 이해하기 쉽습니다.</span><span class="sxs-lookup"><span data-stu-id="ef476-189">The NetX architecture and service call interface are easy to understand.</span></span> <span data-ttu-id="ef476-190">결과적으로 NetX 개발자는 고급 기능을 신속하게 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ef476-190">As a result, NetX developers can quickly use its advanced features.</span></span>

### <a name="improve-time-to-market"></a><span data-ttu-id="ef476-191">출시 시간 개선</span><span class="sxs-lookup"><span data-stu-id="ef476-191">Improve Time to Market</span></span>

<span data-ttu-id="ef476-192">NetX의 강력한 특징이 소프트웨어 개발 프로세스를 가속화합니다.</span><span class="sxs-lookup"><span data-stu-id="ef476-192">The powerful features of NetX accelerate the software development process.</span></span> <span data-ttu-id="ef476-193">NetX는 대부분의 프로세서 및 네트워크 하드웨어 문제를 추상화하여 대부분의 애플리케이션 네트워크 관련 영역에서 이러한 문제를 방지합니다.</span><span class="sxs-lookup"><span data-stu-id="ef476-193">NetX abstracts most processor and network hardware issues, thereby removing these concerns from a majority of application network-specific areas.</span></span> <span data-ttu-id="ef476-194">사용 편의성과 뛰어난 기능 집합과 함께 이 특징은 시장 출시 시간을 단축해 줍니다!</span><span class="sxs-lookup"><span data-stu-id="ef476-194">This, coupled with the ease-of-use and advanced feature set, results in a faster time to market.</span></span>

### <a name="protecting-the-software-investment"></a><span data-ttu-id="ef476-195">소프트웨어 투자 보호</span><span class="sxs-lookup"><span data-stu-id="ef476-195">Protecting the Software Investment</span></span>

<span data-ttu-id="ef476-196">NetX는 ANSI C로만 작성되며 ThreadX 실시간 운영 체제와 완전히 통합됩니다.</span><span class="sxs-lookup"><span data-stu-id="ef476-196">NetX is written exclusively in ANSI C and is fully integrated with the ThreadX real-time operating system.</span></span> <span data-ttu-id="ef476-197">즉, NetX 애플리케이션은 모든 ThreadX 지원 프로세서에 즉시 이식할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ef476-197">This means NetX applications are instantly portable to all ThreadX supported processors.</span></span> <span data-ttu-id="ef476-198">더 놀라운 점은 ThreadX를 사용하면 불과 몇 주 만에 완전히 새로운 프로세서 아키텍처를 지원할 수 있다는 사실입니다.</span><span class="sxs-lookup"><span data-stu-id="ef476-198">Better still, a completely new processor architecture can be supported with ThreadX in a matter of weeks.</span></span> <span data-ttu-id="ef476-199">따라서 NetX를 사용하면 애플리케이션의 마이그레이션 경로를 보장하고 원래 개발 투자를 보호할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ef476-199">As a result, using NetX ensures the application's migration path and protects the original development investment.</span></span>
