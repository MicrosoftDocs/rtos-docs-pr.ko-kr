---
title: 1장 - Azure RTOS NetX Duo PPP(지점 간 프로토콜) 소개
description: 이 장에서는 Azure RTOS NetX Duo PPP(지점 간 프로토콜)를 소개합니다.
author: philmea
ms.author: philmea
ms.date: 06/04/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: f439cf66e6619652ae8ab9097b2de5e584d78c59
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/22/2021
ms.locfileid: "104810656"
---
# <a name="chapter-1---introduction-to-the-azure-rtos-netx-duo-point-to-point-protocol-ppp"></a><span data-ttu-id="619aa-103">1장 - Azure RTOS NetX Duo PPP(지점 간 프로토콜) 소개</span><span class="sxs-lookup"><span data-stu-id="619aa-103">Chapter 1 - Introduction to the Azure RTOS NetX Duo Point-to-Point Protocol (PPP)</span></span>

<span data-ttu-id="619aa-104">일반적으로 NetX 애플리케이션은 이더넷을 통해 실제 물리적 네트워크에 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="619aa-104">Typically, NetX applications connect to the actual physical network through Ethernet.</span></span> <span data-ttu-id="619aa-105">이는 빠르고 효율적인 네트워크 액세스를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="619aa-105">This provides network access that is both fast and efficient.</span></span> <span data-ttu-id="619aa-106">그러나 애플리케이션에 이더넷 액세스 권한이 없는 경우가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="619aa-106">However, there are situations where the application does not have Ethernet access.</span></span> <span data-ttu-id="619aa-107">이러한 경우 애플리케이션은 다른 네트워크 구성원에 직접 연결된 직렬 인터페이스를 통해 네트워크에 계속 연결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="619aa-107">In such cases, the application may still connect to the network through a serial interface connected directly to another network member.</span></span> <span data-ttu-id="619aa-108">이러한 연결을 관리하는 데 사용되는 가장 일반적인 소프트웨어 프로토콜은 PPP(지점 간 프로토콜)입니다.</span><span class="sxs-lookup"><span data-stu-id="619aa-108">The most common software protocol used to manage such a connection is the Point-to-Point Protocol (PPP).</span></span>

<span data-ttu-id="619aa-109">직렬 통신은 비교적 간단하지만 PPP는 다소 복잡합니다.</span><span class="sxs-lookup"><span data-stu-id="619aa-109">Although serial communication is relatively straightforward, the PPP is somewhat complex.</span></span> <span data-ttu-id="619aa-110">PPP는 실제로 LCP(연결 제어 프로토콜), IPCP(인터넷 프로토콜 제어 프로토콜), PAP(암호 인증 프로토콜) 및 CHAP(Challenge-Handshake 인증 프로토콜)와 같은 여러 프로토콜로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="619aa-110">The PPP is actually comprised of multiple protocols, such as the Link Control Protocol (LCP), Internet Protocol Control Protocol (IPCP), Password Authentication Protocol (PAP), and the Challenge-Handshake Authentication Protocol (CHAP).</span></span> <span data-ttu-id="619aa-111">LCP는 PPP의 주요 프로토콜입니다.</span><span class="sxs-lookup"><span data-stu-id="619aa-111">The LCP is the main protocol for PPP.</span></span> <span data-ttu-id="619aa-112">여기에서 링크의 기본 구성 요소가 피어 투 피어 방식으로 동적으로 협상됩니다.</span><span class="sxs-lookup"><span data-stu-id="619aa-112">This is where the basic components of the link are dynamically negotiated in a peer-to-peer fashion.</span></span> <span data-ttu-id="619aa-113">링크의 기본 특성을 성공적으로 협상한 후에는 PAP 및/또는 CHAP를 사용하여 연결된 피어가 유효한지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="619aa-113">Once the basic characteristics of the link have been successfully negotiated, the PAP and/or CHAP are used to ensure a connected peer is valid.</span></span> <span data-ttu-id="619aa-114">두 피어가 모두 유효하면 IPCP를 사용하여 피어에서 사용하는 IP 주소를 협상합니다.</span><span class="sxs-lookup"><span data-stu-id="619aa-114">If both peers are valid, the IPCP is then utilized to negotiate the IP addresses used by the peers.</span></span> <span data-ttu-id="619aa-115">IPCP가 완료되면 PPP는 IP 패킷을 보내고 받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="619aa-115">Once IPCP completes, PPP is then able to send and receive IP packets.</span></span>

<span data-ttu-id="619aa-116">NetX는 PPP를 주로 디바이스 드라이버로 봅니다.</span><span class="sxs-lookup"><span data-stu-id="619aa-116">NetX views the PPP primarily as a device driver.</span></span> <span data-ttu-id="619aa-117">*nx_ppp_driver* 함수는 NetX IP 생성 함수 *nx_ip_create* 에 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="619aa-117">The *nx_ppp_driver* function is supplied to the NetX IP create function, *nx_ip_create*.</span></span> <span data-ttu-id="619aa-118">그렇지 않으면 NetX는 PPP에 대한 직접적인 정보를 가지고 있지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="619aa-118">Otherwise, NetX does not have any direct knowledge of PPP.</span></span>

## <a name="ppp-serial-communication"></a><span data-ttu-id="619aa-119">PPP 직렬 통신</span><span class="sxs-lookup"><span data-stu-id="619aa-119">PPP Serial Communication</span></span>

<span data-ttu-id="619aa-120">NetX PPP 패키지를 사용하려면 애플리케이션이 직렬 통신 드라이버를 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="619aa-120">The NetX PPP package requires the application to provide a serial communication driver.</span></span> <span data-ttu-id="619aa-121">드라이버는 8비트 문자를 지원해야 하며 소프트웨어 흐름 제어를 사용할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="619aa-121">The driver must support 8-bit characters and may also employ software flow control.</span></span> <span data-ttu-id="619aa-122">드라이버를 초기화하는 것은 애플리케이션의 책임입니다. 이는 PPP 인스턴스를 만들기 전에 수행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="619aa-122">It is the application’s responsibility to initialize the driver, which should be done prior to creating the PPP instance.</span></span>

<span data-ttu-id="619aa-123">PPP 패킷을 보내려면 직렬 드라이버 출력 바이트 루틴을 PPP에 제공해야 합니다(*nx_ppp_create* 함수에 지정됨).</span><span class="sxs-lookup"><span data-stu-id="619aa-123">In order to send PPP packets, a serial driver output byte routine must be provided to PPP (specified in the *nx_ppp_create* function).</span></span> <span data-ttu-id="619aa-124">이 직렬 드라이버 바이트 출력 루틴은 전체 PPP 패킷을 전송하기 위해 반복적으로 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="619aa-124">This serial driver byte output routine will be called repetitively in order to transmit the entire PPP packet.</span></span> <span data-ttu-id="619aa-125">출력을 버퍼링하는 것은 직렬 드라이버의 책임입니다.</span><span class="sxs-lookup"><span data-stu-id="619aa-125">It is the serial driver’s responsibility to buffer the output.</span></span> <span data-ttu-id="619aa-126">수신 쪽에서 애플리케이션의 직렬 드라이버는 새 바이트가 도착할 때마다 PPP *nx_ppp_byte_receive* 함수를 호출해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="619aa-126">On the receive side, the application’s serial driver must call the PPP *nx_ppp_byte_receive* function whenever a new byte arrives.</span></span> <span data-ttu-id="619aa-127">일반적으로 이 작업은 ISR(Interrupt Service Routine)의 컨텍스트 내에서 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="619aa-127">This is typically done from within the context of an Interrupt Service Routine (ISR).</span></span> <span data-ttu-id="619aa-128">*nx_ppp_byte_receive* 함수는 들어오는 바이트를 순환 버퍼에 배치하고 PPP 수신 스레드에 해당 상태를 알립니다.</span><span class="sxs-lookup"><span data-stu-id="619aa-128">The *nx_ppp_byte_receive* function places the incoming byte into a circular buffer and alerts the PPP receive thread of its presence.</span></span>

## <a name="ppp-over-ethernet-communication"></a><span data-ttu-id="619aa-129">이더넷 통신을 통한 PPP</span><span class="sxs-lookup"><span data-stu-id="619aa-129">PPP Over Ethernet Communication</span></span>

<span data-ttu-id="619aa-130">NetX PPP는 이더넷을 통해 PPP 메시지를 전송할 수도 있습니다. 이 경우 NetX PPP 패키지는 이더넷 드라이버를 제공하기 위해 애플리케이션이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="619aa-130">NetX PPP also can transmit PPP message over Ethernet, in this situation, the NetX PPP package requires the application to provide an Ethernet communication driver.</span></span>

<span data-ttu-id="619aa-131">이더넷을 통해 PPP 패킷을 전송하려면 출력 루틴이 PPP에 제공되어야 합니다(*nx_ppp_packet_send_set* 함수에 지정됨).</span><span class="sxs-lookup"><span data-stu-id="619aa-131">In order to send PPP packets over Ethernet, an output routine must be provided to PPP (specified in the *nx_ppp_packet_send_set* function).</span></span> <span data-ttu-id="619aa-132">이 출력 루틴은 전체 PPP 패킷을 전송하기 위해 반복적으로 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="619aa-132">This output routine will be called repetitively in order to transmit the entire PPP packet.</span></span> <span data-ttu-id="619aa-133">수신 쪽에서 애플리케이션의 수신자는 새 패킷이 도착할 때마다 PPP *nx_ppp_packet_receive* 함수를 호출해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="619aa-133">On the receive side, the application’s receiver must call the PPP *nx_ppp_packet_receive* function whenever a new packet arrives.</span></span>

## <a name="ppp-packet"></a><span data-ttu-id="619aa-134">PPP 패킷</span><span class="sxs-lookup"><span data-stu-id="619aa-134">PPP Packet</span></span>

<span data-ttu-id="619aa-135">PPP는 모든 PPP 프로토콜 제어와 사용자 데이터를 캡슐화하기 위해 AHDLC 프레이밍(HDLC의 하위 집합)을 활용합니다.</span><span class="sxs-lookup"><span data-stu-id="619aa-135">PPP utilizes AHDLC framing (a subset of HDLC) for encapsulating all PPP protocol control and user data.</span></span> <span data-ttu-id="619aa-136">AHDLC 프레임은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="619aa-136">An AHDLC frame looks like the following:</span></span>

|<span data-ttu-id="619aa-137">**플래그**</span><span class="sxs-lookup"><span data-stu-id="619aa-137">**Flag**</span></span>|<span data-ttu-id="619aa-138">**Addr**</span><span class="sxs-lookup"><span data-stu-id="619aa-138">**Addr**</span></span>|<span data-ttu-id="619aa-139">**Ctrl**</span><span class="sxs-lookup"><span data-stu-id="619aa-139">**Ctrl**</span></span>|<span data-ttu-id="619aa-140">**정보**</span><span class="sxs-lookup"><span data-stu-id="619aa-140">**Information**</span></span>|<span data-ttu-id="619aa-141">**CRC**</span><span class="sxs-lookup"><span data-stu-id="619aa-141">**CRC**</span></span>|<span data-ttu-id="619aa-142">**플래그**</span><span class="sxs-lookup"><span data-stu-id="619aa-142">**Flag**</span></span>|
|--------|--------|--------|---------------|-------|--------|
|<span data-ttu-id="619aa-143">7E</span><span class="sxs-lookup"><span data-stu-id="619aa-143">7E</span></span> |<span data-ttu-id="619aa-144">FF</span><span class="sxs-lookup"><span data-stu-id="619aa-144">FF</span></span>|<span data-ttu-id="619aa-145">03</span><span class="sxs-lookup"><span data-stu-id="619aa-145">03</span></span>|<span data-ttu-id="619aa-146">[0-1502바이트]</span><span class="sxs-lookup"><span data-stu-id="619aa-146">[0-1502 bytes]</span></span>|<span data-ttu-id="619aa-147">2바이트</span><span class="sxs-lookup"><span data-stu-id="619aa-147">2-byte</span></span>| <span data-ttu-id="619aa-148">7E</span><span class="sxs-lookup"><span data-stu-id="619aa-148">7E</span></span>|

<span data-ttu-id="619aa-149">각각의 모든 PPP 프레임에는 이 전체적인 모양이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="619aa-149">Each and every PPP frame has this overall appearance.</span></span> <span data-ttu-id="619aa-150">정보 필드의 처음 2바이트에는 PPP 프로토콜 형식이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="619aa-150">The first two bytes of the information field contain the PPP protocol type.</span></span> <span data-ttu-id="619aa-151">유효한 값은 다음과 같이 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="619aa-151">Valid values are defined as follows:</span></span>

- <span data-ttu-id="619aa-152">C021: LCP</span><span class="sxs-lookup"><span data-stu-id="619aa-152">C021:  LCP</span></span>
- <span data-ttu-id="619aa-153">8021: IPCP</span><span class="sxs-lookup"><span data-stu-id="619aa-153">8021: IPCP</span></span>
- <span data-ttu-id="619aa-154">C023: PAP</span><span class="sxs-lookup"><span data-stu-id="619aa-154">C023: PAP</span></span>
- <span data-ttu-id="619aa-155">C223: CHAP</span><span class="sxs-lookup"><span data-stu-id="619aa-155">C223: CHAP</span></span>
- <span data-ttu-id="619aa-156">0021: IP 데이터 패킷</span><span class="sxs-lookup"><span data-stu-id="619aa-156">0021: IP Data Packet</span></span>

<span data-ttu-id="619aa-157">0x0021 프로토콜 형식이 있는 경우 IP 패킷은 즉시 따라옵니다.</span><span class="sxs-lookup"><span data-stu-id="619aa-157">If the 0x0021 protocol type is present, the IP packet follows immediately.</span></span> <span data-ttu-id="619aa-158">그렇지 않고 다른 프로토콜 중 하나가 있으면 다음 바이트가 특정 프로토콜에 해당합니다.</span><span class="sxs-lookup"><span data-stu-id="619aa-158">Otherwise, if one of the other protocols is present, the following bytes correspond to that particular protocol.</span></span>

<span data-ttu-id="619aa-159">고유한 0x7E 시작/종료 프레임 표식을 보장하고 소프트웨어 흐름 제어를 지원하기 위해 AHDLC는 이스케이프 시퀀스를 사용하여 다양한 바이트 값을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="619aa-159">In order to ensure unique 0x7E beginning/end-of frame markers and to support software flow control, AHDLC uses escape sequences to represent various byte values.</span></span> <span data-ttu-id="619aa-160">0x7D 값은 다음 문자가 인코딩되도록 지정하는데, 이는 기본적으로 0x20과 배타적 OR로 처리된 원래 문자입니다.</span><span class="sxs-lookup"><span data-stu-id="619aa-160">The 0x7D value specifies that the character following is encoded, which is basically the original character exclusive ORed with 0x20.</span></span> <span data-ttu-id="619aa-161">예를 들어, 헤더의 Ctrl 필드에 대한 0x03 값은 2바이트 시퀀스인 7D 23으로 표현됩니다.</span><span class="sxs-lookup"><span data-stu-id="619aa-161">For example, the 0x03 value for the Ctrl field in the header is represented by the two byte sequence: 7D 23.</span></span> <span data-ttu-id="619aa-162">기본적으로 0x20보다 작은 값은 정보 필드에 있는 0x7E 및 0x7D 값과 함께 이스케이프 시퀀스로 변환됩니다.</span><span class="sxs-lookup"><span data-stu-id="619aa-162">By default, values less than 0x20 are converted into an escape sequence, as well as 0x7E and 0x7D values found in the Information field.</span></span> <span data-ttu-id="619aa-163">이스케이프 시퀀스는 CRC 필드에도 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="619aa-163">Note that escape sequences also apply to the CRC field.</span></span>

## <a name="link-control-protocol-lcp"></a><span data-ttu-id="619aa-164">LCP(연결 제어 프로토콜)</span><span class="sxs-lookup"><span data-stu-id="619aa-164">Link Control Protocol (LCP)</span></span>

<span data-ttu-id="619aa-165">LCP는 기본 PPP 프로토콜이며 첫 번째로 실행할 프로토콜입니다.</span><span class="sxs-lookup"><span data-stu-id="619aa-165">The LCP is the primary PPP protocol and is the first protocol to run.</span></span> <span data-ttu-id="619aa-166">LCP는 사용할 MRU(최대 수신 단위) 및 인증 프로토콜(PAP, CHAP 또는 없음)을 비롯한 다양한 PPP 매개 변수를 협상합니다.</span><span class="sxs-lookup"><span data-stu-id="619aa-166">LCP is responsible for negotiating various PPP parameters, including the Maximum Receive Unit (MRU) and the Authentication Protocol (PAP, CHAP, or none) to use.</span></span> <span data-ttu-id="619aa-167">LCP의 양쪽 모두가 PPP 매개 변수에 동의하면 인증 프로토콜(있는 경우)이 실행되기 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="619aa-167">Once both sides of LCP agree on PPP parameters, the authentication protocols—if any—then start running.</span></span>

## <a name="password-authentication-protocol-pap"></a><span data-ttu-id="619aa-168">PAP(암호 인증 프로토콜)</span><span class="sxs-lookup"><span data-stu-id="619aa-168">Password Authentication Protocol (PAP)</span></span>

<span data-ttu-id="619aa-169">PAP는 연결의 한쪽에서 제공되는 이름 및 암호를 사용하는 비교적 간단한 프로토콜입니다(LCP에서 협상됨).</span><span class="sxs-lookup"><span data-stu-id="619aa-169">The PAP is a relatively straightforward protocol that relies on a name and password being supplied by one side of the connection (as negotiated during LCP).</span></span> <span data-ttu-id="619aa-170">그런 다음, 다른 쪽에서 이 정보를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="619aa-170">The other side then verifies this information.</span></span> <span data-ttu-id="619aa-171">올바른 경우, 승인 메시지가 보낸 사람에게 반환되고 PPP는 IPCP 상태 시스템으로 진행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="619aa-171">If correct, an acceptance message is returned to the sender and PPP can then proceed to the IPCP state machine.</span></span> <span data-ttu-id="619aa-172">그렇지 않고 이름이나 암호가 잘못된 경우 연결이 거부됩니다.</span><span class="sxs-lookup"><span data-stu-id="619aa-172">Otherwise, if either the name or password is incorrect, the connection is rejected.</span></span>

>[!NOTE]
> <span data-ttu-id="619aa-173">인터페이스 양쪽 모두에서 PAP를 요청할 수 있지만 일반적으로 PAP는 한 방향에서만 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="619aa-173">Both sides of the interface can request PAP, but PAP is typically used in only one direction.</span></span>

## <a name="challenge-handshake-authentication-protocol-chap"></a><span data-ttu-id="619aa-174">CHAP(Challenge Handshake 인증 프로토콜)</span><span class="sxs-lookup"><span data-stu-id="619aa-174">Challenge-Handshake Authentication Protocol (CHAP)</span></span>

<span data-ttu-id="619aa-175">CHAP는 PAP보다 더 복잡한 인증 프로토콜입니다.</span><span class="sxs-lookup"><span data-stu-id="619aa-175">The CHAP is a more complex authentication protocol than PAP.</span></span> <span data-ttu-id="619aa-176">CHAP 인증자는 해당 피어에 이름과 값을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="619aa-176">The CHAP authenticator supplies its peer with a name and a value.</span></span> <span data-ttu-id="619aa-177">그러면 피어는 제공된 이름을 사용하여 두 엔터티 간의 공유된 "비밀"을 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="619aa-177">The peer then uses the supplied name to find a shared “secret” between the two entities.</span></span> <span data-ttu-id="619aa-178">그런 다음, ID, 값 및 "비밀"에 대해 계산이 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="619aa-178">A computation is then done over the ID, value, and the “secret.”</span></span> <span data-ttu-id="619aa-179">이 계산 결과는 응답에서 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="619aa-179">The result of this computation is returned in the response.</span></span> <span data-ttu-id="619aa-180">올바른 경우, PPP는 IPCP 상태 시스템으로 진행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="619aa-180">If correct, PPP can then proceed to the IPCP state machine.</span></span> <span data-ttu-id="619aa-181">그렇지 않고 결과가 잘못된 경우 연결이 거부됩니다.</span><span class="sxs-lookup"><span data-stu-id="619aa-181">Otherwise, if the result is incorrect, the connection is rejected.</span></span>

<span data-ttu-id="619aa-182">CHAP의 또 다른 흥미로운 측면은 연결이 설정된 후 임의의 간격으로 발생할 수 있다는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="619aa-182">Another interesting aspect of CHAP is that it can occur at random intervals after a connection has been established.</span></span> <span data-ttu-id="619aa-183">이는 연결이 인증된 후에 하이재킹되는 것을 방지하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="619aa-183">This is used to prevent a connection from being hijacked – after it has been authenticated.</span></span> <span data-ttu-id="619aa-184">이러한 임의 시간 중 하나에서 챌린지에 실패하면 연결이 즉시 종료됩니다.</span><span class="sxs-lookup"><span data-stu-id="619aa-184">If a challenge fails at one of these random times, the connection is immediately terminated.</span></span>

>[!NOTE]
> <span data-ttu-id="619aa-185">인터페이스 양쪽 모두에서 CHAP를 요청할 수 있지만 일반적으로 CHAP는 한 방향에서만 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="619aa-185">Both sides of the interface can request CHAP, but CHAP is typically used in only one direction.</span></span>

## <a name="internet-protocol-control-protocol-ipcp"></a><span data-ttu-id="619aa-186">IPCP(인터넷 프로토콜 제어 프로토콜)</span><span class="sxs-lookup"><span data-stu-id="619aa-186">Internet Protocol Control Protocol (IPCP)</span></span>

<span data-ttu-id="619aa-187">IPCP는 NetX IP 데이터 전송에 PPP 통신을 사용할 수 있기 전에 실행할 마지막 프로토콜입니다.</span><span class="sxs-lookup"><span data-stu-id="619aa-187">The IPCP is the last protocol to execute before the PPP communication is available for NetX IP data transfer.</span></span> <span data-ttu-id="619aa-188">이 프로토콜의 주요 목적은 한 피어가 다른 피어에게 해당 IP 주소를 알리는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="619aa-188">The main purpose of this protocol is for one peer to inform the other of its IP address.</span></span> <span data-ttu-id="619aa-189">IP 주소가 설정되면 NetX IP 데이터 전송이 활성화됩니다.</span><span class="sxs-lookup"><span data-stu-id="619aa-189">Once the IP address is setup, NetX IP data transfer is enabled.</span></span>

## <a name="data-transfer"></a><span data-ttu-id="619aa-190">데이터 전송</span><span class="sxs-lookup"><span data-stu-id="619aa-190">Data Transfer</span></span>

<span data-ttu-id="619aa-191">앞에서 언급했듯이 NetX IP 데이터 패킷은 프로토콜 ID가 0x0021인 PPP 프레임에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="619aa-191">As mentioned previously, NetX IP data packets reside in PPP frames with a protocol ID of 0x0021.</span></span> <span data-ttu-id="619aa-192">수신된 모든 데이터 패킷은 하나 이상의 NX_PACKET 구조에 배치되고 NetX 수신 처리로 전송됩니다.</span><span class="sxs-lookup"><span data-stu-id="619aa-192">All received data packets are placed in one or more NX_PACKET structures and transferred to the NetX receive processing.</span></span> <span data-ttu-id="619aa-193">전송 시 NetX 패킷 내용은 AHDLC 프레임에 배치되어 전송됩니다.</span><span class="sxs-lookup"><span data-stu-id="619aa-193">On transmission, the NetX packet contents are placed in an AHDLC frame and transmitted.</span></span>

## <a name="ppp-rfcs"></a><span data-ttu-id="619aa-194">PPP RFC</span><span class="sxs-lookup"><span data-stu-id="619aa-194">PPP RFCs</span></span>

<span data-ttu-id="619aa-195">NetX PPP는 RFC1332, RFC1334, RFC1661, RFC1994 및 관련 RFC와 호환됩니다.</span><span class="sxs-lookup"><span data-stu-id="619aa-195">NetX PPP is compliant with RFC1332, RFC1334, RFC1661, RFC1994, and related RFCs.</span></span>