---
title: 3장 - Azure RTOS NetX의 기능 구성 요소
description: 이 장에서는 기능 관점에서 고성능 Azure RTOS NetX TCP/IP 스택에 대한 설명을 포함합니다.
author: philmea
ms.author: philmea
ms.date: 05/19/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: db23aa152b2765ac7cc9be098723fc5df0947484
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/22/2021
ms.locfileid: "104811701"
---
# <a name="chapter-3---functional-components-of-azure-rtos-netx"></a><span data-ttu-id="f0769-103">3장 - Azure RTOS NetX의 기능 구성 요소</span><span class="sxs-lookup"><span data-stu-id="f0769-103">Chapter 3 - Functional Components of Azure RTOS NetX</span></span>

<span data-ttu-id="f0769-104">이 장에서는 기능 관점에서 고성능 Azure RTOS NetX TCP/IP 스택에 대한 설명을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-104">This chapter contains a description of the high-performance Azure RTOS NetX TCP/IP stack from a functional perspective.</span></span> 

## <a name="execution-overview"></a><span data-ttu-id="f0769-105">실행 개요</span><span class="sxs-lookup"><span data-stu-id="f0769-105">Execution Overview</span></span>

<span data-ttu-id="f0769-106">NetX 애플리케이션 내에서는 초기화, 애플리케이션 인터페이스 호출, 내부 IP 스레드, IP 주기적 타이머, 네트워크 드라이버와 같은 5가지 형식의 프로그램이 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-106">There are five types of program execution within a NetX application: initialization, application interface calls, internal IP thread, IP periodic timers, and the network driver.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="f0769-107">NetX는 ThreadX를 설치해야 하며 스레드 실행, 일시 중단, 주기적 타이머 및 상호 배제 기능에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-107">NetX requires the installation of ThreadX and depends on its thread execution, suspension, periodic timers, and mutual exclusion facilities.</span></span>

### <a name="initialization"></a><span data-ttu-id="f0769-108">초기화</span><span class="sxs-lookup"><span data-stu-id="f0769-108">Initialization</span></span>

<span data-ttu-id="f0769-109">다른 NetX 서비스를 호출하기 전에 \***nx_system_initialize** _ 서비스를 호출해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-109">The service \***nx_system_initialize** _ must be called before any other NetX service is called.</span></span> <span data-ttu-id="f0769-110">ThreadX _ *_tx_application_define_*\* 루틴이나 애플리케이션 스레드에서 시스템 초기화를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-110">System initialization can be called either from the ThreadX _ *_tx_application_define_*\* routine or from application threads.</span></span>

<span data-ttu-id="f0769-111">\***nx_system_initialize** _가 반환되면 시스템이 패킷 풀 및 IP 인스턴스를 만들 준비가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-111">After \***nx_system_initialize** _ returns, the system is ready to create packet pools and IP instances.</span></span> <span data-ttu-id="f0769-112">IP 인스턴스를 만들려면 기본 패킷 풀이 필요하므로 IP 인스턴스를 만들기 전에 하나 이상의 NetX 패킷 풀이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-112">Because creating an IP instance requires a default packet pool, at least one NetX packet pool must exist prior to creating an IP instance.</span></span> <span data-ttu-id="f0769-113">패킷 풀 및 IP 인스턴스는 ThreadX 초기화 함수인 _ _tx_application_define_\* 및 애플리케이션 스레드에서 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-113">Creating packet pools and IP instances are allowed from the ThreadX initialization function _ *_tx_application_define_*\* and from application threads.</span></span>

<span data-ttu-id="f0769-114">내부적으로 IP 인스턴스는 두 부분을 거쳐 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-114">Internally, creating an IP instance is accomplished in two parts.</span></span> <span data-ttu-id="f0769-115">첫 번째 부분은 ***tx_application_define*** 에서 또는 애플리케이션 스레드의 컨텍스트로부터 호출자의 컨텍스트 내에서 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-115">The first part is done within the context of the caller, either from ***tx_application_define*** or from an application thread's context.</span></span> <span data-ttu-id="f0769-116">여기에는 IP 데이터 구조를 설정하고 내부 IP 스레드를 비롯한 다양한 IP 리소스를 만드는 작업이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-116">This includes setting up the IP data structure and creating various IP resources, including the internal IP thread.</span></span> <span data-ttu-id="f0769-117">두 번째 부분은 내부 IP 스레드에서 초기 실행 중에 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-117">The second part is performed during the initial execution from the internal IP thread.</span></span> <span data-ttu-id="f0769-118">여기서 IP 만들기의 첫 번째 부분을 수행하는 동안 제공되는 네트워크 드라이버를 먼저 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-118">This is where the network driver, supplied during the first part of IP creation, is first called.</span></span> <span data-ttu-id="f0769-119">내부 IP 스레드에서 네트워크 드라이버를 호출하면 초기화를 처리하는 중에 드라이버는 I/O를 수행하거나 일시 중단할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-119">Calling the network driver from the internal IP thread enables the driver to perform I/O and suspend during its initialization processing.</span></span> <span data-ttu-id="f0769-120">네트워크 드라이버가 초기화 처리에서 반환되면 IP 생성이 완료됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-120">When the network driver returns from its initialization processing, the IP creation is complete.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="f0769-121">NetX 서비스 **nx_ip_status_check** 는 IP 인스턴스 및 해당 기본 인터페이스 상태에 대한 정보를 가져오는 데 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-121">The NetX service **nx_ip_status_check** is available to obtain information on the IP instance and its primary interface status.</span></span> <span data-ttu-id="f0769-122">이러한 상태 정보에는 링크를 초기화하고, 사용하도록 설정하고, IP 주소가 확인되는지 여부가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-122">Such status information includes whether or not the link is initialized, enabled, and IP address is resolved.</span></span> <span data-ttu-id="f0769-123">이 정보는 새로 만든 IP 인스턴스를 사용해야 하는 애플리케이션 스레드를 동기화하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-123">This information is used to synchronize application threads needing to use a newly created IP instance.</span></span> <span data-ttu-id="f0769-124">멀티홈 시스템의 경우 아래의 "멀티홈 지원"을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f0769-124">For multihome systems, see "Multihome Support" below.</span></span> <span data-ttu-id="f0769-125">지정된 인터페이스에 대한 정보를 얻기 위해 **nx_ip_interface_status_check** 를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-125">**nx_ip_interface_status_check** is available to obtain information on the specified interface.</span></span>

### <a name="application-interface-calls"></a><span data-ttu-id="f0769-126">애플리케이션 인터페이스 호출</span><span class="sxs-lookup"><span data-stu-id="f0769-126">Application Interface Calls</span></span>

<span data-ttu-id="f0769-127">애플리케이션의 호출은 ThreadX RTOS에서 실행되는 애플리케이션 스레드에서 주로 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-127">Calls from the application are largely made from application threads running under the ThreadX RTOS.</span></span> <span data-ttu-id="f0769-128">그러나 일부 초기화, 만들기, 활성화 서비스는 ***tx_application_define*** 에서 호출될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-128">However, some initialization, create, and enable services may be called from ***tx_application_define***.</span></span> <span data-ttu-id="f0769-129">4장의 “허용되는 원본” 섹션은 각 NetX 서비스를 호출할 수 있는 항목을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-129">The "Allowed From" sections in Chapter 4 indicate from which each NetX service can be called.</span></span>

<span data-ttu-id="f0769-130">대부분의 경우, 체크섬 계산과 같은 집약적인 작업 처리는 IP 인스턴스에 대한 다른 스레드의 액세스를 차단하지 않고 호출 스레드의 컨텍스트 내에서 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-130">For the most part, processing intensive activities such as computing checksums is done within the calling thread's context—without blocking the access of other threads to the IP instance.</span></span> <span data-ttu-id="f0769-131">예를 들어 전송 시에는 기본 IP 전송 함수를 호출하기 전에 ***nx_udp_socket_send*** 서비스 내에서 UDP 체크섬 계산이 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-131">For example, on transmission, the UDP checksum calculation is performed inside the ***nx_udp_socket_send*** service, prior to calling the underlying IP send function.</span></span> <span data-ttu-id="f0769-132">수신된 패킷에서 UDP 체크섬은 애플리케이션 스레드의 컨텍스트에서 실행되는 ***nx_udp_socket_receive*** 서비스에서 계산됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-132">On a received packet, the UDP checksum is calculated in the ***nx_udp_socket_receive*** service, executed in the context of the application thread.</span></span> <span data-ttu-id="f0769-133">이렇게 하면 우선 순위가 낮은 스레드에서 집약적인 체크섬 계산을 처리하므로 더 높은 우선 순위 스레드의 네트워크 요청이 지연되는 것을 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-133">This helps prevent stalling network requests of higher-priority threads because of processing intensive checksum computation in lower-priority threads.</span></span>

<span data-ttu-id="f0769-134">IP 주소 및 포트 번호와 같은 값은 호스트 바이트 순서로 API 함수에 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-134">Values, such as IP addresses and port numbers, are passed to API functions in host byte order.</span></span> <span data-ttu-id="f0769-135">내부적으로 이러한 값은 호스트 바이트 순서에도 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-135">Internally these values are stored in host byte order as well.</span></span> <span data-ttu-id="f0769-136">이를 통해 개발자는 디버거를 통해 값을 쉽게 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-136">This enables developers to easily view the values via a debugger.</span></span> <span data-ttu-id="f0769-137">이러한 값이 전송용 프레임으로 프로그래밍 되면 네트워크 바이트 순서로 변환됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-137">When these values are programmed into a frame for transmission, they are converted to network byte order.</span></span>

### <a name="internal-ip-thread"></a><span data-ttu-id="f0769-138">내부 IP 스레드</span><span class="sxs-lookup"><span data-stu-id="f0769-138">Internal IP Thread</span></span>

<span data-ttu-id="f0769-139">언급했듯이 NetX의 각 IP 인스턴스는 고유한 스레드를 가지고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-139">As mentioned, each IP instance in NetX has its own thread.</span></span> <span data-ttu-id="f0769-140">내부 IP 스레드의 우선 순위 및 스택 크기는 ***nx_ip_create*** 서비스에 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-140">The priority and stack size of the internal IP thread is defined in the ***nx_ip_create*** service.</span></span> <span data-ttu-id="f0769-141">내부 IP 스레드는 실행 준비 모드에서 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-141">The internal IP thread is created in a ready-to-execute mode.</span></span> <span data-ttu-id="f0769-142">IP 스레드의 우선 순위가 호출 스레드보다 높으면 IP 만들기 호출 내에서 선점이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-142">If the IP thread has a higher priority than the calling thread, preemption may occur inside the IP create call.</span></span>

<span data-ttu-id="f0769-143">내부 IP 스레드의 진입점은 내부 함수 ***_nx_ip_thread_entry*** 에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-143">The entry point of the internal IP thread is at the internal function ***_nx_ip_thread_entry***.</span></span> <span data-ttu-id="f0769-144">시작할 때, 내부 IP 스레드는 먼저 애플리케이션별 네트워크 드라이버에 대한 세 번의 호출로 구성된 네트워크 드라이버 초기화를 완료합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-144">When started, the internal IP thread first completes network driver initialization, which consists of making three calls to the application-specific network driver.</span></span> <span data-ttu-id="f0769-145">첫 번째 호출은 네트워크 드라이버를 IP 인스턴스에 연결한 후 초기화 호출을 통해 네트워크 드라이버가 초기화 프로세스를 수행하게 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-145">The first call is to attach the network driver to the IP instance, followed by an initialization call, which allows the network driver to go through the initialization process.</span></span> <span data-ttu-id="f0769-146">네트워크 드라이버가 초기화에서 반환된 후(하드웨어가 제대로 설정되기를 기다리는 동안 일시 중단될 수 있음) 내부 IP 스레드가 네트워크 드라이버를 다시 호출하여 링크를 사용하도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-146">After the network driver returns from initialization (it may suspend while waiting for the hardware to be properly set up), the internal IP thread calls the network driver again to enable the link.</span></span> 

<span data-ttu-id="f0769-147">네트워크 드라이버가 링크 사용 호출에서 반환된 후 내부 IP 스레드는 이 IP 인스턴스에 대한 처리가 필요한 다양한 이벤트를 확인하는 영구 루프 검사를 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-147">After the network driver returns from the link enable call, the internal IP thread enters an endless loop checking for various events that need processing for this IP instance.</span></span> <span data-ttu-id="f0769-148">이 루프에서 처리되는 이벤트에는 지연된 IP 패킷 수신, IP 패킷 조각 어셈블리, ICMP ping 처리, IGMP 처리, TCP 패킷 큐 처리, TCP 주기적 처리, IP 조각 어셈블리 시간 제한, IGMP 주기적 처리가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-148">Events processed in this loop include deferred IP packet reception, IP packet fragment assembly, ICMP ping processing, IGMP processing, TCP packet queue processing, TCP periodic processing, IP fragment assembly timeouts, and IGMP periodic processing.</span></span> <span data-ttu-id="f0769-149">이벤트에는 IP 네트워크에서 ARP 패킷 처리 및 ARP 정기적 처리와 같은 주소 확인 작업도 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-149">Events also include address resolution activities: ARP packet processing and ARP periodic processing in the IP network.</span></span>

> [!NOTE]
> <span data-ttu-id="f0769-150">수신 대기 및 연결 해제 콜백을 포함한 NetX 콜백 함수는 원래 호출 스레드가 아닌 내부 IP 스레드에서 호출됩니다. 애플리케이션은 NetX 콜백 함수 내에서 일시 중단되지 않도록 주의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-150">*The NetX callback functions, including listen and disconnect callbacks, are called from the internal IP thread—not the original calling thread. The application must take care not to suspend inside any NetX callback function.*</span></span>

### <a name="ip-periodic-timers"></a><span data-ttu-id="f0769-151">IP 주기적 타이머</span><span class="sxs-lookup"><span data-stu-id="f0769-151">IP Periodic Timers</span></span>
<span data-ttu-id="f0769-152">각 IP 인스턴스에는 두 개의 ThreadX 주기적 타이머가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-152">There are two ThreadX periodic timers used for each IP instance.</span></span> <span data-ttu-id="f0769-153">첫 번째 타이머는 ARP, IGMP, TCP 시간 제한에 대한 1초 타이머이며, IP 조각 리어셈블 처리도 구동합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-153">The first one is a one-second timer for ARP, IGMP, TCP timeout, and it also drives IP fragment reassemble processing.</span></span> <span data-ttu-id="f0769-154">두 번째 타이머는 TCP 재전송 시간 제한을 구동하는 100ms 타이머입니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-154">The second timer is a 100ms timer to drive the TCP retransmission timeout.</span></span>

### <a name="network-driver"></a><span data-ttu-id="f0769-155">네트워크 드라이버</span><span class="sxs-lookup"><span data-stu-id="f0769-155">Network Driver</span></span>
<span data-ttu-id="f0769-156">NetX의 각 IP 인스턴스는 ***nx_ip_create*** 서비스에 지정된 디바이스 드라이버로 식별되는 기본 인터페이스를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-156">Each IP instance in NetX has a primary interface, which is identified by its device driver specified in the ***nx_ip_create*** service.</span></span> <span data-ttu-id="f0769-157">네트워크 드라이버는 패킷 전송, 패킷 수신, 상태 및 제어 요청을 포함한 다양한 NetX 요청을 처리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-157">The network driver is responsible for handling various NetX requests, including packet transmission, packet reception, and requests for status and control.</span></span>

<span data-ttu-id="f0769-158">멀티홈 시스템의 경우 IP 인스턴스는 각 해당 인터페이스에 대해 이러한 작업을 수행하는 연결된 네트워크 드라이버를 가진 여러 인터페이스를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-158">For a multi-home system, the IP instance has multiple interfaces, each with an associated network driver that performs these tasks for the respective interface.</span></span>

<span data-ttu-id="f0769-159">또한 네트워크 드라이버는 미디어에서 발생하는 비동기 이벤트도 처리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-159">The network driver must also handle asynchronous events occurring on the media.</span></span> <span data-ttu-id="f0769-160">미디어의 비동기 이벤트에는 패킷 수신, 패킷 전송 완료, 상태 변경이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-160">Asynchronous events from the media include packet reception, packet transmission completion, and status changes.</span></span> <span data-ttu-id="f0769-161">NetX는 다양한 이벤트 처리를 위한 여러 액세스 함수를 포함하는 네트워크 드라이버를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-161">NetX provides the network driver with several access functions to handle various events.</span></span> <span data-ttu-id="f0769-162">이러한 함수는 네트워크 드라이버의 인터럽트 서비스 루틴 부분에서 호출되도록 설계되었습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-162">These functions are designed to be called from the interrupt service routine portion of the network driver.</span></span> <span data-ttu-id="f0769-163">IP 네트워크의 경우 네트워크 드라이버가 수신한 모든 ARP 패킷을 \* **_nx_arp_packet_deferred_receive** _ 내부 함수로 전달해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-163">For IP networks, the network driver should forward all ARP packets received to the \***_nx_arp_packet_deferred_receive** _ internal function.</span></span> <span data-ttu-id="f0769-164">모든 RARP 패킷은 __ _nx_rarp_packet_deferred_receive_ _ 내부 함수로 전달되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-164">All RARP packets should be forwarded to _ *_ _nx_rarp_packet_deferred_receive_* _ internal function.</span></span> <span data-ttu-id="f0769-165">IP 패킷에는 두 가지 옵션이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-165">There are two options for IP packets.</span></span> <span data-ttu-id="f0769-166">IP 패킷을 빠르게 디스패치해야 하는 경우 들어오는 IP 패킷을 __ _nx_ip_packet_receive_ _로 전달하여 즉시 처리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-166">If fast dispatch of IP packets is required, incoming IP packets should be forwarded to _ *_ _nx_ip_packet_receive_* _ for immediate processing.</span></span> <span data-ttu-id="f0769-167">이렇게 하면 NetX의 IP 패킷 처리 성능이 크게 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-167">This greatly improves NetX performance in handling IP packets.</span></span> <span data-ttu-id="f0769-168">그렇지 않으면 네트워크 드라이버가 IP 패킷을 _ \* _ _nx_ip_packet_deferred_receive_\*\*로 전달해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-168">Otherwise, the network driver should forward IP packets to _\*_ _nx_ip_packet_deferred_receive_\*\*.</span></span> <span data-ttu-id="f0769-169">이 서비스는 IP 패킷을 지연된 처리 큐에 배치한 다음, 이 큐에서 내부 IP 스레드에 의해 처리되므로 ISR 처리 시간이 최소화됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-169">This service places the IP packet in the deferred processing queue where it is then handled by the internal IP thread, which results in the least amount of ISR processing time.</span></span>

<span data-ttu-id="f0769-170">네트워크 드라이버는 IP 스레드의 컨텍스트를 실행되기 위해 인터럽트 처리를 연기할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-170">The network driver can also defer interrupt processing to run out of the context of the IP thread.</span></span> <span data-ttu-id="f0769-171">이 모드에서 ISR은 필요한 정보를 저장하고 내부 함수 ***_nx_ip_driver_deferred_processing*** 을 호출하여 인터럽트 컨트롤러를 승인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-171">In this mode, the ISR shall save the necessary information, call the internal function ***_nx_ip_driver_deferred_processing***, and acknowledge the interrupt controller.</span></span> <span data-ttu-id="f0769-172">이 서비스는 디바이스 드라이버에 대한 콜백을 예약하여 인터럽트를 유발하는 이벤트 프로세스를 완료하도록 IP 스레드에 알립니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-172">This service notifies IP thread to schedule a callback to the device driver to complete the processing of the event that causes the interrupt.</span></span>

<span data-ttu-id="f0769-173">일부 네트워크 컨트롤러는 유용한 CPU 리소스를 차지하지 않고도 TCP/IP 헤더 체크섬 계산 및 하드웨어의 유효성 검사를 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-173">Some network controllers are capable of performing TCP/IP header checksum computation and validation in hardware, without taking up valuable CPU resources.</span></span> <span data-ttu-id="f0769-174">하드웨어 역량 기능을 활용하기 위해 NetX는 컴파일 시 다양한 소프트웨어 체크섬 계산을 사용하거나 또는 사용하지 않도록 옵션을 제공하고, 런타임에 체크섬 계산을 설정하거나 해제하는 옵션도 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-174">To take advantage of the hardware capability feature, NetX provides options to enable or disable various software checksum computation at compilation time, as well as turning on or off checksum computation at run time.</span></span> <span data-ttu-id="f0769-175">NetX 네트워크 드라이버 작성에 대한 자세한 내용은 "[5장 NetX 네트워크 드라이버](chapter5.md)"를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f0769-175">See "[Chapter 5 NetX Network Drivers](chapter5.md)" for more detailed information on writing NetX network drivers.</span></span>

### <a name="multihome-support"></a><span data-ttu-id="f0769-176">멀티홈 지원</span><span class="sxs-lookup"><span data-stu-id="f0769-176">Multihome Support</span></span>
<span data-ttu-id="f0769-177">NetX는 단일 IP 인스턴스를 사용하여 여러 실제 디바이스에 연결된 시스템을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-177">NetX supports systems connected to multiple physical devices using a single IP instance.</span></span> <span data-ttu-id="f0769-178">각 실제 인터페이스는 IP 인스턴스의 인터페이스 제어 블록에 할당됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-178">Each physical interface is assigned to an interface control block in the IP instance.</span></span> <span data-ttu-id="f0769-179">멀티홈 시스템을 사용하려는 애플리케이션은 시스템에 연결된 실제 디바이스 수로 **NX_MAX_PHSYCIAL_INTERFACES** 값을 정의하고 NetX 라이브러리를 다시 빌드해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-179">Applications wishing to use a multihome system must define the value for **NX_MAX_PHSYCIAL_INTERFACES** to the number of physical devices attached to the system, and rebuild NetX library.</span></span> <span data-ttu-id="f0769-180">기본적으로 **NX_MAX_PHYSICAL_INTERFACES** 는 하나로 설정되고, IP 인스턴스에서 하나의 인터페이스 제어 블록을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-180">By default **NX_MAX_PHYSICAL_INTERFACES** is set to one, creating one interface control block in the IP instance.</span></span>

<span data-ttu-id="f0769-181">NetX 애플리케이션은 \***nx_ip_create** _ 서비스를 사용하여 기본 디바이스를 위한 단일 IP 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-181">The NetX application creates a single IP instance for the primary device using the \***nx_ip_create** _ service.</span></span> <span data-ttu-id="f0769-182">애플리케이션은 각 추가 네트워크 디바이스에 대해 _ _nx_ip_interface_attach_\* 서비스를 사용하여 IP 인스턴스에 디바이스를 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-182">For each additional network devices, the application attaches the device to the IP instance using the _ *_nx_ip_interface_attach_*\* service.</span></span>

<span data-ttu-id="f0769-183">각 네트워크 인터페이스 구조에는 인터페이스 IP 주소, 서브넷 마스크, IP MTU 크기, MAC 계층 주소 정보를 포함하여 IP 제어 블록에 포함된 네트워크 인터페이스에 대한 네트워크 정보의 하위 집합이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-183">Each network interface structure contains a subset of network information about the network interface that is contained in the IP control block, including interface IP address, subnet mask, IP MTU size, and MAC-layer address information.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="f0769-184">멀티홈을 지원하는 NetX는 이전 버전의 NetX와 호환됩니다. 명시적 인터페이스 정보를 사용하지 않는 서비스는 기본 네트워크 디바이스로 기본 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-184">*NetX with multihome support is backward compatible with earlier versions of NetX. Services that do not take explicit interface information default to the primary network device.*</span></span>

<span data-ttu-id="f0769-185">기본 인터페이스의 IP 인스턴스 목록에 인덱스 0가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-185">The primary interface has index zero in the IP instance list.</span></span> <span data-ttu-id="f0769-186">IP 인스턴스에 연결된 각 후속 디바이스에는 다음 인덱스가 할당됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-186">Each subsequent device attached to the IP instance is assigned the next index.</span></span>

<span data-ttu-id="f0769-187">TCP, UDP, ICMP, IGMP를 포함하여 IP 인스턴스를 사용하는 모든 상위 계층 프로토콜 서비스를 연결된 모든 디바이스에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-187">All upper layer protocol services for which the IP instance is enabled, including TCP, UDP, ICMP, and IGMP, are available to all the attached devices.</span></span>

<span data-ttu-id="f0769-188">대부분의 경우 NetX는 패킷을 전송할 때 사용할 가장 적합한 소스 주소를 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-188">In most cases, NetX can determine the best source address to use when transmitting a packet.</span></span> <span data-ttu-id="f0769-189">소스 주소 선택은 대상 주소를 기준으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-189">The source address selection is based on the destination address.</span></span> <span data-ttu-id="f0769-190">대상 주소에서 최적의 주소를 결정할 수 없는 경우 애플리케이션에서 사용할 특정 소스 주소를 지정할 수 있도록 NetX 서비스가 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-190">NetX services are provided to allow applications to specify a specific source address to use, in cases where the most suitable one cannot be determined by the destination address.</span></span> <span data-ttu-id="f0769-191">예를 들어, 멀티홈 시스템에서 애플리케이션은 IP 브로드캐스트 또는 멀티캐스트 대상 주소로 패킷을 전송해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-191">An example would be in a multihome system, an application needs to send a packet to an IP broadcast or multicast destination addresses.</span></span>

<span data-ttu-id="f0769-192">멀티홈 애플리케이션 개발을 위한 서비스는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-192">Services specifically for developing multihome applications include the following:</span></span>

<span data-ttu-id="f0769-193">nx_igmp_multicast_interface_join nx_ip_driver_interface_direct_command nx_ip_interface_address_get nx_ip_interface_address_set nx_ip_interface_attach nx_ip_interface_info_get nx_ip_interface_status_check nx_ip_raw_packet_interface_send nx_udp_socket_interface_send</span><span class="sxs-lookup"><span data-stu-id="f0769-193">*nx_igmp_multicast_interface_join nx_ip_driver_interface_direct_command nx_ip_interface_address_get nx_ip_interface_address_set nx_ip_interface_attach nx_ip_interface_info_get nx_ip_interface_status_check nx_ip_raw_packet_interface_send nx_udp_socket_interface_send*</span></span>

<span data-ttu-id="f0769-194">이러한 서비스는 "[4장 - Azure RTOS NetX 서비스 설명](chapter4.md)"에 자세히 나와 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-194">These services are explained in greater detail in "[Chapter 4 - Description of Azure RTOS NetX Services](chapter4.md)".</span></span>

### <a name="loopback-interface"></a><span data-ttu-id="f0769-195">루프백 인터페이스</span><span class="sxs-lookup"><span data-stu-id="f0769-195">Loopback Interface</span></span>
<span data-ttu-id="f0769-196">루프백 인터페이스는 실제 링크가 연결되어 있지 않은 특수한 네트워크 인터페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-196">The loopback interface is a special network interface without an physical link attached to.</span></span> <span data-ttu-id="f0769-197">루프백 인터페이스를 사용하면 애플리케이션에서 IP 루프백 주소 127.0.0.1을 사용하여 통신할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-197">The loopback interface allows applications to communicate using the IP loopback address 127.0.0.1</span></span>

<span data-ttu-id="f0769-198">논리적 루프백 인터페이스를 활용하려면 구성 가능한 옵션 ***NX_DISABLE_LOOPBACK_INTERFACE*** 이 설정되지 않았는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-198">To utilize a logical loopback interface, ensure the configurable option ***NX_DISABLE_LOOPBACK_INTERFACE*** is not set.</span></span>

### <a name="interface-control-blocks"></a><span data-ttu-id="f0769-199">인터페이스 제어 블록</span><span class="sxs-lookup"><span data-stu-id="f0769-199">Interface Control Blocks</span></span>
<span data-ttu-id="f0769-200">IP 인스턴스의 인터페이스 제어 블록 수는 실제 인터페이스(\***NX_MAX_PHYSICAL_INTERFACES** _로 정의됨)의 수와 루프백 인터페이스(사용 가능한 경우) 수를 더한 값과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-200">The number of interface control blocks in the IP instance is the number of physical interfaces (defined by \***NX_MAX_PHYSICAL_INTERFACES** _) plus the loopback interface if it is enabled.</span></span> <span data-ttu-id="f0769-201">총 인터페이스 수는 _\*_NX_MAX_IP_INTERFACES_\*\*에 정의되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-201">The total number of interfaces is defined in _\*_NX_MAX_IP_INTERFACES_\*\*.</span></span>

## <a name="protocol-layering"></a><span data-ttu-id="f0769-202">프로토콜 계층화</span><span class="sxs-lookup"><span data-stu-id="f0769-202">Protocol Layering</span></span>

<span data-ttu-id="f0769-203">NetX에 의해 구현된 TCP/IP는 계층화된 프로토콜로, 더 복잡한 프로토콜이 더 단순한 기본 프로토콜에 기반하여 빌드됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-203">The TCP/IP implemented by NetX is a layered protocol, which means more complex protocols are built on top of simpler underlying protocols.</span></span> <span data-ttu-id="f0769-204">TCP/IP에서 가장 낮은 계층 프로토콜은 ‘링크 계층’에 있으며 네트워크 드라이버에서 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-204">In TCP/ IP, the lowest layer protocol is at the *link Layer* and is handled by the network driver.</span></span> <span data-ttu-id="f0769-205">이 수준은 일반적으로 이더넷을 대상으로 하지만 파이버, 시리얼 또는 거의 모든 실제 미디어를 대상으로 할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-205">This level is typically targeted towards Ethernet, but it could also be fiber, serial, or virtually any physical media.</span></span>

<span data-ttu-id="f0769-206">링크 계층의 맨 위에는 ‘네트워크 계층’이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-206">On top of the link layer is the *Network layer*.</span></span> <span data-ttu-id="f0769-207">TCP/IP에서 이것은 기본적으로 네트워크를 통해 간단한 패킷을 최선의 방법으로 주고받는 것을 담당하는 IP입니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-207">In TCP/IP, this is the IP, which is basically responsible for sending and receiving simple packets, in a best-effort manner, across the network.</span></span> <span data-ttu-id="f0769-208">ICMP 및 IGMP와 같은 관리 형식 프로토콜은 일반적으로 IP를 주고받는 경우에도 네트워크 계층으로 분류됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-208">Management type protocols like ICMP and IGMP are typically also categorized as network layers, even though they rely on IP for sending and receiving.</span></span>

<span data-ttu-id="f0769-209">‘전송 계층’은 네트워크 계층의 맨 위에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-209">The *Transport layer* rests on top of the network layer.</span></span> <span data-ttu-id="f0769-210">이 계층은 네트워크의 호스트 간 데이터 흐름을 관리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-210">This layer is responsible for managing the flow of data between hosts on the network.</span></span> <span data-ttu-id="f0769-211">NetX에서 지원하는 전송 서비스에는 UDP 및 TCP의 두 가지 형식이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-211">There are two types of transport services supported by NetX: UDP and TCP.</span></span> <span data-ttu-id="f0769-212">UDP 서비스는 연결하지 않고 두 호스트 간에 데이터를 주고받는 최선의 방법을 제공하는 반면, TCP는 두 호스트 엔티티 간에 안정적인 연결 지향 서비스를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-212">UDP services provide best-effort sending and receiving of data between two hosts in a connectionless manner, while TCP provides reliable connection-oriented service between two host entities.</span></span>

<span data-ttu-id="f0769-213">이 계층은 실제 네트워크 데이터 패킷에 반영됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-213">This layering is reflected in the actual network data packets.</span></span> <span data-ttu-id="f0769-214">TCP/IP의 각 계층에는 헤더라는 정보 블록이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-214">Each layer in TCP/IP contains a block of information called a header.</span></span> <span data-ttu-id="f0769-215">헤더를 사용하여 데이터(및 프로토콜 정보)를 둘러싸는 이 기술을 일반적으로 데이터 캡슐화라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-215">This technique of surrounding data (and possibly protocol information) with a header is typically called data encapsulation.</span></span> <span data-ttu-id="f0769-216">그림 1은 NetX 계층화의 예를 보여주고 그림 2는 전송 중인 UDP 데이터에 대한 결과 데이터 캡슐화의 예를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-216">Figure 1 shows an example of NetX layering and Figure 2 shows the resulting data encapsulation for UDP data being sent.</span></span>

![프로토콜 계층화](./media/user-guide/protocol-layering.png)

<span data-ttu-id="f0769-218">**그림 1. 프로토콜 계층화**</span><span class="sxs-lookup"><span data-stu-id="f0769-218">**FIGURE 1. Protocol Layering**</span></span>

![UDP 데이터 캡슐화](./media/user-guide/udp-data-encapsulation.png)

<span data-ttu-id="f0769-220">**그림 2. UDP 데이터 캡슐화**</span><span class="sxs-lookup"><span data-stu-id="f0769-220">**FIGURE 2. UDP Data Encapsulation**</span></span>

## <a name="packet-pools"></a><span data-ttu-id="f0769-221">패킷 풀</span><span class="sxs-lookup"><span data-stu-id="f0769-221">Packet Pools</span></span>

<span data-ttu-id="f0769-222">실시간 네트워킹 애플리케이션에서 신속하고 결정적인 방식으로 패킷을 할당하는 것은 항상 어려운 과제입니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-222">Allocating packets in a fast and deterministic manner is always a challenge in real-time networking applications.</span></span> <span data-ttu-id="f0769-223">이를 염두에 둔 NetX는 고정 크기 네트워크 패킷의 여러 풀을 만들고 관리할 수 있는 기능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-223">With this in mind, NetX provides the ability to create and manage multiple pools of fixed-size network packets.</span></span>

<span data-ttu-id="f0769-224">NetX 패킷 풀은 고정 크기의 메모리 블록으로 구성되므로 내부 조각화 문제가 발생하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-224">Because NetX packet pools consist of fixed-size memory blocks, there are never any internal fragmentation problems.</span></span> <span data-ttu-id="f0769-225">물론 조각화는 본질적으로 비결정적인 동작을 야기합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-225">Of course, fragmentation causes behavior that is inherently nondeterministic.</span></span>

<span data-ttu-id="f0769-226">더불어, NetX 패킷을 할당하고 해제하는 데 필요한 시간은 간단한 연결된 목록 조작에 해당합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-226">In addition, the time required to allocate and free a NetX packet amounts to simple linked-list manipulation.</span></span> <span data-ttu-id="f0769-227">또한 패킷 할당 및 할당 해제는 사용 가능한 목록의 맨 위에서 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-227">Furthermore, packet allocation and deallocation is done at the head of the available list.</span></span> <span data-ttu-id="f0769-228">이렇게 하면 가장 빠른 연결된 목록 처리를 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-228">This provides the fastest possible linked list processing.</span></span>

<span data-ttu-id="f0769-229">일반적으로 유연성 부족은 고정 크기 패킷 풀의 주요 단점입니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-229">Lack of flexibility is typically the main drawback of fixed-size packet pools.</span></span> <span data-ttu-id="f0769-230">최악의 경우 들어오는 패킷을 처리하는 최적의 패킷 페이로드 크기를 결정하는 것은 어려운 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-230">Determining the optimal packet payload size that also handles the worst-case incoming packet is a difficult task.</span></span> <span data-ttu-id="f0769-231">NetX 패킷은 ‘패킷 체인’이라는 옵션 기능을 사용하여 이 문제를 해결합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-231">NetX packets address this problem with an optional feature called *packet chaining*.</span></span> <span data-ttu-id="f0769-232">실제 네트워크 패킷은 함께 연결된 두 개 이상의 NetX 패킷으로 구성될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-232">An actual network packet can be made of one or more NetX packets linked together.</span></span> <span data-ttu-id="f0769-233">또한 패킷 헤더는 패킷의 맨 위에 대한 포인터를 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-233">In addition, the packet header maintains a pointer to the top of the packet.</span></span> <span data-ttu-id="f0769-234">추가 프로토콜이 추가되면 이 포인터는 단순히 뒤로 이동하고 새 헤더는 데이터 바로 앞에 작성됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-234">As additional protocols are added, this pointer is simply moved backwards and the new header is written directly in front of the data.</span></span> <span data-ttu-id="f0769-235">유연한 패킷 기술이 없으면 스택은 처리 집약적인 새 헤더를 사용하여 다른 버퍼를 할당하고 데이터를 새 버퍼에 복사해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-235">Without the flexible packet technology, the stack would have to allocate another buffer and copy the data into a new buffer with the new header, which is processing intensive.</span></span>

<span data-ttu-id="f0769-236">각 패킷 페이로드 크기는 지정된 패킷 풀에 대해 고정되므로 페이로드 크기보다 큰 애플리케이션 데이터에는 여러 패킷이 함께 연결되어 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-236">Since each packet payload size is fixed for a given packet pool, application data larger than the payload size  requires multiple packets chained together.</span></span> <span data-ttu-id="f0769-237">사용자 데이터를 사용하여 패킷을 채울 때 애플리케이션은 ***nx_packet_data_append*** 서비스를 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-237">When filling a packet with user data, the application must use the service ***nx_packet_data_append***.</span></span> <span data-ttu-id="f0769-238">이 서비스는 애플리케이션 데이터를 패킷으로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-238">This service moves application data into a packet.</span></span> <span data-ttu-id="f0769-239">패킷이 사용자 데이터를 저장하기에 충분하지 않은 경우 사용자 데이터를 저장하기 위한 추가 패킷이 할당됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-239">In situations where a packet is not enough to hold user data, additional packets are allocated to store user data.</span></span> <span data-ttu-id="f0769-240">패킷 체인을 사용하려면 드라이버에서 연결된 패킷으로 수신하거나 전송할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-240">To use packet chaining, the driver must be able to receive into or transmit from chained packets.</span></span>

<span data-ttu-id="f0769-241">각 NetX 패킷 메모리 풀은 공용 리소스입니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-241">Each NetX packet memory pool is a public resource.</span></span> <span data-ttu-id="f0769-242">NetX는 패킷 풀의 사용 방법에 제약 조건을 두지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-242">NetX places no constraints on how packet pools are used.</span></span>

### <a name="packet-pool-memory-area"></a><span data-ttu-id="f0769-243">패킷 풀 메모리 영역</span><span class="sxs-lookup"><span data-stu-id="f0769-243">Packet Pool Memory Area</span></span>
<span data-ttu-id="f0769-244">패킷 풀의 메모리 영역은 생성 중에 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-244">The memory area for the packet pool is specified during creation.</span></span> <span data-ttu-id="f0769-245">ThreadX 및 NetX 개체의 다른 메모리 영역과 마찬가지로 대상의 주소 공간 어디에서나 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-245">Like other memory areas for ThreadX and NetX objects, it can be located anywhere in the target's address space.</span></span> <span data-ttu-id="f0769-246">이는 애플리케이션에 상당한 유연성을 제공하기 때문에 중요한 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-246">This is an important feature because of the considerable flexibility it gives the application.</span></span> <span data-ttu-id="f0769-247">예를 들어 통신 제품에 네트워크 버퍼를 위한 고속 메모리 영역이 있다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-247">For example, suppose that a communication product has a high-speed memory area for network buffers.</span></span> <span data-ttu-id="f0769-248">이 메모리 영역은 NetX 패킷 메모리 풀로 만들어 쉽게 활용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-248">This memory area is easily utilized by making it into a NetX packet memory pool.</span></span>

### <a name="creating-packet-pools"></a><span data-ttu-id="f0769-249">패킷 풀 만들기</span><span class="sxs-lookup"><span data-stu-id="f0769-249">Creating Packet Pools</span></span>
<span data-ttu-id="f0769-250">패킷 풀은 초기화 중에 또는 애플리케이션 스레드에서 런타임 중에 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-250">Packet pools are created either during initialization or during runtime by application threads.</span></span> <span data-ttu-id="f0769-251">NetX 애플리케이션의 패킷 메모리 풀 수에는 제한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-251">There are no limits on the number of packet memory pools in a NetX application.</span></span>

### <a name="packet-header-nx_packet"></a><span data-ttu-id="f0769-252">패킷 헤더 NX_PACKET</span><span class="sxs-lookup"><span data-stu-id="f0769-252">Packet Header NX_PACKET</span></span>
<span data-ttu-id="f0769-253">기본적으로 NetX는 패킷 페이로드 영역 바로 앞에 패킷 헤더를 배치합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-253">By default, NetX places the packet header immediately before the packet payload area.</span></span> <span data-ttu-id="f0769-254">패킷 메모리 풀은 기본적으로 일련의 패킷이며 헤더 바로 뒤에 패킷 페이로드가 배치됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-254">The packet memory pool is basically a series of packets—headers followed immediately by the packet payload.</span></span> <span data-ttu-id="f0769-255">패킷 헤더(***NX_PACKET***)와 패킷 풀의 레이아웃은 그림 3에 나와 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-255">The packet header (***NX_PACKET***) and the layout of the packet pool are pictured in Figure 3.</span></span>

<span data-ttu-id="f0769-256">무복사 작업을 수행할 수 있는 네트워크 디바이스 드라이버의 경우 일반적으로 패킷 페이로드 영역의 시작 주소가 DMA 논리로 프로그래밍이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-256">For network devices driver that are able to perform zero copy operations, typically the starting address of the packet payload area is programmed into the DMA logic.</span></span> <span data-ttu-id="f0769-257">특정 DMA 엔진은 페이로드 영역에 맞춤 요구 사항이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-257">Certain DMA engines have alignment requirement on the payload area.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="f0769-258">\*네트워크 드라이버는 패킷의 전송이 완료되면 \***nx_packet_transmit_release** _ 함수를 호출해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-258">\*The network driver to must call the \***nx_packet_transmit_release** _ function when the transmission of a packet is complete.</span></span> <span data-ttu-id="f0769-259">이 함수는 사용 가능한 풀에 실제로 다시 배치되기 전에 패킷이 TCP 출력 큐의 일부가 아닌지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-259">This function checks to make sure the packet is not part of a TCP output queue before it is actually placed back in the available pool.</span></span> <span data-ttu-id="f0769-260">이 함수를 호출하지 않으면 예기치 않은 결과가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-260">Failure to call this function can result in unpredictable behavior._</span></span>

![패킷 헤더 및 패킷 풀 레이아웃](./media/user-guide/packet-header-packet-pool-layout.png)

<span data-ttu-id="f0769-262">**그림 3. 패킷 헤더 및 패킷 풀 레이아웃**</span><span class="sxs-lookup"><span data-stu-id="f0769-262">**FIGURE 3. Packet Header and Packet Pool Layout**</span></span>

<span data-ttu-id="f0769-263">패킷 헤더의 필드는 다음 표와 같이 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-263">The fields of the packet header are defined as shown in the following table.</span></span> <span data-ttu-id="f0769-264">이 표는 NX_PACKET 구조체에 있는 모든 멤버의 포괄적인 목록은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-264">Note that this table is not a comprehensive list of all the members in the *NX_PACKET* structure.</span></span>

| <span data-ttu-id="f0769-265">패킷 헤더</span><span class="sxs-lookup"><span data-stu-id="f0769-265">Packet header</span></span>          | <span data-ttu-id="f0769-266">용도</span><span class="sxs-lookup"><span data-stu-id="f0769-266">Purpose</span></span>                                                                                                                                                                                                                                                                                                                            |
|------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="f0769-267">*nx_packet_pool_owner*</span><span class="sxs-lookup"><span data-stu-id="f0769-267">*nx_packet_pool_owner*</span></span>   | <span data-ttu-id="f0769-268">이 필드는 이 특정 패킷을 소유한 패킷 풀을 가리킵니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-268">This field points to the packet pool that owns this particular packet.</span></span> <span data-ttu-id="f0769-269">패킷이 해제되면 이 특정 풀로 해제됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-269">When the packet is released, it is released to this particular pool.</span></span> <span data-ttu-id="f0769-270">각 패킷 내부의 풀 소유권을 통해 데이터그램이 여러 패킷 풀에서 여러 패킷을 소유할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-270">With the pool ownership inside each packet, it is possible for a datagram to span multiple packets from multiple packet pools.</span></span>                                                         |
| <span data-ttu-id="f0769-271">*nx_packet_next*</span><span class="sxs-lookup"><span data-stu-id="f0769-271">*nx_packet_next*</span></span>         | <span data-ttu-id="f0769-272">이 필드는 동일한 프레임 내의 다음 패킷을 가리킵니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-272">This field points to the next packet within the same frame.</span></span> <span data-ttu-id="f0769-273">NULL인 경우 프레임의 일부인 추가 패킷이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-273">If NULL, there are no additional packets that are part of the frame.</span></span> |
| <span data-ttu-id="f0769-274">*nx_packet_last*</span><span class="sxs-lookup"><span data-stu-id="f0769-274">*nx_packet_last*</span></span>         | <span data-ttu-id="f0769-275">이 필드는 동일한 네트워크 패킷 내의 마지막 패킷을 가리킵니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-275">This field points to the last packet within the same network packet.</span></span> <span data-ttu-id="f0769-276">NULL인 경우 이 패킷은 전체 네트워크 패킷을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-276">If NULL, this packet represents the entire network packet.</span></span>  |
| <span data-ttu-id="f0769-277">*nx_packet_length*</span><span class="sxs-lookup"><span data-stu-id="f0769-277">*nx_packet_length*</span></span>       | <span data-ttu-id="f0769-278">이 필드는 nx_packet_next 멤버에 의해 함께 연결된 모든 패킷의 모든 바이트 수를 포함하여 전체 네트워크 패킷의 총 바이트 수를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-278">This field contains the total number of bytes in the entire network packet, including the total of all bytes in all packets chained together by the *nx_packet_next* member.</span></span> |
| <span data-ttu-id="f0769-279">*nx_packet_ip_interface*</span><span class="sxs-lookup"><span data-stu-id="f0769-279">*nx_packet_ip_interface*</span></span> | <span data-ttu-id="f0769-280">이 필드는 인터페이스 드라이버에 의해 수신될 때 패킷에 할당되고, NetX에 의해 나가는 패킷에 할당되는 인터페이스 제어 블록입니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-280">This field is the interface control block which is assigned to the packet when it is received by the interface driver, and by NetX for outgoing packets.</span></span> <span data-ttu-id="f0769-281">인터페이스 제어 블록은 네트워크 주소, MAC 주소, IP 주소 등의 인터페이스 및 링크 사용 및 실제 매핑 필요와 같은 인터페이스 상태를 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-281">An interface control block describes the interface e.g. network address, MAC address, IP address and interface status such as link enabled and physical mapping required.</span></span> |
| <span data-ttu-id="f0769-282">*nx_packet_data_start*</span><span class="sxs-lookup"><span data-stu-id="f0769-282">*nx_packet_data_start*</span></span>   | <span data-ttu-id="f0769-283">이 필드는 이 패킷의 실제 페이로드 영역의 시작을 가리킵니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-283">This field points to the start of the physical payload area of this packet.</span></span> <span data-ttu-id="f0769-284">NX_PACKET 헤더 바로 뒤에 있을 필요는 없지만 ***nx_packet_pool_create*** 서비스에 대한 기본값입니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-284">It does not have to be immediately following the NX_PACKET header, but that is the default for the ***nx_packet_pool_create*** service.</span></span> |
| <span data-ttu-id="f0769-285">*nx_packet_data_end*</span><span class="sxs-lookup"><span data-stu-id="f0769-285">*nx_packet_data_end*</span></span>     | <span data-ttu-id="f0769-286">이 필드는 이 패킷의 실제 페이로드 영역의 끝을 가리킵니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-286">This field points to the end of the physical payload area of this packet.</span></span> <span data-ttu-id="f0769-287">이 필드와 nx_packet_data_start 필드 간의 차이는 페이로드 크기를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-287">The difference between this field and the nx_packet_data_start field represents the payload size.</span></span> |
| <span data-ttu-id="f0769-288">*nx_packet_prepend_ptr*</span><span class="sxs-lookup"><span data-stu-id="f0769-288">*nx_packet_prepend_ptr*</span></span>  | <span data-ttu-id="f0769-289">이 필드는 패킷 페이로드 영역의 기존 패킷 데이터(있는 경우) 앞에 프로토콜 헤더나 실제 데이터와 같은 패킷 데이터가 추가되는 위치를 가리킵니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-289">This field points to the location of where packet data, either protocol header or actual data, is added in front of the existing packet data (if any) in the packet payload area.</span></span> <span data-ttu-id="f0769-290">nx_packet_data_start 포인터 위치보다 크거나 같아야 하며 nx_packet_append_ptr 포인터보다 작거나 같아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-290">It must be greater than or equal to the *nx_packet_data_start* pointer location and less than or equal to the *nx_packet_append_ptr* pointer.</span></span>  <span data-ttu-id="f0769-291">성능상의 이유로, 전송을 위해 패킷이 NetX 서비스에 전달될 때 NetX는 앞에 추가 포인터가 긴 단어 맞춤 주소를 가리키는 것으로 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-291">*For performance reasons, NetX assumes that when the packet is passed into NetX services for transmission, the prepend pointer points to long word aligned address.*</span></span> |
| <span data-ttu-id="f0769-292">*nx_packet_append_ptr*</span><span class="sxs-lookup"><span data-stu-id="f0769-292">*nx_packet_append_ptr*</span></span>    | <span data-ttu-id="f0769-293">이 필드는 현재 패킷 페이로드 영역에 있는 데이터의 끝을 가리킵니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-293">This field points to the end of the data currently in the packet payload area.</span></span> <span data-ttu-id="f0769-294">nx_packet_prepend_ptr 및 nx_packet_data_end가 가리키는 메모리 위치 사이에 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-294">It must be in between the memory location pointed to by *nx_packet_prepend_ptr* and *nx_packet_data_end*.</span></span> <span data-ttu-id="f0769-295">이 필드와 nx_packet_prepend_ptr 필드 간의 차이는 이 패킷의 데이터양을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-295">The difference between this field and the *nx_packet_prepend_ptr* field represents the amount of data in this packet.</span></span> |
| <span data-ttu-id="f0769-296">*nx_packet_fragment_next*</span><span class="sxs-lookup"><span data-stu-id="f0769-296">*nx_packet_fragment_next*</span></span> | <span data-ttu-id="f0769-297">이 필드는 전체 패킷을 다시 어셈블할 수 있을 때까지 조각난 패킷을 보관하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-297">This field is used to hold fragmented packets until the entire packet can be re-assembled.</span></span> |
| <span data-ttu-id="f0769-298">*nx_packet_pad*</span><span class="sxs-lookup"><span data-stu-id="f0769-298">*nx_packet_pad*</span></span>           | <span data-ttu-id="f0769-299">이 필드는 원하는 맞춤 요구 사항을 달성하기 위해 4바이트 단어로 된 패딩의 길이를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-299">This fields defines the length of padding in 4- byte words to achieve the desired alignment requirement.</span></span> <span data-ttu-id="f0769-300">NX_PACKET_HEADER_PAD가 정의되지 않은 경우 이 필드는 제거됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-300">This field is removed if *NX_PACKET_HEADER_PAD* is not defined.</span></span> |
|  |  |

### <a name="packet-header-offsets"></a><span data-ttu-id="f0769-301">패킷 헤더 오프셋</span><span class="sxs-lookup"><span data-stu-id="f0769-301">Packet Header Offsets</span></span>

<span data-ttu-id="f0769-302">패킷 헤더 크기는 헤더 크기를 수용할 수 있는 충분한 공간을 허용하도록 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-302">Packet header size is defined to allow enough room to accommodate the size of the header.</span></span> <span data-ttu-id="f0769-303">nx_packet_allocate 서비스는 패킷을 할당하고 지정된 패킷 형식에 따라 패킷의 앞에 추가 포인터를 조정하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-303">The *nx_packet_allocate* service is used to allocate a packet and adjusts the prepend pointer in the packet according to the type of packet specified.</span></span> <span data-ttu-id="f0769-304">패킷 형식은 프로토콜 헤더(예: UDP, TCP, ICMP)를 프로토콜 데이터 앞에 삽입하는 데 필요한 오프셋을 NetX에게 알려줍니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-304">The packet type tells NetX the offset required for inserting the protocol header (such as UDP, TCP, or ICMP) in front of the protocol data.</span></span>

<span data-ttu-id="f0769-305">다음 형식은 패킷의 IP 헤더와 실제 계층(이더넷) 헤더를 고려하도록 NetX에서 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-305">The following types are defined in NetX to take into account the IP header and physical layer (Ethernet) header in the packet.</span></span> <span data-ttu-id="f0769-306">후자의 경우, 필요한 4바이트 맞춤을 고려하여 16바이트로 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-306">In the latter case, it is assumed to be 16 bytes taking the required 4-byte alignment into consideration.</span></span> <span data-ttu-id="f0769-307">IP 패킷은 IP 네트워크의 패킷을 할당하는 애플리케이션에 대해 NetX에서 계속 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-307">IP packets are still defined in NetX for applications to allocate packets for IP networks.</span></span> <span data-ttu-id="f0769-308">다음 표에서는 기호를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-308">The following table shows symbols defined:</span></span>

| <span data-ttu-id="f0769-309">패킷 형식</span><span class="sxs-lookup"><span data-stu-id="f0769-309">Packet Type</span></span>   | <span data-ttu-id="f0769-310">값</span><span class="sxs-lookup"><span data-stu-id="f0769-310">Value</span></span> |
|---------------|-------|
| <span data-ttu-id="f0769-311">NX_IP_PACKET</span><span class="sxs-lookup"><span data-stu-id="f0769-311">NX_IP_PACKET</span></span>  | <span data-ttu-id="f0769-312">0x24</span><span class="sxs-lookup"><span data-stu-id="f0769-312">0x24</span></span>  |
| <span data-ttu-id="f0769-313">NX_UDP_PACKET</span><span class="sxs-lookup"><span data-stu-id="f0769-313">NX_UDP_PACKET</span></span> | <span data-ttu-id="f0769-314">0x2c</span><span class="sxs-lookup"><span data-stu-id="f0769-314">0x2c</span></span>  |
| <span data-ttu-id="f0769-315">NX_TCP_PACKET</span><span class="sxs-lookup"><span data-stu-id="f0769-315">NX_TCP_PACKET</span></span> | <span data-ttu-id="f0769-316">0x38</span><span class="sxs-lookup"><span data-stu-id="f0769-316">0x38</span></span>  |
|               |       |

### <a name="pool-capacity"></a><span data-ttu-id="f0769-317">풀 용량</span><span class="sxs-lookup"><span data-stu-id="f0769-317">Pool Capacity</span></span>
<span data-ttu-id="f0769-318">패킷 풀의 패킷 수는 페이로드 크기와 패킷 풀 만들기 서비스에 제공된 메모리 영역의 총 바이트 수의 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-318">The number of packets in a packet pool is a function of the payload size and the total number of bytes in the memory area supplied to the packet pool create service.</span></span> <span data-ttu-id="f0769-319">풀의 용량은 패킷 크기(NX_PACKET 헤더의 크기, 페이로드 크기 및 올바른 맞춤 포함)를 제공된 메모리 영역의 총 바이트 수로 나누어 계산합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-319">The capacity of the pool is calculated by dividing the packet size (including the size of the NX_PACKET header, the payload size, and proper alignment) into the total number of bytes in the supplied memory area.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="f0769-320">스레드 일시 중단</span><span class="sxs-lookup"><span data-stu-id="f0769-320">Thread Suspension</span></span>
<span data-ttu-id="f0769-321">빈 풀에서 패킷을 기다리는 동안 애플리케이션 스레드가 일시 중단될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-321">Application threads can suspend while waiting for a packet from an empty pool.</span></span> <span data-ttu-id="f0769-322">패킷이 풀로 반환되면 일시 중단된 스레드에 이 패킷이 제공되고 다시 시작됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-322">When a packet is returned to the pool, the suspended thread is given this packet and resumed.</span></span>

<span data-ttu-id="f0769-323">여러 스레드가 동일한 패킷 풀에서 일시 중단되면 일시 중단된 순서대로(FIFO) 다시 시작됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-323">If multiple threads are suspended on the same packet pool, they are resumed in the order they were suspended (FIFO).</span></span>

### <a name="pool-statistics-and-errors"></a><span data-ttu-id="f0769-324">풀 통계 및 오류</span><span class="sxs-lookup"><span data-stu-id="f0769-324">Pool Statistics and Errors</span></span>
<span data-ttu-id="f0769-325">사용하도록 설정된 경우 NetX 패킷 관리 소프트웨어 **오류** 는 애플리케이션에 유용할 수 있는 몇 가지 통계 및 오류를 추적합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-325">If enabled, the NetX packet management software **Errors** keeps track of several statistics and errors that may be useful to the application.</span></span> <span data-ttu-id="f0769-326">패킷 풀에 대해 다음 통계 및 오류 보고서가 유지 관리됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-326">The following statistics and error reports are maintained for packet pools:</span></span>

* <span data-ttu-id="f0769-327">풀의 총 패킷</span><span class="sxs-lookup"><span data-stu-id="f0769-327">Total Packets in Pool</span></span>
* <span data-ttu-id="f0769-328">풀의 사용 가능한 패킷</span><span class="sxs-lookup"><span data-stu-id="f0769-328">Free Packets in Pool</span></span>
* <span data-ttu-id="f0769-329">풀 빈 할당 요청</span><span class="sxs-lookup"><span data-stu-id="f0769-329">Pool Empty Allocation Requests</span></span>
* <span data-ttu-id="f0769-330">풀 빈 할당 일시 중단</span><span class="sxs-lookup"><span data-stu-id="f0769-330">Pool Empty Allocation Suspensions</span></span>
* <span data-ttu-id="f0769-331">잘못된 패킷 릴리스</span><span class="sxs-lookup"><span data-stu-id="f0769-331">Invalid Packet Releases</span></span>

<span data-ttu-id="f0769-332">\***NX_DISABLE_PACKET_INFO** _가 정의되어 있지 않은 경우 풀의 총 패킷 수와 사용 가능한 패킷 수를 제외한 모든 통계 및 오류 보고서는 NetX 라이브러리에 내장되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-332">All of these statistics and error reports, except for total and free packet count in pool, are built into NetX library unless \***NX_DISABLE_PACKET_INFO** _ is defined.</span></span> <span data-ttu-id="f0769-333">이 데이터는 애플리케이션이 _ _nx_packet_pool_info_get_\* 서비스를 사용하여 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-333">This data is available to the application with the _ *_nx_packet_pool_info_get_*\* service.</span></span>

### <a name="packet-pool-control-block-nx_packet_pool"></a><span data-ttu-id="f0769-334">패킷 풀 제어 블록 NX_PACKET_POOL</span><span class="sxs-lookup"><span data-stu-id="f0769-334">Packet Pool Control Block NX_PACKET_POOL</span></span>

<span data-ttu-id="f0769-335">각 패킷 메모리 풀의 특성은 해당 제어 블록에서 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-335">The characteristics of each packet memory pool are found in its control block.</span></span> <span data-ttu-id="f0769-336">이 풀에는 사용 가능한 패킷의 연결된 목록, 사용 가능한 패킷 수 및 이 풀의 패킷에 대한 페이로드 크기와 같은 유용한 정보가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-336">It contains useful information such as the linked list of free packets, the number of free packets, and the payload size for packets in this pool.</span></span> <span data-ttu-id="f0769-337">이 구조는 nx_api.h 파일에서 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-337">This structure is defined in the *nx_api.h* file.</span></span>

<span data-ttu-id="f0769-338">패킷 풀 제어 블록은 메모리 내 어디에나 위치할 수 있지만, 제어 블록을 모든 함수의 범위 밖에 정의하여 전역 구조로 만드는 것이 가장 일반적입니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-338">Packet pool control blocks can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

## <a name="ip-protocol"></a><span data-ttu-id="f0769-339">IP 프로토콜</span><span class="sxs-lookup"><span data-stu-id="f0769-339">IP Protocol</span></span>

<span data-ttu-id="f0769-340">NetX의 IP(인터넷 프로토콜) 구성 요소는 인터넷에서 IP 패킷을 주고받는 역할을 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-340">The Internet Protocol (IP) component of NetX is responsible for sending and receiving IP packets on the Internet.</span></span> <span data-ttu-id="f0769-341">NetX에서 기본 네트워크 드라이버를 활용하여 TCP, UDP, ICMP, IGMP 메시지를 최종적으로 주고받는 구성 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-341">In NetX, it is the component ultimately responsible for sending and receiving TCP, UDP, ICMP, and IGMP messages, utilizing the underlying network driver.</span></span>

<span data-ttu-id="f0769-342">NetX는 IP 프로토콜 (RFC 791)을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-342">NetX supports IP protocol (RFC 791)</span></span>

### <a name="ip-addresses"></a><span data-ttu-id="f0769-343">IP 주소</span><span class="sxs-lookup"><span data-stu-id="f0769-343">IP Addresses</span></span>

<span data-ttu-id="f0769-344">인터넷의 각 호스트에는 IP 주소라는 고유한 32비트 식별자가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-344">Each host on the Internet has a unique 32-bit identifier called an IP address.</span></span> <span data-ttu-id="f0769-345">그림 4에 설명된 대로 IP 주소에는 5개의 클래스가 있습니다</span><span class="sxs-lookup"><span data-stu-id="f0769-345">There are five classes of IP addresses as described in Figure 4.</span></span> <span data-ttu-id="f0769-346">5개의 IP 주소 클래스의 범위는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-346">The ranges of the five IP address classes are as follows:</span></span>

| <span data-ttu-id="f0769-347">클래스</span><span class="sxs-lookup"><span data-stu-id="f0769-347">Class</span></span> | <span data-ttu-id="f0769-348">범위</span><span class="sxs-lookup"><span data-stu-id="f0769-348">Range</span></span>                        |
|-------|------------------------------|
| <span data-ttu-id="f0769-349">A</span><span class="sxs-lookup"><span data-stu-id="f0769-349">A</span></span>     | <span data-ttu-id="f0769-350">0.0.0.0 ~ 127.255.255.255</span><span class="sxs-lookup"><span data-stu-id="f0769-350">0.0.0.0 to 127.255.255.255</span></span>   |
| <span data-ttu-id="f0769-351">b</span><span class="sxs-lookup"><span data-stu-id="f0769-351">B</span></span>     | <span data-ttu-id="f0769-352">128.0.0.0 ~ 191.255.255.255</span><span class="sxs-lookup"><span data-stu-id="f0769-352">128.0.0.0 to 191.255.255.255</span></span> |
| <span data-ttu-id="f0769-353">C</span><span class="sxs-lookup"><span data-stu-id="f0769-353">C</span></span>     | <span data-ttu-id="f0769-354">192.0.0.0 ~ 223.255.255.255</span><span class="sxs-lookup"><span data-stu-id="f0769-354">192.0.0.0 to 223.255.255.255</span></span> |
| <span data-ttu-id="f0769-355">D</span><span class="sxs-lookup"><span data-stu-id="f0769-355">D</span></span>     | <span data-ttu-id="f0769-356">224.0.0.0 ~ 239.255.255.255</span><span class="sxs-lookup"><span data-stu-id="f0769-356">224.0.0.0 to 239.255.255.255</span></span> |
| <span data-ttu-id="f0769-357">E</span><span class="sxs-lookup"><span data-stu-id="f0769-357">E</span></span>     | <span data-ttu-id="f0769-358">240.0.0.0 ~ 247.255.255.255</span><span class="sxs-lookup"><span data-stu-id="f0769-358">240.0.0.0 to 247.255.255.255</span></span> |

<span data-ttu-id="f0769-359">**7비트 24비트**</span><span class="sxs-lookup"><span data-stu-id="f0769-359">**7 bits 24 bits**</span></span>

![IP 주소 구조](./media/user-guide/ip-address-structure.png)

<span data-ttu-id="f0769-361">**그림 4. IP 주소 구조**</span><span class="sxs-lookup"><span data-stu-id="f0769-361">**FIGURE 4. IP Address Structure**</span></span>

<span data-ttu-id="f0769-362">또한 주소 사양에는 ‘유니캐스트’, ‘브로드캐스트’, ‘멀티캐스트’의 세 가지 형식이 있습니다.  </span><span class="sxs-lookup"><span data-stu-id="f0769-362">There are also three types of address specifications: *unicast*, *broadcast*, and *multicast*.</span></span> <span data-ttu-id="f0769-363">유니캐스트 주소는 인터넷에서 특정 호스트를 식별하는 IP 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-363">Unicast addresses are those IP addresses that identify a specific host on the Internet.</span></span> <span data-ttu-id="f0769-364">유니캐스트 주소는 소스 또는 대상 IP 주소일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-364">Unicast addresses can be either a source or a destination IP address.</span></span> <span data-ttu-id="f0769-365">브로드캐스트 주소는 특정 네트워크 또는 하위 네트워크의 모든 호스트를 식별하고 대상 주소로만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-365">A broadcast address identifies all hosts on a specific network or sub-network and can only be used as destination addresses.</span></span> <span data-ttu-id="f0769-366">브로드캐스트 주소는 주소의 호스트 ID 부분을 하나로 설정하여 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-366">Broadcast addresses are specified by having the host ID portion of the address set to ones.</span></span> <span data-ttu-id="f0769-367">멀티캐스트 주소(클래스 D)는 인터넷에서 호스트의 동적 그룹을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-367">Multicast addresses (Class D) specify a dynamic group of hosts on the Internet.</span></span> <span data-ttu-id="f0769-368">멀티캐스트 그룹의 멤버는 언제든지 참여하고 나갈 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-368">Members of the multicast group may join and leave whenever they wish.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="f0769-369">IP를 통한 UDP와 같은 연결 없는 프로토콜만이 브로드캐스트와 멀티캐스트 그룹의 제한된 브로드캐스트 기능을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-369">*Only connectionless protocols like UDP over IP can utilize broadcast and the limited broadcast capability of the multicast group.*</span></span>

> [!IMPORTANT]
> <span data-ttu-id="f0769-370">*매크로* IP_ADDRESS *는*  \***nx_api.h** _에 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-370">*The macro* IP_ADDRESS *is defined in* \***nx_api.h** _.</span></span> <span data-ttu-id="f0769-371">마침표 대신 쉼표를 사용하여 IP 주소를 쉽게 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-371">It allows easy specification of IP addresses using commas instead of a periods.</span></span> <span data-ttu-id="f0769-372">예를 들어 IP_ADDRESS(128,0,0,0)_는 그림 4에 표시된 첫 번째 클래스 B 주소를 지정합니다.\*</span><span class="sxs-lookup"><span data-stu-id="f0769-372">For example, IP_ADDRESS(128,0,0,0) _specifies the first class B address shown in Figure 4.\*</span></span>

### <a name="ip-gateway-address"></a><span data-ttu-id="f0769-373">IP 게이트웨이 주소</span><span class="sxs-lookup"><span data-stu-id="f0769-373">IP Gateway Address</span></span>

<span data-ttu-id="f0769-374">네트워크 게이트웨이는 네트워크의 호스트가 로컬 도메인 외부의 대상으로 향하는 패킷을 릴레이 하도록 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-374">Network gateways assist hosts on their networks to relay packets destined to destinations outside the local domain.</span></span> <span data-ttu-id="f0769-375">각 노드는 네트워크 환경 중 하나 또는 미리 프로그래밍된 고정 라우팅 테이블을 통해 다음 홉을 전송할 대상에 대한 약간의 정보를 가지고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-375">Each node has some knowledge of which next hop to send to, either the destination one of its neighbors, or through a pre-programmed static routing table.</span></span> <span data-ttu-id="f0769-376">그러나 이러한 접근 방식이 실패할 경우 노드는 패킷을 대상으로 라우팅하는 방법에 대한 자세한 정보가 있는 기본 게이트웨이로 패킷을 전달해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-376">However if these approaches fail, the node should forward the packet to its default gateway which has more information on how to route the packet to its destination.</span></span> <span data-ttu-id="f0769-377">기본 게이트웨이는 IP 인스턴스에 연결된 실제 인터페이스 중 하나를 통해 직접 액세스할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-377">Note that the default gateway must be directly accessible through one of the physical interfaces attached to the IP instance.</span></span> <span data-ttu-id="f0769-378">애플리케이션은 IP 기본 게이트웨이 주소를 구성하기 위해 ***nx_ip_gateway_address_set*** 를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-378">The application calls ***nx_ip_gateway_address_set*** to configure IP default gateway address.</span></span>

### <a name="ip-header"></a><span data-ttu-id="f0769-379">IP 헤더</span><span class="sxs-lookup"><span data-stu-id="f0769-379">IP Header</span></span>

<span data-ttu-id="f0769-380">인터넷에서 IP 패킷을 전송하려면 IP 헤더가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-380">For any IP packet to be sent on the Internet, it must have an IP header.</span></span> <span data-ttu-id="f0769-381">상위 수준의 프로토콜(UDP, TCP, ICMP, IGMP)이 패킷을 전송하기 위해 IP 구성 요소를 호출할 때 IP 전송 모듈은 데이터 앞에 IP 헤더를 배치합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-381">When higher-level protocols (UDP, TCP, ICMP, or IGMP) call the IP component to send a packet, the IP transmit module places an IP header in front of the data.</span></span> <span data-ttu-id="f0769-382">반대로, IP 패킷이 네트워크에서 수신되면, IP 구성 요소는 상위 수준의 프로토콜로 전송되기 전에 패킷에서 IP 헤더를 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-382">Conversely, when IP packets are received from the network, the IP component removes the IP header from the packet before delivery to the higher-level protocols.</span></span> <span data-ttu-id="f0769-383">그림 5는 IP 헤더의 형식을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-383">Figure 5 shows the format of the IP header.</span></span>

![IP 헤더 형식](./media/user-guide/ip-header-format.png)

<span data-ttu-id="f0769-385">**그림 5. IP 헤더 형식**</span><span class="sxs-lookup"><span data-stu-id="f0769-385">**FIGURE 5. IP Header Format**</span></span>

> [!IMPORTANT]
> <span data-ttu-id="f0769-386">TCP/IP 구현의 모든 헤더는 big endian 형식이어야 합니다. 이 형식에서 단어의 가장 중요한 바이트는 가장 낮은 바이트 주소에 있습니다. 예를 들어 IP 헤더의 4비트 버전과 4비트 헤더 길이는 헤더의 첫 번째 바이트에 위치해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-386">*All headers in the TCP/IP implementation are expected to be in big endian format. In this format, the most significant byte of the word resides at the lowest byte address. For example, the 4-bit version and the 4-bit header length of the IP header must be located on the first byte of the header.*</span></span>

<span data-ttu-id="f0769-387">IP 헤더의 필드는 다음과 같이 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-387">The fields of the IP header are defined as follows:</span></span>

<span data-ttu-id="f0769-388">**IP 헤더 필드 용도**</span><span class="sxs-lookup"><span data-stu-id="f0769-388">**IP Header Field Purpose**</span></span>

<span data-ttu-id="f0769-389">***4비트 버전*** 이 필드에는 이 헤더가 나타내는 IP 버전이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-389">***4-bit version*** This field contains the version of IP this header represents.</span></span> <span data-ttu-id="f0769-390">NetX에서 지원하는 IP 버전 4의 경우 이 필드의 값은 4입니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-390">For IP version 4, which is what NetX supports, the value of this field is 4.</span></span>

<span data-ttu-id="f0769-391">***4비트 헤더 길이*** 이 필드는 IP 헤더에 있는 32비트 단어 수를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-391">***4-bit header length*** This field specifies the number of 32-bit words in the IP header.</span></span> <span data-ttu-id="f0769-392">옵션 단어가 없을 경우 이 필드의 값은 5입니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-392">If no option words are present, the value for this field is 5.</span></span>

<span data-ttu-id="f0769-393">***8비트 TOS(서비스 유형)*** 이 필드는 이 IP 패킷에 대해 요청된 서비스 유형을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-393">***8-bit type of service (TOS)*** This field specifies the type of service requested for this IP packet.</span></span> <span data-ttu-id="f0769-394">유효한 요청은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-394">Valid requests are as follows:</span></span>

| <span data-ttu-id="f0769-395">**TOS 요청**</span><span class="sxs-lookup"><span data-stu-id="f0769-395">**TOS Request**</span></span>     | <span data-ttu-id="f0769-396">**값**</span><span class="sxs-lookup"><span data-stu-id="f0769-396">**Value**</span></span> |
| ------------------- | --------- |
| <span data-ttu-id="f0769-397">보통</span><span class="sxs-lookup"><span data-stu-id="f0769-397">Normal</span></span>              | <span data-ttu-id="f0769-398">0x00</span><span class="sxs-lookup"><span data-stu-id="f0769-398">0x00</span></span>      |
| <span data-ttu-id="f0769-399">최소 지연</span><span class="sxs-lookup"><span data-stu-id="f0769-399">Minimum Delay</span></span>       | <span data-ttu-id="f0769-400">0x10</span><span class="sxs-lookup"><span data-stu-id="f0769-400">0x10</span></span>      |
| <span data-ttu-id="f0769-401">최대 데이터</span><span class="sxs-lookup"><span data-stu-id="f0769-401">Maximum Data</span></span>        | <span data-ttu-id="f0769-402">0x08</span><span class="sxs-lookup"><span data-stu-id="f0769-402">0x08</span></span>      |
| <span data-ttu-id="f0769-403">최대 안정성</span><span class="sxs-lookup"><span data-stu-id="f0769-403">Maximum Reliability</span></span> | <span data-ttu-id="f0769-404">0x04</span><span class="sxs-lookup"><span data-stu-id="f0769-404">0x04</span></span>      |
| <span data-ttu-id="f0769-405">최소 비용</span><span class="sxs-lookup"><span data-stu-id="f0769-405">Minimum Cost</span></span>        | <span data-ttu-id="f0769-406">0x02</span><span class="sxs-lookup"><span data-stu-id="f0769-406">0x02</span></span>      |

<span data-ttu-id="f0769-407">***16비트 총 길이*** 이 필드는 IP 헤더를 포함하여 IP 데이터그램의 총 길이(바이트)를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-407">***16-bit total length*** This field contains the total length of the IP datagram in bytes, including the IP header.</span></span> <span data-ttu-id="f0769-408">IP 데이터그램은 TCP/IP 인터넷에 있는 기본 정보 단위입니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-408">An IP datagram is the basic unit of information found on a TCP/IP Internet.</span></span> <span data-ttu-id="f0769-409">데이터 외에도 대상 및 소스 주소가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-409">It contains a destination and source address in addition to data.</span></span> <span data-ttu-id="f0769-410">16비트 필드이기 때문에 IP 데이터그램의 최대 크기는 65,535바이트입니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-410">Because it is a 16-bit field, the maximum size of an IP datagram is 65,535 bytes.</span></span>

<span data-ttu-id="f0769-411">***16비트 ID*** 필드는 호스트에서 전송된 각 IP 데이터그램을 고유하게 식별하는 데 사용되는 숫자입니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-411">***16-bit identification*** The field is a number used to uniquely identify each IP datagram sent from a host.</span></span> <span data-ttu-id="f0769-412">이 숫자는 일반적으로 IP 데이터그램이 전송된 후에 증가합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-412">This number is typically incremented after an IP datagram is sent.</span></span> <span data-ttu-id="f0769-413">특히 수신된 IP 패킷 조각을 어셈블하는 데 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-413">It is especially useful in assembling received IP packet fragments.</span></span>

<span data-ttu-id="f0769-414">***3비트 플래그*** 이 필드는 IP 조각화 정보를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-414">***3-bit flags*** This field contains IP fragmentation information.</span></span> <span data-ttu-id="f0769-415">비트 14는 “Don't Fragment” 비트입니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-415">Bit 14 is the "don't fragment" bit.</span></span> <span data-ttu-id="f0769-416">이 비트가 설정되면 나가는 IP 데이터그램이 조각나지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-416">If this bit is set, the outgoing IP datagram will not be fragmented.</span></span> <span data-ttu-id="f0769-417">비트 13은 “More Fragments” 비트입니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-417">Bit 13 is the "more fragments" bit.</span></span> <span data-ttu-id="f0769-418">이 비트가 설정되면 더 많은 조각이 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-418">If this bit is set, there are more fragments.</span></span> <span data-ttu-id="f0769-419">이 비트가 0이면 이는 IP 패킷의 마지막 조각입니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-419">If this bit is clear, this is the last fragment of the IP packet.</span></span>

<span data-ttu-id="f0769-420">**IP 헤더 필드 용도**</span><span class="sxs-lookup"><span data-stu-id="f0769-420">**IP Header Field Purpose**</span></span>

<span data-ttu-id="f0769-421">***13비트 조각 오프셋*** 이 필드에는 조각 오프셋의 상위 13비트가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-421">***13-bit fragment offset*** This field contains the upper 13-bits of the fragment offset.</span></span> <span data-ttu-id="f0769-422">따라서 조각 오프셋은 8바이트 경계에서만 허용됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-422">Because of this, fragment offsets are only allowed on 8-byte boundaries.</span></span> <span data-ttu-id="f0769-423">조각화된 IP 데이터그램의 첫 번째 조각은 “More Fragments” 비트 집합을 포함하고 오프셋은 0입니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-423">The first fragment of a fragmented IP datagram will have the “more fragments” bit set and have an offset of 0.</span></span>

<span data-ttu-id="f0769-424">***8비트 TTL(Time to Live)*** 이 필드는 데이터그램이 전달할 수 있는 라우터 수를 포함하며, 기본적으로 데이터그램의 수명을 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-424">***8-bit time to live (TTL)*** This field contains the number of routers this datagram can pass, which limits the lifetime of the datagram.</span></span>

<span data-ttu-id="f0769-425">***8비트 프로토콜*** 이 필드는 IP 데이터그램을 사용하는 프로토콜을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-425">***8-bit protocol*** This field specifies which protocol is using the IP datagram.</span></span> <span data-ttu-id="f0769-426">다음은 유효한 프로토콜과 해당 값의 목록입니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-426">The following is a list of valid protocols and their values:</span></span>

| <span data-ttu-id="f0769-427">프로토콜</span><span class="sxs-lookup"><span data-stu-id="f0769-427">Protocol</span></span> | <span data-ttu-id="f0769-428">값</span><span class="sxs-lookup"><span data-stu-id="f0769-428">Value</span></span> |
|----------|-------|
| <span data-ttu-id="f0769-429">ICMP</span><span class="sxs-lookup"><span data-stu-id="f0769-429">ICMP</span></span>     | <span data-ttu-id="f0769-430">0x01</span><span class="sxs-lookup"><span data-stu-id="f0769-430">0x01</span></span>  |
| <span data-ttu-id="f0769-431">IGMP</span><span class="sxs-lookup"><span data-stu-id="f0769-431">IGMP</span></span>     | <span data-ttu-id="f0769-432">0x02</span><span class="sxs-lookup"><span data-stu-id="f0769-432">0x02</span></span>  |
| <span data-ttu-id="f0769-433">TCP</span><span class="sxs-lookup"><span data-stu-id="f0769-433">TCP</span></span>      | <span data-ttu-id="f0769-434">0X06</span><span class="sxs-lookup"><span data-stu-id="f0769-434">0X06</span></span>  |
| <span data-ttu-id="f0769-435">UDP</span><span class="sxs-lookup"><span data-stu-id="f0769-435">UDP</span></span>      | <span data-ttu-id="f0769-436">0X11</span><span class="sxs-lookup"><span data-stu-id="f0769-436">0X11</span></span>  |
|          |       |


<span data-ttu-id="f0769-437">***16비트 체크섬*** 이 필드에는 IP 헤더만 포함하는 16비트 체크섬이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-437">***16-bit checksum*** This field contains the 16-bit checksum that covers the IP header only.</span></span> <span data-ttu-id="f0769-438">IP 페이로드를 포함하는 상위 수준 프로토콜에는 추가 체크섬이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-438">There are additional checksums in the higher level protocols that cover the IP payload.</span></span>

<span data-ttu-id="f0769-439">***32비트 원본 IP 주소*** 이 필드는 항상 호스트 주소이고 송신자의 IP 주소를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-439">***32-bit source IP address*** This field contains the IP address of the sender and is always a host address.</span></span>

<span data-ttu-id="f0769-440">***32비트 대상 IP 주소*** 이 필드는 주소가 브로드캐스트 또는 멀티캐스트 주소인 경우 수신자 또는 수신자의 IP 주소를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-440">***32-bit destination IP address*** This field contains the IP address of the receiver or receivers if the address is a broadcast or multicast address.</span></span>

### <a name="creating-ip-instances"></a><span data-ttu-id="f0769-441">IP 인스턴스 만들기</span><span class="sxs-lookup"><span data-stu-id="f0769-441">Creating IP Instances</span></span>

<span data-ttu-id="f0769-442">IP 인스턴스는 초기화 중에 또는 애플리케이션 스레드에서 런타임 중에 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-442">IP instances are created either during initialization or during runtime by application threads.</span></span> <span data-ttu-id="f0769-443">내부 IP 스레드의 초기 IP 주소, 네트워크 마스크, 기본 패킷 풀, 미디어 드라이버, 메모리 및 우선 순위는 *nx_ip_create* 서비스에 의해 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-443">The initial IP address, network mask, default packet pool, media driver, and memory and priority of the internal IP thread are defined by the *nx_ip_create* service.</span></span> <span data-ttu-id="f0769-444">애플리케이션에서 IP 주소를 잘못된 주소(0.0.0.0)로 설정한 IP 인스턴스를 초기화하는 경우 인터페이스 주소는 나중에 RARP를 통한 수동 구성이나 DHCP 또는 유사한 프로토콜을 통해 해결하는 것으로 간주합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-444">If the application initializes the IP instance with its IP address set to an invalid address(0.0.0.0), it is assumed that the interface address is going to resolved by manual configuration later, via RARP, or through DHCP or similar protocols.</span></span>

<span data-ttu-id="f0769-445">여러 네트워크 인터페이스가 있는 시스템의 경우 기본 인터페이스는 *nx_ip_create* 를 호출할 때 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-445">For systems with multiple network interfaces, the primary interface is designated when calling *nx_ip_create*.</span></span> <span data-ttu-id="f0769-446">각 추가 인터페이스는 nx_ip_interface_attach를 호출하여 동일한 IP 인스턴스에 연결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-446">Each additional interface can be attached to the same IP instance by calling *nx_ip_interface_attach*.</span></span> <span data-ttu-id="f0769-447">이 서비스는 네트워크 인터페이스(예: IP 주소, 네트워크 마스크)에 대한 정보를 인터페이스 제어 블록에 저장하고 드라이버 인스턴스를 IP 인스턴스의 인터페이스 제어 블록과 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-447">This service stores information about the network interface (such as IP address, network mask) in the interface control block, and associates the driver instance with the interface control block in the IP instance.</span></span> <span data-ttu-id="f0769-448">드라이버는 데이터 패킷을 수신할 때 인터페이스 정보를 IP 수신 논리로 전달하기 전에 NX_PACKET 구조에 저장해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-448">As the driver receives a data packet, it needs to store the interface information in the NX_PACKET structure before forwarding it to the IP receive logic.</span></span> <span data-ttu-id="f0769-449">인터페이스를 연결하기 전에 IP 인스턴스를 이미 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-449">Note an IP instance must already be created before attaching any interfaces.</span></span>

 ### <a name="ip-send"></a><span data-ttu-id="f0769-450">IP 전송</span><span class="sxs-lookup"><span data-stu-id="f0769-450">IP Send</span></span>
 <span data-ttu-id="f0769-451">NetX의 IP 전송 처리는 매우 간소화되었습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-451">The IP send processing in NetX is very streamlined.</span></span>

<span data-ttu-id="f0769-452">패킷의 앞에 추가 포인터는 IP 헤더에 맞게 뒤로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-452">The prepend pointer in the packet is moved backwards to accommodate the IP header.</span></span> <span data-ttu-id="f0769-453">IP 헤더가 완료되고(호출 프로토콜 계층에서 지정한 모든 옵션 포함), IP 체크섬이 인라인으로 계산되며, 패킷이 연결된 네트워크 드라이버로 디스패치됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-453">The IP header is completed (with all the options specified by the calling protocol layer), the IP checksum is computed in-line, and the packet is dispatched to the associated network driver.</span></span> <span data-ttu-id="f0769-454">또한 나가는 조각화도 IP 전송 처리 내에서 조정됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-454">In addition, outgoing fragmentation is also coordinated from within the IP send processing.</span></span>

<span data-ttu-id="f0769-455">IP의 경우 NetX는 대상 IP 주소에 대한 실제 매핑이 필요한 경우 ARP 요청을 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-455">For IP, NetX initiates ARP requests if physical mapping is needed for the destination IP address.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="f0769-456">IP 연결의 경우 큐에 있는 패킷 수가 ARP 큐 깊이(기호에서 정의됨)를 초과할 때까지 IP 주소 확인(예: 실제 매핑)이 필요한 패킷이 ARP 큐에 배치됩니다. 큐 깊이에 도달하면 NetX가 큐에서 가장 오래된 패킷을 제거하고 대기 중인 나머지 패킷에 대한 주소 확인을 계속 기다립니다. 반면 ARP 항목이 확인되지 않으면 ARP 항목에서 보류 중인 패킷은 ARP 항목 시간 초과 시 해제됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-456">*For IP connectivity, packets that require IP address resolution (i.e., physical mapping) are enqueued on the ARP queue until the number of packets queued exceeds the ARP queue depth (defined by the* *symbol **NX_ARP_MAX_QUEUE_DEPTH**). If the* *queue depth is reached, NetX will remove the oldest packet on the queue and continue waiting for address resolution for the remaining packets enqueued. On the other hand, if an ARP entry is not resolved, the pending packets on the ARP entry are released upon ARP entry timeout.*</span></span>

<span data-ttu-id="f0769-457">여러 네트워크 인터페이스를 포함하는 시스템의 경우 NetX는 대상 IP 주소를 기반으로 인터페이스를 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-457">For systems with multiple network interfaces, NetX chooses an interface based on the destination IP address.</span></span> <span data-ttu-id="f0769-458">선택 프로세스에 적용되는 프로시저는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-458">The following procedure applies to the selection process:</span></span>

1. <span data-ttu-id="f0769-459">대상 주소가 IP 브로드캐스트 또는 멀티캐스트인 경우 유효한 나가는 인터페이스가 지정된 경우 해당 인터페이스를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-459">If a destination address is IP broadcast or multicast, and if a valid outgoing interface is specified, use that interface.</span></span> <span data-ttu-id="f0769-460">그러지 않으면 첫 번째 실제 인터페이스가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-460">Otherwise, the first physical interface is used.</span></span>

2. <span data-ttu-id="f0769-461">대상 주소가 고정 라우팅 테이블에 있는 경우 게이트웨이와 연결된 인터페이스가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-461">If the destination address is found in the static routing table, the interface associated with the gateway is used.</span></span>

3. <span data-ttu-id="f0769-462">대상이 온-링크인 경우 온-링크 인터페이스가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-462">If the destination is on-link, the on-link interface is used.</span></span>

4. <span data-ttu-id="f0769-463">대상 주소가 루프백 주소인 127.0.0.1인 경우 루프백 인터페이스가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-463">If the destination address is a loopback address 127.0.0.1, the loopback interface is used.</span></span>

5. <span data-ttu-id="f0769-464">기본 게이트웨이가 적절히 구성된 경우 기본 게이트웨이와 연결된 인터페이스를 사용하여 패킷을 전송합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-464">If the default gateway is properly configured, use the interface associated with the default gateway to transmit the packet.</span></span>

6. <span data-ttu-id="f0769-465">위의 모든 작업이 실패하면 출력 패킷이 삭제됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-465">The output packet is dropped if all the above fails.</span></span>

### <a name="ip-receive"></a><span data-ttu-id="f0769-466">IP 수신</span><span class="sxs-lookup"><span data-stu-id="f0769-466">IP Receive</span></span>

<span data-ttu-id="f0769-467">IP 수신 처리는 지연된 수신 패킷 큐에서 패킷을 처리하기 위해 네트워크 드라이버 또는 내부 IP 스레드에서 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-467">The IP receive processing is either called from the network driver or the internal IP thread (for processing packets on the deferred received packet queue).</span></span> <span data-ttu-id="f0769-468">IP 수신 처리는 프로토콜 필드를 검사하고 올바른 프로토콜 구성 요소에 대한 패킷의 디스패치를 시도합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-468">The IP receive processing examines the protocol field and attempts to dispatch the packet to the proper protocol component.</span></span> <span data-ttu-id="f0769-469">패킷이 실제로 디스패치 되기 전에 IP 헤더를 지나서 앞에 추가 포인터를 이동하면 IP 헤더가 제거됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-469">Before the packet is actually dispatched, the IP header is removed by advancing the prepend pointer past the IP header.</span></span>

<span data-ttu-id="f0769-470">또한 IP 수신 처리는 조각난 IP 패킷을 감지하고 조각화를 사용하는 경우 조각난 패킷 리어셈블에 필요한 단계를 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-470">IP receive processing also detects fragmented IP packets and performs the necessary steps to reassemble them if fragmentation is enabled.</span></span> <span data-ttu-id="f0769-471">조각화가 필요하지만 사용하도록 설정되지 않은 경우 패킷이 삭제됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-471">If fragmentation is needed but not enabled, the packet is dropped.</span></span>

<span data-ttu-id="f0769-472">NetX는 패킷에 지정된 인터페이스에 따라 적절한 네트워크 인터페이스를 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-472">NetX determines the appropriate network interface based on the interface specified in the packet.</span></span> <span data-ttu-id="f0769-473">패킷 인터페이스가 NULL이면 NetX는 기본 인터페이스로 기본 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-473">If the packet interface is NULL, NetX defaults to the primary interface.</span></span> <span data-ttu-id="f0769-474">이는 레거시 NetX 이더넷 드라이버와의 호환성을 보장하기 위해 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-474">This is done to guarantee compatibility with legacy NetX Ethernet drivers.</span></span>

### <a name="raw-ip-send"></a><span data-ttu-id="f0769-475">원시 IP 전송</span><span class="sxs-lookup"><span data-stu-id="f0769-475">Raw IP Send</span></span>

<span data-ttu-id="f0769-476">원시 IP 패킷은 NetX에서 직접 지원하고 처리하지 않는 상위 계층 프로토콜 페이로드를 포함하는 IP 프레임입니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-476">A raw IP packet is an IP frame that contains upper layer protocol payload not directly supported (and processed) by NetX.</span></span> <span data-ttu-id="f0769-477">원시 패킷을 통해 개발자는 자신의 IP 기반 애플리케이션을 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-477">A raw packet allows developers to define their own IP-based applications.</span></span> <span data-ttu-id="f0769-478">__nx_ip_raw_packet_enabled__ 서비스에서 원시 IP 패킷 처리를 사용하도록 설정한 경우 애플리케이션은 \***nx_ip_raw_packet_send** _ 서비스를 사용하여 원시 IP 패킷을 직접 전송할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-478">An application may send raw IP packets directly using the ***nx_ip_raw_packet_send** _ service if raw IP packet processing has been enabled with the _*_nx_ip_raw_packet_enabled_\*_ service.</span></span> <span data-ttu-id="f0769-479">그러나 대상 주소가 멀티캐스트 또는 브로드캐스트 주소인 경우 NetX는 첫 번째 기본 인터페이스로 기본 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-479">If the destination address is a multicast or broadcast address, however, NetX defaults to the first (primary) interface.</span></span> <span data-ttu-id="f0769-480">따라서 보조 인터페이스에서 이러한 패킷을 전송하려면 애플리케이션이 _ _nx_ip_raw_packet_interface_send_\* 서비스를 사용하여 나가는 패킷에 사용할 원본 주소를 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-480">Therefore, to send such packets out on secondary interfaces, the application must use the _ *_nx_ip_raw_packet_interface_send_*\* service to specify the source address to use for the outgoing packet.</span></span>

### <a name="raw-ip-receive"></a><span data-ttu-id="f0769-481">원시 IP 수신</span><span class="sxs-lookup"><span data-stu-id="f0769-481">Raw IP Receive</span></span>

<span data-ttu-id="f0769-482">원시 IP 패킷 처리를 사용하는 경우 애플리케이션은 \***nx_ip_raw_packet_receive** _ 서비스를 통해 원시 IP 패킷을 받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-482">If raw IP packet processing is enabled, the application may receive raw IP packets through the \***nx_ip_raw_packet_receive** _ service.</span></span> <span data-ttu-id="f0769-483">들어오는 모든 패킷은 IP 헤더에 지정된 프로토콜에 따라 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-483">All incoming packets are processed according to the protocol specified in the IP header.</span></span> <span data-ttu-id="f0769-484">프로토콜이 UDP, TCP, IGMP 또는 ICMP를 지정하는 경우 NetX는 패킷 프로토콜 유형에 적절한 처리기를 사용하여 패킷을 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-484">If the protocol specifies UDP, TCP, IGMP or ICMP, NetX will process the packet using the appropriate handler for the packet protocol type.</span></span> <span data-ttu-id="f0769-485">프로토콜이 이러한 프로토콜 중 하나가 아니고 원시 IP 수신을 사용하도록 설정한 경우 들어오는 패킷은 원시 패킷 큐에 추가되어 애플리케이션이 _ *_nx_ip_raw_packet_receive_*\* 서비스를 통해 수신할 수 있을 때까지 대기합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-485">If the protocol is not one of these protocols, and raw IP receive is enabled, the incoming packet will be put into the raw packet queue waiting for the application to receive it via the _ *_nx_ip_raw_packet_receive_*\* service.</span></span> <span data-ttu-id="f0769-486">또한 애플리케이션 스레드는 원시 IP 패킷을 기다리는 동안 선택적 시간 제한으로 일시 중단될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-486">In addition, application threads may suspend with an optional timeout while waiting for a raw IP packet.</span></span>

### <a name="default-packet-pool"></a><span data-ttu-id="f0769-487">기본 패킷 크기</span><span class="sxs-lookup"><span data-stu-id="f0769-487">Default Packet Pool</span></span>

<span data-ttu-id="f0769-488">각 IP 인스턴스에는 생성 중에 기본 패킷 풀이 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-488">Each IP instance is given a default packet pool during creation.</span></span> <span data-ttu-id="f0769-489">이 패킷 풀은 ARP, RARP, ICMP, IGMP, 다양한 TCP 제어 패킷(예: SYN, ACK)에 대해 패킷을 할당하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-489">This packet pool is used to allocate packets for ARP, RARP, ICMP, IGMP, various TCP control packets (such as SYN, ACK).</span></span> <span data-ttu-id="f0769-490">NetX에서 패킷을 할당해야 할 때 기본 패킷 풀이 비어 있으면 NetX가 특정 작업을 중단해야 할 수 있으며 가능한 경우 오류 메시지를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-490">If the default packet pool is empty when NetX needs to allocate a packet, NetX may have to abort the particular operation, and will return an error message if possible.</span></span>

### <a name="ip-helper-thread"></a><span data-ttu-id="f0769-491">IP 도우미 스레드</span><span class="sxs-lookup"><span data-stu-id="f0769-491">IP Helper Thread</span></span>

<span data-ttu-id="f0769-492">각 IP 인스턴스에는 도우미 스레드가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-492">Each IP instance has a helper thread.</span></span> <span data-ttu-id="f0769-493">이 스레드는 모든 지연된 패킷 처리 및 모든 정기적 처리를 담당합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-493">This thread is responsible for handling all deferred packet processing and all periodic processing.</span></span> <span data-ttu-id="f0769-494">IP 도우미 스레드는 ***nx_ip_create*** 에서 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-494">The IP helper thread is created in ***nx_ip_create.***</span></span> <span data-ttu-id="f0769-495">여기서 스레드에 스택 및 우선 순위가 부여됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-495">This is where the thread is given its stack and priority.</span></span> <span data-ttu-id="f0769-496">IP 도우미 스레드의 첫 번째 처리 작업은 IP 만들기 서비스와 연결된 네트워크 드라이버 초기화를 완료하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-496">Note that the first processing in the IP helper thread is to finish the network driver initialization associated with the IP create service.</span></span> <span data-ttu-id="f0769-497">네트워크 드라이버 초기화가 완료되면 도우미 스레드는 패킷 및 정기적 요청을 처리하기 위해 무한 루프를 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-497">After the network driver initialization is complete, the helper thread starts an endless loop to process packet and periodic requests.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="f0769-498">IP 도우미 스레드에서 설명할 수 없는 동작이 나타나는 경우, IP 만들기 서비스 중에 스택 크기를 늘리는 것이 첫 번째 디버깅 단계입니다. 스택이 너무 작으면 IP 도우미 스레드가 메모리를 덮어쓸 수 있으며 이로 인해 비정상적인 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-498">*If unexplained behavior is seen within the IP helper thread, increasing its stack size during the IP create service is the first debugging step. If the stack is too small, the IP helper thread could possibly be overwriting memory, which may cause unusual problems.*</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="f0769-499">스레드 일시 중단</span><span class="sxs-lookup"><span data-stu-id="f0769-499">Thread Suspension</span></span>

<span data-ttu-id="f0769-500">애플리케이션 스레드는 원시 IP 패킷을 수신하는 동안 일시 중단될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-500">Application threads can suspend while attempting to receive raw IP packets.</span></span> <span data-ttu-id="f0769-501">원시 패킷이 수신되면 새 패킷이 일시 중단된 첫 번째 스레드에 제공되고 해당 스레드가 다시 시작됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-501">After a raw packet is received, the new packet is given to the first thread suspended and that thread is resumed.</span></span> <span data-ttu-id="f0769-502">패킷을 수신하는 NetX 서비스에는 모두 선택적 일시 중단 시간 제한이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-502">NetX services for receiving packets all have an optional suspension timeout.</span></span> <span data-ttu-id="f0769-503">패킷을 수신하거나 시간 제한이 만료되면 애플리케이션 스레드가 적절한 완료 상태로 다시 시작됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-503">When a packet is received or the timeout expires, the application thread is resumed with the appropriate completion status.</span></span>

### <a name="ip-statistics-and-errors"></a><span data-ttu-id="f0769-504">IP 통계 및 오류</span><span class="sxs-lookup"><span data-stu-id="f0769-504">IP Statistics and Errors</span></span>

<span data-ttu-id="f0769-505">사용하도록 설정된 경우 NetX는 애플리케이션에 유용할 수 있는 몇 가지 통계 및 오류를 추적합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-505">If enabled, the NetX keeps track of several statistics and errors that may be useful to the application.</span></span> <span data-ttu-id="f0769-506">각 IP 인스턴스에 대해 다음 통계 및 오류 보고서가 유지 관리됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-506">The following statistics and error reports are maintained for each IP instance:</span></span>

- <span data-ttu-id="f0769-507">전송된 총 IP 패킷</span><span class="sxs-lookup"><span data-stu-id="f0769-507">Total IP Packets Sent</span></span>
- <span data-ttu-id="f0769-508">전송된 총 IP 바이트</span><span class="sxs-lookup"><span data-stu-id="f0769-508">Total IP Bytes Sent</span></span>
- <span data-ttu-id="f0769-509">수신된 총 IP 패킷</span><span class="sxs-lookup"><span data-stu-id="f0769-509">Total IP Packets Received</span></span>
- <span data-ttu-id="f0769-510">수신된 총 IP 바이트</span><span class="sxs-lookup"><span data-stu-id="f0769-510">Total IP Bytes Received</span></span>
- <span data-ttu-id="f0769-511">총 IP 잘못된 패킷</span><span class="sxs-lookup"><span data-stu-id="f0769-511">Total IP Invalid Packets</span></span>
- <span data-ttu-id="f0769-512">삭제된 총 IP 수신 패킷</span><span class="sxs-lookup"><span data-stu-id="f0769-512">Total IP Receive Packets Dropped</span></span>
- <span data-ttu-id="f0769-513">총 IP 수신 체크섬 오류</span><span class="sxs-lookup"><span data-stu-id="f0769-513">Total IP Receive Checksum Errors</span></span>
- <span data-ttu-id="f0769-514">삭제된 총 IP 전송 패킷</span><span class="sxs-lookup"><span data-stu-id="f0769-514">Total IP Send Packets Dropped</span></span>
- <span data-ttu-id="f0769-515">전송된 총 IP 조각</span><span class="sxs-lookup"><span data-stu-id="f0769-515">Total IP Fragments Sent</span></span>
- <span data-ttu-id="f0769-516">수신된 총 IP 조각</span><span class="sxs-lookup"><span data-stu-id="f0769-516">Total IP Fragments Received</span></span>

<span data-ttu-id="f0769-517">이러한 모든 통계 및 오류 보고서는 ***nx_ip_info_get*** 서비스를 사용하여 애플리케이션에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-517">All of these statistics and error reports are available to the application with the ***nx_ip_info_get*** service.</span></span>

### <a name="ip-control-block-nx_ip"></a><span data-ttu-id="f0769-518">IP 제어 블록 NX_IP</span><span class="sxs-lookup"><span data-stu-id="f0769-518">IP Control Block NX_IP</span></span>

<span data-ttu-id="f0769-519">각 IP 인스턴스의 특성은 해당 제어 블록에서 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-519">The characteristics of each IP instance are found in its control block.</span></span> <span data-ttu-id="f0769-520">각 네트워크 디바이스의 IP 주소 및 네트워크 마스크, 인접 IP 및 실제 하드웨어 주소 매핑 표와 같은 유용한 정보를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-520">It contains useful information such as the IP addresses and network masks of each network device, and a table of neighbor IP and physical hardware address mapping.</span></span> <span data-ttu-id="f0769-521">이 구조는 ***nx_api.h*** 에 정의됩니다. IP 인스턴스 제어 블록은 메모리의 어디에나 위치할 수 있지만 제어 블록을 모든 함수의 범위 밖에 정의하여 전역 구조로 만드는 것이 가장 일반적입니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-521">This structure is defined in the ***nx_api.h*** IP instance control blocks can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="static-ip-routing"></a><span data-ttu-id="f0769-522">고정 IP 라우팅</span><span class="sxs-lookup"><span data-stu-id="f0769-522">Static IP Routing</span></span>

<span data-ttu-id="f0769-523">고정 라우팅 기능을 사용하면 애플리케이션에서 특정 네트워크 외부 대상 IP 주소에 대해 IP 네트워크 및 다음 홉 주소를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-523">The static routing feature allows an application to specify an IP network and next hop address for specific out of network destination IP addresses.</span></span> <span data-ttu-id="f0769-524">고정 라우팅을 사용하도록 설정한 경우 NetX는 고정 라우팅 테이블을 통해 전송할 패킷의 대상 주소와 일치하는 항목을 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-524">If static routing is enabled, NetX searches through the static routing table for an entry matching the destination address of the packet to send.</span></span> <span data-ttu-id="f0769-525">일치하는 항목이 없으면 NetX는 실제 인터페이스 목록을 검색하여 대상 IP 주소와 네트워크 마스크를 기반으로 소스 IP 주소와 다음 홉 주소를 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-525">If no match is found, NetX searches through the list of physical interfaces and chooses a source IP address and next hop address based on the destination IP address and the network mask.</span></span> <span data-ttu-id="f0769-526">대상이 IP 인스턴스에 연결된 네트워크 드라이버의 IP 주소와 일치하지 않으면 NetX는 기본 게이트웨이에 직접 연결된 인터페이스를 선택하고 인터페이스의 IP 주소를 소스 주소로 사용하고 기본 게이트웨이를 다음 홉으로 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-526">If the destination does not match any of the IP addresses of the network drivers attached to the IP instance, NetX chooses an interface that is directly connected to the default gateway, and uses the IP address of the interface as source address, and the default gateway as the next hop.</span></span>

<span data-ttu-id="f0769-527">각각 ***nx_ip_static_route_add*** 및 \***nx_ip_static_route_delete** _ 서비스를 사용하여 고정 라우팅 테이블에서 항목을 추가하고 제거할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-527">Entries can be added and removed from the static routing table using the ***nx_ip_static_route_add*** and \***nx_ip_static_route_delete** _ services, respectively.</span></span> <span data-ttu-id="f0769-528">고정 라우팅을 사용하려면 호스트 애플리케이션이 \*_NX_ENABLE_IP_STATIC_ROUTING_\*\*을 정의하여 이 기능을 사용하도록 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-528">To use static routing, the host application must enable this feature by defining _ *_NX_ENABLE_IP_STATIC_ROUTING_*.\*</span></span>

> [!IMPORTANT]
> <span data-ttu-id="f0769-529">고정 라우팅 테이블에 항목을 추가하는 경우 NetX는 테이블에 이미 있는 지정된 대상 주소와 일치하는 항목을 확인합니다. 항목이 있는 경우 네트워크 마스크에서 더 작은 네트워크(더 긴 접두사)가 있는 항목을 선호합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-529">*When adding an entry to the static routing table, NetX checks for a matching entry for the specified destination address already in the table. If one exists, it gives preference to the entry with the smaller network (longer prefix) in the network mask.*</span></span>

### <a name="ip-fragmentation"></a><span data-ttu-id="f0769-530">IP 조각화</span><span class="sxs-lookup"><span data-stu-id="f0769-530">IP Fragmentation</span></span>

<span data-ttu-id="f0769-531">네트워크 디바이스에는 나가는 패킷의 크기가 제한될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-531">The network device may have limits on the size of outgoing packets.</span></span> <span data-ttu-id="f0769-532">이 제한을 MTU(최대 전송 단위)라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-532">This limit is called the maximum transmission unit (MTU).</span></span> <span data-ttu-id="f0769-533">IP MTU는 링크 계층 드라이버가 IP 패킷을 조각화 하지 않고 전송할 수 있는 가장 큰 IP 프레임 크기입니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-533">IP MTU is the largest IP frame size a link layer driver is able to transmit without fragmenting the IP packet.</span></span> <span data-ttu-id="f0769-534">디바이스 드라이버 초기화 단계에서 드라이버 모듈은 ***nx_ip_interface_mtu_set*** 서비스를 통해 IP MTU 크기를 구성해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-534">During a device driver initialization phase, the driver module must configure its IP MTU size via the service \***nx_ip_interface_mtu_set**.\*</span></span>

<span data-ttu-id="f0769-535">권장하지는 않지만 애플리케이션은 디바이스에서 지원되는 기본 IP MTU보다 큰 데이터그램을 생성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-535">Although not recommended, the application may generate datagrams larger than the underlying IP MTU supported by the device.</span></span> <span data-ttu-id="f0769-536">이와 같은 IP 데이터그램을 전송하기 전에 IP 계층은 이러한 패킷을 분할해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-536">Before transmitting such IP datagram, the IP layer must fragment these packets.</span></span> <span data-ttu-id="f0769-537">조각난 IP 프레임을 수신하는 경우, 수신 끝은 조각난 모든 IP 프레임을 동일한 조각화 ID로 저장하고 순서대로 리어셈블해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-537">On receiving fragmented IP frames, the receiving end must store all fragmented IP frames with the same fragmentation ID, and reassemble them in order.</span></span> <span data-ttu-id="f0769-538">IP 수신 논리가 모든 조각을 수집하여 원래 IP 프레임을 제때 복원할 수 없는 경우 모든 조각이 해제됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-538">If the IP receive logic is unable to collect all the fragments to restore the original IP frame in time, all the fragments are released.</span></span> <span data-ttu-id="f0769-539">이러한 패킷 손실을 감지하고 그로부터 복구하는 것은 상위 계층 프로토콜의 역할입니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-539">It is up to the upper layer protocol to detect such packet loss and recover from it.</span></span>

<span data-ttu-id="f0769-540">IP 조각화 및 리어셈블리 작업을 지원하기 위해 시스템 디자이너는 ***nx_ip_fragment_enable*** 서비스를 사용하여 NetX에서 IP 조각화 기능을 사용하도록 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-540">In order to support IP fragmentation and reassembly operation, the system designer must enable the IP fragmentation feature in NetX using the ***nx_ip_fragment_enable*** service.</span></span> <span data-ttu-id="f0769-541">이 기능을 사용하도록 설정하지 않으면 네트워크 드라이버의 MTU를 초과하는 패킷뿐만 아니라 들어오는 조각난 IP 패킷도 삭제됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-541">If this feature is not enabled, incoming fragmented IP packets are discarded, as well as packets that exceed the network driver's MTU.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="f0769-542">\ \**NetX 라이브러리를 빌드할 때 **NX_DISABLE_FRAGMENTATION** 을 정의하여 IP 조각화 논리를 완전히 제거할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-542">*The IP Fragmentation logic can be removed completely by defining* \***NX_DISABLE_FRAGMENTATION** _ _when building theNetX library.</span></span> <span data-ttu-id="f0769-543">이렇게 하면 NetX의 코드 크기를 줄일 수 있습니다.\*</span><span class="sxs-lookup"><span data-stu-id="f0769-543">Doing so helps reduce the code size of NetX.\*</span></span>

## <a name="address-resolution-protocol-arp-in-ip"></a><span data-ttu-id="f0769-544">IP의 ARP(주소 확인 프로토콜)</span><span class="sxs-lookup"><span data-stu-id="f0769-544">Address Resolution Protocol (ARP) in IP</span></span>

<span data-ttu-id="f0769-545">ARP(주소 확인 프로토콜)는 32비트 IP 주소를 기본 실제 미디어(RFC 826)의 주소에 동적으로 매핑하는 역할을 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-545">The Address Resolution Protocol (ARP) is responsible for dynamically mapping 32-bit IP addresses to those of the underlying physical media (RFC 826).</span></span> <span data-ttu-id="f0769-546">이더넷은 가장 일반적인 실제 미디어이며 48비트 주소를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-546">Ethernet is the most typical physical media, and it supports 48-bit addresses.</span></span> <span data-ttu-id="f0769-547">ARP의 필요성은 ***nx_ip_create*** 서비스에 제공된 네트워크 드라이버에 의해 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-547">The need for ARP is determined by the network driver supplied to the ***nx_ip_create*** service.</span></span> <span data-ttu-id="f0769-548">물리적 매핑이 필요한 경우 네트워크 드라이버는 인터페이스 구조에서 플래그 ***nx_interface_address_mapping_needed*** 를 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-548">If physical mapping is required, the network driver must set the flag ***nx_interface_address_mapping_needed*** in the interface strcuture.</span></span>

### <a name="arp-enable"></a><span data-ttu-id="f0769-549">ARP 사용</span><span class="sxs-lookup"><span data-stu-id="f0769-549">ARP Enable</span></span>
<span data-ttu-id="f0769-550">ARP가 제대로 작동하려면 먼저 애플리케이션이 ***nx_arp_enable*** 서비스를 사용하도록 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-550">For ARP to function properly, it must first be enabled by the application with the ***nx_arp_enable*** service.</span></span> <span data-ttu-id="f0769-551">이 서비스는 ARP 사용 서비스에 제공된 메모리에서 ARP 캐시 영역을 만드는 등 ARP 처리를 위한 다양한 데이터 구조를 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-551">This service sets up various data structures for ARP processing, including the creation of an ARP cache area from the memory supplied to the ARP enable service.</span></span>

### <a name="arp-cache"></a><span data-ttu-id="f0769-552">ARP 캐시</span><span class="sxs-lookup"><span data-stu-id="f0769-552">ARP Cache</span></span>
<span data-ttu-id="f0769-553">ARP 캐시는 내부 ARP 매핑 데이터 구조의 배열로 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-553">The ARP cache can be viewed as an array of internal ARP mapping data structures.</span></span> <span data-ttu-id="f0769-554">각 내부 구조는 IP 주소와 실제 하드웨어 주소 간의 관계를 유지 관리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-554">Each internal structure is capable of maintaining the relationship between an IP address and a physical hardware address.</span></span> <span data-ttu-id="f0769-555">또한 각 데이터 구조에는 링크 포인터가 있어 여러 연결된 목록에 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-555">In addition, each data structure has link pointers so it can be part of multiple linked lists.</span></span>

<span data-ttu-id="f0769-556">매핑이 ARP 테이블에 있는 경우 애플리케이션은 \***nx_arp_ip_address_find** _ 서비스를 사용하여 하드웨어 MAC 주소를 제공하는 방법으로 ARP 캐시에서 IP 주소를 조회할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-556">Application can look up an IP address from the ARP cache by supplying hardware MAC address using the service \***nx_arp_ip_address_find** _ if the mapping exists in the ARP table.</span></span> <span data-ttu-id="f0769-557">마찬가지로 _ _nx_arp_hardware_address_find_\* 서비스는 지정된 IP 주소에 대한 MAC 주소를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-557">Similarly, the service _ *_nx_arp_hardware_address_find_*\* returns the MAC address for a given IP address.</span></span>


### <a name="arp-dynamic-entries"></a><span data-ttu-id="f0769-558">ARP 동적 항목</span><span class="sxs-lookup"><span data-stu-id="f0769-558">ARP Dynamic Entries</span></span>

<span data-ttu-id="f0769-559">기본적으로 ARP 사용 서비스는 ARP 캐시의 모든 항목을 사용 가능한 동적 ARP 항목 목록에 배치합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-559">By default, the ARP enable service places all entries in the ARP cache on the list of available dynamic ARP entries.</span></span> <span data-ttu-id="f0769-560">매핑되지 않은 IP 주소에 대한 전송 요청이 감지되면 이 목록에서 NetX가 동적 ARP 항목을 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-560">A dynamic ARP entry is allocated from this list by NetX when a send request to an unmapped IP address is detected.</span></span> <span data-ttu-id="f0769-561">할당 후 ARP 항목이 설정되고 실제 미디어로 ARP 요청이 전송됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-561">After allocation, the ARP entry is set up and an ARP request is sent to the physical media.</span></span>

<span data-ttu-id="f0769-562">***nx_arp_dynamic_entry_set*** 서비스에서 동적 항목을 만들 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-562">A dynamic entry can also be created by the service ***nx_arp_dynamic_entry_set***.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="f0769-563">모든 동적 ARP 항목이 사용 중인 경우 오래 전에 사용한 ARP 항목이 새 매핑으로 바뀝니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-563">*If all dynamic ARP entries are in use, the least recently used ARP entry is replaced with a new mapping.*</span></span>

### <a name="arp-static-entries"></a><span data-ttu-id="f0769-564">ARP 고정 항목</span><span class="sxs-lookup"><span data-stu-id="f0769-564">ARP Static Entries</span></span>
<span data-ttu-id="f0769-565">또한 애플리케이션은 ***nx_arp_static_entry_create*** 서비스를 사용하여 고정 ARP 매핑을 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-565">The application can also set up static ARP mapping by using the ***nx_arp_static_entry_create*** service.</span></span> <span data-ttu-id="f0769-566">이 서비스는 동적 ARP 항목 목록에서 ARP 항목을 할당하고 애플리케이션에서 제공하는 매핑 정보와 함께 고정 목록에 배치합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-566">This service allocates an ARP entry from the dynamic ARP entry list and places it on the static list with the mapping information supplied by the application.</span></span> <span data-ttu-id="f0769-567">고정 ARP 항목에는 재사용 또는 에이징이 적용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-567">Static ARP entries are not subject to reuse or aging.</span></span> <span data-ttu-id="f0769-568">애플리케이션은 서비스 ***nx_arp_static_entry_delete*** 를 사용하여 고정 항목을 삭제할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-568">The application can delete a static entry by using the service ***nx_arp_static_entry_delete***.</span></span>
<span data-ttu-id="f0769-569">ARP 테이블의 모든 고정 항목을 제거하기 위해 애플리케이션은 ***nx_arp_static_entries_delete*** 서비스를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-569">To remove all static entries in the ARP table, the application may use the service ***nx_arp_static_entries_delete***.</span></span>

### <a name="automatic-arp-entry"></a><span data-ttu-id="f0769-570">자동 ARP 항목</span><span class="sxs-lookup"><span data-stu-id="f0769-570">Automatic ARP Entry</span></span>
<span data-ttu-id="f0769-571">NetX는 ARP 요청에 대한 피어 응답 후 피어의 IP/MAC 매핑을 기록합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-571">NetX records the peer's IP/MAC mapping after the peer responses to the ARP request.</span></span> <span data-ttu-id="f0769-572">NetX는 또한 네트워크에서 요청되지 않은 ARP 요청을 기반으로 피어 IP/MAC 주소 매핑을 기록하는 자동 ARP 항목 기능을 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-572">NetX also implements the automatic ARP entry feature where it records peer IP/MAC address mapping based on unsolicited ARP requests from the network.</span></span> <span data-ttu-id="f0769-573">이 기능을 사용하면 ARP 테이블을 피어 정보로 채울 수 있으므로 ARP 요청/응답 주기를 통과하는 데 필요한 지연을 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-573">This feature allows the ARP table to be populated with peer information, reducing the delay needed to go through the ARP request/response cycle.</span></span> <span data-ttu-id="f0769-574">그러나 자동 ARP를 사용하는 경우의 단점은 ARP 테이블이 로컬 링크에 많은 노드가 있는 사용량이 많은 네트워크에서 빠르게 채워지는 경향이 있고, 결국 이로 인해 ARP 항목을 대체하게 된다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-574">However the downside with enabling automatic ARP is that the ARP table tend to fill up quickly on a busy network with many nodes on the local link, which would eventually lead to ARP entry replacement.</span></span>

<span data-ttu-id="f0769-575">이 기능은 기본적으로 사용하도록 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-575">This feature is enabled by default.</span></span> <span data-ttu-id="f0769-576">이 기능을 사용하지 않으려면 정의된 ***NX_DISABLE_ARP_AUTO_ENTRY*** 기호를 사용하여 NetX 라이브러리를 컴파일해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-576">To disable it, the NetX library must be compiled with the symbol ***NX_DISABLE_ARP_AUTO_ENTRY*** defined.</span></span>

### <a name="arp-messages"></a><span data-ttu-id="f0769-577">ARP 메시지</span><span class="sxs-lookup"><span data-stu-id="f0769-577">ARP Messages</span></span>

<span data-ttu-id="f0769-578">앞에서 언급한 대로 IP 작업에서 IP 주소에 대한 매핑이 필요하다는 것을 감지하면 ARP 요청 메시지가 전송됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-578">As mentioned previously, an ARP request message is sent when the IP task detects that mapping is needed for an IP address.</span></span> <span data-ttu-id="f0769-579">ARP 요청은 해당 ARP 응답이 수신될 때까지 주기적으로(매 \***NX_ARP_UPDATE_RATE** _초마다) 전송됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-579">ARP requests are sent periodically (every \***NX_ARP_UPDATE_RATE** _ seconds) until a corresponding ARP response is received.</span></span> <span data-ttu-id="f0769-580">ARP 시도가 중단되기 전에 총 _ *_NX_ARP_MAXIMUM_RETRIES_*\* ARP 요청이 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-580">A total of _ *_NX_ARP_MAXIMUM_RETRIES_*\* ARP requests are made before the ARP attempt is abandoned.</span></span> <span data-ttu-id="f0769-581">ARP 응답이 수신되면 관련된 실제 주소 정보는 캐시에 있는 ARP 항목에 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-581">When an ARP response is received, the associated physical address information is stored in the ARP entry that is in the cache.</span></span>

<span data-ttu-id="f0769-582">멀티홈 시스템의 경우 NetX는 지정된 대상 주소에 따라 ARP 요청 및 응답을 보낼 인터페이스를 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-582">For multihome systems, NetX determines which interface to send the ARP requests and responses based on destination address specified.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="f0769-583">NetX가 ARP 응답을 대기하는 동안 나가는 IP 패킷은 큐에 대기합니다. 큐에 있는 나가는 IP 패킷 수는 상수 **NX_ARP_MAX_QUEUE_DEPTH** 에 의해 정의됩니다.  \*\*</span><span class="sxs-lookup"><span data-stu-id="f0769-583">*Outgoing IP packets are queued while NetX waits for the ARP response. The number of outgoing IP* *packets queued is defined by the constant* \***NX_ARP_MAX_QUEUE_DEPTH**.\*</span></span>

<span data-ttu-id="f0769-584">NetX는 로컬 IP 네트워크에 있는 다른 노드의 ARP 요청에도 응답합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-584">NetX also responds to ARP requests from other nodes on the local IP network.</span></span> <span data-ttu-id="f0769-585">ARP 요청을 수신하는 인터페이스의 현재 IP 주소와 일치하는 외부 ARP 요청이 이루어지면 NetX는 현재 실제 주소를 포함하는 ARP 응답 메시지를 작성합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-585">When an external ARP request is made that matches the current IP address of the interface that receives the ARP request, NetX builds an ARP response message that contains the current physical address.</span></span>

<span data-ttu-id="f0769-586">이더넷 ARP 요청 및 응답의 형식은 그림 6에 나타나 있으며 아래에 설명되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-586">The formats of Ethernet ARP requests and responses are shown in Figure 6 and are described below:</span></span>

| <span data-ttu-id="f0769-587">요청/응답 필드</span><span class="sxs-lookup"><span data-stu-id="f0769-587">Request/Response Field</span></span>       | <span data-ttu-id="f0769-588">용도</span><span class="sxs-lookup"><span data-stu-id="f0769-588">Purpose</span></span>    |
|------------------------------|-----------------|
| <span data-ttu-id="f0769-589">이더넷 대상 주소</span><span class="sxs-lookup"><span data-stu-id="f0769-589">Ethernet Destination Address</span></span> | <span data-ttu-id="f0769-590">이 6바이트 필드는 ARP 응답의 대상 주소를 포함하며 ARP 요청을 위한 브로드캐스트(모두 포함)입니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-590">This 6-byte field contains the destination address for the ARP response and is a broadcast (all ones) for ARP requests.</span></span> <span data-ttu-id="f0769-591">이 필드는 네트워크 드라이버에 의해 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-591">This field is setup by the network driver.</span></span> |
| <span data-ttu-id="f0769-592">이더넷 원본 주소</span><span class="sxs-lookup"><span data-stu-id="f0769-592">Ethernet Source Address</span></span>      | <span data-ttu-id="f0769-593">이 6바이트 필드는 ARP 요청 또는 응답의 송신자 주소를 포함하고 네트워크 드라이버에 의해 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-593">This 6-byte field contains the address of the sender of the ARP request or response and is set up by the network driver.</span></span> |
| <span data-ttu-id="f0769-594">프레임 유형</span><span class="sxs-lookup"><span data-stu-id="f0769-594">Frame Type</span></span>                   | <span data-ttu-id="f0769-595">이 2바이트 필드는 표시되는 이더넷 프레임 형식을 포함하며, ARP 요청 및 응답의 경우 이는 0x0806과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-595">This 2-byte field contains the type of Ethernet frame present and, for ARP requests and responses, this is equal to 0x0806.</span></span> <span data-ttu-id="f0769-596">네트워크 드라이버가 설정할 마지막 필드입니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-596">This is the last field the network driver is responsible for setting up.</span></span> |
| <span data-ttu-id="f0769-597">하드웨어 종류</span><span class="sxs-lookup"><span data-stu-id="f0769-597">Hardware Type</span></span>                | <span data-ttu-id="f0769-598">이 2바이트 필드에는 이더넷에 대해 0x0001인 하드웨어 형식이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-598">This 2-byte field contains the hardware type, which is 0x0001 for Ethernet.</span></span> |
| <span data-ttu-id="f0769-599">프로토콜 종류</span><span class="sxs-lookup"><span data-stu-id="f0769-599">Protocol Type</span></span>                | <span data-ttu-id="f0769-600">이 2바이트 필드에는 IP 주소에 대해 0x0800인 프로토콜 형식이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-600">This 2-byte field contains the protocol type, which is 0x0800 for IP addresses.</span></span> |
| <span data-ttu-id="f0769-601">하드웨어 크기</span><span class="sxs-lookup"><span data-stu-id="f0769-601">Hardware Size</span></span>                | <span data-ttu-id="f0769-602">이 1바이트 필드에는 이더넷 주소에 대해 6인 하드웨어 주소 크기가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-602">This 1-byte field contains the hardware address size, which is 6 for Ethernet addresses.</span></span> |


![ARP 패킷 형식](./media/user-guide/arp-packet-format.png)

<span data-ttu-id="f0769-604">**그림 6. ARP 패킷 형식**</span><span class="sxs-lookup"><span data-stu-id="f0769-604">**FIGURE 6. ARP Packet Format**</span></span>

| <span data-ttu-id="f0769-605">요청/응답 필드</span><span class="sxs-lookup"><span data-stu-id="f0769-605">Request/Response Field</span></span> | <span data-ttu-id="f0769-606">용도</span><span class="sxs-lookup"><span data-stu-id="f0769-606">Purpose</span></span>  |
|---|---|
| <span data-ttu-id="f0769-607">프로토콜 크기</span><span class="sxs-lookup"><span data-stu-id="f0769-607">Protocol Size</span></span> | <span data-ttu-id="f0769-608">이 1바이트 필드에는 IP 주소에 대해 4인 IP 주소 크기가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-608">This 1-byte field contains the IP address size, which is 4 for IP addresses.</span></span>  |
| <span data-ttu-id="f0769-609">작업 코드</span><span class="sxs-lookup"><span data-stu-id="f0769-609">Operation Code</span></span> | <span data-ttu-id="f0769-610">이 2바이트 필드에는 이 ARP 패킷에 대한 작업이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-610">This 2-byte field contains the operation for this ARP packet.</span></span> <span data-ttu-id="f0769-611">ARP 요청은 0x0001 값으로 지정되고, ARP 응답은 0x0002 값으로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-611">An ARP request is specified with the value of 0x0001, while an ARP response is represented by a value of 0x0002.</span></span>  |
| <span data-ttu-id="f0769-612">송신자 이더넷 주소</span><span class="sxs-lookup"><span data-stu-id="f0769-612">Sender Ethernet Address</span></span> | <span data-ttu-id="f0769-613">이 6바이트 필드에는 송신자의 이더넷 주소가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-613">This 6-byte field contains the sender's Ethernet address.</span></span> |
| <span data-ttu-id="f0769-614">송신자 IP 주소</span><span class="sxs-lookup"><span data-stu-id="f0769-614">Sender IP Address</span></span> | <span data-ttu-id="f0769-615">이 4바이트 필드에는 송신자의 IP 주소가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-615">This 4-byte field contains the sender's IP address.</span></span> |
| <span data-ttu-id="f0769-616">대상 이더넷 주소</span><span class="sxs-lookup"><span data-stu-id="f0769-616">Target Ethernet Address</span></span> | <span data-ttu-id="f0769-617">이 6바이트 필드에는 대상의 이더넷 주소가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-617">This 6-byte field contains the target's Ethernet address.</span></span> |
| <span data-ttu-id="f0769-618">대상 IP 주소</span><span class="sxs-lookup"><span data-stu-id="f0769-618">Target IP Address</span></span> | <span data-ttu-id="f0769-619">이 4바이트 필드에는 대상의 IP 주소가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-619">This 4-byte field contains the target's IP address.</span></span> |

> [!IMPORTANT]
> <span data-ttu-id="f0769-620">ARP 요청 및 응답은 이더넷 수준 패킷입니다. 다른 모든 TCP/IP 패킷은 IP 패킷 헤더에서 캡슐화됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-620">*ARP requests and responses are Ethernet-level packets. All other TCP/IP packets are encapsulated by an IP packet header.*</span></span>

> [!IMPORTANT]
> <span data-ttu-id="f0769-621">TCP/IP 구현의 모든 ARP 메시지는 Big Endian 형식이어야 합니다. 이 형식에서 단어의 가장 중요한 바이트는 가장 낮은 바이트 주소에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-621">*All ARP messages in the TCP/IP implementation are expected to be in big endian format. In this format, the most significant byte of the word resides at the lowest byte address.*</span></span>

### <a name="arp-aging"></a><span data-ttu-id="f0769-622">ARP 에이징</span><span class="sxs-lookup"><span data-stu-id="f0769-622">ARP Aging</span></span>

<span data-ttu-id="f0769-623">NetX는 자동 동적 ARP 항목 무효화를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-623">NetX supports automatic dynamic ARP entry invalidation.</span></span><span data-ttu-id="f0769-624">\ ***NX_ARP_EXPIRATION_RATE** 는 실제 매핑에 대해 설정된 IP 주소가 유효한 상태로 유지되는 시간(초)을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-624">\ ***NX_ARP_EXPIRATION_RATE** _specifies the number of seconds an established IP address to physical mapping stays valid.</span></span> <span data-ttu-id="f0769-625">만료 후 ARP 항목은 ARP 캐시에서 제거됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-625">After expiration, the ARP entry is removed from the ARP cache.</span></span> <span data-ttu-id="f0769-626">다음 번에 해당 IP 주소로 전송하려고 하면 새 ARP 요청이 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-626">The next attempt to send to the corresponding IP address will result in a new ARP request.</span></span> <span data-ttu-id="f0769-627">_ \*_NX_ARP_EXPIRATION_RATE_\*\*를 0으로 설정하면 기본 구성인 ARP 에이징을 사용하지 않게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-627">Setting _ *_NX_ARP_EXPIRATION_RATE_*\* to zero disables ARP aging, which is the default configuration.</span></span>

### <a name="arp-defend"></a><span data-ttu-id="f0769-628">ARP 방어</span><span class="sxs-lookup"><span data-stu-id="f0769-628">ARP Defend</span></span>

<span data-ttu-id="f0769-629">ARP 요청 또는 ARP 응답 패킷이 수신되고 송신자가 이 노드의 IP 주소와 충돌하는 동일한 IP 주소를 가질 때 NetX는 해당 주소에 대한 ARP 요청을 방어 수단으로 전송합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-629">When an ARP request or ARP response packet is received and the sender has the same IP address, which conflicts with the IP address of this node, NetX sends an ARP request for that address as a defense.</span></span> <span data-ttu-id="f0769-630">충돌 ARP 패킷이 10초 이내에 두 번 이상 수신되면 NetX는 더 이상 방어 패킷을 전송하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-630">If the conflict ARP packet is received more than once in 10 seconds, NetX does not send more defend packets.</span></span> <span data-ttu-id="f0769-631">기본 간격 10 초는 \***NX_ARP_DEFEND_INTERVAL** _로 다시 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-631">The default interval 10 seconds can be redefined by \***NX_ARP_DEFEND_INTERVAL** _.</span></span> <span data-ttu-id="f0769-632">이 동작은 RFC5227의 2.4(c)에 지정된 정책을 따릅니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-632">This behavior follows the policy specified in 2.4(c) of RFC5227.</span></span> <span data-ttu-id="f0769-633">Windows XP에서는 ARP 프로브를 위한 응답으로 ARP 알림을 무시하기 때문에 사용자가 _\*_NX_ARP_DEFEND_BY_REPLY_\*\*를 정의하여 ARP 응답을 추가 방어 수단으로 전송할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-633">Since Windows XP ignores ARP announcement as a response for its ARP probe, user can define _\*_NX_ARP_DEFEND_BY_REPLY_\*\*to send ARP response as additional defence.</span></span>

### <a name="arp-statistics-and-errors"></a><span data-ttu-id="f0769-634">ARP 통계 및 오류</span><span class="sxs-lookup"><span data-stu-id="f0769-634">ARP Statistics and Errors</span></span>

<span data-ttu-id="f0769-635">사용하도록 설정된 경우 NetX ARP 소프트웨어는 애플리케이션에 유용할 수 있는 몇 가지 통계 및 오류를 추적합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-635">If enabled, the NetX ARP software keeps track of several statistics and errors that may be useful to the application.</span></span> <span data-ttu-id="f0769-636">각 IP의 ARP 처리에 대해 다음 통계 및 오류 보고서가 유지 관리됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-636">The following statistics and error reports are maintained for each IP's ARP processing:</span></span>

- <span data-ttu-id="f0769-637">전송된 총 ARP 요청</span><span class="sxs-lookup"><span data-stu-id="f0769-637">Total ARP Requests Sent</span></span>
- <span data-ttu-id="f0769-638">수신된 총 ARP 요청</span><span class="sxs-lookup"><span data-stu-id="f0769-638">Total ARP Requests Received</span></span>
- <span data-ttu-id="f0769-639">전송된 총 ARP 응답</span><span class="sxs-lookup"><span data-stu-id="f0769-639">Total ARP Responses Sent</span></span>
- <span data-ttu-id="f0769-640">수신된 총 ARP 응답</span><span class="sxs-lookup"><span data-stu-id="f0769-640">Total ARP Responses Received</span></span>
- <span data-ttu-id="f0769-641">총 ARP 동적 항목</span><span class="sxs-lookup"><span data-stu-id="f0769-641">Total ARP Dynamic Entries</span></span>
- <span data-ttu-id="f0769-642">총 ARP 고정 항목</span><span class="sxs-lookup"><span data-stu-id="f0769-642">Total ARP Static Entries</span></span>
- <span data-ttu-id="f0769-643">총 ARP 오래된 항목</span><span class="sxs-lookup"><span data-stu-id="f0769-643">Total ARP Aged Entries</span></span>
- <span data-ttu-id="f0769-644">총 ARP 잘못된 메시지</span><span class="sxs-lookup"><span data-stu-id="f0769-644">Total ARP Invalid Messages</span></span>

<span data-ttu-id="f0769-645">이러한 모든 통계 및 오류 보고서는 애플리케이션에서 ***nx_arp_info_get*** 서비스를 통해 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-645">All these statistics and error reports are available to the application with the ***nx_arp_info_get*** service.</span></span>

## <a name="reverse-address-resolution-protocol-rarp-in-ip"></a><span data-ttu-id="f0769-646">IP의 RARP(역주소 확인 프로토콜)</span><span class="sxs-lookup"><span data-stu-id="f0769-646">Reverse Address Resolution Protocol (RARP) in IP</span></span>

<span data-ttu-id="f0769-647">RARP(역주소 확인 프로토콜)는 호스트의 32비트 IP 주소(RFC 903)에 대한 네트워크 할당을 요청하는 프로토콜입니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-647">The Reverse Address Resolution Protocol (RARP) is the protocol for requesting network assignment of the host's 32-bit IP addresses (RFC 903).</span></span> <span data-ttu-id="f0769-648">이 작업은 RARP 요청을 통해 수행되며 네트워크 멤버가 RARP 응답에서 호스트 네트워크 인터페이스에 IP 주소를 할당할 때까지 주기적으로 계속됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-648">This is done through an RARP request and continues periodically until a network member assigns an IP address to the host network interface in an RARP response.</span></span> <span data-ttu-id="f0769-649">애플리케이션은 IP 주소가 0인 ***nx_ip_create*** 서비스에서 IP 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-649">The application creates an IP instance by the service ***nx_ip_create*** with a zero IP address.</span></span> <span data-ttu-id="f0769-650">애플리케이션에서 RARP를 사용하는 경우 RARP 프로토콜을 사용하여 IP 주소가 0인 인터페이스를 통해 액세스할 수 있는 네트워크 서버에서 IP 주소를 요청할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-650">If RARP is enabled by the application, it can use the RARP protocol to request an IP address from the network server accessible through the interface that has a zero IP address.</span></span>

### <a name="rarp-enable"></a><span data-ttu-id="f0769-651">RARP 사용</span><span class="sxs-lookup"><span data-stu-id="f0769-651">RARP Enable</span></span>

<span data-ttu-id="f0769-652">RARP를 사용하려면 애플리케이션에서 IP 주소가 0인 IP 인스턴스를 만든 다음, ***nx_rarp_enable*** 서비스를 사용하여 RARP를 사용하도록 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-652">To use RARP, the application must create the IP instance with an IP address of zero, then enable RARP using the service ***nx_rarp_enable***.</span></span> <span data-ttu-id="f0769-653">멀티홈 시스템의 경우 IP 인스턴스와 연결된 하나 이상의 네트워크 디바이스에 0인 IP 주소가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-653">For multihome systems, at least one network device associated with the IP instance must have an IP address of zero.</span></span> <span data-ttu-id="f0769-654">RARP 처리는 네트워크 지정 IP 주소를 사용하는 유효한 RARP 응답이 수신될 때까지 IP 주소가 필요한 NetX 시스템에 대한 RARP 요청 메시지를 주기적으로 전송합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-654">The RARP processing periodically sends RARP request messages for the NetX system requiring an IP address until a valid RARP reply with the network designated IP address is received.</span></span> <span data-ttu-id="f0769-655">이때 RARP 처리가 완료됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-655">At this point, RARP processing is complete.</span></span>

<span data-ttu-id="f0769-656">RARP를 사용하도록 설정한 후에는 모든 인터페이스 주소가 확인되면 자동으로 사용할 수 없게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-656">After RARP has been enabled, it is disabled automatically after all interface addresses are resolved.</span></span> <span data-ttu-id="f0769-657">애플리케이션이 ***nx_rarp_disable*** 서비스를 사용하여 강제로 RARP를 종료할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-657">The application may force RARP to terminate by using the service ***nx_rarp_disable***.</span></span>

###  <a name="rarp-request"></a><span data-ttu-id="f0769-658">RARP 요청</span><span class="sxs-lookup"><span data-stu-id="f0769-658">RARP Request</span></span>

<span data-ttu-id="f0769-659">RARP 요청 패킷의 형식은 [ARP 메시지](#arp-messages) 항목의 그림 6에 표시된 ARP 패킷과 거의 동일합니다. 유일한 차이점은 프레임 유형 필드는 0x8035이고 ‘작업 코드’ 필드는 3이며 RARP 요청을 지정하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-659">The format of an RARP request packet is almost identical to the ARP packet shown in Figure 6 in the topic [ARP Messages](#arp-messages).The only difference is the frame type field is 0x8035 and the *Operation Code* field is 3, designating an RARP request.</span></span> <span data-ttu-id="f0769-660">앞에서 언급한 대로 RARP 요청은 네트워크에서 할당된 IP 주소를 가진 RARP 회신이 수신될 때까지 주기적으로(매 ***NX_RARP_UPDATE_RATE*** 초마다) 전송됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-660">As mentioned previously, RARP requests will be sent periodically (every ***NX_RARP_UPDATE_RATE*** seconds) until a RARP reply with the network assigned IP address is received.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="f0769-661">TCP/IP 구현의 모든 RARP 메시지는 Big Endian 형식이어야 합니다. 이 형식에서 단어의 가장 중요한 바이트는 가장 낮은 바이트 주소에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-661">*All RARP messages in the TCP/IP implementation are expected to be in big endian format. In this format, the most significant byte of the word resides at the lowest byte address.*</span></span>

### <a name="rarp-reply"></a><span data-ttu-id="f0769-662">RARP 응답</span><span class="sxs-lookup"><span data-stu-id="f0769-662">RARP Reply</span></span>

<span data-ttu-id="f0769-663">RARP 응답 메시지는 네트워크에서 수신되고 이 호스트에 할당된 네트워크 IP 주소를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-663">RARP reply messages are received from the network and contain the network assigned IP address for this host.</span></span> <span data-ttu-id="f0769-664">RARP 응답 패킷의 형식은 그림 6에 표시된 ARP 패킷과 거의 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-664">The format of an RARP reply packet is almost identical to the ARP packet shown in Figure 6.</span></span> <span data-ttu-id="f0769-665">유일한 차이점은 프레임 유형 필드는 0x8035이고 ‘작업 코드’ 필드는 4이며 RARP 응답을 지정하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-665">The only difference is the frame type field is 0x8035 and the *Operation Code* field is 4, which designates an RARP reply.</span></span> <span data-ttu-id="f0769-666">수신 후 IP 주소는 IP 인스턴스에서 설정되고 주기적 RARP 요청은 사용할 수 없으며 IP 인스턴스는 정상적인 네트워크 작업을 수행할 준비가 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-666">After received, the IP address is setup in the IP instance, the periodic RARP request is disabled, and the IP instance is now ready for normal network operation.</span></span>

<span data-ttu-id="f0769-667">멀티홈 호스트의 경우 IP 주소가 요청 네트워크 인터페이스에 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-667">For multihome hosts, the IP address is applied to the requesting network interface.</span></span> <span data-ttu-id="f0769-668">여전히 IP 주소 할당을 요청하는 다른 네트워크 인터페이스가 있는 경우 모든 인터페이스 IP 주소 요청이 해결될 때까지 주기적인 RARP 서비스는 계속됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-668">If there are other network interfaces still requesting an IP address assignment, the periodic RARP service continues until all interface IP address requests are resolved.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="f0769-669">애플리케이션은 RARP 처리가 완료될 때까지 IP 인스턴스를 사용하면 안 됩니다. **nx_ip_status_check** 를 사용하여 애플리케이션에서 RARP 완료를 기다릴 수 있습니다. 멀티홈 시스템의 경우 애플리케이션은 해당 인터페이스에서 RARP 처리가 완료될 때까지 요청 인터페이스를 사용하지 않아야 합니다. **nx_ip_interface_status_check** 서비스를 사용하여 보조 디바이스의 IP 주소 상태를 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-669">*The application should not use the IP instance until the RARP processing is complete. The **nx_ip_status_check** may be used by applications to wait for the RARP completion. For multihome systems, the application should not use the requesting interface until the RARP processing is complete on that interface. Status of the IP address on the secondary device can be checked with the **nx_ip_interface_status_check** service.*</span></span>

### <a name="rarp-statistics-and-errors"></a><span data-ttu-id="f0769-670">RARP 통계 및 오류</span><span class="sxs-lookup"><span data-stu-id="f0769-670">RARP Statistics and Errors</span></span>

<span data-ttu-id="f0769-671">사용하도록 설정된 경우 NetX RARP 소프트웨어는 애플리케이션에 유용할 수 있는 몇 가지 통계 및 오류를 추적합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-671">If enabled, the NetX RARP software keeps track of several statistics and errors that may be useful to the application.</span></span> <span data-ttu-id="f0769-672">각 IP의 RARP 처리에 대해 다음 통계 및 오류 보고서가 유지 관리됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-672">The following statistics and error reports are maintained for each IP's RARP processing:</span></span>

- <span data-ttu-id="f0769-673">전송된 총 RARP 요청</span><span class="sxs-lookup"><span data-stu-id="f0769-673">Total RARP Requests Sent</span></span>
- <span data-ttu-id="f0769-674">수신된 총 RARP 응답</span><span class="sxs-lookup"><span data-stu-id="f0769-674">Total RARP Responses Received</span></span>
- <span data-ttu-id="f0769-675">총 RARP 잘못된 메시지</span><span class="sxs-lookup"><span data-stu-id="f0769-675">Total RARP Invalid Messages</span></span>

<span data-ttu-id="f0769-676">이러한 모든 통계 및 오류 보고서는 애플리케이션에서 ***nx_rarp_info_get*** 서비스를 통해 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-676">All these statistics and error reports are available to the application with the ***nx_rarp_info_get*** service.</span></span>

## <a name="internet-control-message-protocol-icmp"></a><span data-ttu-id="f0769-677">ICMP(Internet Control Message Protocol)</span><span class="sxs-lookup"><span data-stu-id="f0769-677">Internet Control Message Protocol (ICMP)</span></span>

<span data-ttu-id="f0769-678">IP용 ICMP(Internet Control Message Protocol)는 IP 네트워크 멤버 간의 오류 및 제어 정보를 전달하는 것으로 제한됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-678">Internet Control Message Protocol for IP (ICMP) is limited to passing error and control information between IP network members.</span></span>

<span data-ttu-id="f0769-679">대부분의 다른 애플리케이션 계층(예: TCP/IP) 메시지와 마찬가지로 ICMP 메시지는 ICMP 프로토콜을 지정하는 IP 헤더에 의해 캡슐화됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-679">Like most other application layer (e.g., TCP/IP) messages, ICMP messages are encapsulated by an IP header with the ICMP protocol designation.</span></span>

### <a name="icmp-statistics-and-errors"></a><span data-ttu-id="f0769-680">ICMP 통계 및 오류</span><span class="sxs-lookup"><span data-stu-id="f0769-680">ICMP Statistics and Errors</span></span>

<span data-ttu-id="f0769-681">사용하도록 설정된 경우 NetX는 애플리케이션에 유용할 수 있는 몇 가지 ICMP 통계 및 오류를 추적합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-681">If enabled, NetX keeps track of several ICMP statistics and errors that may be useful to the application.</span></span> <span data-ttu-id="f0769-682">각 IP의 ICMP 처리에 대해 다음 통계 및 오류 보고서가 유지 관리됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-682">The following statistics and error reports are maintained for each IP's ICMP processing:</span></span>

- <span data-ttu-id="f0769-683">전송된 총 ICMP Ping</span><span class="sxs-lookup"><span data-stu-id="f0769-683">Total ICMP Pings Sent</span></span>
- <span data-ttu-id="f0769-684">총 ICMP Ping 시간 제한</span><span class="sxs-lookup"><span data-stu-id="f0769-684">Total ICMP Ping Timeouts</span></span>
- <span data-ttu-id="f0769-685">일시 중단된 총 ICMP Ping 스레드</span><span class="sxs-lookup"><span data-stu-id="f0769-685">Total ICMP Ping Threads Suspended</span></span>
- <span data-ttu-id="f0769-686">수신된 총 ICMP Ping 응답</span><span class="sxs-lookup"><span data-stu-id="f0769-686">Total ICMP Ping Responses Received</span></span>
- <span data-ttu-id="f0769-687">총 ICMP 체크섬 오류</span><span class="sxs-lookup"><span data-stu-id="f0769-687">Total ICMP Checksum Errors</span></span>
- <span data-ttu-id="f0769-688">총 ICMP 처리되지 않은 메시지</span><span class="sxs-lookup"><span data-stu-id="f0769-688">Total ICMP Unhandled Messages</span></span>

<span data-ttu-id="f0769-689">이러한 모든 통계 및 오류 보고서는 애플리케이션이 ***nx_icmp_info_get*** 서비스를 사용하여 이용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-689">All these statistics and error reports are available to the application with the ***nx_icmp_info_get*** service.</span></span>

### <a name="icmp-enable"></a><span data-ttu-id="f0769-690">ICMP 사용</span><span class="sxs-lookup"><span data-stu-id="f0769-690">ICMP Enable</span></span>
<span data-ttu-id="f0769-691">NetX에서 ICMP 메시지를 처리하려면 먼저 애플리케이션이 ***nx_icmp_enable*** 서비스를 호출하여 ICMP를 처리하도록 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-691">Before ICMP messages can be processed by NetX, the application must call the ***nx_icmp_enable*** service to enable ICMP processing.</span></span> <span data-ttu-id="f0769-692">이 작업이 완료되면 애플리케이션에서 Ping 요청을 실행하고 들어오는 Ping 패킷을 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-692">After this is done, the application can issue ping requests and field incoming ping packets.</span></span>

### <a name="icmp-echo-request"></a><span data-ttu-id="f0769-693">ICMP 에코 요청</span><span class="sxs-lookup"><span data-stu-id="f0769-693">ICMP Echo Request</span></span>
<span data-ttu-id="f0769-694">에코 요청은 호스트 IP 주소로 식별되는 네트워크에 특정 노드가 있는지 확인하는 데 일반적으로 사용되는 ICMP 메시지의 한 유형입니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-694">An echo request is one type of ICMP message that is typically used to check for the existence of a specific node on the network, as identified by its host IP address.</span></span> <span data-ttu-id="f0769-695">인기있는 Ping 명령은 ICMP 에코 요청/에코 응답 메시지를 사용하여 구현됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-695">The popular ping command is implemented using ICMP echo request/echo reply messages.</span></span> <span data-ttu-id="f0769-696">특정 호스트가 있는 경우 해당 네트워크 스택은 Ping 요청 및 응답을 ping 응답으로 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-696">If the specific host is present, its network stack processes the ping request and responses with a ping response.</span></span> <span data-ttu-id="f0769-697">그림 7에서는 ICMP Ping 메시지 형식에 대해 자세히 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-697">Figure 7 details the ICMP ping message format.</span></span>

![ICMP Ping 메시지](./media/user-guide/icmp-ping-message.png)

<span data-ttu-id="f0769-699">**그림 7. ICMPv4 Ping 메시지**</span><span class="sxs-lookup"><span data-stu-id="f0769-699">**FIGURE 7. ICMP Ping Message**</span></span>

> [!IMPORTANT]
> <span data-ttu-id="f0769-700">TCP/IP 구현의 모든 ICMP 메시지는 Big Endian 형식이어야 합니다. 이 형식에서 단어의 가장 중요한 바이트는 가장 낮은 바이트 주소에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-700">*All ICMP messages in the TCP/IP implementation are expected to be in big endian format. In this format, the most significant byte of the word resides at the lowest byte address.*</span></span>

<span data-ttu-id="f0769-701">다음 표에서는 ICMP 헤더 형식에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-701">The following table describes the ICMP header format:</span></span>

| <span data-ttu-id="f0769-702">헤더 필드</span><span class="sxs-lookup"><span data-stu-id="f0769-702">Header Field</span></span>    | <span data-ttu-id="f0769-703">용도</span><span class="sxs-lookup"><span data-stu-id="f0769-703">Purpose</span></span> |
|-----------------|---------------------------------------------------|
| <span data-ttu-id="f0769-704">Type</span><span class="sxs-lookup"><span data-stu-id="f0769-704">Type</span></span>            | <span data-ttu-id="f0769-705">이 필드에서는 ICMP 메시지(31-24비트)를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-705">This field specifies the ICMP message (bits 31- 24).</span></span> <span data-ttu-id="f0769-706">가장 일반적인 메시지: 0 에코 응답   8 에코 요청</span><span class="sxs-lookup"><span data-stu-id="f0769-706">The most common are:   0 Echo Reply   8 Echo Request</span></span> |
| <span data-ttu-id="f0769-707">코드</span><span class="sxs-lookup"><span data-stu-id="f0769-707">Code</span></span>            | <span data-ttu-id="f0769-708">이 필드는 형식 필드(23-16비트)에서 컨텍스트에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-708">This field is context specific on the type field (bits 23-16).</span></span> <span data-ttu-id="f0769-709">에코 요청 또는 응답의 경우 코드는 0으로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-709">For an echo request or reply the code is set to zero.</span></span> |
| <span data-ttu-id="f0769-710">체크섬</span><span class="sxs-lookup"><span data-stu-id="f0769-710">Checksum</span></span>        | <span data-ttu-id="f0769-711">이 필드는 형식 필드에서 시작하는 ICMP 헤더 전체를 포함하여 ICMP 메시지의 보수 합계에 대한 16비트 체크섬을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-711">This field contains the 16-bit checksum of the one's complement sum of the ICMP message including the entire the ICMP header starting with the Type field.</span></span> <span data-ttu-id="f0769-712">체크섬을 생성하기 전에 체크섬 필드가 지워집니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-712">Before generating the checksum, the checksum field is cleared.</span></span>                 |
| <span data-ttu-id="f0769-713">Identification(식별)</span><span class="sxs-lookup"><span data-stu-id="f0769-713">Identification</span></span>  | <span data-ttu-id="f0769-714">이 필드는 호스트를 식별하는 ID 값을 포함합니다. 호스트는 에코 응답의 에코 요청에서 추출된 ID를 사용해야 합니다(31-16비트).</span><span class="sxs-lookup"><span data-stu-id="f0769-714">This field contains an ID value identifying the host; a host should use the ID extracted from an ECHO request in the ECHO REPLY (bits 31-16).</span></span> |
| <span data-ttu-id="f0769-715">시퀀스 번호</span><span class="sxs-lookup"><span data-stu-id="f0769-715">Sequence number</span></span> | <span data-ttu-id="f0769-716">이 필드는 ID 값을 포함합니다. 호스트는 에코 응답의 에코 요청에서 추출된 ID를 사용해야 합니다(31-16비트).</span><span class="sxs-lookup"><span data-stu-id="f0769-716">This field contains an ID value; a host should use the ID extracted from an ECHO request in the ECHO REPLY (bits 31-16).</span></span> <span data-ttu-id="f0769-717">ID 필드와 달리 이 값은 동일한 호스트의 후속 에코 요청에서 변경됩니다(15-0비트).</span><span class="sxs-lookup"><span data-stu-id="f0769-717">Unlike the identifier field, this value will change in a subsequent Echo request from the same host (bits 15-0).</span></span> |


### <a name="icmp-echo-response"></a><span data-ttu-id="f0769-718">ICMP 에코 응답</span><span class="sxs-lookup"><span data-stu-id="f0769-718">ICMP Echo Response</span></span>
<span data-ttu-id="f0769-719">ping 응답은 외부 ping 요청에 대한 응답으로 ICMP 구성 요소에 의해 내부적으로 생성되는 또 다른 형식의 ICMP 메시지입니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-719">A ping response is another type of ICMP message that is generated internally by the ICMP component in response to an external ping request.</span></span> <span data-ttu-id="f0769-720">ping 응답에는 승인 외에도 ping 요청에 제공된 사용자 데이터 복사본도 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-720">In addition to acknowledgement, the ping response also contains a copy of the user data supplied in the ping request.</span></span>

## <a name="internet-group-management-protocol-igmp"></a><span data-ttu-id="f0769-721">IGMP(Internet Group Management Protocol)</span><span class="sxs-lookup"><span data-stu-id="f0769-721">Internet Group Management Protocol (IGMP)</span></span>

<span data-ttu-id="f0769-722">IGMP(Internet Group Management Protocol)는 IP 멀티캐스트 그룹(RFC 1112와 RFC 2236)을 수신하거나 조인하려는 네트워크 환경 및 라우터와 통신할 수 있는 디바이스를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-722">The Internet Group Management Protocol (IGMP) provides a device to communicate with its neighbors and its routers that it intends to receive, or join, an IP multicast group (RFC 1112 and RFC 2236).</span></span> <span data-ttu-id="f0769-723">멀티캐스트 그룹은 기본적으로 네트워크 멤버의 동적 집합이며 클래스 D IP 주소로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-723">A multicast group is basically a dynamic collection of network members and is represented by a Class D IP address.</span></span> <span data-ttu-id="f0769-724">멀티캐스트 그룹의 멤버는 언제든지 탈퇴할 수 있고, 새로운 멤버는 언제든지 조인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-724">Members of the multicast group may leave at any time, and new members may join at any time.</span></span> <span data-ttu-id="f0769-725">그룹에 조인하고 탈퇴하는 것과 관련된 조정은 IGMP의 역할입니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-725">The coordination involved in joining and leaving the group is the responsibility of IGMP.</span></span>

### <a name="igmp-enable"></a><span data-ttu-id="f0769-726">IGMP 사용</span><span class="sxs-lookup"><span data-stu-id="f0769-726">IGMP Enable</span></span>

<span data-ttu-id="f0769-727">NetX에서 멀티캐스팅 작업을 수행하려면 먼저 애플리케이션이 ***nx_igmp_enable*** 서비스를 호출해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-727">Before any multicasting activity can take place in NetX, the application must call the ***nx_igmp_enable*** service.</span></span> <span data-ttu-id="f0769-728">이 서비스는 멀티캐스트 요청에 준비하기 위해 기본적인 IGMP 초기화를 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-728">This service performs basic IGMP initialization in preparation for multicast requests.</span></span>

### <a name="multicast-ip-addressing"></a><span data-ttu-id="f0769-729">멀티캐스트 IP 주소 지정</span><span class="sxs-lookup"><span data-stu-id="f0769-729">Multicast IP Addressing</span></span>

<span data-ttu-id="f0769-730">앞에서 설명한 대로 멀티캐스트 주소는 실제로 58페이지의 그림 4에 나와 있는 것처럼 클래스 D IP 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-730">As mentioned previously, multicast addresses are actually Class D IP addresses as shown in Figure 4 on page 58.</span></span> <span data-ttu-id="f0769-731">클래스 D 주소의 하위 28비트는 멀티캐스트 그룹 ID에 해당합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-731">The lower 28-bits of the Class D address correspond to the multicast group ID.</span></span> <span data-ttu-id="f0769-732">미리 정의된 일련의 멀티캐스트 주소가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-732">There are a series of pre-defined multicast addresses.</span></span> <span data-ttu-id="f0769-733">그러나 *모든 호스트 주소*(244.0.0.1)는 IGMP 처리에 특히 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-733">However, the *all hosts address* (244.0.0.1) is particularly important to IGMP processing.</span></span> <span data-ttu-id="f0769-734">‘모든 호스트 주소’는 라우터가 모든 멀티캐스트 멤버를 쿼리하여 자신이 속한 멀티캐스트 그룹을 보고하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-734">The *all hosts address* is used by routers to query all multicast members to report on which multicast groups they belong to.</span></span>

### <a name="physical-address-mapping-in-ip"></a><span data-ttu-id="f0769-735">IP의 실제 주소 매핑</span><span class="sxs-lookup"><span data-stu-id="f0769-735">Physical Address Mapping in IP</span></span>

<span data-ttu-id="f0769-736">클래스 D 멀티캐스트 주소는 01.00.5e.00.00.00에서 01.00.5e.7f.ff.ff까지 범위의 실제 이더넷 주소로 직접 매핑됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-736">Class D multicast addresses map directly to physical Ethernet addresses ranging from 01.00.5e.00.00.00 through 01.00.5e.7f.ff.ff.</span></span> <span data-ttu-id="f0769-737">IP 멀티캐스트 주소의 하단 23비트는 이더넷 주소의 하위 23비트에 직접 매핑됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-737">The lower 23 bits of the IP multicast address map directly to the lower 23 bits of the Ethernet address.</span></span>

### <a name="multicast-group-join"></a><span data-ttu-id="f0769-738">멀티캐스트 그룹 조인</span><span class="sxs-lookup"><span data-stu-id="f0769-738">Multicast Group Join</span></span>

<span data-ttu-id="f0769-739">특정 멀티캐스트 그룹에 조인해야 하는 애플리케이션은 ***nx_igmp_multicast_join*** 서비스를 호출하여 이 작업을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-739">Applications that need to join a particular multicast group may do so by calling the ***nx_igmp_multicast_join*** service.</span></span> <span data-ttu-id="f0769-740">이 서비스는 이 멀티캐스트 그룹에 조인하려는 요청 수를 추적합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-740">This service keeps track of the number of requests to join this multicast group.</span></span> <span data-ttu-id="f0769-741">멀티캐스트 그룹에 조인하려는 첫 번째 애플리케이션 요청이라면 IGMP 보고서는 그룹에 조인하려는 이 호스트의 의도를 나타내는 기본 네트워크에 전송됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-741">If this is the first application request to join the multicast group, an IGMP report is sent out on the primary network indicating this host's intention to join the group.</span></span> <span data-ttu-id="f0769-742">그런 다음, 네트워크 드라이버를 호출하여 이 멀티캐스트 그룹에 대한 이더넷 주소로 패킷을 수신 대기하도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-742">Next, the network driver is called to set up for listening for packets with the Ethernet address for this multicast group.</span></span>

<span data-ttu-id="f0769-743">멀티홈 시스템에서, 멀티캐스트 그룹이 특정 인터페이스를 통해 접근할 수 있다면, 애플리케이션은 기본 네트워크의 멀티캐스트 그룹으로 제한된 ***nx_igmp_multicast_join*** 대신 ***nx_igmp_multicast_interface_join*** 서비스를 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-743">In a multihome system, if the multicast group is accessible via a specific interface, application shall use the service ***nx_igmp_multicast_interface_join*** instead of \***nx_igmp_multicast_join**,\* which is limited to multicast groups on the primary network.</span></span>

### <a name="multicast-group-leave"></a><span data-ttu-id="f0769-744">멀티캐스트 그룹 나가기</span><span class="sxs-lookup"><span data-stu-id="f0769-744">Multicast Group Leave</span></span>

<span data-ttu-id="f0769-745">이전에 조인된 멀티캐스트 그룹을 탈퇴해야 하는 애플리케이션은 ***nx_igmp_multicast_leave*** 서비스를 호출하여 나갈 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-745">Applications that need to leave a previously joined multicast group may do so by calling the ***nx_igmp_multicast_leave*** service.</span></span> <span data-ttu-id="f0769-746">이 서비스는 그룹이 조인된 횟수와 관련된 내부 수를 줄입니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-746">This service reduces the internal count associated with how many times the group was joined.</span></span> <span data-ttu-id="f0769-747">그룹에 대한 처리 중인 조인 요청이 없는 경우 네트워크 드라이버를 호출하여 이 멀티캐스트 그룹의 이더넷 주소로 패킷을 수신 대기하지 않도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-747">If there are no outstanding join requests for a group, the network driver is called to disable listening for packets with this multicast group's Ethernet address</span></span>

### <a name="multicast-loopback"></a><span data-ttu-id="f0769-748">멀티캐스트 루프백</span><span class="sxs-lookup"><span data-stu-id="f0769-748">Multicast Loopback</span></span>

<span data-ttu-id="f0769-749">애플리케이션은 동일한 노드의 소스 중 하나에서 시작된 멀티캐스트 트래픽을 수신하려고 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-749">An application may wish to receive multicast traffic originated from one of the sources on the same node.</span></span> <span data-ttu-id="f0769-750">이렇게 하려면 ***nx_igmp_loopback_enable*** 서비스를 사용하여 IP 멀티캐스트 구성 요소가 루프백을 사용하도록 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-750">This requires the IP multicast component to have loopback enabled by using the service ***nx_igmp_loopback_enable***.</span></span>

### <a name="igmp-report-message"></a><span data-ttu-id="f0769-751">IGMP 보고서 메시지</span><span class="sxs-lookup"><span data-stu-id="f0769-751">IGMP Report Message</span></span>

<span data-ttu-id="f0769-752">애플리케이션이 멀티캐스트 그룹에 조인할 때, IGMP 보고서 메시지는 특정 멀티캐스트 그룹에 조인하려는 호스트의 의도를 나타내기 위해 네트워크를 통해 전송됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-752">When the application joins a multicast group, an IGMP report message is sent via the network to indicate the host's intention to join a particular multicast group.</span></span> <span data-ttu-id="f0769-753">IGMP 보고서 메시지의 형식은 그림 8에서 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-753">The format of the IGMP report message is shown in Figure 8.</span></span> <span data-ttu-id="f0769-754">멀티캐스트 그룹 주소는 IGMP 보고서 메시지의 그룹 메시지와 대상 IP 주소에 모두 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-754">The multicast group address is used for both the group message in the IGMP report message and the destination IP address.</span></span>

![IGMP 보고서 메시지](./media/user-guide/igmp-report-message.png)

<span data-ttu-id="f0769-756">**그림 8. IGMP 보고서 메시지**</span><span class="sxs-lookup"><span data-stu-id="f0769-756">**FIGURE 8. IGMP Report Message**</span></span>

<span data-ttu-id="f0769-757">위의 그림에서(그림 8) IGMP 헤더에는 버전/유형 필드, 최대 응답 시간, 체크섬 필드 및 멀티캐스트 그룹 주소 필드가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-757">In the figure above (Figure 8), the IGMP header contains a version/type field, maximum response time, a checksum field, and a multicast group address field.</span></span> <span data-ttu-id="f0769-758">IGMPv1 메시지의 경우 최대 응답 시간 필드는 IGMPv1 프로토콜의 일부가 아니므로 항상 0으로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-758">For IGMPv1 messages, the Maximum Response Time field is always set to zero, as this is not part of the IGMPv1 protocol.</span></span> <span data-ttu-id="f0769-759">최대 응답 시간 필드는 호스트가 쿼리 형식 IGMP 메시지를 수신할 때 설정되고 호스트가 IGMPv2 프로토콜로 정의된 다른 호스트의 보고서 형식 메시지를 수신할 때 삭제됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-759">The Maximum Response Time field is set when the host receives a Query type IGMP message and cleared when a host receives another host's Report type message as defined by the IGMPv2 protocol.</span></span>

<span data-ttu-id="f0769-760">다음은 IGMP 헤더 형식에 대한 설명입니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-760">The following describes the IGMP header format:</span></span>

| <span data-ttu-id="f0769-761">**헤더 필드**</span><span class="sxs-lookup"><span data-stu-id="f0769-761">**Header Field**</span></span>          | <span data-ttu-id="f0769-762">**용도**</span><span class="sxs-lookup"><span data-stu-id="f0769-762">**Purpose**</span></span> |
|-----------------------|--------------------------------------------------------------------|
| <span data-ttu-id="f0769-763">버전</span><span class="sxs-lookup"><span data-stu-id="f0769-763">Version</span></span>               | <span data-ttu-id="f0769-764">이 필드는 IGMP 버전(31-28비트)을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-764">This field specifies the IGMP version (bits 31- 28).</span></span>                                                                               |
| <span data-ttu-id="f0769-765">형식</span><span class="sxs-lookup"><span data-stu-id="f0769-765">Type</span></span>                  | <span data-ttu-id="f0769-766">이 필드는 IGMP 메시지 유형(27-24비트)을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-766">This field specifies the type of IGMP message (bits 27 -24).</span></span>                                                                       |
| <span data-ttu-id="f0769-767">최대 응답 시간</span><span class="sxs-lookup"><span data-stu-id="f0769-767">Maximum Response Time</span></span> | <span data-ttu-id="f0769-768">IGMPv1에서 사용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-768">Not used in IGMPv1.</span></span> <span data-ttu-id="f0769-769">IGMPv2에서 이 필드는 최대 응답 시간으로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-769">In IGMPv2 this field serves as the maximum response time.</span></span>                                                      |
| <span data-ttu-id="f0769-770">체크섬</span><span class="sxs-lookup"><span data-stu-id="f0769-770">Checksum</span></span>              | <span data-ttu-id="f0769-771">이 필드에는 IGMP 버전(0-15비트)으로 시작하는 IGMP 메시지의 1의 보수 합계에 대한 16비트 체크섬이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-771">This field contains the 16-bit checksum of the one's complement sum of the IGMP message starting with the IGMP version (bits 0-15)</span></span> |
| <span data-ttu-id="f0769-772">그룹 주소</span><span class="sxs-lookup"><span data-stu-id="f0769-772">Group Address</span></span>         | <span data-ttu-id="f0769-773">32비트 클래스 D 그룹 IP 주소</span><span class="sxs-lookup"><span data-stu-id="f0769-773">32-bit class D group IP address</span></span> |


<span data-ttu-id="f0769-774">또한 IGMP 보고서 메시지는 멀티캐스트 라우터에 의해 전송된 IGMP 쿼리 메시지에 응답하여 전송됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-774">IGMP report messages are also sent in response to IGMP query messages sent by a multicast router.</span></span> <span data-ttu-id="f0769-775">멀티캐스트 라우터는 그룹 멤버 자격이 여전히 필요한 호스트를 확인하기 위해 주기적으로 쿼리 메시지를 전송합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-775">Multicast routers periodically send query messages out to see which hosts still require group membership.</span></span> <span data-ttu-id="f0769-776">쿼리 메시지는 그림 8에 표시된 IGMP 보고서 메시지와 동일한 형식을 갖습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-776">Query messages have the same format as the IGMP Report message shown in Figure 8.</span></span> <span data-ttu-id="f0769-777">유일한 차이점은 IGMP 형식이 1과 같고 그룹 주소 필드는 0으로 설정된다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-777">The only differences are the IGMP type is equal to 1 and the group address field is set to 0.</span></span> <span data-ttu-id="f0769-778">IGMP 쿼리 메시지는 멀티캐스트 라우터에 의해 ‘모든 호스트’ IP 주소로 전송됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-778">IGMP Query messages are sent to the *all hosts* IP address by the multicast router.</span></span> <span data-ttu-id="f0769-779">그룹 멤버 자격을 유지 관리하려는 호스트가 다른 IGMP 보고서 메시지를 전송하여 응답합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-779">A host that still wishes to maintain group membership responds by sending another IGMP Report message.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="f0769-780">TCP/IP 구현의 모든 메시지는 **Big Endian** 형식이어야 합니다. 이 형식에서 단어의 가장 중요한 바이트는 가장 낮은 바이트 주소에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-780">*All messages in the TCP/IP implementation are expected to be in **big endian** format. In this format, the most significant byte of the word resides at the lowest byte address.*</span></span>

### <a name="igmp-statistics-and-errors"></a><span data-ttu-id="f0769-781">IGMP 통계 및 오류</span><span class="sxs-lookup"><span data-stu-id="f0769-781">IGMP Statistics and Errors</span></span>

<span data-ttu-id="f0769-782">사용하도록 설정된 경우 NetX IGMP 소프트웨어는 애플리케이션에 유용할 수 있는 몇 가지 통계 및 오류를 추적합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-782">If enabled, the NetX IGMP software keeps track of several statistics and errors that may be useful to the application.</span></span> <span data-ttu-id="f0769-783">각 IP의 IGMP 처리에 대해 다음 통계 및 오류 보고서가 유지 관리됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-783">The following statistics and error reports are maintained for each IP's IGMP processing:</span></span>

- <span data-ttu-id="f0769-784">전송된 총 IGMP 보고서</span><span class="sxs-lookup"><span data-stu-id="f0769-784">Total IGMP Reports Sent</span></span>
- <span data-ttu-id="f0769-785">수신된 총 IGMP 쿼리</span><span class="sxs-lookup"><span data-stu-id="f0769-785">Total IGMP Queries Received</span></span>
- <span data-ttu-id="f0769-786">총 IGMP 체크섬 오류</span><span class="sxs-lookup"><span data-stu-id="f0769-786">Total IGMP Checksum Errors</span></span>
- <span data-ttu-id="f0769-787">조인된 총 IGMP 현재 그룹</span><span class="sxs-lookup"><span data-stu-id="f0769-787">Total IGMP Current Groups Joined</span></span>

<span data-ttu-id="f0769-788">이러한 모든 통계 및 오류 보고서는 애플리케이션이 ***nx_igmp_info_get*** 서비스를 사용하여 이용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-788">All these statistics and error reports are available to the application with the ***nx_igmp_info_get*** service.</span></span>

## <a name="user-datagram-protocol-udp"></a><span data-ttu-id="f0769-789">UDP(User Datagram Protocol)</span><span class="sxs-lookup"><span data-stu-id="f0769-789">User Datagram Protocol (UDP)</span></span>

<span data-ttu-id="f0769-790">UDP(User Datagram Protocol)는 네트워크 멤버(RFC 768) 간에 가장 간단한 형식의 데이터 전송을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-790">The User Datagram Protocol (UDP) provides the simplest form of data transfer between network members (RFC 768).</span></span> <span data-ttu-id="f0769-791">UDP 데이터 패킷은 한 네트워크 멤버에서 다른 네트워크 멤버로 최상의 방법으로 전송됩니다. 즉, 패킷 수신자의 확인을 위한 기본 제공 메커니즘은 제공되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-791">UDP data packets are sent from one network member to another in a best effort fashion; i.e., there is no built-in mechanism for acknowledgement by the packet recipient.</span></span> <span data-ttu-id="f0769-792">또한 UDP 패킷을 전송할 때 미리 연결할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-792">In addition, sending a UDP packet does not require any connection to be established in advance.</span></span> <span data-ttu-id="f0769-793">따라서 UDP 패킷 전송은 매우 효율적입니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-793">Because of this, UDP packet transmission is very efficient.</span></span>

### <a name="udp-header"></a><span data-ttu-id="f0769-794">UDP 헤더</span><span class="sxs-lookup"><span data-stu-id="f0769-794">UDP Header</span></span>
<span data-ttu-id="f0769-795">UDP는 전송 중인 애플리케이션의 데이터 앞에 간단한 패킷 헤더를 배치하고, 수신된 UDP 패킷을 애플리케이션에 전송하기 전에 수신한 패킷에서 유사한 UDP 헤더를 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-795">UDP places a simple packet header in front of the application's data on transmission, and removes a similar UDP header from the packet on reception before delivering a received UDP packet to the application.</span></span> <span data-ttu-id="f0769-796">UDP는 패킷을 주고받기 위해 IP 프로토콜을 활용하는데, 이는 패킷이 네트워크에 있을 때 UDP 헤더 앞에 IP 헤더가 있음을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-796">UDP utilizes the IP protocol for sending and receiving packets, which means there is an IP header in front of the UDP header when the packet is on the network.</span></span> <span data-ttu-id="f0769-797">그림 9는 UDP 헤더의 형식을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-797">Figure 9 shows the format of the UDP header.</span></span>

![UDP 헤더](./media/user-guide/udp-header.png)

<span data-ttu-id="f0769-799">**그림 9. UDP 헤더**</span><span class="sxs-lookup"><span data-stu-id="f0769-799">**FIGURE 9. UDP Header**</span></span>

> [!IMPORTANT]
> <span data-ttu-id="f0769-800">UDP/IP 구현의 모든 헤더는 big endian 형식이어야 합니다. 이 형식에서 단어의 가장 중요한 바이트는 가장 낮은 바이트 주소에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-800">*All headers in the UDP/IP implementation are expected to be in big endian format. In this format, the most significant byte of the word resides at the lowest byte address.*</span></span>

<span data-ttu-id="f0769-801">다음은 UDP 헤더 형식에 대한 설명입니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-801">The following describes the UDP header format:</span></span>

| <span data-ttu-id="f0769-802">헤더 필드</span><span class="sxs-lookup"><span data-stu-id="f0769-802">Header Field</span></span>                   | <span data-ttu-id="f0769-803">용도</span><span class="sxs-lookup"><span data-stu-id="f0769-803">Purpose</span></span> |
|--------------------------------|---------------------------------------------|
| <span data-ttu-id="f0769-804">16비트 원본 포트 번호</span><span class="sxs-lookup"><span data-stu-id="f0769-804">16-bit source port number</span></span>      | <span data-ttu-id="f0769-805">이 필드에는 UDP 패킷을 전송할 포트가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-805">This field contains the port on which the UDP packet is being sent from.</span></span> <span data-ttu-id="f0769-806">유효한 UDP 포트의 범위는 1에서 0xFFFF까지입니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-806">Valid UDP ports range from 1 through 0xFFFF.</span></span> |
| <span data-ttu-id="f0769-807">16비트 대상 포트 번호</span><span class="sxs-lookup"><span data-stu-id="f0769-807">16-bit destination port number</span></span> | <span data-ttu-id="f0769-808">이 필드에는 패킷을 전송할 UDP 포트가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-808">This field contains the UDP port to which the packet is being sent to.</span></span> <span data-ttu-id="f0769-809">유효한 UDP 포트의 범위는 1에서 0xFFFF까지입니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-809">Valid UDP ports range from 1 through 0xFFFF.</span></span>   |
| <span data-ttu-id="f0769-810">16비트 UDP 길이</span><span class="sxs-lookup"><span data-stu-id="f0769-810">16-bit UDP length</span></span>   | <span data-ttu-id="f0769-811">이 필드에는 UDP 헤더의 크기를 포함하여 UDP 패킷의 바이트 수가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-811">This field contains the number of bytes in the UDP packet, including the size of the UDP header.</span></span>                                  |
| <span data-ttu-id="f0769-812">16비트 UDP 체크섬</span><span class="sxs-lookup"><span data-stu-id="f0769-812">16-bit UDP checksum</span></span> | <span data-ttu-id="f0769-813">이 필드에는 UDP 헤더, 패킷 데이터 영역, 의사 IP 헤더를 포함하여 패킷에 대한 16비트 체크섬이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-813">This field contains the 16-bit checksum for the packet, including the UDP header, the packet data area, and the pseudo IP header.</span></span> |

### <a name="udp-enable"></a><span data-ttu-id="f0769-814">UDP 사용</span><span class="sxs-lookup"><span data-stu-id="f0769-814">UDP Enable</span></span>

<span data-ttu-id="f0769-815">UDP 패킷을 전송하려면 먼저 ***nx_udp_enable*** 서비스를 호출하여 애플리케이션에서 UDP를 사용하도록 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-815">Before UDP packet transmission is possible, the application must first enable UDP by calling the ***nx_udp_enable*** service.</span></span> <span data-ttu-id="f0769-816">사용하도록 설정된 후 애플리케이션은 UDP 패킷을 자유롭게 주고받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-816">After enabled, the application is free to send and receive UDP packets.</span></span>

### <a name="udp-socket-create"></a><span data-ttu-id="f0769-817">UDP 소켓 만들기</span><span class="sxs-lookup"><span data-stu-id="f0769-817">UDP Socket Create</span></span>

<span data-ttu-id="f0769-818">UDP 소켓은 초기화 중에 또는 애플리케이션 스레드에 의한 런타임 중에 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-818">UDP sockets are created either during initialization or during runtime by application threads.</span></span> <span data-ttu-id="f0769-819">초기 서비스 유형, TTL(Time to live), 수신 큐 깊이는 ***nx_udp_socket_create*** 서비스에 의해 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-819">The initial type of service, time to live, and receive queue depth are defined by the ***nx_udp_socket_create*** service.</span></span> <span data-ttu-id="f0769-820">애플리케이션의 UDP 소켓 수에는 제한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-820">There are no limits on the number of UDP sockets in an application.</span></span>

### <a name="udp-checksum"></a><span data-ttu-id="f0769-821">UDP 체크섬</span><span class="sxs-lookup"><span data-stu-id="f0769-821">UDP Checksum</span></span>

<span data-ttu-id="f0769-822">UDP는 IP 의사 헤더(소스 IP 주소, 대상 IP 주소, 프로토콜/길이 IP 단어로 구성), UDP 헤더, UDP 패킷 데이터를 포함하는 1의 보수 16비트 체크섬을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-822">UDP specifies a one's complement 16-bit checksum that covers the IP pseudo header (consisting of the source IP address, destination IP address, and the protocol/length IP word), the UDP header, and the UDP packet data.</span></span> <span data-ttu-id="f0769-823">계산된 UDP 체크섬이 0이면 모두 0으로 저장됩니다(0xFFFF).</span><span class="sxs-lookup"><span data-stu-id="f0769-823">If the calculated UDP checksum is 0, it is stored as all ones (0xFFFF).</span></span> <span data-ttu-id="f0769-824">전송 소켓에 UDP 체크섬 논리가 사용할 수 없는 경우, 0이 UDP 체크섬 필드에 배치되어 체크섬이 계산되지 않았음을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-824">If the sending socket has the UDP checksum logic disabled, a zero is placed in the UDP checksum field to indicate the checksum was not calculated.</span></span> <span data-ttu-id="f0769-825">UDP 체크섬이 수신자에 의해 계산된 체크섬과 일치하지 않으면 UDP 패킷은 폐기됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-825">If the UDP checksum does not match the computed checksum by the receiver, the UDP packet is simply discarded.</span></span>

<span data-ttu-id="f0769-826">IPv4 네트워크에서 UDP 체크섬은 선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-826">On the IP network, UDP checksum is optional.</span></span> <span data-ttu-id="f0769-827">NetX를 사용하면 애플리케이션이 소켓 단위로 UDP 체크섬 계산을 사용하거나 사용하지 않도록 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-827">NetX allows an application to enable or disable UDP checksum calculation on a per-socket basis.</span></span> <span data-ttu-id="f0769-828">기본적으로 UDP 소켓 체크섬 논리를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-828">By default, the UDP socket checksum logic is enabled.</span></span> <span data-ttu-id="f0769-829">애플리케이션은 ***nx_udp_socket_checksum_disable*** 서비스를 호출하여 특정 UDP 소켓에 대한 체크섬 논리를 사용하지 않도록 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-829">The application can disable checksum logic for a particular UDP socket by calling the ***nx_udp_socket_checksum_disable*** service.</span></span>

<span data-ttu-id="f0769-830">특정 이더넷 컨트롤러는 즉시 UDP 체크섬을 생성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-830">Certain Ethernet controllers are able to generate the UDP checksum on the fly.</span></span> <span data-ttu-id="f0769-831">시스템이 하드웨어 체크섬 계산 기능을 사용할 수 있는 경우, NetX 라이브러리를 체크섬 논리 없이 빌드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-831">If the system is able to use hardware checksum computation feature, the NetX library can be built without the checksum logic.</span></span> <span data-ttu-id="f0769-832">UDP 소프트웨어 체크섬을 사용하지 않도록 설정하려면 ***NX_DISABLE_UDP_TX_CHECKSUM*** 및 \*\**NX_DISABLE_UDP_RX_CHECKSUM* \*_([2장](chapter2.md)에 설명됨) 기호를 사용하여 NetX 라이브러리를 빌드해야 합니다.\*\*\*\*  서비스를 호출하여 애플리케이션에서 소켓 단위로 IP UDP 체크섬 처리를 사용하지 않도록 설정할 수 있지만 구성 옵션은 NetX에서 UDP 체크섬 논리를 완전히 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-832">To disable UDP software checksum, the NetX library must be built with the following symbols defined: ***NX_DISABLE_UDP_TX_CHECKSUM*** and ***NX_DISABLE_UDP_RX_CHECKSUM\*\*_ (described in [Chapter 2](chapter2.md)). The configuration options remove UDP checksum logic from NetX entirely, while calling the _* nx_udp_socket_checksum_disable**\* service allows the application to disable IP UDP checksum processing on a per socket basis.</span></span>

### <a name="udp-ports-and-binding"></a><span data-ttu-id="f0769-833">UDP 포트 및 바인딩</span><span class="sxs-lookup"><span data-stu-id="f0769-833">UDP Ports and Binding</span></span>

<span data-ttu-id="f0769-834">UDP 포트는 UDP 프로토콜의 논리적 끝점입니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-834">A UDP port is a logical end point in the UDP protocol.</span></span> <span data-ttu-id="f0769-835">NetX의 UDP 구성 요소에는 65,535개의 유효한 포트가 있으며, 범위는 1 ~ 0xFFFF입니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-835">There are 65,535 valid ports in the UDP component of NetX, ranging from 1 through 0xFFFF.</span></span> <span data-ttu-id="f0769-836">UDP 데이터를 주고받으려면 먼저 애플리케이션에서 UDP 소켓을 만든 다음 원하는 포트에 바인딩해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-836">To send or receive UDP data, the application must first create a UDP socket, then bind it to a desired port.</span></span> <span data-ttu-id="f0769-837">UDP 소켓을 포트에 바인딩한 후 애플리케이션은 해당 소켓에서 데이터를 주고받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-837">After binding a UDP socket to a port, the application may send and receive data on that socket.</span></span>

### <a name="udp-fast-pathtrade"></a><span data-ttu-id="f0769-838">UDP 빠른 경로&trade;</span><span class="sxs-lookup"><span data-stu-id="f0769-838">UDP Fast Path&trade;</span></span>

<span data-ttu-id="f0769-839">UDP 빠른 경로&trade;는 NetX UDP 구현을 통한 낮은 패킷 오버헤드 경로에 대한 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-839">The UDP Fast Path&trade; is the name for a low packet overhead path through the NetX UDP implementation.</span></span> <span data-ttu-id="f0769-840">UDP 패킷을 전송하려면 \***nx_udp_socket_send** _, __nx_ip_packet_send__, 네트워크 드라이버에 대한 최종 호출과 같은 몇 가지 함수 호출만 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-840">Sending a UDP packet requires just a few function calls: ***nx_udp_socket_send** _, _*_nx_ip_packet_send_\*_, and the eventual call to the network driver.</span></span> <span data-ttu-id="f0769-841">_*_nx_udp_socket_send_*_ 는 기존 NetX 애플리케이션에 대해 NetX에서 사용할 수 있으며 IP 패킷에만 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-841">_*_nx_udp_socket_send_*_ is available in NetX for existing NetX applications and is only applicable for IP packets.</span></span> <span data-ttu-id="f0769-842">그러나 기본 방법은 아래에서 설명하는 _ *_nx_udp_socket_send_*\* 서비스를 사용하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-842">The preferred method, however, is to use _ *_nx_udp_socket_send_*\* service discussed below.</span></span> <span data-ttu-id="f0769-843">UDP 패킷 수신 시, UDP 패킷은 적절한 UDP 소켓 수신 큐에 배치되거나 네트워크 드라이버 수신 인터럽트 처리에서 단일 함수 호출로 일시 중단된 애플리케이션 스레드에 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-843">On UDP packet reception, the UDP packet is either placed on the appropriate UDP socket receive queue or delivered to a suspended application thread in a single function call from the network driver's receive interrupt processing.</span></span> <span data-ttu-id="f0769-844">UDP 패킷을 주고받기 위해 최적화된 이 논리는 UDP 빠른 경로 기술의 핵심입니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-844">This highly optimized logic for sending and receiving UDP packets is the essence of UDP Fast Path technology.</span></span>

### <a name="udp-packet-send"></a><span data-ttu-id="f0769-845">UDP 패킷 전송</span><span class="sxs-lookup"><span data-stu-id="f0769-845">UDP Packet Send</span></span>

<span data-ttu-id="f0769-846">IP 네트워크를 통해 UDP 데이터를 전송하는 작업은 \***nx_udp_socket_send** _ 함수를 호출하여 쉽게 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-846">Sending UDP data over IP networks is easily accomplished by calling the \***nx_udp_socket_send** _ function.</span></span> <span data-ttu-id="f0769-847">호출자는 _IP 주소 \* 필드에 IP 버전을 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-847">The caller must set the IP version in the _IP address\* field.</span></span> <span data-ttu-id="f0769-848">NetX는 대상 IP 주소를 기준으로 전송된 UDP 패킷에 가장 적합한 소스 주소를 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-848">NetX will determine the best source address for transmitted UDP packets based on the destination IP address.</span></span> <span data-ttu-id="f0769-849">이 서비스는 패킷 데이터 앞에 UDP 헤더를 배치하고 내부 IP 전송 루틴을 사용하여 이를 네트워크로 전송합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-849">This service places a UDP header in front of the packet data and sends it out onto the network using an internal IP send routine.</span></span> <span data-ttu-id="f0769-850">모든 UDP 패킷 전송이 즉시 처리되므로 UDP 패킷을 전송할 때 스레드가 일시 중단되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-850">There is no thread suspension on sending UDP packets because all UDP packet transmissions are processed immediately.</span></span>

<span data-ttu-id="f0769-851">멀티캐스트 또는 브로드캐스트 대상에 대해 애플리케이션은 NetX 디바이스가 선택할 여러 IP 주소를 가지고 있는 경우 사용할 소스 IP 주소를 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-851">For multicast or broadcast destinations, the application should specify the source IP address to use if the NetX device has multiple IP addresses to choose from.</span></span> <span data-ttu-id="f0769-852">이러한 작업은 ***nx_udp_socket_interface_send.*** 서비스로 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-852">This can be done with the services ***nx_udp_socket_interface_send.***</span></span>

> [!IMPORTANT]
> <span data-ttu-id="f0769-853">**nx_udp_socket_send** 가 멀티캐스트 또는 브로드캐스트 패킷 전송에 사용되는 경우 첫 번째 인터페이스의 IP 주소가 소스 주소로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-853">*If **nx_udp_socket_send** is used for transmitting multicast or broadcast packets, the IP address of the first interface is used as source address.*</span></span>

> [!IMPORTANT]
> <span data-ttu-id="f0769-854">이 소켓에 대해 UDP 체크섬 논리를 사용하는 경우 UDP 또는 IP 데이터 구조에 대한 액세스를 차단하지 않고 호출 스레드의 컨텍스트에서 체크섬 작업이 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-854">*If UDP checksum logic is enabled for this socket, the checksum operation is performed in the context of the calling thread, without blocking access to the UDP or IP data structures.*</span></span>

> [!NOTE]
> <span data-ttu-id="f0769-855">**NX_PACKET** 구조체에 있는 UDP 페이로드 데이터는 긴 단어 경계에 있어야 합니다. 애플리케이션에서 NetX가 UDP, IP, 실제 미디어 헤더를 배치할 수 있도록 앞에 추가 포인터와 데이터 시작 포인터 사이에 충분한 공간을 남겨 두어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-855">*The UDP payload data residing in the **NX_PACKET** structure should reside on a long-word boundary. The application needs to leave sufficient space between the prepend pointer and the data start pointer for NetX to place the UDP, IP, and physical media headers.*</span></span>

### <a name="udp-packet-receive"></a><span data-ttu-id="f0769-856">UDP 패킷 수신</span><span class="sxs-lookup"><span data-stu-id="f0769-856">UDP Packet Receive</span></span>

<span data-ttu-id="f0769-857">애플리케이션 스레드는 ***nx_udp_socket_receive*** 를 호출하여 특정 소켓에서 UDP 패킷을 수신할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-857">Application threads may receive UDP packets from a particular socket by calling ***nx_udp_socket_receive***.</span></span> <span data-ttu-id="f0769-858">소켓 수신 함수는 소켓의 수신 큐에서 가장 오래된 패킷을 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-858">The socket receive function delivers the oldest packet on the socket's receive queue.</span></span> <span data-ttu-id="f0769-859">수신 큐에 패킷이 없는 경우 패킷이 도착할 때까지 호출 스레드가 선택적 시간 제한으로 일시 중단될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-859">If there are no packets on the receive queue, the calling thread can suspend (with an optional timeout) until a packet arrives.</span></span>

<span data-ttu-id="f0769-860">UDP 수신 패킷 처리(일반적으로 네트워크 드라이버의 수신 인터럽트 처리기에서 호출됨)는 패킷을 UDP 소켓의 수신 큐에 배치하거나 패킷을 대기 중인 첫 번째 일시 중단된 스레드로 전달하는 역할을 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-860">The UDP receive packet processing (usually called from the network driver's receive interrupt handler) is responsible for either placing the packet on the UDP socket's receive queue or delivering it to the first suspended thread waiting for a packet.</span></span> <span data-ttu-id="f0769-861">패킷이 큐에 있는 경우 수신 처리는 소켓과 관련된 최대 수신 큐 깊이도 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-861">If the packet is queued, the receive processing also checks the maximum receive queue depth associated with the socket.</span></span> <span data-ttu-id="f0769-862">새로 큐에 배치된 패킷이 큐 깊이를 초과하면 큐에서 가장 오래된 패킷이 삭제됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-862">If this newly queued packet exceeds the queue depth, the oldest packet in the queue is discarded.</span></span>

### <a name="udp-receive-notify"></a><span data-ttu-id="f0769-863">UDP 수신 알림</span><span class="sxs-lookup"><span data-stu-id="f0769-863">UDP Receive Notify</span></span>

<span data-ttu-id="f0769-864">애플리케이션 스레드가 둘 이상의 소켓에서 수신된 데이터를 처리해야 하는 경우 ***nx_udp_socket_receive_notify*** 함수를 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-864">If the application thread needs to process received data from more than one socket, the ***nx_udp_socket_receive_notify*** function should be used.</span></span> <span data-ttu-id="f0769-865">이 함수는 소켓에 대한 수신 패킷 콜백 함수를 등록합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-865">This function registers a receive packet callback function for the socket.</span></span> <span data-ttu-id="f0769-866">피켓이 소켓에 수신될 때마다 콜백 함수가 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-866">Whenever a packet is received on the socket, the callback function is executed.</span></span>

<span data-ttu-id="f0769-867">콜백 함수의 내용은 애플리케이션마다 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-867">The contents of the callback function is application-specific.</span></span> <span data-ttu-id="f0769-868">그러나 현재 해당 소켓에서 패킷을 사용할 수 있음을 처리 스레드에 알리기 위한 논리를 포함하고 있을 가능성이 높습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-868">However, it would most likely contain logic to inform the processing thread that a packet is now available on the corresponding socket.</span></span>

### <a name="peer-address-and-port"></a><span data-ttu-id="f0769-869">피어 주소 및 포트</span><span class="sxs-lookup"><span data-stu-id="f0769-869">Peer Address and Port</span></span>

<span data-ttu-id="f0769-870">UDP 패킷을 수신하면 애플리케이션에서 ***nx_udp_packet_info_extract*** 서비스를 사용하여 송신자의 IP 주소와 포트 번호를 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-870">On receiving a UDP packet, application may find the sender's IP address and port number by using the service ***nx_udp_packet_info_extract***.</span></span> <span data-ttu-id="f0769-871">성공적으로 반환되면 이 서비스는 송신자의 IP 주소, 송신자의 포트 번호, 패킷을 수신한 로컬 인터페이스에 대한 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-871">On successful return, this service provides information on the sender's IP address, sender's port number, and the local interface through which the packet was received.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="f0769-872">스레드 일시 중단</span><span class="sxs-lookup"><span data-stu-id="f0769-872">Thread Suspension</span></span>

<span data-ttu-id="f0769-873">앞에서 설명한 대로 애플리케이션 스레드는 특정 UDP 포트에서 UDP 패킷을 수신하려 하는 동안 일시 중단할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-873">As mentioned previously, application threads can suspend while attempting to receive a UDP packet on a particular UDP port.</span></span> <span data-ttu-id="f0769-874">해당 포트에서 패킷이 수신되면 패킷이 일시 중단된 첫 번째 스레드에 제공되고 해당 스레드가 다시 시작됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-874">After a packet is received on that port, it is given to the first thread suspended and that thread is then resumed.</span></span> <span data-ttu-id="f0769-875">대부분의 NetX 서비스에서 사용할 수 있는 기능인 UDP 수신 패킷을 일시 중단할 경우 선택적 시간 제한을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-875">An optional timeout is available when suspending on a UDP receive packet, a feature available for most NetX services.</span></span>

### <a name="udp-socket-statistics-and-errors"></a><span data-ttu-id="f0769-876">UDP 소켓 통계 및 오류</span><span class="sxs-lookup"><span data-stu-id="f0769-876">UDP Socket Statistics and Errors</span></span>

<span data-ttu-id="f0769-877">사용하도록 설정된 경우 NetX UDP 소프트웨어는 애플리케이션에 유용할 수 있는 몇 가지 통계 및 오류를 추적합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-877">If enabled, the NetX UDP socket software keeps track of several statistics and errors that may be useful to the application.</span></span> <span data-ttu-id="f0769-878">각 IP/UDP 인스턴스에 대해 다음 통계 및 오류 보고서가 유지 관리됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-878">The following statistics and error reports are maintained for each IP/UDP instance:</span></span>

- <span data-ttu-id="f0769-879">전송된 총 UDP 패킷</span><span class="sxs-lookup"><span data-stu-id="f0769-879">Total UDP Packets Sent</span></span>
- <span data-ttu-id="f0769-880">전송된 총 UDP 바이트</span><span class="sxs-lookup"><span data-stu-id="f0769-880">Total UDP Bytes Sent</span></span>
- <span data-ttu-id="f0769-881">수신된 총 UDP 패킷</span><span class="sxs-lookup"><span data-stu-id="f0769-881">Total UDP Packets Received</span></span>
- <span data-ttu-id="f0769-882">수신된 총 UDP 바이트</span><span class="sxs-lookup"><span data-stu-id="f0769-882">Total UDP Bytes Received</span></span>
- <span data-ttu-id="f0769-883">총 UDP 잘못된 패킷</span><span class="sxs-lookup"><span data-stu-id="f0769-883">Total UDP Invalid Packets</span></span>
- <span data-ttu-id="f0769-884">삭제된 총 UDP 수신 패킷</span><span class="sxs-lookup"><span data-stu-id="f0769-884">Total UDP Receive Packets Dropped</span></span>
- <span data-ttu-id="f0769-885">총 UDP 수신 체크섬 오류</span><span class="sxs-lookup"><span data-stu-id="f0769-885">Total UDP Receive Checksum Errors</span></span>
- <span data-ttu-id="f0769-886">전송된 UDP 소켓 패킷</span><span class="sxs-lookup"><span data-stu-id="f0769-886">UDP Socket Packets Sent</span></span>
- <span data-ttu-id="f0769-887">전송된 UDP 소켓 바이트</span><span class="sxs-lookup"><span data-stu-id="f0769-887">UDP Socket Bytes Sent</span></span>
- <span data-ttu-id="f0769-888">수신된 UDP 소켓 패킷</span><span class="sxs-lookup"><span data-stu-id="f0769-888">UDP Socket Packets Received</span></span>
- <span data-ttu-id="f0769-889">수신된 UDP 소켓 바이트</span><span class="sxs-lookup"><span data-stu-id="f0769-889">UDP Socket Bytes Received</span></span>
- <span data-ttu-id="f0769-890">큐에 있는 UDP 소켓 패킷</span><span class="sxs-lookup"><span data-stu-id="f0769-890">UDP Socket Packets Queued</span></span>
- <span data-ttu-id="f0769-891">삭제된 UDP 소켓 수신 패킷</span><span class="sxs-lookup"><span data-stu-id="f0769-891">UDP Socket Receive Packets Dropped</span></span>
- <span data-ttu-id="f0769-892">UDP 소켓 체크섬 오류</span><span class="sxs-lookup"><span data-stu-id="f0769-892">UDP Socket Checksum Errors</span></span>

<span data-ttu-id="f0769-893">이 모든 통계 및 오류 보고서는 모든 UDP 소켓을 모은 UDP 통계를 위한 ***nx_udp_info_get*** 서비스와 지정된 UDP 소켓의 UDP 통계를 위한 ***nx_udp_socket_info_get*** 서비스를 통해 애플리케이션에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-893">All these statistics and error reports are available to the application with the ***nx_udp_info_get*** service for UDP statistics amassed over all UDP sockets, and the ***nx_udp_socket_info_get*** service for UDP statistics on the specified UDP socket.</span></span>

### <a name="udp-socket-control-block-nx_udp_socket"></a><span data-ttu-id="f0769-894">UDP 소켓 제어 블록 NX_UDP_SOCKET</span><span class="sxs-lookup"><span data-stu-id="f0769-894">UDP Socket Control Block NX_UDP_SOCKET</span></span>

<span data-ttu-id="f0769-895">각 UDP 소켓의 특성은 관련된 **NX_UDP_SOCKET** 제어 블록에서 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-895">The characteristics of each UDP socket are found in the associated **NX_UDP_SOCKET** control block.</span></span> <span data-ttu-id="f0769-896">IP 데이터 구조에 대한 링크, 정신 및 수신 경로에 대한 네트워크 인터페이스, 바인딩된 포트, 수신 패킷 큐와 같은 유용한 정보를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-896">It contains useful information such as the link to the IP data structure, the network interface for the sending and receiving paths, the bound port, and the receive packet queue.</span></span> <span data-ttu-id="f0769-897">이 구조는 **_nx_api.h_** 파일에서 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-897">This structure is defined in the **_nx_api.h_** file.</span></span>

## <a name="transmission-control-protocol-tcp"></a><span data-ttu-id="f0769-898">TCP(Transmission Control Protocol)</span><span class="sxs-lookup"><span data-stu-id="f0769-898">Transmission Control Protocol (TCP)</span></span>

<span data-ttu-id="f0769-899">TCP(Transmission Control Protocol)는 두 네트워크 멤버(RFC 793) 간의 신뢰할 수 있는 스트림 데이터 전송을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-899">The Transmission Control Protocol (TCP) provides reliable stream data transfer between two network members (RFC 793).</span></span> <span data-ttu-id="f0769-900">한 네트워크 멤버에서 전송된 모든 데이터는 수신 멤버에 의해 확인되고 승인됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-900">All data sent from one network member are verified and acknowledged by the receiving member.</span></span> <span data-ttu-id="f0769-901">또한 두 멤버는 데이터를 전송하기 전에 연결을 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-901">In addition, the two members must have established a connection prior to any data transfer.</span></span> <span data-ttu-id="f0769-902">이로 인해 신뢰할 수 있는 데이터 전송이 가능하지만 앞에서 설명한 UDP 데이터 전송보다 훨씬 많은 오버헤드를 필요로 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-902">All this results in reliable data transfer; however, it does require substantially more overhead than the previously described UDP data transfer.</span></span>

### <a name="tcp-header"></a><span data-ttu-id="f0769-903">TCP 헤더</span><span class="sxs-lookup"><span data-stu-id="f0769-903">TCP Header</span></span>

<span data-ttu-id="f0769-904">전송 시 TCP 헤더는 사용자의 데이터 앞에 배치됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-904">On transmission, TCP header is placed in front of the data from the user.</span></span> <span data-ttu-id="f0769-905">수신 시 TCP 헤더가 들어오는 패킷에서 제거되고 사용자 데이터만 애플리케이션에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-905">On reception, TCP header is removed from the incoming packet, leaving only the user data available to the application.</span></span> <span data-ttu-id="f0769-906">TCP는 IP 프로토콜을 활용하여 패킷을 주고받는데, 이는 패킷이 네트워크에 있을 때 TCP 헤더 앞에 IP 헤더가 있다는 것을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-906">TCP utilizes the IP protocol to send and receive packets, which means there is an IP header in front of the TCP header when the packet is on the network.</span></span> <span data-ttu-id="f0769-907">그림 10에서는 TCP 헤더의 형식을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-907">Figure 10 shows the format of the TCP header.</span></span>

![TCP 헤더](./media/user-guide/tcp-header.png)

<span data-ttu-id="f0769-909">**그림 10. TCP 헤더**</span><span class="sxs-lookup"><span data-stu-id="f0769-909">**FIGURE 10. TCP Header**</span></span>

<span data-ttu-id="f0769-910">다음은 TCP 헤더 형식에 대한 설명입니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-910">The following describes the TCP header format:</span></span>

| <span data-ttu-id="f0769-911">헤더 필드</span><span class="sxs-lookup"><span data-stu-id="f0769-911">Header Field</span></span> | <span data-ttu-id="f0769-912">용도</span><span class="sxs-lookup"><span data-stu-id="f0769-912">Purpose</span></span> |
|---|---|
| <span data-ttu-id="f0769-913">16비트 원본 포트 번호</span><span class="sxs-lookup"><span data-stu-id="f0769-913">16-bit source port number</span></span> | <span data-ttu-id="f0769-914">이 필드에는 TCP 패킷이 전송되는 포트가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-914">This field contains the port the TCP packet is being sent out on.</span></span> <span data-ttu-id="f0769-915">유효한 TCP 포트 범위는 1에서 0xFFFF까지입니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-915">Valid TCP ports range from 1 through 0xFFFF.</span></span> |
| <span data-ttu-id="f0769-916">16비트 대상 포트 번호</span><span class="sxs-lookup"><span data-stu-id="f0769-916">16-bit destination port number</span></span> | <span data-ttu-id="f0769-917">이 필드에는 패킷이 전송되는 TCP 포트가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-917">This field contains the TCP port the packet is being sent to.</span></span> <span data-ttu-id="f0769-918">유효한 TCP 포트 범위는 1에서 0xFFFF까지입니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-918">Valid TCP ports range from 1 through 0xFFFF.</span></span> |
| <span data-ttu-id="f0769-919">32비트 시퀀스 번호</span><span class="sxs-lookup"><span data-stu-id="f0769-919">32-bit sequence number</span></span> | <span data-ttu-id="f0769-920">이 필드에는 연결의 이 끝쪽에서 전송된 데이터의 시퀀스 번호가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-920">This field contains the sequence number for data sent from this end of the connection.</span></span> <span data-ttu-id="f0769-921">원래 시퀀스는 두 TCP 노드 간의 초기 연결 시퀀스 중에 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-921">The original sequence is established during the initial connection sequence between two TCP nodes.</span></span> <span data-ttu-id="f0769-922">해당 지점에서 데이터를 전송할 때마다 시퀀스 번호가 전송된 바이트 양만큼 증가합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-922">Every data transfer from that point results in an increment of the sequence number by the amount bytes sent.</span></span> |
| <span data-ttu-id="f0769-923">32비트 승인 번호</span><span class="sxs-lookup"><span data-stu-id="f0769-923">32-bit acknowledgement number</span></span> | <span data-ttu-id="f0769-924">이 필드에는 연결의 이 쪽에서 마지막으로 수신된 바이트에 해당하는 시퀀스 번호가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-924">This field contains the sequence number corresponding to the last byte received by this side of the connection.</span></span> <span data-ttu-id="f0769-925">이는 이전에 전송된 데이터가 연결의 다른 쪽 끝에서 성공적으로 수신되었는지 여부를 확인하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-925">This is used to determine whether or not data previously sent has successfully been received by the other end of the connection.</span></span> |
| <span data-ttu-id="f0769-926">4비트 헤더 길이</span><span class="sxs-lookup"><span data-stu-id="f0769-926">4-bit header length</span></span>           | <span data-ttu-id="f0769-927">이 필드에는 TCP 헤더의 32비트 단어 수가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-927">This field contains the number of 32-bit words in the TCP header.</span></span> <span data-ttu-id="f0769-928">TCP 헤더에 옵션이 없는 경우 이 필드는 5입니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-928">If no options are present in the TCP header, this field is 5.</span></span> |
| <span data-ttu-id="f0769-929">6비트 코드 비트</span><span class="sxs-lookup"><span data-stu-id="f0769-929">6-bit code bits</span></span>               | <span data-ttu-id="f0769-930">이 필드에는 연결과 관련된 다양한 제어 정보를 나타내는 데 사용되는 6개의 서로 다른 코드 비트가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-930">This field contains the six different code bits used to indicate various control information associated with the connection.</span></span> <span data-ttu-id="f0769-931">제어 비트는 다음과 같이 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-931">The control bits are defined as follows:</span></span> |



| <span data-ttu-id="f0769-932">이름</span><span class="sxs-lookup"><span data-stu-id="f0769-932">Name</span></span> | <span data-ttu-id="f0769-933">bit</span><span class="sxs-lookup"><span data-stu-id="f0769-933">Bit</span></span> | <span data-ttu-id="f0769-934">의미</span><span class="sxs-lookup"><span data-stu-id="f0769-934">Meaning</span></span>                                                     |
|------|-----|-------------------------------------------------------------|
| <span data-ttu-id="f0769-935">URG</span><span class="sxs-lookup"><span data-stu-id="f0769-935">URG</span></span>  | <span data-ttu-id="f0769-936">21</span><span class="sxs-lookup"><span data-stu-id="f0769-936">21</span></span>  | <span data-ttu-id="f0769-937">긴급 데이터 표시</span><span class="sxs-lookup"><span data-stu-id="f0769-937">Urgent data present</span></span>                                         |
| <span data-ttu-id="f0769-938">ACK</span><span class="sxs-lookup"><span data-stu-id="f0769-938">ACK</span></span>  | <span data-ttu-id="f0769-939">20</span><span class="sxs-lookup"><span data-stu-id="f0769-939">20</span></span>  | <span data-ttu-id="f0769-940">승인 번호가 유효합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-940">Acknowledgement number is valid</span></span>                             |
| <span data-ttu-id="f0769-941">PSH</span><span class="sxs-lookup"><span data-stu-id="f0769-941">PSH</span></span>  | <span data-ttu-id="f0769-942">19</span><span class="sxs-lookup"><span data-stu-id="f0769-942">19</span></span>  | <span data-ttu-id="f0769-943">이 데이터를 즉시 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-943">Handle this data immediately</span></span>                                |
| <span data-ttu-id="f0769-944">RST</span><span class="sxs-lookup"><span data-stu-id="f0769-944">RST</span></span>  | <span data-ttu-id="f0769-945">18</span><span class="sxs-lookup"><span data-stu-id="f0769-945">18</span></span>  | <span data-ttu-id="f0769-946">연결을 다시 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-946">Reset the connection</span></span>                                        |
| <span data-ttu-id="f0769-947">SYN</span><span class="sxs-lookup"><span data-stu-id="f0769-947">SYN</span></span>  | <span data-ttu-id="f0769-948">17</span><span class="sxs-lookup"><span data-stu-id="f0769-948">17</span></span>  | <span data-ttu-id="f0769-949">연결 설정에 사용되는 시퀀스 번호를 동기화합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-949">Synchronize sequence numbers (used to establish connection)</span></span> |
| <span data-ttu-id="f0769-950">FIN</span><span class="sxs-lookup"><span data-stu-id="f0769-950">FIN</span></span>  | <span data-ttu-id="f0769-951">16</span><span class="sxs-lookup"><span data-stu-id="f0769-951">16</span></span>  | <span data-ttu-id="f0769-952">송신자가 전송을 완료했습니다(연결을 닫는 데 사용됨).</span><span class="sxs-lookup"><span data-stu-id="f0769-952">Sender is finished with transmit (used to close connection)</span></span> |

<span data-ttu-id="f0769-953">**16비트 창**</span><span class="sxs-lookup"><span data-stu-id="f0769-953">**16-bit window**</span></span>

<span data-ttu-id="f0769-954">이 필드는 흐름 제어에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-954">This field is used for flow control.</span></span> <span data-ttu-id="f0769-955">소켓이 현재 수신할 수 있는 바이트의 양이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-955">It contains the amount of bytes the socket can currently receive.</span></span> <span data-ttu-id="f0769-956">이는 기본적으로 흐름 제어에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-956">This basically is used for flow control.</span></span> <span data-ttu-id="f0769-957">송신자는 전송할 데이터가 수신자의 수신 가능 창에 맞는지 확인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-957">The sender is responsible for making sure the data to send will fit into the receiver’s advertised window.</span></span>

| <span data-ttu-id="f0769-958">**헤더 필드**</span><span class="sxs-lookup"><span data-stu-id="f0769-958">**Header Field**</span></span>          | <span data-ttu-id="f0769-959">**용도**</span><span class="sxs-lookup"><span data-stu-id="f0769-959">**Purpose**</span></span> |
| ------------------------- | --- |
| <span data-ttu-id="f0769-960">**16비트 TCP 체크섬**</span><span class="sxs-lookup"><span data-stu-id="f0769-960">**16-bit TCP checksum**</span></span>   | <span data-ttu-id="f0769-961">이 필드에는 TCP 헤더, 패킷 데이터 영역, 의사 IP 헤더를 포함하는 패킷에 대한 16비트 체크섬이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-961">This field contains the 16-bit checksum for the packet including the TCP header, the packet data area, and the pseudo IP header.</span></span>                |
| <span data-ttu-id="f0769-962">**16비트 긴급 포인터**</span><span class="sxs-lookup"><span data-stu-id="f0769-962">**16-bit urgent pointer**</span></span> | <span data-ttu-id="f0769-963">이 필드에는 긴급 데이터의 마지막 바이트의 양수 오프셋이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-963">This field contains the positive offset of the last byte of the urgent data.</span></span> <span data-ttu-id="f0769-964">이 필드는 URG 코드 비트가 헤더에 설정된 경우에만 유효합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-964">This field is only valid if the URG code bit is set in the header.</span></span> |

> [!IMPORTANT]
> <span data-ttu-id="f0769-965">TCP/IP 구현의 모든 헤더는 big endian 형식이어야 합니다. 이 형식에서 단어의 가장 중요한 바이트는 가장 낮은 바이트 주소에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-965">*All headers in the TCP/IP implementation are expected to be in big endian format. In this format, the most significant byte of the word resides at the lowest byte address.*</span></span>

### <a name="tcp-enable"></a><span data-ttu-id="f0769-966">TCP 사용</span><span class="sxs-lookup"><span data-stu-id="f0769-966">TCP Enable</span></span>

<span data-ttu-id="f0769-967">TCP 연결 및 패킷 전송을 사용하려면 먼저 애플리케이션이 nx_tcp_enable 서비스를 호출하여 TCP를 사용하도록 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-967">Before TCP connections and packet transmissions are possible, the application must first enable TCP by calling the nx_tcp_enable service.</span></span> <span data-ttu-id="f0769-968">사용하도록 설정된 후 애플리케이션은 모든 TCP 서비스에 자유롭게 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-968">After enabled, the application is free to access all TCP services.</span></span>

### <a name="tcp-socket-create"></a><span data-ttu-id="f0769-969">TCP 소켓 만들기</span><span class="sxs-lookup"><span data-stu-id="f0769-969">TCP Socket Create</span></span>

<span data-ttu-id="f0769-970">TCP 소켓은 초기화 중에 또는 애플리케이션 스레드에 의한 런타임 중에 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-970">TCP sockets are created either during initialization or during runtime by application threads.</span></span> <span data-ttu-id="f0769-971">초기 서비스 형식, TTL(Time-to-Live), 창 크기는 ***nx_tcp_socket_create*** 서비스에 의해 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-971">The initial type of service, time to live, and window size are defined by the ***nx_tcp_socket_create*** service.</span></span> <span data-ttu-id="f0769-972">애플리케이션의 TCP 소켓 수에는 제한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-972">There are no limits on the number of TCP sockets in an application.</span></span>

### <a name="tcp-checksum"></a><span data-ttu-id="f0769-973">TCP 체크섬</span><span class="sxs-lookup"><span data-stu-id="f0769-973">TCP Checksum</span></span>

<span data-ttu-id="f0769-974">TCP는 IP 의사 헤더(소스 IP 주소, 대상 IP 주소, 프로토콜/길이 IP 단어로 구성), TCP 헤더, TCP 패킷 데이터를 포함하는 1의 보수 16비트 체크섬을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-974">TCP specifies a one’s complement 16-bit checksum that covers the IP pseudo header, (consisting of the source IP address, destination IP address, and the protocol/length IP word), the TCP header, and the TCP packet data.</span></span>

<span data-ttu-id="f0769-975">특정 네트워크 컨트롤러는 하드웨어에서 TCP 체크섬 계산 및 유효성 검사를 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-975">Certain network controllers are able to perform TCP checksum computation and validation in hardware.</span></span> <span data-ttu-id="f0769-976">이러한 시스템의 경우, 애플리케이션은 런타임 오버헤드를 줄이기 위해 가능한 한 많은 하드웨어 체크섬 논리를 사용해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-976">For such systems, applications may want to use hardware checksum logic as much as possible to reduce runtime overhead.</span></span> <span data-ttu-id="f0769-977">애플리케이션은 빌드 시 **NX_DISABLE_TCP_TX_CHECKSUM** 및 **NX_DISABLE_TCP_RX_CHECKSUM** 을 정의하여 NetX 라이브러리에서 TCP 체크섬 계산 논리를 모두 사용하지 않도록 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-977">Applications may disable TCP checksum computation logic from the NetX library altogether at build time by defining **NX_DISABLE_TCP_TX_CHECKSUM** and **NX_DISABLE_TCP_RX_CHECKSUM**.</span></span> <span data-ttu-id="f0769-978">이렇게 하면 TCP 체크섬 코드는 컴파일되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-978">This way, the TCP checksum code is not compiled in.</span></span>

### <a name="tcp-port"></a><span data-ttu-id="f0769-979">TCP 포트</span><span class="sxs-lookup"><span data-stu-id="f0769-979">TCP Port</span></span>

<span data-ttu-id="f0769-980">TCP 포트는 TCP 프로토콜의 논리적 연결 지점입니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-980">A TCP port is a logical connection point in the TCP protocol.</span></span> <span data-ttu-id="f0769-981">NetX의 TCP 구성 요소에는 65,535개의 유효한 포트가 있으며, 범위는 1 ~ 0xFFFF입니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-981">There are 65,535 valid ports in the TCP component of NetX, ranging from 1 through 0xFFFF.</span></span> <span data-ttu-id="f0769-982">한 포트의 데이터를 다른 대상 포트로 전송할 수 있는 UDP와 달리 TCP 포트는 다른 특정 TCP 포트에 연결되며 이 연결이 설정될 때, 연결을 구성하는 두 포트 사이에서만 데이터 전송이 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-982">Unlike UDP in which data from one port can be sent to any other destination port, a TCP port is connected to another specific TCP port, and only when this connection is established can any data transfer take place—and only between the two ports making up the connection.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="f0769-983">TCP 포트는 UDP 포트와 완전히 분리되어 있습니다. 예를 들어, UDP 포트 번호 1은 TCP 포트 번호 1과 관련이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-983">*TCP ports are completely separate from UDP ports; e.g., UDP port number 1 has no relation to TCP port number 1.*</span></span>

## <a name="client-server-model"></a><span data-ttu-id="f0769-984">클라이언트 서버 모델</span><span class="sxs-lookup"><span data-stu-id="f0769-984">Client-Server Model</span></span>

<span data-ttu-id="f0769-985">데이터 전송에 TCP를 사용하려면 먼저 두 TCP 소켓 사이에 연결을 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-985">To use TCP for data transfer, a connection must first be established between the two TCP sockets.</span></span> <span data-ttu-id="f0769-986">연결 설정은 클라이언트 서버 방식으로 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-986">The establishment of the connection is done in a client-server fashion.</span></span> <span data-ttu-id="f0769-987">연결의 클라이언트 쪽은 연결을 시작하는 쪽이고, 서버 쪽은 처리가 완료되기 전에 클라이언트 연결 요청을 기다리기만 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-987">The client side of the connection is the side that initiates the connection, while the server side simply waits for client connection requests before any processing is done.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="f0769-988">멀티홈 디바이스의 경우 NetX는 연결에 사용할 원본 주소와 연결의 대상 IP 주소를 기준으로 하는 다음 홉 주소를 자동으로 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-988">*For multihome devices, NetX automatically determines the source address to use for the connection, and the next hop address based on the destination IP address of the connection.*</span></span>

### <a name="tcp-socket-state-machine"></a><span data-ttu-id="f0769-989">TCP 소켓 상태 시스템</span><span class="sxs-lookup"><span data-stu-id="f0769-989">TCP Socket State Machine</span></span>

<span data-ttu-id="f0769-990">두 TCP 소켓(하나의 클라이언트와 하나의 서버) 간의 연결이 복잡하며 상태 시스템 방식으로 관리됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-990">The connection between two TCP sockets (one client and one server) is complex and is managed in a state machine manner.</span></span> <span data-ttu-id="f0769-991">각 TCP 소켓은 CLOSED 상태로 시작됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-991">Each TCP socket starts in a CLOSED state.</span></span> <span data-ttu-id="f0769-992">연결 이벤트를 통해 각 소켓의 상태 시스템은 TCP 데이터 전송의 대부분을 ESTABLISHED 상태로 마이그레이션합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-992">Through connection events each socket's state machine migrates into the ESTABLISHED state, which is where the bulk of the data transfer in TCP takes place.</span></span> <span data-ttu-id="f0769-993">연결의 한쪽이 더 이상 데이터를 전송하지 않으려는 경우 연결이 끊어집니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-993">When one side of the connection no longer wishes to send data, it disconnects.</span></span> <span data-ttu-id="f0769-994">다른 쪽의 연결이 끊긴 후, 결국 TCP 소켓은 CLOSED 상태로 돌아갑니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-994">After the other side disconnects, eventually the TCP socket returns to the CLOSED state.</span></span> <span data-ttu-id="f0769-995">이 프로세스는 TCP 클라이언트와 서버가 연결을 설정하고 닫을 때마다 반복됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-995">This process repeats each time a TCP client and server establish and close a connection.</span></span> <span data-ttu-id="f0769-996">그림 11에서는 TCP 상태 시스템의 다양한 상태를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-996">Figure 11 shows the various states of the TCP state machine.</span></span>

![TCP 상태 시스템의 상태](./media/user-guide/states-tcp-state-machine.png)

### <a name="figure-11-states-of-the-tcp-state-machine"></a><span data-ttu-id="f0769-998">그림 11.</span><span class="sxs-lookup"><span data-stu-id="f0769-998">FIGURE 11.</span></span> <span data-ttu-id="f0769-999">TCP 상태 시스템의 상태</span><span class="sxs-lookup"><span data-stu-id="f0769-999">States of the TCP State Machine</span></span>

### <a name="tcp-client-connection"></a><span data-ttu-id="f0769-1000">TCP 클라이언트 연결</span><span class="sxs-lookup"><span data-stu-id="f0769-1000">TCP Client Connection</span></span>

<span data-ttu-id="f0769-1001">앞에서 설명한 대로 TCP 연결의 클라이언트 측에서 TCP 서버에 대한 연결 요청을 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1001">As mentioned previously, the client side of the TCP connection initiates a connection request to a TCP server.</span></span> <span data-ttu-id="f0769-1002">연결 요청을 하려면 먼저 클라이언트 IP 인스턴스에서 TCP를 사용하도록 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1002">Before a connection request can be made, TCP must be enabled on the client IP instance.</span></span> <span data-ttu-id="f0769-1003">또한 클라이언트 TCP 소켓은 다음에 \***nx_tcp_socket_create**_ 서비스를 사용하여 만들고 _\*nx_tcp_client_socket_bind 서비스를 통해 포트에 바인딩되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1003">In addition, the client TCP socket must next be created with the ***nx_tcp_socket_create** _ service and bound to a port via the _*_nx_tcp_client_socket_bind_\*_ service.</span></span> <span data-ttu-id="f0769-1004">클라이언트 소켓이 바인딩된 후에는 _ _nx_tcp_client_socket_connect_\* 서비스를 사용하여 TCP 서버와의 연결을 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1004">After the client socket is bound, the _ *_nx_tcp_client_socket_connect_*\* service is used to establish a connection with a TCP server.</span></span> <span data-ttu-id="f0769-1005">연결 시도를 시작하려면 소켓이 CLOSED 상태여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1005">Note the socket must be in a CLOSED state to initiate a connection attempt.</span></span> <span data-ttu-id="f0769-1006">연결 설정은 NetX가 SYN 패킷을 실행한 다음 서버에서 SYN ACK 패킷을 다시 대기하는 것으로 시작하며 이는 연결 요청에 대한 승인을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1006">Establishing the connection starts with NetX issuing a SYN packet and then waiting for a SYN ACK packet back from the server, which signifies acceptance of the connection request.</span></span> <span data-ttu-id="f0769-1007">SYN ACK가 수신되면 NetX는 ACK 패킷으로 응답하고 클라이언트 소켓을 ESTABLISHED 상태로 수준을 올립니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1007">After the SYN ACK is received, NetX responds with an ACK packet and promotes the client socket to the ESTABLISHED state.</span></span>

### <a name="tcp-client-disconnection"></a><span data-ttu-id="f0769-1008">TCP 클라이언트 연결 끊기</span><span class="sxs-lookup"><span data-stu-id="f0769-1008">TCP Client Disconnection</span></span>

<span data-ttu-id="f0769-1009">***nx_tcp_socket_disconnect*** 를 호출하여 연결을 닫습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1009">Closing the connection is accomplished by calling ***nx_tcp_socket_disconnect***.</span></span> <span data-ttu-id="f0769-1010">일시 중단이 지정되지 않은 경우 클라이언트 소켓은 RST 패킷을 서버 소켓으로 전송하고 소켓을 CLOSED 상태로 둡니다</span><span class="sxs-lookup"><span data-stu-id="f0769-1010">If no suspension is specified, the client socket sends a RST packet to the server socket and places the socket in the CLOSED state.</span></span> <span data-ttu-id="f0769-1011">그렇지 않고 일시 중단이 요청되면 다음과 같이 전체 TCP 연결 끊기 프로토콜이 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1011">Otherwise, if a suspension is requested, the full TCP disconnect protocol is performed, as follows:</span></span>

- <span data-ttu-id="f0769-1012">서버가 이전에 연결 끊기 요청을 시작한 경우(클라이언트 소켓이 이미 FIN 패킷을 수신하여 ACK로 응답하고 CLOSE WAIT 상태에 있음), NetX는 클라이언트 TCP 소켓 상태를 LAST ACK 상태로 승격하고 FIN 패킷을 전송합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1012">If the server previously initiated a disconnect request (the client socket has already received a FIN packet, responded with an ACK, and is in the CLOSE WAIT state), NetX promotes the client TCP socket state to the LAST ACK state and sends a FIN packet.</span></span> <span data-ttu-id="f0769-1013">그런 다음, 서버로부터 ACK를 기다렸다가 연결을 끊고 CLOSED 상태로 들어갑니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1013">It then waits for an ACK from the server before completing the disconnect and entering the CLOSED state.</span></span>

- <span data-ttu-id="f0769-1014">반면에 클라이언트가 연결 해제 요청을 가장 먼저 시작하는 경우(서버는 연결이 끊기지 않았으며 소켓은 여전히 ESTABLISHED 상태) NetX는 연결을 해제하기 위해 FIN 패킷을 전송하고 서버로부터 FIN과 ACK를 받기 위해 대기한 후 연결을 완전히 끊고 소켓을 CLOSED 상태로 둡니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1014">If on the other hand, the client is the first to initiate a disconnect request (the server has not disconnected and the socket is still in the ESTABLISHED state), NetX sends a FIN packet to initiate the disconnect and waits to receive a FIN and an ACK from the server before completing the disconnect and placing the socket in a CLOSED state.</span></span>

<span data-ttu-id="f0769-1015">소켓 전송 큐에 여전히 패킷이 있는 경우 NetX는 패킷을 승인할 수 있도록 지정된 시간 제한을 일시 중단합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1015">If there are still packets on the socket transmit queue, NetX suspends for the specified timeout to allow the packets to be acknowledged.</span></span> <span data-ttu-id="f0769-1016">시간 제한이 만료되면 NetX는 클라이언트 소켓의 전송 큐를 비웁니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1016">If the timeout expires, NetX empties the transmit queue of the client socket.</span></span>

<span data-ttu-id="f0769-1017">클라이언트 소켓에서 포트의 바인딩을 해제하기 위해 애플리케이션은 ***nx_tcp_client_socket_unbind*** 를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1017">To unbind the port from the client socket, the application calls ***nx_tcp_client_socket_unbind***.</span></span> <span data-ttu-id="f0769-1018">포트가 해제되기 전에 소켓이 CLOSED 상태이거나 연결 끊기(예: TIMED WAIT 상태) 프로세스 중이어야 합니다. 그렇지 않으면 오류가 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1018">The socket must be in a CLOSED state or in the process of disconnecting (i.e., TIMED WAIT state) before the port is released; otherwise, an error is returned.</span></span>

<span data-ttu-id="f0769-1019">마지막으로, 애플리케이션이 더 이상 클라이언트 소켓을 필요로 하지 않으면 ***nx_tcp_socket_delete*** 를 호출하여 소켓을 삭제합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1019">Finally, if the application no longer needs the client socket, it calls ***nx_tcp_socket_delete*** to delete the socket.</span></span>

### <a name="tcp-server-connection"></a><span data-ttu-id="f0769-1020">TCP 서버 연결</span><span class="sxs-lookup"><span data-stu-id="f0769-1020">TCP Server Connection</span></span>

<span data-ttu-id="f0769-1021">TCP 연결의 서버 측은 수동적입니다. 즉, 서버는 클라이언트가 연결 요청을 시작할 때까지 기다립니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1021">The server side of a TCP connection is passive; i.e., the server waits for a client to initiate connection request.</span></span> <span data-ttu-id="f0769-1022">클라이언트 연결을 허용하려면 먼저 \***nx_tcp_enable** _ 서비스를 호출하여 IP 인스턴스에서 TCP를 사용하도록 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1022">To accept a client connection, TCP must first be enabled on the IP instance by calling the service \***nx_tcp_enable** _.</span></span> <span data-ttu-id="f0769-1023">다음으로 애플리케이션은 _ _nx_tcp_socket_create_\* 서비스를 사용하여 TCP 소켓을 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1023">Next, the application must create a TCP socket using the _ *_nx_tcp_socket_create_*\* service.</span></span>

<span data-ttu-id="f0769-1024">서버 소켓이 연결 요청을 수신 대기하도록 설정되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1024">The server socket must also be set up for listening for connection requests.</span></span> <span data-ttu-id="f0769-1025">이 작업은 ***nx_tcp_server_socket_listen*** 서비스를 사용하여 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1025">This is achieved by using the ***nx_tcp_server_socket_listen*** service.</span></span> <span data-ttu-id="f0769-1026">이 서비스는 서버 소켓을 LISTEN 상태로 두고 지정된 서버 포트를 소켓에 바인딩합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1026">This service places the server socket in the LISTEN state and binds the specified server port to the socket.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="f0769-1027">소켓 수신 대기 콜백 루틴을 설정하기 위해 애플리케이션은 **nx_tcp_server_socket_listen** 서비스의 tcp_listen_callback 인수에 대해 적절한 콜백 함수를 지정합니다. 그런 다음, 이 애플리케이션 콜백 함수는 이 서버 포트에서 새로운 연결이 요청될 때마다 NetX에 의해 실행됩니다. 콜백의 처리는 애플리케이션 제어 중입니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1027">*To set a socket listen callback routine the application specifies the appropriate callback function for the tcp_listen_callback argument of the **nx_tcp_server_socket_listen** service. This application callback function is then executed by NetX whenever a new connection is requested on this server port. The processing in the callback is under application control.*</span></span>

<span data-ttu-id="f0769-1028">클라이언트 연결 요청을 수락하기 위해 애플리케이션은 \***nx_tcp_server_socket_accept** _ 서비스를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1028">To accept client connection requests, the application calls the \***nx_tcp_server_socket_accept** _ service.</span></span> <span data-ttu-id="f0769-1029">수락 서비스를 호출하려면 서버 소켓이 LISTEN 상태 또는 SYN RECEIVED 상태(즉, 서버가 LISTEN 상태이고 연결을 요청하는 클라이언트로부터 SYN 패킷을 수신함)여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1029">The server socket must either be in a LISTEN state or a SYN RECEIVED state (i.e., the server is in the LISTEN state and has received a SYN packet from a client requesting a connection) to call the accept service.</span></span> <span data-ttu-id="f0769-1030">_ _nx_tcp_server_socket_accept_\*에서 성공적으로 반환되면 연결이 설정되었으며 서버 소켓이 ESTABLISHED 상태에 있음을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1030">A successful return status from _ *_nx_tcp_server_socket_accept_*\* indicates the connection has been set up and the server socket is in the ESTABLISHED state.</span></span>

<span data-ttu-id="f0769-1031">서버 소켓에 유효한 연결이 있으면 추가 클라이언트 연결 요청이 listen_queue_size에 의해 지정된 깊이까지 큐에 대기하고 \***nx_tcp_server_socket_listen** _ 서비스에 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1031">After the server socket has a valid connection, additional client connection requests are queued up to the depth specified by the *listen_queue_size*, passed into the \***nx_tcp_server_socket_listen** _ service.</span></span> <span data-ttu-id="f0769-1032">서버 포트에서 후속 연결을 처리하려면 애플리케이션은 사용 가능한 소켓(즉, CLOSED 상태의 소켓)을 사용하여 _ _nx_tcp_server_socket_relisten_\*를 호출해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1032">In order to process subsequent connections on a server port, the application must call _ *_nx_tcp_server_socket_relisten_*\* with an available socket (i.e., a socket in a CLOSED state).</span></span> <span data-ttu-id="f0769-1033">소켓과 연결된 이전 연결이 완료되고 소켓이 CLOSED 상태인 경우 동일한 서버 소켓을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1033">Note that the same server socket could be used if the previous connection associated with the socket is now finished and the socket is in the CLOSED state.</span></span>

### <a name="tcp-server-disconnection"></a><span data-ttu-id="f0769-1034">TCP 서버 연결 끊기</span><span class="sxs-lookup"><span data-stu-id="f0769-1034">TCP Server Disconnection</span></span>

<span data-ttu-id="f0769-1035">***nx_tcp_socket_disconnect*** 를 호출하여 연결을 닫습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1035">Closing the connection is accomplished by calling ***nx_tcp_socket_disconnect***.</span></span> <span data-ttu-id="f0769-1036">일시 중단이 지정되지 않은 경우 서버 소켓은 RST 패킷을 클라이언트 소켓으로 전송하고 소켓을 CLOSED 상태로 둡니다</span><span class="sxs-lookup"><span data-stu-id="f0769-1036">If no suspension is specified, the server socket sends a RST packet to the client socket and places the socket in the CLOSED state.</span></span> <span data-ttu-id="f0769-1037">그렇지 않고 일시 중단이 요청되면 다음과 같이 전체 TCP 연결 끊기 프로토콜이 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1037">Otherwise, if a suspension is requested, the full TCP disconnect protocol is performed, as follows: |</span></span>

- <span data-ttu-id="f0769-1038">클라이언트가 이전에 연결 끊기 요청을 시작한 경우(서버 소켓이 이미 FIN 패킷을 수신하여 ACK로 응답하고 CLOSE WAIT 상태에 있음), NetX는 TCP 소켓 상태를 LAST ACK 상태로 승격하고 FIN 패킷을 전송합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1038">If the client previously initiated a disconnect request (the server socket has already received a FIN packet, responded with an ACK, and is in the CLOSE WAIT state), NetX promotes the TCP socket state to the LAST ACK state and sends a FIN packet.</span></span> <span data-ttu-id="f0769-1039">그런 다음, 클라이언트로부터 ACK를 기다렸다가 연결을 끊고 CLOSED 상태로 들어갑니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1039">It then waits for an ACK from the client before completing the disconnect and entering the CLOSED state.</span></span>

- <span data-ttu-id="f0769-1040">반면에 서버가 연결 해제 요청을 가장 먼저 시작하는 경우(클라이언트는 연결이 끊기지 않았으며 소켓은 여전히 ESTABLISHED 상태) NetX는 연결을 해제하기 위해 FIN 패킷을 전송하고 클라이언트로부터 FIN과 ACK를 받기 위해 대기한 후 연결을 완전히 끊고 소켓을 CLOSED 상태로 둡니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1040">If on the other hand, the server is the first to initiate a disconnect request (the client has not disconnected and the socket is still in the ESTABLISHED state), NetX sends a FIN packet to initiate the disconnect and waits to receive a FIN and an ACK from the client before completing the disconnect and placing the socket in a CLOSED state.</span></span>

<span data-ttu-id="f0769-1041">소켓 전송 큐에 여전히 패킷이 있는 경우 NetX는 패킷을 승인할 수 있도록 지정된 시간 제한을 일시 중단합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1041">If there are still packets on the socket transmit queue, NetX suspends for the specified timeout to allow those packets to be acknowledged.</span></span> <span data-ttu-id="f0769-1042">시간 제한이 만료되면 NetX는 서버 소켓의 전송 큐를 플러시합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1042">If the timeout expires, NetX flushes the transmit queue of the server socket.</span></span>

<span data-ttu-id="f0769-1043">연결 끊기 처리가 완료되고 서버 소켓이 CLOSED 상태이면 애플리케이션은 ***nx_tcp_server_socket_unaccept*** 서비스를 호출하여 이 소켓과 서버 포트와의 연결을 종료해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1043">After the disconnect processing is complete and the server socket is in the CLOSED state, the application must call the ***nx_tcp_server_socket_unaccept*** service to end the association of this socket with the server port.</span></span> <span data-ttu-id="f0769-1044">***nx_tcp_socket_disconnect*** 또는 \***nx_tcp_server_socket_accept** _를 오류 상태로 반환하는 경우에도 애플리케이션에서 이 서비스를 호출해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1044">Note this service must be called by the application even if ***nx_tcp_socket_disconnect*** or \***nx_tcp_server_socket_accept** _ return an error status.</span></span> <span data-ttu-id="f0769-1045">_nx_tcp_server_socket_unaccept_ 를 반환한 후, 소켓을 클라이언트나 서버 소켓으로 사용할 수 있으며 더 이상 필요하지 않은 경우에는 삭제 할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1045">After the _ *_nx_tcp_server_socket_unaccept_*\* returns, the socket can be used as a client or server socket, or even deleted if it is no longer needed.</span></span> <span data-ttu-id="f0769-1046">동일한 서버 포트에서 다른 클라이언트 연결을 허용하려면 이 소켓에서 ***nx_tcp_server_socket_relisten*** 서비스를 호출해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1046">If accepting another client connection on the same server port is desired, the ***nx_tcp_server_socket_relisten*** service should be called on this socket.</span></span>

<span data-ttu-id="f0769-1047">다음 코드 세그먼트는 일반적인 TCP 서버가 사용하는 호출 시퀀스를 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1047">The following code segment illustrates the sequence of calls a typical TCP server uses:</span></span>

```c
/* Set up a previously created TCP socket to listen on port 12 */

nx_tcp_server_socket_listen()

/* Loop to make a (another) connection. */
while(1) {

    /* Wait for a client socket connection request for 100 ticks. */
    nx_tcp_server_socket_accept();

    /* (Send and receive TCP messages with the TCP client) */

    /* Disconnect the server socket. */
    nx_tcp_socket_disconnect();

    /* Remove this server socket from listening on the port. */

    nx_tcp_server_socket_unaccept(&server_socket);

    /* Set up server socket to relisten on the same port for the next
    client. */
    nx_tcp_server_socket_relisten();
}
```

### <a name="mss-validation"></a><span data-ttu-id="f0769-1048">MSS 유효성 검사</span><span class="sxs-lookup"><span data-stu-id="f0769-1048">MSS Validation</span></span>

<span data-ttu-id="f0769-1049">MSS(최대 세그먼트 크기)는 TCP 호스트가 기본 IP 계층에 의해 조각나지 않고 수신할 수 있는 최대 바이트 수입니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1049">The Maximum Segment Size (MSS) is the maximum amount of bytes a TCP host can receive without being fragmented by the underlying IP layer.</span></span> <span data-ttu-id="f0769-1050">TCP 연결 설정 단계를 수행하는 동안 양쪽 끝에서 자체 TCP MSS 값을 교환하여 송신자가 수신자의 MSS보다 큰 TCP 데이터 세그먼트를 전송하지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1050">During TCP connection establishment phase, both ends exchanges its own TCP MSS value, so that the sender does not send a TCP data segment that is larger than the receiver's MSS.</span></span> <span data-ttu-id="f0769-1051">NetX TCP 모듈은 연결을 설정하기 전에 피어의 보급된 MSS 값의 유효성을 선택적으로 검사합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1051">NetX TCP module will optionally validate its peer's advertised MSS value before establishing a connection.</span></span> <span data-ttu-id="f0769-1052">기본적으로 NetX는 이러한 검사를 사용하도록 설정하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1052">By default NetX does not enable such a check.</span></span> <span data-ttu-id="f0769-1053">MSS 유효성 검사를 수행하려는 애플리케이션은 NetX 라이브러리를 빌드할 때 ***NX_ENABLE_TCP_MSS_CHECKING** _를 정의해야 하며 최솟값은 _*_NX_TCP_MSS_MINIMUM_\*_ 에 정의되어 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1053">Applications wishing to perform MSS validation shall define ***NX_ENABLE_TCP_MSS_CHECKING** _ when building the NetX library, and the minimum value shall be defined in _*_NX_TCP_MSS_MINIMUM_\*_.</span></span> <span data-ttu-id="f0769-1054">MSS 값이 _ _NX_TCP_MSS_MINIMUM_\* 미만으로 들어오는 TCP 연결이 삭제됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1054">Incoming TCP connections with MSS values below _ *_NX_TCP_MSS_MINIMUM_*\* are dropped.</span></span>

### <a name="stop-listening-on-a-server-port"></a><span data-ttu-id="f0769-1055">서버 포트에서 수신 대기 중지</span><span class="sxs-lookup"><span data-stu-id="f0769-1055">Stop Listening on a Server Port</span></span>

<span data-ttu-id="f0769-1056">애플리케이션이 이전에 ***nx_tcp_server_socket_listen** _ 서비스에 대한 호출로 이전에 지정된 서버 포트에서 클라이언트 연결 요청을 더 이상 수신 대기하지 않으려는 경우, 애플리케이션은 _ *_nx_tcp_server_socket_unlisten_** 서비스를 호출하기만 하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1056">If the application no longer wishes to listen for client connection requests on a server port that was previously specified by a call to the ***nx_tcp_server_socket_listen** _ service, the application simply calls the _ *_nx_tcp_server_socket_unlisten_** service.</span></span> <span data-ttu-id="f0769-1057">이 서비스는 연결을 기다리는 소켓을 다시 CLOSED 상태로 두고 큐에 있는 클라이언트 연결 요청 패킷을 모두 해제합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1057">This service places any socket waiting for a connection back in the CLOSED state and releases any queued client connection request packets.</span></span>

### <a name="tcp-window-size"></a><span data-ttu-id="f0769-1058">TCP 창 크기</span><span class="sxs-lookup"><span data-stu-id="f0769-1058">TCP Window Size</span></span>

<span data-ttu-id="f0769-1059">연결의 설정 및 데이터 전송 단계를 수행하는 동안 각 포트는 처리할 수 있는 데이터 양을 보고합니다. 이를 창 크기라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1059">During both the setup and data transfer phases of the connection, each port reports the amount of data it can handle, which is called its window size.</span></span> <span data-ttu-id="f0769-1060">데이터가 수신되고 처리되면 이 창 크기는 동적으로 조정됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1060">As data are received and processed, this window size is adjusted dynamically.</span></span> <span data-ttu-id="f0769-1061">TCP에서 송신자는 수신자의 창에 맞는 양의 데이터만 전송할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1061">In TCP, a sender can only send an amount of data that fits into the receiver's window.</span></span> <span data-ttu-id="f0769-1062">기본적으로 창 크기는 연결의 각 방향에서 데이터 전송을 위한 흐름 제어를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1062">In essence, the window size provides flow control for data transfer in each direction of the connection.</span></span>

### <a name="tcp-packet-send"></a><span data-ttu-id="f0769-1063">TCP 패킷 전송</span><span class="sxs-lookup"><span data-stu-id="f0769-1063">TCP Packet Send</span></span>

<span data-ttu-id="f0769-1064">***nx_tcp_socket_send*** 함수를 호출하여 TCP 데이터 전송을 쉽게 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1064">Sending TCP data is easily accomplished by calling the ***nx_tcp_socket_send*** function.</span></span> <span data-ttu-id="f0769-1065">전송 중인 데이터의 크기가 소켓의 MSS 값 또는 현재 피어 수신 창 크기 중 더 작은 값보다 클 경우, TCP 내부 논리는 전송을 위해 최소 크기(MSS, 피어 수신 창)에 맞는 데이터를 잘라냅니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1065">If the size of the data being transmitted is larger than the MSS value of the socket or the current peer receive window size, whichever is smaller, TCP internal logic carves off the data that fits into min (MSS, peer receive Window) for transmission.</span></span> <span data-ttu-id="f0769-1066">그런 다음, 이 서비스는 체크섬 계산을 포함하여 패킷 앞에 TCP 헤더를 빌드합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1066">This service then builds a TCP header in front of the packet (including the checksum calculation).</span></span> <span data-ttu-id="f0769-1067">수신자의 창 크기가 0이 아닌 경우, 호출자는 수신자 창 크기를 채울 수 있는 만큼의 최대한 많은 데이터를 전송합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1067">If the receiver's window size is not zero, the caller will send as much data as it can to fill up the receiver window size.</span></span> <span data-ttu-id="f0769-1068">수신 창이 0이 되면, 호출자는 이 패킷을 보낼 수 있을 만큼 수신자의 창 크기가 커지기를 일시 중단하고 대기할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1068">If the receive window becomes zero, the caller may suspend and wait for the receiver's window size to increase enough for this packet to be sent.</span></span> <span data-ttu-id="f0769-1069">언제든지 여러 스레드가 동일한 소켓을 통해 데이터를 전송하는 동안 스레드는 일시 중단될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1069">At any given time, multiple threads may suspend while trying to send data through the same socket.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="f0769-1070">NX_PACKET 구조에 있는 TCP 데이터는 긴 단어 경계에 있어야 합니다. 또한 앞에 추가 포인터와 데이터 시작 포인터 사이에 TCP, IP, 실제 미디어 헤더가 배치될 수 있도록 충분한 공간이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1070">*The TCP data residing in the NX_PACKET structure should reside on a long-word boundary. In addition, there needs to be sufficient space between the prepend pointer and the data start pointer to place the TCP, IP, and physical media headers.*</span></span>

### <a name="tcp-packet-retransmit"></a><span data-ttu-id="f0769-1071">TCP 패킷 재전송</span><span class="sxs-lookup"><span data-stu-id="f0769-1071">TCP Packet Retransmit</span></span>

<span data-ttu-id="f0769-1072">이전에 전송된 TCP 패킷은 ACK가 연결의 다른 쪽에서 반환될 때까지 실제로 내부적으로 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1072">Previously transmitted TCP packets sent actually stored internally until an ACK is returned from the other side of the connection.</span></span> <span data-ttu-id="f0769-1073">전송된 데이터가 시간 제한 기간 내에 승인되지 않으면 저장된 패킷이 다시 전송되고 다음 시간 제한 기간이 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1073">If transmitted data is not acknowledged within the timeout period, the stored packet is re-sent and the next timeout period is set.</span></span> <span data-ttu-id="f0769-1074">ACK가 수신되면 내부 전송 큐의 승인 번호로 처리되는 모든 패킷이 최종적으로 해제됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1074">When an ACK is received, all packets covered by the acknowledgement number in the internal transmit queue are finally released.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="f0769-1075">\*애플리케이션은 \***nx_tcp_socket_send** _ 함수가 NX_SUCCESS와 함께 반환된 후 패킷을 다시 사용하거나 패킷의 내용을 변경하지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1075">\*Application shall not reuse the packet or alter the contents of the packet after the \***nx_tcp_socket_send** _ function returns with NX_SUCCESS.</span></span> <span data-ttu-id="f0769-1076">전송된 패킷은 결과적으로 다른 끝에서 데이터를 승인한 후 NetX 내부 처리에 의해 해제됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1076">The transmitted packet is eventually released by NetX internal processing after the data is acknowledged by the other end._</span></span>

### <a name="tcp-keepalive"></a><span data-ttu-id="f0769-1077">TCP Keepalive</span><span class="sxs-lookup"><span data-stu-id="f0769-1077">TCP Keepalive</span></span>

<span data-ttu-id="f0769-1078">TCP Keepalive 기능을 사용하면 소켓이 적절한 종료(예: 피어 크래시) 없이 피어 연결이 끊어졌는지 여부를 감지하거나 특정 네트워크 모니터링 기능이 장시간 유휴 상태에서 연결이 종료되는 것을 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1078">TCP Keepalive feature allows a socket to detect whether or not its peer disconnects without proper termination (for example, the peer crashed), or to prevent certain network monitoring facilities to terminate a connection for long periods of idle.</span></span> <span data-ttu-id="f0769-1079">TCP Keepalive는 데이터가 없는 TCP 프레임을 주기적으로 전송하고, 시퀀스 번호가 현재 시퀀스 번호보다 작은 값으로 설정됨으로써 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1079">TCP Keepalive works by periodically sending a TCP frame with no data, and the sequence number set to one less than the current sequence number.</span></span> <span data-ttu-id="f0769-1080">이러한 TCP Keepalive 프레임을 수신하면 수신자가 여전히 활성화 상태인 경우 현재 시퀀스 번호에 대해 ACK로 응답합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1080">On receiving such TCP Keepalive frame, the recipient, if still alive, responses with an ACK for its current sequence number.</span></span> <span data-ttu-id="f0769-1081">이렇게 하면 keepalive 트랜잭션이 완료됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1081">This completes the keepalive transaction.</span></span>

<span data-ttu-id="f0769-1082">기본적으로 keepalive 기능은 사용하도록 설정되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1082">By default the keepalive feature is not enabled.</span></span> <span data-ttu-id="f0769-1083">이 기능을 사용하려면 \***NX_ENABLE_TCP_KEEPALIVE** _가 정의된 NetX 라이브러리를 빌드해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1083">To use this feature, NetX library must be built with \***NX_ENABLE_TCP_KEEPALIVE** _ defined.</span></span> <span data-ttu-id="f0769-1084">_ _NX_TCP_KEEPALIVE_INITIAL_\* 기호는 keepalive 프레임이 시작되기 전의 비활성 시간(초)을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1084">The symbol _ *_NX_TCP_KEEPALIVE_INITIAL_*\* specifies the number of seconds of inactivity before the keepalive frame is initiated.</span></span>

### <a name="tcp-packet-receive"></a><span data-ttu-id="f0769-1085">TCP 패킷 수신</span><span class="sxs-lookup"><span data-stu-id="f0769-1085">TCP Packet Receive</span></span>

<span data-ttu-id="f0769-1086">TCP 수신 패킷 처리(IP 도우미 스레드에서 호출)는 다양한 연결 및 연결 끊기 작업뿐만 아니라 전송 승인 처리도 담당합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1086">The TCP receive packet processing (called from the IP helper thread) is responsible for handling various connection and disconnection actions as well as transmit acknowledge processing.</span></span> <span data-ttu-id="f0769-1087">또한 TCP 수신 패킷 처리는 수신 데이터가 있는 패킷을 적절한 TCP 소켓의 수신 큐에 배치하거나 패킷을 대기 중인 첫 번째 일시 중단된 스레드에 패킷을 전달하는 역할을 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1087">In addition, the TCP receive packet processing is responsible for placing packets with receive data on the appropriate TCP socket's receive queue or delivering the packet to the first suspended thread waiting for a packet.</span></span>

### <a name="tcp-receive-notify"></a><span data-ttu-id="f0769-1088">TCP 수신 알림</span><span class="sxs-lookup"><span data-stu-id="f0769-1088">TCP Receive Notify</span></span>

<span data-ttu-id="f0769-1089">애플리케이션 스레드가 둘 이상의 소켓에서 받은 데이터를 처리해야 하는 경우 ***nx_tcp_socket_receive_notify*** 함수를 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1089">If the application thread needs to process received data from more than one socket, the ***nx_tcp_socket_receive_notify*** function should be used.</span></span> <span data-ttu-id="f0769-1090">이 함수는 소켓에 대한 수신 패킷 콜백 함수를 등록합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1090">This function registers a receive packet callback function for the socket.</span></span> <span data-ttu-id="f0769-1091">피켓이 소켓에 수신될 때마다 콜백 함수가 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1091">Whenever a packet is received on the socket, the callback function is executed.</span></span>

<span data-ttu-id="f0769-1092">콜백 함수의 콘텐츠는 애플리케이션에 따라 다르지만, 그 함수는 해당 소켓에서 패킷을 사용할 수 있다는 것을 처리 스레드에 알리는 논리를 포함할 가능성이 큽니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1092">The contents of the callback function are application-specific; however, the function would most likely contain logic to inform the processing thread that a packet is available on the corresponding socket.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="f0769-1093">스레드 일시 중단</span><span class="sxs-lookup"><span data-stu-id="f0769-1093">Thread Suspension</span></span>

<span data-ttu-id="f0769-1094">앞에서 설명한 대로 애플리케이션 스레드는 특정 TCP 포트에서 데이터를 수신하는 동안 일시 중단할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1094">As mentioned previously, application threads can suspend while attempting to receive data from a particular TCP port.</span></span> <span data-ttu-id="f0769-1095">해당 포트에서 패킷이 수신되면 패킷이 일시 중단된 첫 번째 스레드에 제공되고 해당 스레드가 다시 시작됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1095">After a packet is received on that port, it is given to the first thread suspended and that thread is then resumed.</span></span> <span data-ttu-id="f0769-1096">대부분의 NetX 서비스에서 사용할 수 있는 기능인 TCP 수신 패킷을 일시 중단할 경우 선택적 시간 제한을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1096">An optional timeout is available when suspending on a TCP receive packet, a feature available for most NetX services.</span></span>

<span data-ttu-id="f0769-1097">스레드 일시 중단은 클라이언트와 서버 모두, 클라이언트 바인딩 및 연결 끊기 서비스에도 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1097">Thread suspension is also available for connection (both client and server), client binding, and disconnection services.</span></span>

### <a name="tcp-socket-statistics-and-errors"></a><span data-ttu-id="f0769-1098">TCP 소켓 통계 및 오류</span><span class="sxs-lookup"><span data-stu-id="f0769-1098">TCP Socket Statistics and Errors</span></span>

<span data-ttu-id="f0769-1099">사용하도록 설정된 경우 NetX TCP 소프트웨어는 애플리케이션에 유용할 수 있는 몇 가지 통계 및 오류를 추적합니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1099">If enabled, the NetX TCP socket software keeps track of several statistics and errors that may be useful to the application.</span></span> <span data-ttu-id="f0769-1100">각 IP/TCP 인스턴스에 대해 다음 통계 및 오류 보고서가 유지 관리됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1100">The following statistics and error reports are maintained for each IP/TCP instance:</span></span>

- <span data-ttu-id="f0769-1101">전송된 총 TCP 패킷</span><span class="sxs-lookup"><span data-stu-id="f0769-1101">Total TCP Packets Sent</span></span>
- <span data-ttu-id="f0769-1102">전송된 총 TCP 바이트</span><span class="sxs-lookup"><span data-stu-id="f0769-1102">Total TCP Bytes Sent</span></span>
- <span data-ttu-id="f0769-1103">수신된 총 TCP 패킷</span><span class="sxs-lookup"><span data-stu-id="f0769-1103">Total TCP Packets Received</span></span>
- <span data-ttu-id="f0769-1104">수신된 총 TCP 바이트</span><span class="sxs-lookup"><span data-stu-id="f0769-1104">Total TCP Bytes Received</span></span>
- <span data-ttu-id="f0769-1105">총 TCP 잘못된 패킷</span><span class="sxs-lookup"><span data-stu-id="f0769-1105">Total TCP Invalid Packets</span></span>
- <span data-ttu-id="f0769-1106">삭제된 총 TCP 수신 패킷</span><span class="sxs-lookup"><span data-stu-id="f0769-1106">Total TCP Receive Packets Dropped</span></span>
- <span data-ttu-id="f0769-1107">총 TCP 수신 체크섬 오류</span><span class="sxs-lookup"><span data-stu-id="f0769-1107">Total TCP Receive Checksum Errors</span></span>
- <span data-ttu-id="f0769-1108">총 TCP 연결</span><span class="sxs-lookup"><span data-stu-id="f0769-1108">Total TCP Connections</span></span>
- <span data-ttu-id="f0769-1109">총 TCP 연결 끊김</span><span class="sxs-lookup"><span data-stu-id="f0769-1109">Total TCP Disconnections</span></span>
- <span data-ttu-id="f0769-1110">삭제된 총 TCP 연결</span><span class="sxs-lookup"><span data-stu-id="f0769-1110">Total TCP Connections Dropped</span></span>
- <span data-ttu-id="f0769-1111">총 TCP 패킷 재전송</span><span class="sxs-lookup"><span data-stu-id="f0769-1111">Total TCP Packet Retransmits</span></span>
- <span data-ttu-id="f0769-1112">전송된 TCP 소켓 패킷</span><span class="sxs-lookup"><span data-stu-id="f0769-1112">TCP Socket Packets Sent</span></span>
- <span data-ttu-id="f0769-1113">전송된 TCP 소켓 바이트</span><span class="sxs-lookup"><span data-stu-id="f0769-1113">TCP Socket Bytes Sent</span></span>
- <span data-ttu-id="f0769-1114">수신된 TCP 소켓 패킷</span><span class="sxs-lookup"><span data-stu-id="f0769-1114">TCP Socket Packets Received</span></span>
- <span data-ttu-id="f0769-1115">수신된 TCP 소켓 바이트</span><span class="sxs-lookup"><span data-stu-id="f0769-1115">TCP Socket Bytes Received</span></span>
- <span data-ttu-id="f0769-1116">TCP 소켓 패킷 재전송</span><span class="sxs-lookup"><span data-stu-id="f0769-1116">TCP Socket Packet Retransmits</span></span>
- <span data-ttu-id="f0769-1117">큐에 있는 TCP 소켓 패킷</span><span class="sxs-lookup"><span data-stu-id="f0769-1117">TCP Socket Packets Queued</span></span>
- <span data-ttu-id="f0769-1118">TCP 소켓 체크섬 오류</span><span class="sxs-lookup"><span data-stu-id="f0769-1118">TCP Socket Checksum Errors</span></span>
- <span data-ttu-id="f0769-1119">TCP 소켓 상태</span><span class="sxs-lookup"><span data-stu-id="f0769-1119">TCP Socket State</span></span>
- <span data-ttu-id="f0769-1120">TCP 소켓 전송 큐 깊이</span><span class="sxs-lookup"><span data-stu-id="f0769-1120">TCP Socket Transmit Queue Depth</span></span>
- <span data-ttu-id="f0769-1121">TCP 소켓 전송 창 크기</span><span class="sxs-lookup"><span data-stu-id="f0769-1121">TCP Socket Transmit Window Size</span></span>
- <span data-ttu-id="f0769-1122">TCP 소켓 수신 창 크기</span><span class="sxs-lookup"><span data-stu-id="f0769-1122">TCP Socket Receive Window Size</span></span>

<span data-ttu-id="f0769-1123">이러한 모든 통계 및 오류 보고서는 총 TCP 통계의 경우 ***nx_tcp_info_get** _ 서비스와 소켓당 TCP 통계의 경우 _ _nx_tcp_socket_info_get_* 서비스가 있는 애플리케이션에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1123">All these statistics and error reports are available to the application with the ***nx_tcp_info_get** _ service for total TCP statistics and the _ *_nx_tcp_socket_info_get_** service for TCP statistics per socket.</span></span>

## <a name="tcp-socket-control-block-nx_tcp_socket"></a><span data-ttu-id="f0769-1124">TCP 소켓 제어 블록 NX_TCP_SOCKET</span><span class="sxs-lookup"><span data-stu-id="f0769-1124">TCP Socket Control Block NX_TCP_SOCKET</span></span>

<span data-ttu-id="f0769-1125">각 TCP 소켓의 특징은 연결된 *NX_TCP_SOCKET* 제어 블록에서 찾을 수 있습니다. 여기에는 IP 데이터 구조에 대 한 링크, 네트워크 연결 인터페이스, 바인딩된 포트 및 수신 패킷 큐와 같은 유용한 정보가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1125">The characteristics of each TCP socket are found in the associated *NX_TCP_SOCKET* control block, which contains useful information such as the link to the IP data structure, the network connection interface, the bound port, and the receive packet queue.</span></span> <span data-ttu-id="f0769-1126">이 구조는 ***nx_api.h*** 파일에서 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="f0769-1126">This structure is defined in the ***nx_api.h*** file.</span></span>
