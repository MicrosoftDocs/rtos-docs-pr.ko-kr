---
title: 5장 - Azure RTOS NetX Duo 네트워크 드라이버
description: 이 장에서는 Azure RTOS NetX Duo의 네트워크 드라이버에 대해 설명합니다.
author: philmea
ms.author: philmea
ms.date: 05/19/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: ede57b7512f4a1a4c30759f428962739aaa2777c
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/22/2021
ms.locfileid: "104810999"
---
# <a name="chapter-5---azure-rtos-netx-duo-network-drivers"></a><span data-ttu-id="68a92-103">5장 - Azure RTOS NetX Duo 네트워크 드라이버</span><span class="sxs-lookup"><span data-stu-id="68a92-103">Chapter 5 - Azure RTOS NetX Duo Network Drivers</span></span>

<span data-ttu-id="68a92-104">이 장에서는 Azure RTOS NetX Duo의 네트워크 드라이버에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-104">This chapter contains a description of network drivers for Azure RTOS NetX Duo.</span></span> <span data-ttu-id="68a92-105">제공된 정보는 개발자가 NetX Duo용 애플리케이션별 네트워크 드라이버를 작성하는 데 도움이 되도록 설계되었습니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-105">The information presented is designed to help developers write application-specific network drivers for NetX Duo.</span></span>

## <a name="driver-introduction"></a><span data-ttu-id="68a92-106">드라이버 소개</span><span class="sxs-lookup"><span data-stu-id="68a92-106">Driver Introduction</span></span>

<span data-ttu-id="68a92-107">NX_IP 구조에는 단일 IP 인스턴스를 관리하는 모든 항목이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-107">The NX_IP structure contains everything to manage a single IP instance.</span></span> <span data-ttu-id="68a92-108">여기에는 일반적인 TCP/IP 프로토콜 정보뿐만 아니라 애플리케이션별 실제 네트워크 드라이버의 항목 루틴이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-108">This includes general TCP/IP protocol information as well as the application-specific physical network driver's entry routine.</span></span> <span data-ttu-id="68a92-109">드라이버의 항목 루틴은 \***nx_ip_create** _ 서비스 중에 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-109">The driver's entry routine is defined during the \***nx_ip_create** _ service.</span></span> <span data-ttu-id="68a92-110">_ *_nx_ip_interface_attach_*\* 서비스를 통해 IP 인스턴스에 추가 디바이스를 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-110">Additional devices may be added to the IP instance via the _ *_nx_ip_interface_attach_*\* service.</span></span>

<span data-ttu-id="68a92-111">NetX Duo와 애플리케이션의 네트워크 드라이버 간의 통신은 **NX_IP_DRIVER** 요청 구조를 통해 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-111">Communication between NetX Duo and the application's network driver is accomplished through the **NX_IP_DRIVER** request structure.</span></span> <span data-ttu-id="68a92-112">이 구조는 대부분 호출자의 스택에서 로컬로 정의되므로 드라이버 및 호출 함수가 반환된 후에 릴리스됩니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-112">This structure is most often defined locally on the caller's stack and is therefore released after the driver and calling function return.</span></span> <span data-ttu-id="68a92-113">구조는 다음과 같이 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-113">The structure is defined as follows.</span></span>

```c
typedef struct NX_IP_DRIVER_STRUCT
{
      UINT           nx_ip_driver_command;
      UINT           nx_ip_driver_status;
      ULONG          nx_ip_driver_physical_address_msw;
      ULONG          nx_ip_driver_physical_address_lsw;
      NX_PACKET      *nx_ip_driver_packet;
      ULONG          *nx_ip_driver_return_ptr;
      NX_IP          *nx_ip_driver_ptr;
      NX_INTERFACE   *nx_ip_driver_interface;01
} NX_IP_DRIVER;
```
## <a name="driver-entry"></a><span data-ttu-id="68a92-114">드라이버 항목</span><span class="sxs-lookup"><span data-stu-id="68a92-114">Driver Entry</span></span> 

<span data-ttu-id="68a92-115">NetX Duo는 드라이버 초기화 및 패킷 전송, 네트워크 디바이스 초기화 및 활성화를 포함한 다양한 제어 및 상태 작업을 위해 네트워크 드라이버 진입 함수를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-115">NetX Duo invokes the network driver entry function for driver initialization and for sending packets and for various control and status operations, including initializing and enabling the network device.</span></span> <span data-ttu-id="68a92-116">NetX Duo는 _ *NX_IP_DRIVER*\* 요청 구조에서 \***nx_ip_driver_command** _ 필드를 설정하여 네트워크 드라이버에 명령을 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-116">NetX Duo issues commands to the network driver by setting the ***nx_ip_driver_command** _ field in the _ *NX_IP_DRIVER** request structure.</span></span> <span data-ttu-id="68a92-117">드라이버 진입 함수의 형식은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-117">The driver entry function has the following format:</span></span>

```c
VOID my_driver_entry(NX_IP_DRIVER *request);
```
## <a name="driver-requests"></a><span data-ttu-id="68a92-118">드라이버 요청</span><span class="sxs-lookup"><span data-stu-id="68a92-118">Driver Requests</span></span>

<span data-ttu-id="68a92-119">NetX Duo는 특정 명령을 사용하여 드라이버 요청을 만들고 드라이버 진입 함수를 호출하여 명령을 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-119">NetX Duo creates the driver request with a specific command and invokes the driver entry function to execute the command.</span></span> <span data-ttu-id="68a92-120">각 네트워크 드라이버에는 단일 진입 함수가 있으므로 NetX Duo는 드라이버 요청 데이터 구조를 통해 모든 요청을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-120">Because each network driver has a single entry function, NetX Duo makes all requests through the driver request data structure.</span></span> <span data-ttu-id="68a92-121">드라이버 요청 데이터 구조( _\*NX_IP_DRIVER\*\*)의 \***nx_ip_driver_command** _ 멤버는 요청을 정의합니다. 상태 정보는 \**_nx_ip_driver_status_*_ 멤버의 호출자에게 다시 보고됩니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-121">The ***nx_ip_driver_command** _ member of the driver request data structure (_*NX_IP_DRIVER\*\*) defines the request. Status information is reported back to the caller in the member \**_nx_ip_driver_status_*_.</span></span> <span data-ttu-id="68a92-122">이 필드가 _\*NX_SUCCESS\*\*인 경우 드라이버 요청이 성공적으로 완료된 것입니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-122">If this field is _\*NX_SUCCESS\*\*, the driver request was completed successfully.</span></span>

<span data-ttu-id="68a92-123">NetX Duo는 드라이버에 대한 모든 액세스를 직렬화합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-123">NetX Duo serializes all access to the driver.</span></span> <span data-ttu-id="68a92-124">따라서 드라이버는 진입 함수를 호출하는 여러 스레드를 비동기적으로 처리할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-124">Therefore, the driver does not need to handle multiple threads asynchronously calling the entry function.</span></span> <span data-ttu-id="68a92-125">디바이스 드라이버 함수는 IP 뮤텍스가 잠긴 상태에서 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-125">Note that the device driver function executes with the IP mutex locked.</span></span> <span data-ttu-id="68a92-126">따라서 디바이스 드라이버 내부 함수는 스스로 차단하지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-126">Therefore the device driver internal function shall not block itself.</span></span>

<span data-ttu-id="68a92-127">일반적으로 디바이스 드라이버는 인터럽트도 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-127">Typically the device driver also handles interrupts.</span></span> <span data-ttu-id="68a92-128">따라서 모든 드라이버 함수는 인터럽트로부터 안전해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-128">Therefore, all driver functions need to be interrupt-safe.</span></span>

### <a name="driver-initialization"></a><span data-ttu-id="68a92-129">드라이버 초기화</span><span class="sxs-lookup"><span data-stu-id="68a92-129">Driver Initialization</span></span>   
<span data-ttu-id="68a92-130">실제 드라이버 초기화 프로세스는 애플리케이션마다 다르지만, 일반적으로 데이터 구조와 실제 하드웨어 초기화로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-130">Although the actual driver initialization processing is application specific, it usually consists of data structure and physical hardware initialization.</span></span> <span data-ttu-id="68a92-131">드라이버 초기화를 위해 NetX Duo에게 필요한 정보는 IP MTU(최대 전송 단위)이며, 이는 IPv4 또는 IPv6 헤더 등 IP 계층 페이로드에 사용할 수 있는 바이트 수이고 실제 인터페이스에 논리적/물리적 매핑이 필요한 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-131">The information required from NetX Duo for driver initialization is the IP Maximum Transmission Unit (MTU), which is the number of bytes available to the IP-layer payload, including IPv4 or IPv6 header) and if the physical interface needs logical-to-physical mapping.</span></span> <span data-ttu-id="68a92-132">드라이버는 ***nx_ip_interface_mtu_set*** 을 호출하여 인터페이스 MTU 값을 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-132">The driver configures the interface MTU value by calling ***nx_ip_interface_mtu_set***.</span></span>

<span data-ttu-id="68a92-133">디바이스 드라이버는 \***nx_ip_interface_address_mapping_configure** _를 호출하여 인터페이스 주소 매핑이 필요한지 여부를 NetX Duo에게 알려 주어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-133">The device driver needs to call \***nx_ip_interface_address_mapping_configure** _ to inform NetX Duo whether or not interface address mapping is required.</span></span> <span data-ttu-id="68a92-134">주소 매핑이 필요한 경우 드라이버는 유효한 MAC 주소를 사용하여 인터페이스를 구성하고 _\*_nx_ip_interface_physical_address_set_\*\*을 통해 NetX에 MAC 주소를 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-134">If address mapping is needed, the driver is responsible for configuring the interface with valid MAC address, and supply the MAC address to NetX via _\*_nx_ip_interface_physical_address_set_\*\*.</span></span>

<span data-ttu-id="68a92-135">네트워크 드라이버가 NetX Duo에서 NX_LINK INITIALIZE 요청을 수신하면 위에 표시된 NX_IP_DRIVER 요청 제어 블록의 일부로 IP 제어 블록에 대한 포인터를 받습니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-135">When the network driver receives the NX_LINK INITIALIZE request from NetX Duo, it receives a pointer to the IP control block as part of the NX_IP_DRIVER request control block shown above.</span></span>

<span data-ttu-id="68a92-136">애플리케이션이 ***nx_ip_create*** 를 호출하고 나면 IP 도우미 스레드는 명령이 NX_LINK_INITIALIZE로 설정된 드라이버 요청을 드라이버로 보내 실제 네트워크 인터페이스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-136">After the application calls ***nx_ip_create***, the IP helper thread sends a driver request with the command set to NX_LINK_INITIALIZE to the driver to initialize its physical network interface.</span></span> <span data-ttu-id="68a92-137">초기화 요청에는 다음과 같은 NX_IP_DRIVER 멤버가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-137">The following NX_IP_DRIVER members are used for the initialize request.</span></span>

| <span data-ttu-id="68a92-138">NX_IP_DRIVER&nbsp;멤버</span><span class="sxs-lookup"><span data-stu-id="68a92-138">NX_IP_DRIVER&nbsp;member</span></span> | <span data-ttu-id="68a92-139">의미</span><span class="sxs-lookup"><span data-stu-id="68a92-139">Meaning</span></span>    |
| ------------------------- | ----------------------------- |
| <span data-ttu-id="68a92-140">nx_ip_driver_command</span><span class="sxs-lookup"><span data-stu-id="68a92-140">nx_ip_driver_command</span></span>   | <span data-ttu-id="68a92-141">NX_LINK_INITIALIZE</span><span class="sxs-lookup"><span data-stu-id="68a92-141">NX_LINK_INITIALIZE</span></span>    |
| <span data-ttu-id="68a92-142">nx_ip_driver_ptr</span><span class="sxs-lookup"><span data-stu-id="68a92-142">nx_ip_driver_ptr</span></span>       | <span data-ttu-id="68a92-143">IP 인스턴스에 대한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-143">Pointer to the IP instance.</span></span> <span data-ttu-id="68a92-144">드라이버 함수에서 작동할 IP 인스턴스를 찾을 수 있도록 이 값을 드라이버에서 저장해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-144">This value should be saved by the driver so that the driver function can find the IP instance to operate on.</span></span>    |
| <span data-ttu-id="68a92-145">nx_ip_driver_interface</span><span class="sxs-lookup"><span data-stu-id="68a92-145">nx_ip_driver_interface</span></span> | <span data-ttu-id="68a92-146">IP 인스턴스 내의 네트워크 인터페이스 구조에 대한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-146">Pointer to the network interface structure within the IP instance.</span></span> <span data-ttu-id="68a92-147">이 정보는 드라이버에서 저장해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-147">This information should be saved by the driver.</span></span> <span data-ttu-id="68a92-148">패킷 수신 시, 스택 위로 패킷을 전송하는 경우 드라이버는 인터페이스 구조 정보를 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-148">On receiving packets, the driver shall use the interface structure information when sending the packet up the stack.</span></span> <span data-ttu-id="68a92-149">인터페이스 인덱스(디바이스 인덱스)는 이 데이터 구조 내의 nx_interface_index 멤버를 읽음으로써 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-149">The interface index (device index) can be obtained by reading the member nx_interface_index inside this data structure.</span></span> |
| <span data-ttu-id="68a92-150">nx_ip_driver_status</span><span class="sxs-lookup"><span data-stu-id="68a92-150">nx_ip_driver_status</span></span>    | <span data-ttu-id="68a92-151">완료 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-151">Completion status.</span></span> <span data-ttu-id="68a92-152">드라이버가 지정된 인터페이스를 IP 인스턴스로 초기화할 수 없는 경우 0이 아닌 오류 상태를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-152">If the driver is not able to initialize the specified interface to the IP instance, it will return a nonzero error status.</span></span> |


> [!NOTE]  
> <span data-ttu-id="68a92-153">이 드라이버는 실제로 IP 인스턴스를 위해 만들어진 IP 도우미 스레드에서 호출됩니다. 따라서 드라이버 루틴은 차단 작업을 수행하지 않아야 합니다. 그러지 않으면 IP 도우미 스레드가 중단되어 IP 스레드에 의존하는 애플리케이션에 무한 지연이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-153">*The driver is actually called from the IP helper thread that was created for the IP instance. Therefore the driver routine should avoid performing blocking operations, or the IP helper thread could stall, causing unbounded delays to applications that rely on the IP thread*.</span></span>

### <a name="enable-link"></a><span data-ttu-id="68a92-154">링크 사용</span><span class="sxs-lookup"><span data-stu-id="68a92-154">Enable Link</span></span>   
<span data-ttu-id="68a92-155">그런 다음, IP 도우미 스레드는 드라이버 요청에서 드라이버 명령을 NX_LINK_ENABLE로 설정하고 네트워크 드라이버로 요청을 전송하여 실제 네트워크를 사용하도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-155">Next, the IP helper thread enables the physical network by setting the driver command to NX_LINK_ENABLE in the driver request and sending the request to the network driver.</span></span> <span data-ttu-id="68a92-156">이는 IP 도우미 스레드가 초기화 요청을 완료한 직후에 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-156">This happens shortly after the IP helper thread completes the initialization request.</span></span> <span data-ttu-id="68a92-157">링크를 사용하도록 설정하는 것은 인터페이스 인스턴스에서 *nx_interface_link_up* 필드를 설정하는 것만큼 간단합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-157">Enabling the link may be as simple as setting the *nx_interface_link_up* field in the interface instance.</span></span> <span data-ttu-id="68a92-158">그러나 실제 하드웨어 조작도 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-158">But it may also involve manipulation of the physical hardware.</span></span> <span data-ttu-id="68a92-159">링크 사용 요청에는 다음과 같은 NX_IP_DRIVER 멤버가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-159">The following NX_IP_DRIVER members are used for the enable link request.</span></span>

| <span data-ttu-id="68a92-160">NX_IP_DRIVER&nbsp;멤버</span><span class="sxs-lookup"><span data-stu-id="68a92-160">NX_IP_DRIVER&nbsp;member</span></span>       | <span data-ttu-id="68a92-161">의미</span><span class="sxs-lookup"><span data-stu-id="68a92-161">Meaning</span></span>                      |
| ------------------------- | ---------------------------- |
| <span data-ttu-id="68a92-162">nx_ip_driver_command</span><span class="sxs-lookup"><span data-stu-id="68a92-162">nx_ip_driver_command</span></span>   | <span data-ttu-id="68a92-163">NX_LINK_ENABLE</span><span class="sxs-lookup"><span data-stu-id="68a92-163">NX_LINK_ENABLE</span></span>   |
| <span data-ttu-id="68a92-164">nx_ip_driver_ptr</span><span class="sxs-lookup"><span data-stu-id="68a92-164">nx_ip_driver_ptr</span></span>       | <span data-ttu-id="68a92-165">IP 인스턴스에 대한 포인터</span><span class="sxs-lookup"><span data-stu-id="68a92-165">Pointer to IP instance</span></span>  |
| <span data-ttu-id="68a92-166">nx_ip_driver_interface</span><span class="sxs-lookup"><span data-stu-id="68a92-166">nx_ip_driver_interface</span></span> | <span data-ttu-id="68a92-167">인터페이스 인스턴스에 대한 포인터</span><span class="sxs-lookup"><span data-stu-id="68a92-167">Pointer to the interface instance</span></span> |
| <span data-ttu-id="68a92-168">nx_ip_driver_status</span><span class="sxs-lookup"><span data-stu-id="68a92-168">nx_ip_driver_status</span></span>    | <span data-ttu-id="68a92-169">완료 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-169">Completion status.</span></span> <span data-ttu-id="68a92-170">드라이버에서 지정된 인터페이스를 사용하도록 설정할 수 없는 경우 0이 아닌 오류 상태를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-170">If the driver is not able to enable the specified interface, it will return a non-zero error status.</span></span> |

### <a name="disable-link"></a><span data-ttu-id="68a92-171">링크 사용 안 함</span><span class="sxs-lookup"><span data-stu-id="68a92-171">Disable Link</span></span>   
<span data-ttu-id="68a92-172">이 요청은 \***nx_ip_delete** _ 서비스에서 IP 인스턴스를 삭제하는 동안 NetX Duo에서 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-172">This request is made by NetX Duo during the deletion of an IP instance by the \***nx_ip_delete** _ service.</span></span> <span data-ttu-id="68a92-173">또는 애플리케이션에서 전원을 절약할 목적으로 임시로 링크를 사용하지 않도록 설정하기 위해 이 명령을 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-173">Or an application may issue this command in order to temporarily disable the link in order to save power.</span></span> <span data-ttu-id="68a92-174">이 서비스는 IP 인스턴스에서 실제 네트워크 인터페이스를 사용하지 않도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-174">This service disables the physical network interface on the IP instance.</span></span> <span data-ttu-id="68a92-175">링크를 사용하지 않도록 설정하는 프로세스는 인터페이스 인스턴스에서 _nx_interface_link_up\* 플래그를 지우는 것만큼 간단할 수 있습니다. 그러나 실제 하드웨어 조작을 포함할 수도 있습니다. 일반적으로 \***링크 사용**_ 작업의 반대 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-175">The processing to disable the link may be as simple as clearing the _nx_interface_link_up\* flag in the interface instance. But it may also involve manipulation of the physical hardware. Typically it is a reverse operation of the \***Enable Link**_ operation.</span></span> <span data-ttu-id="68a92-176">링크를 사용하지 않도록 설정한 후 애플리케이션은 *_링크 사용_* 작업을 요청하여 인터페이스를 사용하도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-176">After the link is disabled, the application request _ *_Enable Link_*\* operation to enable the interface.</span></span>

<span data-ttu-id="68a92-177">링크를 사용하지 않도록 설정하는 요청에는 다음과 같은 NX_IP_DRIVER 멤버가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-177">The following NX_IP_DRIVER members are used for the disable link request.</span></span>

| <span data-ttu-id="68a92-178">NX_IP_DRIVER&nbsp;멤버</span><span class="sxs-lookup"><span data-stu-id="68a92-178">NX_IP_DRIVER&nbsp;member</span></span>     | <span data-ttu-id="68a92-179">의미</span><span class="sxs-lookup"><span data-stu-id="68a92-179">Meaning</span></span>                      |
| ------------------------- | ---------------------------- |
| <span data-ttu-id="68a92-180">nx_ip_driver_command</span><span class="sxs-lookup"><span data-stu-id="68a92-180">nx_ip_driver_command</span></span>   | <span data-ttu-id="68a92-181">NX_LINK_DISABLE</span><span class="sxs-lookup"><span data-stu-id="68a92-181">NX_LINK_DISABLE</span></span>    |
| <span data-ttu-id="68a92-182">nx_ip_driver_ptr</span><span class="sxs-lookup"><span data-stu-id="68a92-182">nx_ip_driver_ptr</span></span>       | <span data-ttu-id="68a92-183">IP 인스턴스에 대한 포인터</span><span class="sxs-lookup"><span data-stu-id="68a92-183">Pointer to IP instance</span></span>   |
| <span data-ttu-id="68a92-184">nx_ip_driver_interface</span><span class="sxs-lookup"><span data-stu-id="68a92-184">nx_ip_driver_interface</span></span> | <span data-ttu-id="68a92-185">인터페이스 인스턴스에 대한 포인터</span><span class="sxs-lookup"><span data-stu-id="68a92-185">Pointer to the interface instance</span></span>   |
| <span data-ttu-id="68a92-186">nx_ip_driver_status</span><span class="sxs-lookup"><span data-stu-id="68a92-186">nx_ip_driver_status</span></span>    | <span data-ttu-id="68a92-187">완료 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-187">Completion status.</span></span> <span data-ttu-id="68a92-188">드라이버가 IP 인스턴스에서 지정된 인터페이스를 사용하지 않도록 설정할 수 없는 경우 0이 아닌 오류 상태를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-188">If the driver is not able to disable the specified interface in the IP instance, it will return a non-zero error status.</span></span> |

### <a name="uninitialize-link"></a><span data-ttu-id="68a92-189">링크 초기화 취소</span><span class="sxs-lookup"><span data-stu-id="68a92-189">Uninitialize Link</span></span>   
<span data-ttu-id="68a92-190">이 요청은 \***nx_ip_delete** _ 서비스에서 IP 인스턴스를 삭제하는 동안 NetX Duo에서 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-190">This request is made by NetX Duo during the deletion of an IP instance by the \***nx_ip_delete** _ service.</span></span> <span data-ttu-id="68a92-191">이 요청은 인터페이스의 초기화를 취소하고 초기화 단계에서 만들어진 모든 리소스를 릴리스합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-191">This request uninitialize the interface, and release any resources created during initialization phase.</span></span> <span data-ttu-id="68a92-192">일반적으로 *_링크 초기화_* 작업의 반대 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-192">Typically it is a reverse operation of the _ *_Initialize Link_*\* operation.</span></span> <span data-ttu-id="68a92-193">인터페이스 초기화를 취소한 후에는 인터페이스를 다시 초기화할 때까지 디바이스를 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-193">After the interface is uninitalized, the device cannot be used until the interface is initialized again.</span></span>

<span data-ttu-id="68a92-194">링크를 사용하지 않도록 설정하는 요청에는 다음과 같은 NX_IP_DRIVER 멤버가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-194">The following NX_IP_DRIVER members are used for the disable link request.</span></span>

| <span data-ttu-id="68a92-195">NX_IP_DRIVER&nbsp;멤버</span><span class="sxs-lookup"><span data-stu-id="68a92-195">NX_IP_DRIVER&nbsp;member</span></span>    | <span data-ttu-id="68a92-196">의미</span><span class="sxs-lookup"><span data-stu-id="68a92-196">Meaning</span></span>                  |
|------------------------|--------------------------|
| <span data-ttu-id="68a92-197">nx_ip_driver_command</span><span class="sxs-lookup"><span data-stu-id="68a92-197">nx_ip_driver_command</span></span>   | <span data-ttu-id="68a92-198">NX_LINK_UNINITIALZE</span><span class="sxs-lookup"><span data-stu-id="68a92-198">NX_LINK_UNINITIALZE</span></span>      |
| <span data-ttu-id="68a92-199">nx_ip_driver_ptr</span><span class="sxs-lookup"><span data-stu-id="68a92-199">nx_ip_driver_ptr</span></span>       | <span data-ttu-id="68a92-200">IP 인스턴스에 대한 포인터</span><span class="sxs-lookup"><span data-stu-id="68a92-200">Pointer to IP instance</span></span>   |
| <span data-ttu-id="68a92-201">nx_ip_driver_interface</span><span class="sxs-lookup"><span data-stu-id="68a92-201">nx_ip_driver_interface</span></span> | <span data-ttu-id="68a92-202">인터페이스 인스턴스에 대한 포인터</span><span class="sxs-lookup"><span data-stu-id="68a92-202">Pointer to the interface instance</span></span> |
| <span data-ttu-id="68a92-203">nx_ip_driver_status</span><span class="sxs-lookup"><span data-stu-id="68a92-203">nx_ip_driver_status</span></span>    | <span data-ttu-id="68a92-204">완료 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-204">Completion status.</span></span> <span data-ttu-id="68a92-205">드라이버가 지정된 인터페이스를 IP 인스턴스에 대한 초기화를 취소할 수 없는 경우 0이 아닌 오류 상태를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-205">If the driver is not able to uninitialize the specified interface to the IP instance, it will return a non-zero error status.</span></span> |

### <a name="packet-send"></a><span data-ttu-id="68a92-206">패킷 전송</span><span class="sxs-lookup"><span data-stu-id="68a92-206">Packet Send</span></span>   
<span data-ttu-id="68a92-207">이 요청은 모든 NetX Duo 프로토콜이 패킷을 전송하는 데 사용하는 내부 IPv4 또는 IPv6 전송 처리 중에 수행됩니다(ARP, RARP 제외).</span><span class="sxs-lookup"><span data-stu-id="68a92-207">This request is made during internal IPv4 or IPv6 send processing, which all NetX Duo protocols use to transmit packets (except for ARP, RARP).</span></span> <span data-ttu-id="68a92-208">패킷 전송 명령이 수신되면 *nx_packet_prepend_ptr* 은 전송할 패킷의 시작, 즉 IPv4 또는 IPv6 헤더의 시작 부분을 가리킵니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-208">On receiving the packet send command, the *nx_packet_prepend_ptr* points to the beginning of the packet to be sent, which is the beginning of the IPv4 or IPv6 header.</span></span> <span data-ttu-id="68a92-209">*nx_packet_length* 는 전송되는 데이터의 전체 크기(바이트)를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-209">*nx_packet_length* indicates the total size (in bytes) of the data being transmitted.</span></span> <span data-ttu-id="68a92-210">*nx_packet_next* 가 유효하면 나가는 IP 데이터그램은 여러 패킷에 저장되므로 드라이버는 연결된 패킷을 따르고 전체 프레임을 전송해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-210">If *nx_packet_next* is valid, the outgoing IP datagram is stored in multiple packets, the driver is required to follow the chained packet and transmit the entire frame.</span></span> <span data-ttu-id="68a92-211">연결된 각 패킷의 유효한 데이터 영역은 *nx_packet_prepend_ptr* 과 *nx_packet_append_ptr* 사이에 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-211">Note that valid data area in each chained packet is stored between *nx_packet_prepend_ptr* and *nx_packet_append_ptr*.</span></span>

<span data-ttu-id="68a92-212">드라이버는 실제 헤더를 구성해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-212">The driver is responsible for constructing physical header.</span></span> <span data-ttu-id="68a92-213">IP 주소 매핑에 대한 실제 주소가 필요한 경우(예: 이더넷) IP 계층에서 MAC 주소를 이미 확인했습니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-213">If physical address to IP address mapping is required (such as Ethernet), the IP layer already resolved the MAC address.</span></span> <span data-ttu-id="68a92-214">대상 MAC 주소는 *nx_ip_driver_physical_address_msw 및 nx_ip_driver_physical_address_lsw* 에 저장된 IP 인스턴스에서 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-214">The destination MAC address is passed from the IP instance, stored in *nx_ip_driver_physical_address_msw and nx_ip_driver_physical_address_lsw*.</span></span>

<span data-ttu-id="68a92-215">실제 헤더를 추가한 후 패킷 전송 처리는 드라이버의 출력 함수를 호출하여 패킷을 전송합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-215">After adding the physical header, the packet send processing then calls the driver's output function to transmit the packet.</span></span>

<span data-ttu-id="68a92-216">다음 NX_IP_DRIVER 멤버는 패킷 전송 요청에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-216">The following NX_IP_DRIVER members are used for the packet send request.</span></span>

| <span data-ttu-id="68a92-217">NX_IP_DRIVER&nbsp;멤버</span><span class="sxs-lookup"><span data-stu-id="68a92-217">NX_IP_DRIVER&nbsp;member</span></span>              | <span data-ttu-id="68a92-218">의미</span><span class="sxs-lookup"><span data-stu-id="68a92-218">Meaning</span></span>                               |
| -----------------------------------| --------------------------------------|
| <span data-ttu-id="68a92-219">nx_ip_driver_command</span><span class="sxs-lookup"><span data-stu-id="68a92-219">nx_ip_driver_command</span></span>            | <span data-ttu-id="68a92-220">NX_LINK_PACKET_SEND</span><span class="sxs-lookup"><span data-stu-id="68a92-220">NX_LINK_PACKET_SEND</span></span>                |
| <span data-ttu-id="68a92-221">nx_ip_driver_ptr</span><span class="sxs-lookup"><span data-stu-id="68a92-221">nx_ip_driver_ptr</span></span>                | <span data-ttu-id="68a92-222">IP 인스턴스에 대한 포인터</span><span class="sxs-lookup"><span data-stu-id="68a92-222">Pointer to IP instance</span></span>                |
| <span data-ttu-id="68a92-223">nx_ip_driver_packet</span><span class="sxs-lookup"><span data-stu-id="68a92-223">nx_ip_driver_packet</span></span>             | <span data-ttu-id="68a92-224">전송할 패킷에 대한 포인터</span><span class="sxs-lookup"><span data-stu-id="68a92-224">Pointer to the packet to send</span></span>         |
| <span data-ttu-id="68a92-225">nx_ip_driver_interface</span><span class="sxs-lookup"><span data-stu-id="68a92-225">nx_ip_driver_interface</span></span>          | <span data-ttu-id="68a92-226">인터페이스 인스턴스에 대한 포인터</span><span class="sxs-lookup"><span data-stu-id="68a92-226">Pointer to the interface instance.</span></span>    |
| <span data-ttu-id="68a92-227">nx_ip_driver_physical_address_msw</span><span class="sxs-lookup"><span data-stu-id="68a92-227">nx_ip_driver_physical_address_msw</span></span> | <span data-ttu-id="68a92-228">가장 중요한 32비트 실제 주소(실제 매핑이 필요한 경우에만)</span><span class="sxs-lookup"><span data-stu-id="68a92-228">Most significant 32-bits of physical address (only if physical mapping needed)</span></span> |
| <span data-ttu-id="68a92-229">nx_ip_driver_physical_address_lsw</span><span class="sxs-lookup"><span data-stu-id="68a92-229">nx_ip_driver_physical_address_lsw</span></span> | <span data-ttu-id="68a92-230">최하위 32비트 실제 주소(실제 매핑이 필요한 경우에만)</span><span class="sxs-lookup"><span data-stu-id="68a92-230">Least significant 32-bits of physical address (only if physical mapping needed)</span></span> |
| <span data-ttu-id="68a92-231">nx_ip_driver_status</span><span class="sxs-lookup"><span data-stu-id="68a92-231">nx_ip_driver_status</span></span>             | <span data-ttu-id="68a92-232">완료 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-232">Completion status.</span></span> <span data-ttu-id="68a92-233">드라이버가 패킷을 보낼 수 없으면 0이 아닌 오류 상태를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-233">If the driver is not able to send the packet, it will return a non-zero error status.</span></span> |

### <a name="packet-broadcastipv4-packets-only"></a><span data-ttu-id="68a92-234">패킷 브로드캐스트(IPv4 패킷만 해당)</span><span class="sxs-lookup"><span data-stu-id="68a92-234">Packet Broadcast(IPv4 packets only)</span></span>  
<span data-ttu-id="68a92-235">이 요청은 전송 패킷 요청과 거의 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-235">This request is almost identical to the send packet request.</span></span> <span data-ttu-id="68a92-236">유일한 차이점은 대상 실제 주소 필드가 이더넷 브로드캐스트 MAC 주소로 설정된다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-236">The only difference is that the destination physical address fields are set to the Ethernet broadcast MAC address.</span></span> <span data-ttu-id="68a92-237">패킷 브로드캐스트 요청에는 다음과 같은 NX_IP_DRIVER 멤버가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-237">The following NX_IP_DRIVER members are used for the packet broadcast request.</span></span>

| <span data-ttu-id="68a92-238">NX_IP_DRIVER&nbsp;멤버</span><span class="sxs-lookup"><span data-stu-id="68a92-238">NX_IP_DRIVER&nbsp;member</span></span>                | <span data-ttu-id="68a92-239">의미</span><span class="sxs-lookup"><span data-stu-id="68a92-239">Meaning</span></span>                                                                                                  |
|------------------------------------|----------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="68a92-240">nx_ip_driver_command</span><span class="sxs-lookup"><span data-stu-id="68a92-240">nx_ip_driver_command</span></span>               | <span data-ttu-id="68a92-241">NX_LINK_PACKET_BROADCAST</span><span class="sxs-lookup"><span data-stu-id="68a92-241">NX_LINK_PACKET_BROADCAST</span></span>                                                                                 |
| <span data-ttu-id="68a92-242">nx_ip_driver_ptr</span><span class="sxs-lookup"><span data-stu-id="68a92-242">nx_ip_driver_ptr</span></span>                   | <span data-ttu-id="68a92-243">IP 인스턴스에 대한 포인터</span><span class="sxs-lookup"><span data-stu-id="68a92-243">Pointer to IP instance</span></span>                                                                                   |
| <span data-ttu-id="68a92-244">nx_ip_driver_packet</span><span class="sxs-lookup"><span data-stu-id="68a92-244">nx_ip_driver_packet</span></span>                | <span data-ttu-id="68a92-245">전송할 패킷에 대한 포인터</span><span class="sxs-lookup"><span data-stu-id="68a92-245">Pointer to the packet to send</span></span>                                                                            |
| <span data-ttu-id="68a92-246">nx_ip_driver_physical_address_ms w</span><span class="sxs-lookup"><span data-stu-id="68a92-246">nx_ip_driver_physical_address_ms w</span></span> | <span data-ttu-id="68a92-247">0x0000FFFF(브로드캐스트)</span><span class="sxs-lookup"><span data-stu-id="68a92-247">0x0000FFFF (broadcast)</span></span>                                                                                   |
| <span data-ttu-id="68a92-248">nx_ip_driver_physical_address_lsw</span><span class="sxs-lookup"><span data-stu-id="68a92-248">nx_ip_driver_physical_address_lsw</span></span>  | <span data-ttu-id="68a92-249">0xFFFFFFFF(브로드캐스트)</span><span class="sxs-lookup"><span data-stu-id="68a92-249">0xFFFFFFFF (broadcast)</span></span>                                                                                   |
| <span data-ttu-id="68a92-250">nx_ip_driver_interface</span><span class="sxs-lookup"><span data-stu-id="68a92-250">nx_ip_driver_interface</span></span>             | <span data-ttu-id="68a92-251">인터페이스 인스턴스에 대한 포인터</span><span class="sxs-lookup"><span data-stu-id="68a92-251">Pointer to the interface instance.</span></span>                                                                       |
| <span data-ttu-id="68a92-252">nx_ip_driver_status</span><span class="sxs-lookup"><span data-stu-id="68a92-252">nx_ip_driver_status</span></span>                | <span data-ttu-id="68a92-253">완료 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-253">Completion status.</span></span> <span data-ttu-id="68a92-254">드라이버가 패킷을 보낼 수 없으면 0이 아닌 오류 상태를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-254">If the driver is not able to send the packet, it will return a non-zero error status.</span></span> |

### <a name="arp-send"></a><span data-ttu-id="68a92-255">ARP 전송</span><span class="sxs-lookup"><span data-stu-id="68a92-255">ARP Send</span></span>  
<span data-ttu-id="68a92-256">이 요청은 IP 패킷 전송 요청과도 유사합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-256">This request is also similar to the IP packet send request.</span></span> <span data-ttu-id="68a92-257">유일한 차이점은 이더넷 헤더는 IP 패킷 대신 ARP 패킷을 지정하고 대상 실제 주소 필드는 MAC 브로드캐스트 주소로 설정한다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-257">The only difference is that the Ethernet header specifies an ARP packet instead of an IP packet, and destination physical address fields are set to MAC broadcast address.</span></span> <span data-ttu-id="68a92-258">다음 NX_IP_DRIVER 멤버는 ARP 전송 요청에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-258">The following NX_IP_DRIVER members are used for the ARP send request.</span></span>

| <span data-ttu-id="68a92-259">NX_IP_DRIVER&nbsp;멤버</span><span class="sxs-lookup"><span data-stu-id="68a92-259">NX_IP_DRIVER&nbsp;member</span></span>                | <span data-ttu-id="68a92-260">의미</span><span class="sxs-lookup"><span data-stu-id="68a92-260">Meaning</span></span>                                                                                                      |
|------------------------------------|--------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="68a92-261">nx_ip_driver_command</span><span class="sxs-lookup"><span data-stu-id="68a92-261">nx_ip_driver_command</span></span>               | <span data-ttu-id="68a92-262">NX_LINK_ARP_SEND</span><span class="sxs-lookup"><span data-stu-id="68a92-262">NX_LINK_ARP_SEND</span></span>                                                                                             |
| <span data-ttu-id="68a92-263">nx_ip_driver_ptr</span><span class="sxs-lookup"><span data-stu-id="68a92-263">nx_ip_driver_ptr</span></span>                   | <span data-ttu-id="68a92-264">IP 인스턴스에 대한 포인터</span><span class="sxs-lookup"><span data-stu-id="68a92-264">Pointer to IP instance</span></span>                                                                                       |
| <span data-ttu-id="68a92-265">nx_ip_driver_packet</span><span class="sxs-lookup"><span data-stu-id="68a92-265">nx_ip_driver_packet</span></span>                | <span data-ttu-id="68a92-266">전송할 패킷에 대한 포인터</span><span class="sxs-lookup"><span data-stu-id="68a92-266">Pointer to the packet to send</span></span>                                                                                |
| <span data-ttu-id="68a92-267">nx_ip_driver_physical_address_ms w</span><span class="sxs-lookup"><span data-stu-id="68a92-267">nx_ip_driver_physical_address_ms w</span></span> | <span data-ttu-id="68a92-268">0x0000FFFF(브로드캐스트)</span><span class="sxs-lookup"><span data-stu-id="68a92-268">0x0000FFFF (broadcast)</span></span>                                                                                       |
| <span data-ttu-id="68a92-269">nx_ip_driver_physical_address_lsw</span><span class="sxs-lookup"><span data-stu-id="68a92-269">nx_ip_driver_physical_address_lsw</span></span>  | <span data-ttu-id="68a92-270">0xFFFFFFFF(브로드캐스트)</span><span class="sxs-lookup"><span data-stu-id="68a92-270">0xFFFFFFFF (broadcast)</span></span>                                                                                       |
| <span data-ttu-id="68a92-271">nx_ip_driver_interface</span><span class="sxs-lookup"><span data-stu-id="68a92-271">nx_ip_driver_interface</span></span>             | <span data-ttu-id="68a92-272">인터페이스 인스턴스에 대한 포인터</span><span class="sxs-lookup"><span data-stu-id="68a92-272">Pointer to the interface instance.</span></span>                                                                           |
| <span data-ttu-id="68a92-273">nx_ip_driver_status</span><span class="sxs-lookup"><span data-stu-id="68a92-273">nx_ip_driver_status</span></span>                | <span data-ttu-id="68a92-274">완료 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-274">Completion status.</span></span> <span data-ttu-id="68a92-275">드라이버가 ARP 패킷을 전송할 수 없으면 0이 아닌 오류 상태를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-275">If the driver is not able to send the ARP packet, it will return a non-zero error status.</span></span> |

> [!IMPORTANT]  
> <span data-ttu-id="68a92-276">실제 매핑이 필요하지 않은 경우에는 이 요청을 구현할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-276">*If physical mapping is not needed, implementation of this request is not required*.</span></span>

<span data-ttu-id="68a92-277">ARP가 IPv6에서 환경 검색 프로토콜 및 라우터 검색 프로토콜로 대체되었지만 이더넷 네트워크 드라이버는 IPv4 피어 및 라우터와 계속 호환되어야 합니다. 따라서 드라이버는 여전히 ARP 패킷을 처리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-277">*Although ARP has been replaced with the Neighbor Discovery Protocol and the Router Discovery Protocol in IPv6, Ethernet network drivers must still be compatible with IPv4 peers and routers. Therefore, drivers must still handle ARP packets*.</span></span>

### <a name="arp-response-send"></a><span data-ttu-id="68a92-278">ARP 응답 전송</span><span class="sxs-lookup"><span data-stu-id="68a92-278">ARP Response Send</span></span>  
<span data-ttu-id="68a92-279">이 요청은 ARP 전송 패킷 요청과 거의 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-279">This request is almost identical to the ARP send packet request.</span></span> <span data-ttu-id="68a92-280">유일한 차이점은 대상 실제 주소 필드가 IP 인스턴스에서 전달된다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-280">The only difference is the destination physical address fields are passed from the IP instance.</span></span> <span data-ttu-id="68a92-281">다음 NX_IP_DRIVER 멤버는 ARP 응답 전송 요청에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-281">The following NX_IP_DRIVER members are used for the ARP response send request.</span></span>

| <span data-ttu-id="68a92-282">NX_IP_DRIVER&nbsp;멤버</span><span class="sxs-lookup"><span data-stu-id="68a92-282">NX_IP_DRIVER&nbsp;member</span></span>                  | <span data-ttu-id="68a92-283">의미</span><span class="sxs-lookup"><span data-stu-id="68a92-283">Meaning</span></span>                                  |
| -------------------------------------- | -----------------------------------------|
| <span data-ttu-id="68a92-284">nx_ip_driver_command</span><span class="sxs-lookup"><span data-stu-id="68a92-284">nx_ip_driver_command</span></span>                | <span data-ttu-id="68a92-285">NX_LINK_ARP_RESPONSE_SEND</span><span class="sxs-lookup"><span data-stu-id="68a92-285">NX_LINK_ARP_RESPONSE_SEND</span></span>            |
| <span data-ttu-id="68a92-286">nx_ip_driver_ptr</span><span class="sxs-lookup"><span data-stu-id="68a92-286">nx_ip_driver_ptr</span></span>                    | <span data-ttu-id="68a92-287">IP 인스턴스에 대한 포인터</span><span class="sxs-lookup"><span data-stu-id="68a92-287">Pointer to IP instance</span></span>   |
| <span data-ttu-id="68a92-288">nx_ip_driver_packet</span><span class="sxs-lookup"><span data-stu-id="68a92-288">nx_ip_driver_packet</span></span>                 | <span data-ttu-id="68a92-289">전송할 패킷에 대한 포인터</span><span class="sxs-lookup"><span data-stu-id="68a92-289">Pointer to the packet to send</span></span>          |
| <span data-ttu-id="68a92-290">nx_ip_driver_physical_address_msw</span><span class="sxs-lookup"><span data-stu-id="68a92-290">nx_ip_driver_physical_address_msw</span></span> | <span data-ttu-id="68a92-291">가장 중요한 32비트 실제 주소</span><span class="sxs-lookup"><span data-stu-id="68a92-291">Most significant 32-bits of physical address</span></span> |
| <span data-ttu-id="68a92-292">nx_ip_driver_physical_address_lsw</span><span class="sxs-lookup"><span data-stu-id="68a92-292">nx_ip_driver_physical_address_lsw</span></span> | <span data-ttu-id="68a92-293">최하위 32비트 실제 주소</span><span class="sxs-lookup"><span data-stu-id="68a92-293">Least significant 32-bits of physical address</span></span> |
| <span data-ttu-id="68a92-294">nx_ip_driver_interface</span><span class="sxs-lookup"><span data-stu-id="68a92-294">nx_ip_driver_interface</span></span>              | <span data-ttu-id="68a92-295">인터페이스 인스턴스에 대한 포인터</span><span class="sxs-lookup"><span data-stu-id="68a92-295">Pointer to the interface instance</span></span> |
| <span data-ttu-id="68a92-296">nx_ip_driver_status</span><span class="sxs-lookup"><span data-stu-id="68a92-296">nx_ip_driver_status</span></span>                 | <span data-ttu-id="68a92-297">완료 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-297">Completion status.</span></span> <span data-ttu-id="68a92-298">드라이버가 ARP 패킷을 전송할 수 없으면 0이 아닌 오류 상태를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-298">If the driver is not able to send the ARP packet, it will return a non-zero error status.</span></span> |

> [!IMPORTANT]  
> <span data-ttu-id="68a92-299">실제 매핑이 필요하지 않은 경우에는 이 요청을 구현할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-299">*If physical mapping is not needed, implementation of this request is not required*.</span></span>

### <a name="rarp-send"></a><span data-ttu-id="68a92-300">RARP 전송</span><span class="sxs-lookup"><span data-stu-id="68a92-300">RARP Send</span></span>   
<span data-ttu-id="68a92-301">이 요청은 ARP 전송 패킷 요청과 거의 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-301">This request is almost identical to the ARP send packet request.</span></span> <span data-ttu-id="68a92-302">유일한 차이점은 패킷 헤더의 형식이며 실제 대상은 항상 브로드캐스트 주소이기 때문에 실제 주소 필드는 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-302">The only differences are the type of packet header and the physical address fields are not required because the physical destination is always a broadcast address.</span></span>

<span data-ttu-id="68a92-303">RARP 전송 요청에는 다음과 같은 NX_IP_DRIVER 멤버가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-303">The following NX_IP_DRIVER members are used for the RARP send request.</span></span>

| <span data-ttu-id="68a92-304">NX_IP_DRIVER&nbsp;멤버</span><span class="sxs-lookup"><span data-stu-id="68a92-304">NX_IP_DRIVER&nbsp;member</span></span>                | <span data-ttu-id="68a92-305">의미</span><span class="sxs-lookup"><span data-stu-id="68a92-305">Meaning</span></span>                                                                                                       |
|------------------------------------|---------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="68a92-306">nx_ip_driver_command</span><span class="sxs-lookup"><span data-stu-id="68a92-306">nx_ip_driver_command</span></span>               | <span data-ttu-id="68a92-307">NX_LINK_RARP_SEND</span><span class="sxs-lookup"><span data-stu-id="68a92-307">NX_LINK_RARP_SEND</span></span>                                                                                             |
| <span data-ttu-id="68a92-308">nx_ip_driver_ptr</span><span class="sxs-lookup"><span data-stu-id="68a92-308">nx_ip_driver_ptr</span></span>                   | <span data-ttu-id="68a92-309">IP 인스턴스에 대한 포인터</span><span class="sxs-lookup"><span data-stu-id="68a92-309">Pointer to IP instance</span></span>                                                                                        |
| <span data-ttu-id="68a92-310">nx_ip_driver_packet</span><span class="sxs-lookup"><span data-stu-id="68a92-310">nx_ip_driver_packet</span></span>                | <span data-ttu-id="68a92-311">전송할 패킷에 대한 포인터</span><span class="sxs-lookup"><span data-stu-id="68a92-311">Pointer to the packet to send</span></span>                                                                                 |
| <span data-ttu-id="68a92-312">nx_ip_driver_physical_address_ms w</span><span class="sxs-lookup"><span data-stu-id="68a92-312">nx_ip_driver_physical_address_ms w</span></span> | <span data-ttu-id="68a92-313">0x0000FFFF(브로드캐스트)</span><span class="sxs-lookup"><span data-stu-id="68a92-313">0x0000FFFF (broadcast)</span></span>                                                                                        |
| <span data-ttu-id="68a92-314">nx_ip_driver_physical_address_lsw</span><span class="sxs-lookup"><span data-stu-id="68a92-314">nx_ip_driver_physical_address_lsw</span></span>  | <span data-ttu-id="68a92-315">0xFFFFFFFF(브로드캐스트)</span><span class="sxs-lookup"><span data-stu-id="68a92-315">0xFFFFFFFF (broadcast)</span></span>                                                                                        |
| <span data-ttu-id="68a92-316">nx_ip_driver_interface</span><span class="sxs-lookup"><span data-stu-id="68a92-316">nx_ip_driver_interface</span></span>             | <span data-ttu-id="68a92-317">인터페이스 인스턴스에 대한 포인터</span><span class="sxs-lookup"><span data-stu-id="68a92-317">Pointer to the interface instance.</span></span>                                                                            |
| <span data-ttu-id="68a92-318">nx_ip_driver_status</span><span class="sxs-lookup"><span data-stu-id="68a92-318">nx_ip_driver_status</span></span>                | <span data-ttu-id="68a92-319">완료 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-319">Completion status.</span></span> <span data-ttu-id="68a92-320">드라이버가 RARP 패킷을 전송할 수 없으면 0이 아닌 오류 상태를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-320">If the driver is not able to send the RARP packet, it will return a non-zero error status.</span></span> |

> [!IMPORTANT]  
> <span data-ttu-id="68a92-321">RARP 서비스가 필요한 애플리케이션은 이 명령을 구현해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-321">*Applications that require RARP service must implement this command*.</span></span>

### <a name="multicast-group-join"></a><span data-ttu-id="68a92-322">멀티캐스트 그룹 가입</span><span class="sxs-lookup"><span data-stu-id="68a92-322">Multicast Group Join</span></span>   
<span data-ttu-id="68a92-323">이 요청은 IPv4의 ***nx_igmp_multicast_interface join** _ 및 _*_nx_ipv4_multicast_interface_join_\*_ 서비스, IPv6의 _ \*_nxd_ipv6_multicast_interface_join_\*\*서비스와 IPv6에 필요한 다양한 작업을 사용하여 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-323">This request is made with the ***nx_igmp_multicast_interface join** _ and _*_nx_ipv4_multicast_interface_join_*_ service in IPv4, _ *_nxd_ipv6_multicast_interface_join_** service in IPv6, and various operation required by IPv6.</span></span> <span data-ttu-id="68a92-324">네트워크 드라이버는 제공된 멀티캐스트 그룹 주소를 사용하고 해당 멀티캐스트 그룹 주소에서 들어오는 패킷을 허용하도록 실제 미디어를 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-324">The network driver takes the supplied multicast group address and sets up the physical media to accept incoming packets from that multicast group address.</span></span> <span data-ttu-id="68a92-325">멀티캐스트 필터를 지원하지 않는 드라이버의 경우 드라이버 수신 로직은 비규칙(Promiscuous) 모드여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-325">Note that for drivers that don't support multicast filter, the driver receive logic may have to be in promiscuous mode.</span></span> <span data-ttu-id="68a92-326">이 경우 드라이버는 대상 MAC 주소를 기반으로 들어오는 프레임을 필터링하여 IP 인스턴스에 전달되는 트래픽의 양이 줄여야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-326">In this case, the driver may need to filter incoming frames based on destination MAC address, thus reducing the amount of traffic passed into the IP instance.</span></span> <span data-ttu-id="68a92-327">멀티캐스트 그룹 가입 요청에는 다음과 같은 NX_IP_DRIVER 멤버가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-327">The following NX_IP_DRIVER members are used for the multicast group join request.</span></span>

| <span data-ttu-id="68a92-328">NX_IP_DRIVER&nbsp;멤버</span><span class="sxs-lookup"><span data-stu-id="68a92-328">NX_IP_DRIVER&nbsp;member</span></span>                  | <span data-ttu-id="68a92-329">의미</span><span class="sxs-lookup"><span data-stu-id="68a92-329">Meaning</span></span>                                 |
| -------------------------------------- | --------------------------------------- |
| <span data-ttu-id="68a92-330">nx_ip_driver_command</span><span class="sxs-lookup"><span data-stu-id="68a92-330">nx_ip_driver_command</span></span>                | <span data-ttu-id="68a92-331">NX_LINK_MULTICAST_JOIN</span><span class="sxs-lookup"><span data-stu-id="68a92-331">NX_LINK_MULTICAST_JOIN</span></span>               |
| <span data-ttu-id="68a92-332">nx_ip_driver_ptr</span><span class="sxs-lookup"><span data-stu-id="68a92-332">nx_ip_driver_ptr</span></span>                    | <span data-ttu-id="68a92-333">IP 인스턴스에 대한 포인터</span><span class="sxs-lookup"><span data-stu-id="68a92-333">Pointer to IP instance</span></span>  |
| <span data-ttu-id="68a92-334">nx_ip_driver_physical_address_msw</span><span class="sxs-lookup"><span data-stu-id="68a92-334">nx_ip_driver_physical_address_msw</span></span> | <span data-ttu-id="68a92-335">가장 중요한 32비트 실제 멀티캐스트 주소</span><span class="sxs-lookup"><span data-stu-id="68a92-335">Most significant 32-bits of physical multicast address</span></span> |
| <span data-ttu-id="68a92-336">nx_ip_driver_physical_address_lsw</span><span class="sxs-lookup"><span data-stu-id="68a92-336">nx_ip_driver_physical_address_lsw</span></span> | <span data-ttu-id="68a92-337">최하위 32비트 실제 멀티캐스트 주소</span><span class="sxs-lookup"><span data-stu-id="68a92-337">Least significant 32-bits of physical multicast address</span></span> |
| <span data-ttu-id="68a92-338">nx_ip_driver_interface</span><span class="sxs-lookup"><span data-stu-id="68a92-338">nx_ip_driver_interface</span></span>              | <span data-ttu-id="68a92-339">인터페이스 인스턴스에 대한 포인터</span><span class="sxs-lookup"><span data-stu-id="68a92-339">Pointer to the interface instance</span></span> |
| <span data-ttu-id="68a92-340">nx_ip_driver_status</span><span class="sxs-lookup"><span data-stu-id="68a92-340">nx_ip_driver_status</span></span>                 | <span data-ttu-id="68a92-341">완료 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-341">Completion status.</span></span> <span data-ttu-id="68a92-342">드라이버가 멀티캐스트 그룹에 가입할 수 없는 경우 0이 아닌 오류 상태를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-342">If the driver is not able to join the multicast group, it will return a non-zero error status.</span></span> |

> [!NOTE]  
> <span data-ttu-id="68a92-343">IPv6 애플리케이션은 주소 구성과 같은 ICMPv6 기반 프로토콜에 대한 드라이버에서 멀티캐스트를 구현해야 합니다. 그러나 IPv4 애플리케이션은 멀티캐스트 기능이 필요하지 않을 경우 이 요청을 구현할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-343">*IPv6 applications will require multicast to be implemented in the driver for ICMPv6 based protocols such as address configuration. However, for IPv4 applications, implementation of this request is not necessary if multicast capabilities are not required*.</span></span>

> [!IMPORTANT]  
> <span data-ttu-id="68a92-344">IPv6를 사용하도록 설정하지 않고 IPv4에 멀티캐스트 기능이 필요하지 않은 경우 이 요청을 구현할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-344">*If IPv6 is not enabled, and multicast capabilities are not required by IPv4, implementation of this request is not required*.</span></span>

### <a name="multicast-group-leave"></a><span data-ttu-id="68a92-345">멀티캐스트 그룹 탈퇴</span><span class="sxs-lookup"><span data-stu-id="68a92-345">Multicast Group Leave</span></span>  
<span data-ttu-id="68a92-346">이 요청은 IPv4의 ***nx_igmp_multicast_interface_leave** _ 또는 _*_nx_ipv4_multicast_interface_leave_*_ 서비스나 IPv6의 _ *_nxd_ipv6_multicast_interface_leave_** 서비스를 명시적으로 호출하거나 IPv6에 필요한 다양한 내부 NetX Duo 작업을 통해 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-346">This request is invoked by explicitly calling the ***nx_igmp_multicast_interface_leave** _ or _*_nx_ipv4_multicast_interface_leave_*_ services in IPv4, _ *_nxd_ipv6_multicast_interface_leave_** service in IPv6, or by various internal NetX Duo operations required for IPv6.</span></span> <span data-ttu-id="68a92-347">드라이버가 제공된 이더넷 멀티캐스트 주소를 멀티캐스트 목록에서 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-347">The driver removes the supplied Ethernet multicast address from the multicast list.</span></span> <span data-ttu-id="68a92-348">호스트가 멀티캐스트 그룹을 나간 후, 이 이더넷 멀티캐스트 주소를 사용하는 네트워크의 패킷은 더 이상 이 IP 인스턴스에서 수신되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-348">After a host has left a multicast group, packets on the network with this Ethernet multicast address are no longer received by this IP instance.</span></span> <span data-ttu-id="68a92-349">다음 NX_IP_DRIVER 멤버는 멀티캐스트 그룹 탈퇴 요청에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-349">The following NX_IP_DRIVER members are used for the multicast group leave request.</span></span>

| <span data-ttu-id="68a92-350">NX_IP_DRIVER&nbsp;멤버</span><span class="sxs-lookup"><span data-stu-id="68a92-350">NX_IP_DRIVER&nbsp;member</span></span>              | <span data-ttu-id="68a92-351">의미</span><span class="sxs-lookup"><span data-stu-id="68a92-351">Meaning</span></span>                              |
| -----------------------------------| -------------------------------------|
| <span data-ttu-id="68a92-352">nx_ip_driver_command</span><span class="sxs-lookup"><span data-stu-id="68a92-352">nx_ip_driver_command</span></span>            | <span data-ttu-id="68a92-353">NX_LINK_MULTICAST_LEAVE</span><span class="sxs-lookup"><span data-stu-id="68a92-353">NX_LINK_MULTICAST_LEAVE</span></span>           |
| <span data-ttu-id="68a92-354">nx_ip_driver_ptr</span><span class="sxs-lookup"><span data-stu-id="68a92-354">nx_ip_driver_ptr</span></span>                | <span data-ttu-id="68a92-355">IP 인스턴스에 대한 포인터</span><span class="sxs-lookup"><span data-stu-id="68a92-355">Pointer to IP instance</span></span>   |
| <span data-ttu-id="68a92-356">nx_ip_driver_physical_address_msw</span><span class="sxs-lookup"><span data-stu-id="68a92-356">nx_ip_driver_physical_address_msw</span></span> | <span data-ttu-id="68a92-357">가장 중요한 32비트 실제 멀티캐스트 주소</span><span class="sxs-lookup"><span data-stu-id="68a92-357">Most significant 32 bits of physical multicast address</span></span> |
| <span data-ttu-id="68a92-358">nx_ip_driver_physical_address_lsw</span><span class="sxs-lookup"><span data-stu-id="68a92-358">nx_ip_driver_physical_address_lsw</span></span> | <span data-ttu-id="68a92-359">최하위 32비트 실제 멀티캐스트 주소</span><span class="sxs-lookup"><span data-stu-id="68a92-359">Least significant 32 bits of physical multicast address</span></span> |
| <span data-ttu-id="68a92-360">nx_ip_driver_interface</span><span class="sxs-lookup"><span data-stu-id="68a92-360">nx_ip_driver_interface</span></span>              | <span data-ttu-id="68a92-361">인터페이스 인스턴스에 대한 포인터</span><span class="sxs-lookup"><span data-stu-id="68a92-361">Pointer to the interface instance</span></span> |
| <span data-ttu-id="68a92-362">nx_ip_driver_status</span><span class="sxs-lookup"><span data-stu-id="68a92-362">nx_ip_driver_status</span></span>                 | <span data-ttu-id="68a92-363">완료 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-363">Completion status.</span></span> <span data-ttu-id="68a92-364">드라이버가 멀티캐스트 그룹을 나갈 수 없는 경우 0이 아닌 오류 상태를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-364">If the driver is not able to leave the multicast group, it will return a non-zero error status.</span></span> |

> [!IMPORTANT]  
> <span data-ttu-id="68a92-365">IPv4 또는 IPv6에서 멀티캐스트 기능이 필요하지 않은 경우 이 요청을 구현할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-365">*If multicast capabilities are not required by either IPv4 or IPv6, implementation of this request is not required*.</span></span>

### <a name="attach-interface"></a><span data-ttu-id="68a92-366">인터페이스 연결</span><span class="sxs-lookup"><span data-stu-id="68a92-366">Attach Interface</span></span>  
<span data-ttu-id="68a92-367">이 요청은 NetX Duo에서 디바이스 드라이버로 호출되므로 드라이버에서 드라이버 인스턴스를 해당 IP 인스턴스와 IP 내의 실제 인터페이스 인스턴스와 연결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-367">This request is invoked from the NetX Duo to the device driver, allowing the driver to associate the driver instance with the corresponding IP instance and the physical interface instance within the IP.</span></span> <span data-ttu-id="68a92-368">인터페이스 연결 요청에 사용되는 NX_IP_DRIVER 멤버는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-368">The following NX_IP_DRIVER members are used for the attach interface request.</span></span>

| <span data-ttu-id="68a92-369">NX_IP_DRIVER&nbsp;멤버</span><span class="sxs-lookup"><span data-stu-id="68a92-369">NX_IP_DRIVER&nbsp;member</span></span>    | <span data-ttu-id="68a92-370">의미</span><span class="sxs-lookup"><span data-stu-id="68a92-370">Meaning</span></span>                  |
|------------------------|--------------------------|
| <span data-ttu-id="68a92-371">nx_ip_driver_command</span><span class="sxs-lookup"><span data-stu-id="68a92-371">nx_ip_driver_command</span></span>   | <span data-ttu-id="68a92-372">NX_LINK_INTERFACE_ATTACH</span><span class="sxs-lookup"><span data-stu-id="68a92-372">NX_LINK_INTERFACE_ATTACH</span></span> |
| <span data-ttu-id="68a92-373">nx_ip_driver_ptr</span><span class="sxs-lookup"><span data-stu-id="68a92-373">nx_ip_driver_ptr</span></span>       | <span data-ttu-id="68a92-374">IP 인스턴스에 대한 포인터</span><span class="sxs-lookup"><span data-stu-id="68a92-374">Pointer to IP instance</span></span>   |
| <span data-ttu-id="68a92-375">nx_ip_driver_interface</span><span class="sxs-lookup"><span data-stu-id="68a92-375">nx_ip_driver_interface</span></span> | <span data-ttu-id="68a92-376">인터페이스 인스턴스에 대한 포인터</span><span class="sxs-lookup"><span data-stu-id="68a92-376">Pointer to the interface instance.</span></span>|
| <span data-ttu-id="68a92-377">nx_ip_driver_status</span><span class="sxs-lookup"><span data-stu-id="68a92-377">nx_ip_driver_status</span></span>    | <span data-ttu-id="68a92-378">완료 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-378">Completion status.</span></span> <span data-ttu-id="68a92-379">드라이버가 지정된 인터페이스를 IP 인스턴스로 분리할 수 없는 경우 0이 아닌 오류 상태를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-379">If the driver is not able to detach the specified interface to the IP instance, it will return a non-zero error status.</span></span> |

### <a name="detach-interface"></a><span data-ttu-id="68a92-380">인터페이스 분리</span><span class="sxs-lookup"><span data-stu-id="68a92-380">Detach Interface</span></span>    
<span data-ttu-id="68a92-381">이 요청은 디바이스 드라이버에 대한 NetX Duo에 의해 호출되며, 드라이버에서 해당 IP 인스턴스 및 IP 내의 실제 인터페이스 인스턴스와 드라이버 인스턴스의 연결을 끊을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-381">This request is invoked by NetX Duo to the device driver, allowing the driver to disassociate the driver instance with the corresponding IP instance and the physical interface instance within the IP.</span></span> <span data-ttu-id="68a92-382">인터페이스 연결 요청에 사용되는 NX_IP_DRIVER 멤버는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-382">The following NX_IP_DRIVER members are used for the attach interface request.</span></span>

| <span data-ttu-id="68a92-383">NX_IP_DRIVER&nbsp;멤버</span><span class="sxs-lookup"><span data-stu-id="68a92-383">NX_IP_DRIVER&nbsp;member</span></span>    | <span data-ttu-id="68a92-384">의미</span><span class="sxs-lookup"><span data-stu-id="68a92-384">Meaning</span></span>                                                                                                                                    |
|------------------------|--------------------------------------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="68a92-385">nx_ip_driver_command</span><span class="sxs-lookup"><span data-stu-id="68a92-385">nx_ip_driver_command</span></span>   | <span data-ttu-id="68a92-386">NX_LINK_INTERFACE_DETACH</span><span class="sxs-lookup"><span data-stu-id="68a92-386">NX_LINK_INTERFACE_DETACH</span></span>                                                                                                                   |
| <span data-ttu-id="68a92-387">nx_ip_driver_ptr</span><span class="sxs-lookup"><span data-stu-id="68a92-387">nx_ip_driver_ptr</span></span>       | <span data-ttu-id="68a92-388">IP 인스턴스에 대한 포인터</span><span class="sxs-lookup"><span data-stu-id="68a92-388">Pointer to IP instance</span></span>                                                                                                                     |
| <span data-ttu-id="68a92-389">nx_ip_driver_interface</span><span class="sxs-lookup"><span data-stu-id="68a92-389">nx_ip_driver_interface</span></span> | <span data-ttu-id="68a92-390">인터페이스 인스턴스에 대한 포인터</span><span class="sxs-lookup"><span data-stu-id="68a92-390">Pointer to the interface instance.</span></span>                                                                                                         |
| <span data-ttu-id="68a92-391">nx_ip_driver_status</span><span class="sxs-lookup"><span data-stu-id="68a92-391">nx_ip_driver_status</span></span>    | <span data-ttu-id="68a92-392">완료 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-392">Completion status.</span></span> <span data-ttu-id="68a92-393">드라이버가 지정된 인터페이스를 IP 인스턴스에 연결할 수 없는 경우 0이 아닌 오류 상태를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-393">If the driver is not able to attach the specified interface to the IP instance, it will return a non-zero error status.</span></span> |

### <a name="get-link-status"></a><span data-ttu-id="68a92-394">링크 상태 가져오기</span><span class="sxs-lookup"><span data-stu-id="68a92-394">Get Link Status</span></span>    
<span data-ttu-id="68a92-395">애플리케이션은 호스트의 모든 인터페이스에 대해 NetX Duo 서비스 ***nx_ip_interface_status_check*** 서비스를 사용하여 네트워크 인터페이스 링크 상태를 쿼리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-395">The application can query the network interface link status using the NetX Duo service ***nx_ip_interface_status_check*** service for any interface on the host.</span></span> <span data-ttu-id="68a92-396">해당 서비스에 대한 자세한 내용은 149페이지의 4장 “NetX Duo 서비스 설명”을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="68a92-396">See Chapter 4, "Description of NetX Duo Services" on page 149, for more details on these services.</span></span>

<span data-ttu-id="68a92-397">링크 상태는 *nx_ip_driver_interface* 포인터가 가리키는 NX_INTERFACE 구조의 *nx_interface_link_up* 필드에 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-397">The link status is contained in the *nx_interface_link_up* field in the NX_INTERFACE structure pointed to by *nx_ip_driver_interface* pointer.</span></span> <span data-ttu-id="68a92-398">링크 상태 요청에는 다음과 같은 NX_IP_DRIVER 멤버가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-398">The following NX_IP_DRIVER members are used for the link status request.</span></span>

| <span data-ttu-id="68a92-399">NX_IP_DRIVER&nbsp;멤버</span><span class="sxs-lookup"><span data-stu-id="68a92-399">NX_IP_DRIVER&nbsp;member</span></span>       | <span data-ttu-id="68a92-400">의미</span><span class="sxs-lookup"><span data-stu-id="68a92-400">Meaning</span></span>                  |
| --------------------------- | -------------------------|
| <span data-ttu-id="68a92-401">nx_ip_driver_command</span><span class="sxs-lookup"><span data-stu-id="68a92-401">nx_ip_driver_command</span></span>     | <span data-ttu-id="68a92-402">NX_LINK_GET_STATUS</span><span class="sxs-lookup"><span data-stu-id="68a92-402">NX_LINK_GET_STATUS</span></span>    |
| <span data-ttu-id="68a92-403">nx_ip_driver_ptr</span><span class="sxs-lookup"><span data-stu-id="68a92-403">nx_ip_driver_ptr</span></span>         | <span data-ttu-id="68a92-404">IP 인스턴스에 대한 포인터</span><span class="sxs-lookup"><span data-stu-id="68a92-404">Pointer to IP instance</span></span>   |
| <span data-ttu-id="68a92-405">nx_ip_driver_return_ptr</span><span class="sxs-lookup"><span data-stu-id="68a92-405">nx_ip_driver_return_ptr</span></span> | <span data-ttu-id="68a92-406">상태를 배치할 대상에 대한 포인터</span><span class="sxs-lookup"><span data-stu-id="68a92-406">Pointer to the destination to place the status.</span></span> |
| <span data-ttu-id="68a92-407">nx_ip_driver_interface</span><span class="sxs-lookup"><span data-stu-id="68a92-407">nx_ip_driver_interface</span></span>   | <span data-ttu-id="68a92-408">인터페이스 인스턴스에 대한 포인터</span><span class="sxs-lookup"><span data-stu-id="68a92-408">Pointer to the interface instance</span></span>   |
| <span data-ttu-id="68a92-409">nx_ip_driver_status</span><span class="sxs-lookup"><span data-stu-id="68a92-409">nx_ip_driver_status</span></span>      | <span data-ttu-id="68a92-410">완료 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-410">Completion status.</span></span> <span data-ttu-id="68a92-411">드라이버가 특정 상태를 가져올 수 없는 경우 0이 아닌 오류 상태를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-411">If the driver is not able to get specific status, it will return a non-zero error status.</span></span> |

> [!NOTE]  
> <span data-ttu-id="68a92-412">\***nx_ip_status_check** _는 기본 인터페이스 상태를 계속 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-412">\***nx_ip_status_check** _ is still available for checking the status of the primary interface.</span></span> <span data-ttu-id="68a92-413">그러나 애플리케이션 개발자는 인터페이스 특정 서비스인 _ \*_nx_ip_interface_status_check_\*\*를 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-413">However, application developers are encouraged to use the interface specific service: _ *_nx_ip_interface_status_check._*\*</span></span>

### <a name="get-link-speed"></a><span data-ttu-id="68a92-414">링크 속도 가져오기</span><span class="sxs-lookup"><span data-stu-id="68a92-414">Get Link Speed</span></span>  
<span data-ttu-id="68a92-415">이 요청은 ***nx_ip_driver_direct_command*** 서비스 내에서 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-415">This request is made from within the ***nx_ip_driver_direct_command*** service.</span></span> <span data-ttu-id="68a92-416">드라이버는 제공된 대상에서 링크의 회선 속도를 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-416">The driver stores the link's line speed in the supplied destination.</span></span> <span data-ttu-id="68a92-417">링크 회선 속도 요청에는 다음과 같은 NX_IP_DRIVER 멤버가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-417">The following NX_IP_DRIVER members are used for the link line speed request.</span></span>

| <span data-ttu-id="68a92-418">NX_IP_DRIVER&nbsp;멤버</span><span class="sxs-lookup"><span data-stu-id="68a92-418">NX_IP_DRIVER&nbsp;member</span></span>   | <span data-ttu-id="68a92-419">의미</span><span class="sxs-lookup"><span data-stu-id="68a92-419">Meaning</span></span>                   |
| ------------------------| ------------------------- |
| <span data-ttu-id="68a92-420">nx_ip_driver_command</span><span class="sxs-lookup"><span data-stu-id="68a92-420">nx_ip_driver_command</span></span>     | <span data-ttu-id="68a92-421">NX_LINK_GET_SPEED</span><span class="sxs-lookup"><span data-stu-id="68a92-421">NX_LINK_GET_SPEED</span></span>          |
| <span data-ttu-id="68a92-422">nx_ip_driver_ptr</span><span class="sxs-lookup"><span data-stu-id="68a92-422">nx_ip_driver_ptr</span></span>         | <span data-ttu-id="68a92-423">IP 인스턴스에 대한 포인터</span><span class="sxs-lookup"><span data-stu-id="68a92-423">Pointer to IP instance</span></span>                                                                                         |
| <span data-ttu-id="68a92-424">nx_ip_driver_return_ptr</span><span class="sxs-lookup"><span data-stu-id="68a92-424">nx_ip_driver_return_ptr</span></span> | <span data-ttu-id="68a92-425">회선 속도를 배치할 대상에 대한 포인터</span><span class="sxs-lookup"><span data-stu-id="68a92-425">Pointer to the destination to place the line speed</span></span>                                                             |
| <span data-ttu-id="68a92-426">nx_ip_driver_interface</span><span class="sxs-lookup"><span data-stu-id="68a92-426">nx_ip_driver_interface</span></span>   | <span data-ttu-id="68a92-427">인터페이스 인스턴스에 대한 포인터</span><span class="sxs-lookup"><span data-stu-id="68a92-427">Pointer to the interface instance</span></span>                                                                              |
| <span data-ttu-id="68a92-428">nx_ip_driver_status</span><span class="sxs-lookup"><span data-stu-id="68a92-428">nx_ip_driver_status</span></span>      | <span data-ttu-id="68a92-429">완료 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-429">Completion status.</span></span> <span data-ttu-id="68a92-430">드라이버에서 속도 정보를 가져올 수 없는 경우 0이 아닌 오류 상태를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-430">If the driver is not able to get speed information, it will return a non-zero error status.</span></span> |

> [!IMPORTANT]  
> <span data-ttu-id="68a92-431">이 요청은 NetX Duo에서 내부적으로 사용되지 않으므로 해당 구현은 선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-431">*This request is not used internally by NetX Duo so its implementation is optional*.</span></span>

### <a name="get-duplex-type"></a><span data-ttu-id="68a92-432">이중 형식 가져오기</span><span class="sxs-lookup"><span data-stu-id="68a92-432">Get Duplex Type</span></span>   
<span data-ttu-id="68a92-433">이 요청은 ***nx_ip_driver_direct_command*** 서비스 내에서 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-433">This request is made from within the ***nx_ip_driver_direct_command*** service.</span></span> <span data-ttu-id="68a92-434">드라이버는 제공된 대상에 링크의 이중 형식을 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-434">The driver stores the link's duplex type in the supplied destination.</span></span> <span data-ttu-id="68a92-435">이중 형식 요청에 사용되는 NX_IP_DRIVER 멤버는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-435">The following NX_IP_DRIVER members are used for the duplex type request.</span></span>

| <span data-ttu-id="68a92-436">NX_IP_DRIVER&nbsp;멤버</span><span class="sxs-lookup"><span data-stu-id="68a92-436">NX_IP_DRIVER&nbsp;member</span></span>   | <span data-ttu-id="68a92-437">의미</span><span class="sxs-lookup"><span data-stu-id="68a92-437">Meaning</span></span>                                                                                                    |
| --------------------------- | -------------------------------------------------------------------------------------------------------------- |
| <span data-ttu-id="68a92-438">nx_ip_driver_command</span><span class="sxs-lookup"><span data-stu-id="68a92-438">nx_ip_driver_command</span></span>     | <span data-ttu-id="68a92-439">NX_LINK_GET_DUPLEX_TYPE</span><span class="sxs-lookup"><span data-stu-id="68a92-439">NX_LINK_GET_DUPLEX_TYPE</span></span>                                                                                    |
| <span data-ttu-id="68a92-440">nx_ip_driver_ptr</span><span class="sxs-lookup"><span data-stu-id="68a92-440">nx_ip_driver_ptr</span></span>         | <span data-ttu-id="68a92-441">IP 인스턴스에 대한 포인터</span><span class="sxs-lookup"><span data-stu-id="68a92-441">Pointer to IP instance</span></span>                                                                                         |
| <span data-ttu-id="68a92-442">nx_ip_driver_return_ptr</span><span class="sxs-lookup"><span data-stu-id="68a92-442">nx_ip_driver_return_ptr</span></span> | <span data-ttu-id="68a92-443">이중 형식을 배치할 대상에 대한 포인터</span><span class="sxs-lookup"><span data-stu-id="68a92-443">Pointer to the destination to place the duplex type</span></span>                                                            |
| <span data-ttu-id="68a92-444">nx_ip_driver_interface</span><span class="sxs-lookup"><span data-stu-id="68a92-444">nx_ip_driver_interface</span></span>   | <span data-ttu-id="68a92-445">인터페이스 인스턴스에 대한 포인터</span><span class="sxs-lookup"><span data-stu-id="68a92-445">Pointer to the interface instance</span></span>                                                                              |
| <span data-ttu-id="68a92-446">nx_ip_driver_status</span><span class="sxs-lookup"><span data-stu-id="68a92-446">nx_ip_driver_status</span></span>      | <span data-ttu-id="68a92-447">완료 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-447">Completion status.</span></span> <span data-ttu-id="68a92-448">드라이버에서 이중 정보를 가져올 수 없는 경우 0이 아닌 오류 상태를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-448">If the driver is not able to get duplex information, it will return a nonzero error status.</span></span> |

> [!IMPORTANT]  
> <span data-ttu-id="68a92-449">이 요청은 NetX Duo에서 내부적으로 사용되지 않으므로 해당 구현은 선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-449">*This request is not used internally by NetX Duo so its implementation is optional*.</span></span>

### <a name="get-error-count"></a><span data-ttu-id="68a92-450">오류 개수 가져오기</span><span class="sxs-lookup"><span data-stu-id="68a92-450">Get Error Count</span></span>   
<span data-ttu-id="68a92-451">이 요청은 ***nx_ip_driver_direct_command*** 서비스 내에서 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-451">This request is made from within the ***nx_ip_driver_direct_command*** service.</span></span> <span data-ttu-id="68a92-452">드라이버는 제공된 대상에 링크의 오류 개수를 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-452">The driver stores the link's error count in the supplied destination.</span></span> <span data-ttu-id="68a92-453">이 기능을 지원하려면 드라이버에서 작업 오류를 추적해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-453">To support this feature, the driver needs to track operation errors.</span></span> <span data-ttu-id="68a92-454">링크 오류 개수 요청에는 다음과 같은 NX_IP_DRIVER 멤버가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-454">The following NX_IP_DRIVER members are used for the link error count request.</span></span>

| <span data-ttu-id="68a92-455">NX_IP_DRIVER&nbsp;멤버</span><span class="sxs-lookup"><span data-stu-id="68a92-455">NX_IP_DRIVER&nbsp;member</span></span>   | <span data-ttu-id="68a92-456">의미</span><span class="sxs-lookup"><span data-stu-id="68a92-456">Meaning</span></span>                   |
| --------------------------- | -------------------------------|
| <span data-ttu-id="68a92-457">nx_ip_driver_command</span><span class="sxs-lookup"><span data-stu-id="68a92-457">nx_ip_driver_command</span></span>     | <span data-ttu-id="68a92-458">NX_LINK_GET_ERROR_COUNT</span><span class="sxs-lookup"><span data-stu-id="68a92-458">NX_LINK_GET_ERROR_COUNT</span></span>   |
| <span data-ttu-id="68a92-459">nx_ip_driver_ptr</span><span class="sxs-lookup"><span data-stu-id="68a92-459">nx_ip_driver_ptr</span></span>         | <span data-ttu-id="68a92-460">IP 인스턴스에 대한 포인터</span><span class="sxs-lookup"><span data-stu-id="68a92-460">Pointer to IP instance</span></span>   |
| <span data-ttu-id="68a92-461">nx_ip_driver_return_ptr</span><span class="sxs-lookup"><span data-stu-id="68a92-461">nx_ip_driver_return_ptr</span></span> | <span data-ttu-id="68a92-462">오류 개수를 배치할 대상에 대한 포인터</span><span class="sxs-lookup"><span data-stu-id="68a92-462">Pointer to the destination to place the error count</span></span> |
| <span data-ttu-id="68a92-463">nx_ip_driver_interface</span><span class="sxs-lookup"><span data-stu-id="68a92-463">nx_ip_driver_interface</span></span>   | <span data-ttu-id="68a92-464">인터페이스 인스턴스에 대한 포인터</span><span class="sxs-lookup"><span data-stu-id="68a92-464">Pointer to the interface instance</span></span>|
| <span data-ttu-id="68a92-465">nx_ip_driver_status</span><span class="sxs-lookup"><span data-stu-id="68a92-465">nx_ip_driver_status</span></span>      | <span data-ttu-id="68a92-466">완료 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-466">Completion status.</span></span> <span data-ttu-id="68a92-467">드라이버가 오류 개수를 가져올 수 없는 경우 0이 아닌 오류 상태를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-467">If the driver is not able to get error count, it will return a non-zero error status.</span></span> |

> [!IMPORTANT]
> <span data-ttu-id="68a92-468">이 요청은 NetX Duo에서 내부적으로 사용되지 않으므로 해당 구현은 선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-468">*This request is not used internally by NetX Duo so its implementation is optional*.</span></span>

### <a name="get-receive-packet-count"></a><span data-ttu-id="68a92-469">수신 패킷 개수 가져오기</span><span class="sxs-lookup"><span data-stu-id="68a92-469">Get Receive Packet Count</span></span>    
<span data-ttu-id="68a92-470">이 요청은 ***nx_ip_driver_direct_command*** 서비스 내에서 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-470">This request is made from within the ***nx_ip_driver_direct_command*** service.</span></span> <span data-ttu-id="68a92-471">드라이버는 제공된 대상에 링크의 수신 패킷 개수를 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-471">The driver stores the link's receive packet count in the supplied destination.</span></span> <span data-ttu-id="68a92-472">이 기능을 지원하려면 드라이버가 수신된 패킷 개수를 추적해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-472">To support this feature, the driver needs to keep track of the number of packets received.</span></span> <span data-ttu-id="68a92-473">링크 수신 패킷 개수 요청에는 다음과 같은 NX_IP_DRIVER 멤버가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-473">The following NX_IP_DRIVER members are used for the link receive packet count request.</span></span>

| <span data-ttu-id="68a92-474">NX_IP_DRIVER&nbsp;멤버</span><span class="sxs-lookup"><span data-stu-id="68a92-474">NX_IP_DRIVER&nbsp;member</span></span>       | <span data-ttu-id="68a92-475">의미</span><span class="sxs-lookup"><span data-stu-id="68a92-475">Meaning</span></span>                        |
| --------------------------- | -------------------------------|
| <span data-ttu-id="68a92-476">nx_ip_driver_command</span><span class="sxs-lookup"><span data-stu-id="68a92-476">nx_ip_driver_command</span></span>     | <span data-ttu-id="68a92-477">NX_LINK_GET_RX_COUNT</span><span class="sxs-lookup"><span data-stu-id="68a92-477">NX_LINK_GET_RX_COUNT</span></span>      |
| <span data-ttu-id="68a92-478">nx_ip_driver_ptr</span><span class="sxs-lookup"><span data-stu-id="68a92-478">nx_ip_driver_ptr</span></span>         | <span data-ttu-id="68a92-479">IP 인스턴스에 대한 포인터</span><span class="sxs-lookup"><span data-stu-id="68a92-479">Pointer to IP instance</span></span>  |
| <span data-ttu-id="68a92-480">nx_ip_driver_return_ptr</span><span class="sxs-lookup"><span data-stu-id="68a92-480">nx_ip_driver_return_ptr</span></span> | <span data-ttu-id="68a92-481">수신 패킷 개수를 배치할 대상에 대한 포인터</span><span class="sxs-lookup"><span data-stu-id="68a92-481">Pointer to the destination to place the receive packet count</span></span>   |
| <span data-ttu-id="68a92-482">nx_ip_driver_interface</span><span class="sxs-lookup"><span data-stu-id="68a92-482">nx_ip_driver_interface</span></span>   | <span data-ttu-id="68a92-483">실제 네트워크 인터페이스에 대한 포인터</span><span class="sxs-lookup"><span data-stu-id="68a92-483">Pointer to the physical network interface</span></span>  |
| <span data-ttu-id="68a92-484">nx_ip_driver_status</span><span class="sxs-lookup"><span data-stu-id="68a92-484">nx_ip_driver_status</span></span>      | <span data-ttu-id="68a92-485">완료 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-485">Completion status.</span></span> <span data-ttu-id="68a92-486">드라이버가 수신 개수를 가져올 수 없는 경우 0이 아닌 오류 상태를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-486">If the driver is not able to get receive count, it will return a non-zero error status.</span></span> |

> [!IMPORTANT]  
> <span data-ttu-id="68a92-487">이 요청은 NetX Duo에서 내부적으로 사용되지 않으므로 해당 구현은 선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-487">*This request is not used internally by NetX Duo so its implementation is optional*.</span></span>

### <a name="get-transmit-packet-count"></a><span data-ttu-id="68a92-488">전송 패킷 개수 가져오기</span><span class="sxs-lookup"><span data-stu-id="68a92-488">Get Transmit Packet Count</span></span>   
<span data-ttu-id="68a92-489">이 요청은 ***nx_ip_driver_direct_command*** 서비스 내에서 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-489">This request is made from within the ***nx_ip_driver_direct_command*** service.</span></span> <span data-ttu-id="68a92-490">드라이버는 제공된 대상에 링크의 전송 패킷 개수를 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-490">The driver stores the link's transmit packet count in the supplied destination.</span></span> <span data-ttu-id="68a92-491">이 기능을 지원하려면 드라이버가 각 인터페이스에서 전송하는 각 패킷을 추적해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-491">To support this feature, the driver needs to keep track of each packet it transmits on each interface.</span></span> <span data-ttu-id="68a92-492">링크 전송 패킷 개수 요청에는 다음과 같은 NX_IP_DRIVER 멤버가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-492">The following  NX_IP_DRIVER members are used for the link transmit packet count request.</span></span>

| <span data-ttu-id="68a92-493">NX_IP_DRIVER&nbsp;멤버</span><span class="sxs-lookup"><span data-stu-id="68a92-493">NX_IP_DRIVER&nbsp;member</span></span>   | <span data-ttu-id="68a92-494">의미</span><span class="sxs-lookup"><span data-stu-id="68a92-494">Meaning</span></span>                   |
| ----------------------- | ------------------------- |
| <span data-ttu-id="68a92-495">nx_ip_driver_command</span><span class="sxs-lookup"><span data-stu-id="68a92-495">nx_ip_driver_command</span></span> | <span data-ttu-id="68a92-496">NX_LINK_GET_TX_COUNT</span><span class="sxs-lookup"><span data-stu-id="68a92-496">NX_LINK_GET_TX_COUNT</span></span>  |
| <span data-ttu-id="68a92-497">nx_ip_driver_ptr</span><span class="sxs-lookup"><span data-stu-id="68a92-497">nx_ip_driver_ptr</span></span>     | <span data-ttu-id="68a92-498">IP 인스턴스에 대한 포인터</span><span class="sxs-lookup"><span data-stu-id="68a92-498">Pointer to IP instance</span></span>    |
| <span data-ttu-id="68a92-499">nx_ip_driver_return_ptr</span><span class="sxs-lookup"><span data-stu-id="68a92-499">nx_ip_driver_return_ptr</span></span> | <span data-ttu-id="68a92-500">전송 패킷 개수를 배치할 대상에 대한 포인터</span><span class="sxs-lookup"><span data-stu-id="68a92-500">Pointer to the destination to place the transmit packet count</span></span>  |
| <span data-ttu-id="68a92-501">nx_ip_driver_interface</span><span class="sxs-lookup"><span data-stu-id="68a92-501">nx_ip_driver_interface</span></span>   | <span data-ttu-id="68a92-502">인터페이스 인스턴스에 대한 포인터</span><span class="sxs-lookup"><span data-stu-id="68a92-502">Pointer to the interface instance</span></span>   |
| <span data-ttu-id="68a92-503">nx_ip_driver_status</span><span class="sxs-lookup"><span data-stu-id="68a92-503">nx_ip_driver_status</span></span>      | <span data-ttu-id="68a92-504">완료 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-504">Completion status.</span></span> <span data-ttu-id="68a92-505">드라이버가 전송 개수를 가져올 수 없는 경우 0이 아닌 오류 상태를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-505">If the driver is not able to get transmit count, it will return a non-zero error status.</span></span> |

> [!IMPORTANT]  
> <span data-ttu-id="68a92-506">이 요청은 NetX Duo에서 내부적으로 사용되지 않으므로 해당 구현은 선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-506">*This request is not used internally by NetX Duo so its implementation is optional*.</span></span>

### <a name="get-allocation-errors"></a><span data-ttu-id="68a92-507">할당 오류 가져오기</span><span class="sxs-lookup"><span data-stu-id="68a92-507">Get Allocation Errors</span></span>   
<span data-ttu-id="68a92-508">이 요청은 ***nx_ip_driver_direct_command*** 서비스 내에서 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-508">This request is made from within the ***nx_ip_driver_direct_command*** service.</span></span> <span data-ttu-id="68a92-509">드라이버는 제공된 대상에 링크의 패킷 풀 할당 오류 개수를 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-509">The driver stores the link's packet pool allocation error count in the supplied destination.</span></span> <span data-ttu-id="68a92-510">링크 할당 오류 개수 요청에는 다음과 같은 NX_IP_DRIVER 멤버가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-510">The following NX_IP_DRIVER members are used for the link allocation error count request.</span></span>

| <span data-ttu-id="68a92-511">NX_IP_DRIVER&nbsp;멤버</span><span class="sxs-lookup"><span data-stu-id="68a92-511">NX_IP_DRIVER&nbsp;member</span></span>       | <span data-ttu-id="68a92-512">의미</span><span class="sxs-lookup"><span data-stu-id="68a92-512">Meaning</span></span>                       |
| --------------------------- | ----------------------------- |
| <span data-ttu-id="68a92-513">nx_ip_driver_command</span><span class="sxs-lookup"><span data-stu-id="68a92-513">nx_ip_driver_command</span></span>     | <span data-ttu-id="68a92-514">NX_LINK_GET_ALLOC_ERRORS</span><span class="sxs-lookup"><span data-stu-id="68a92-514">NX_LINK_GET_ALLOC_ERRORS</span></span>  |
| <span data-ttu-id="68a92-515">nx_ip_driver_ptr</span><span class="sxs-lookup"><span data-stu-id="68a92-515">nx_ip_driver_ptr</span></span>         | <span data-ttu-id="68a92-516">IP 인스턴스에 대한 포인터</span><span class="sxs-lookup"><span data-stu-id="68a92-516">Pointer to IP instance</span></span>     |
| <span data-ttu-id="68a92-517">nx_ip_driver_return_ptr</span><span class="sxs-lookup"><span data-stu-id="68a92-517">nx_ip_driver_return_ptr</span></span> | <span data-ttu-id="68a92-518">할당 오류 개수를 배치할 대상에 대한 포인터</span><span class="sxs-lookup"><span data-stu-id="68a92-518">Pointer to the destination to place the allocation error count</span></span>  |
| <span data-ttu-id="68a92-519">nx_ip_driver_interface</span><span class="sxs-lookup"><span data-stu-id="68a92-519">nx_ip_driver_interface</span></span>   | <span data-ttu-id="68a92-520">인터페이스 인스턴스에 대한 포인터</span><span class="sxs-lookup"><span data-stu-id="68a92-520">Pointer to the interface instance</span></span>  |
| <span data-ttu-id="68a92-521">nx_ip_driver_status</span><span class="sxs-lookup"><span data-stu-id="68a92-521">nx_ip_driver_status</span></span>      | <span data-ttu-id="68a92-522">완료 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-522">Completion status.</span></span> <span data-ttu-id="68a92-523">드라이버가 할당 오류를 가져올 수 없는 경우 0이 아닌 오류 상태를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-523">If the driver is not able to get allocation errors, it will return a non-zero error status.</span></span> |

> [!IMPORTANT]  
> <span data-ttu-id="68a92-524">이 요청은 NetX Duo에서 내부적으로 사용되지 않으므로 해당 구현은 선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-524">*This request is not used internally by NetX Duo so its implementation is optional*.</span></span>

### <a name="driver-deferred-processing"></a><span data-ttu-id="68a92-525">드라이버 지연된 처리</span><span class="sxs-lookup"><span data-stu-id="68a92-525">Driver Deferred Processing</span></span>    
<span data-ttu-id="68a92-526">이 요청은 전송 또는 수신 ISR에서 _\***nx_ip_driver_deferred_processing**_ 루틴을 호출하는 드라이버에 대한 응답으로 IP 도우미 스레드에서 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-526">This request is made from the IP helper thread in response to the driver calling the _\***nx_ip_driver_deferred_processing**_ routine from a transmit or receive ISR.</span></span> <span data-ttu-id="68a92-527">이렇게 하면 드라이버 ISR에서 패킷 수신 및 IP 도우미 스레드로 전송 처리를 지연시켜 ISR에서 처리할 양을 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-527">This allows the driver ISR to defer the packet receive and transmit processing to the IP helper thread and thus reduce the amount to process in the ISR.</span></span> <span data-ttu-id="68a92-528">*nx_ip_driver_interface* 에서 가리키는 NX_INTERFACE 구조의 _nx_interface_additional_link_info\* 필드는 드라이버에서 IP 도우미 스레드 컨텍스트의 지연된 처리 이벤트에 대한 정보를 저장하는 데 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-528">The _nx_interface_additional_link_info\* field in the NX_INTERFACE structure pointed to by *nx_ip_driver_interface* may be used by the driver to store information about the deferred processing event from the IP helper thread context.</span></span> <span data-ttu-id="68a92-529">지연 처리 이벤트에는 다음과 같은 NX_IP_DRIVER 멤버가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-529">The following  NX_IP_DRIVER members are used for the deferred processing event.</span></span>

| <span data-ttu-id="68a92-530">NX_IP_DRIVER&nbsp;멤버</span><span class="sxs-lookup"><span data-stu-id="68a92-530">NX_IP_DRIVER&nbsp;member</span></span>     | <span data-ttu-id="68a92-531">의미</span><span class="sxs-lookup"><span data-stu-id="68a92-531">Meaning</span></span>                           |
| ------------------------- | --------------------------------- |
| <span data-ttu-id="68a92-532">nx_ip_driver_command</span><span class="sxs-lookup"><span data-stu-id="68a92-532">nx_ip_driver_command</span></span>   | <span data-ttu-id="68a92-533">NX_LINK_DEFERRED_PROCESSING</span><span class="sxs-lookup"><span data-stu-id="68a92-533">NX_LINK_DEFERRED_PROCESSING</span></span>    |
| <span data-ttu-id="68a92-534">nx_ip_driver_ptr</span><span class="sxs-lookup"><span data-stu-id="68a92-534">nx_ip_driver_ptr</span></span>       | <span data-ttu-id="68a92-535">IP 인스턴스에 대한 포인터</span><span class="sxs-lookup"><span data-stu-id="68a92-535">Pointer to IP instance</span></span>            |
| <span data-ttu-id="68a92-536">nx_ip_driver_interface</span><span class="sxs-lookup"><span data-stu-id="68a92-536">nx_ip_driver_interface</span></span> | <span data-ttu-id="68a92-537">인터페이스 인스턴스에 대한 포인터</span><span class="sxs-lookup"><span data-stu-id="68a92-537">Pointer to the interface instance</span></span> |

### <a name="set-physical-address"></a><span data-ttu-id="68a92-538">실제 주소 설정</span><span class="sxs-lookup"><span data-stu-id="68a92-538">Set Physical Address</span></span>  
<span data-ttu-id="68a92-539">이 요청은 \***nx_ip_interface_physical_address_set** _ 서비스 내에서 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-539">This request is made from within the \***nx_ip_interface_physical_address_set** _ service.</span></span> <span data-ttu-id="68a92-540">이 서비스를 사용하면 애플리케이션에서 런타임에 인터페이스 실제 주소를 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-540">This service allows an application to change the interface physical address at run time.</span></span> <span data-ttu-id="68a92-541">이 명령을 수신하는 경우 드라이버는 제공된 실제 주소로 네트워크 인터페이스의 하드웨어 주소를 다시 구성해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-541">On receiving this command, the driver is required to re-configure the hardware address of the network interface to the supplied physical address.</span></span> <span data-ttu-id="68a92-542">IP 인스턴스에 이미 새 주소가 있으므로 이 명령에서 _ *_nx_ip_interface_address_set_*\* 서비스를 호출할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-542">Since the IP instance already has the new address, there is no need to call the _ *_nx_ip_interface_address_set_*\* service from this command.</span></span>

<span data-ttu-id="68a92-543">사용자 명령 요청에는 다음과 같은 NX_IP_DRIVER 멤버가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-543">The following NX_IP_DRIVER members are used for the user command request.</span></span>

| <span data-ttu-id="68a92-544">NX_IP_DRIVER&nbsp;멤버</span><span class="sxs-lookup"><span data-stu-id="68a92-544">NX_IP_DRIVER&nbsp;member</span></span>      | <span data-ttu-id="68a92-545">의미</span><span class="sxs-lookup"><span data-stu-id="68a92-545">Meaning</span></span>                      |
| -------------------------- | ---------------------------- |
| <span data-ttu-id="68a92-546">nx_ip_driver_command</span><span class="sxs-lookup"><span data-stu-id="68a92-546">nx_ip_driver_command</span></span>    | <span data-ttu-id="68a92-547">NX_LINK_SET_PHYSICAL_ADDRESS</span><span class="sxs-lookup"><span data-stu-id="68a92-547">NX_LINK_SET_PHYSICAL_ADDRESS</span></span>  |
| <span data-ttu-id="68a92-548">nx_ip_driver_ptr</span><span class="sxs-lookup"><span data-stu-id="68a92-548">nx_ip_driver_ptr</span></span>        | <span data-ttu-id="68a92-549">IP 인스턴스에 대한 포인터</span><span class="sxs-lookup"><span data-stu-id="68a92-549">Pointer to IP instance</span></span>  |
| <span data-ttu-id="68a92-550">nx_ip_driver_interface</span><span class="sxs-lookup"><span data-stu-id="68a92-550">nx_ip_driver_interface</span></span>  | <span data-ttu-id="68a92-551">인터페이스 인스턴스에 대한 포인터</span><span class="sxs-lookup"><span data-stu-id="68a92-551">Pointer to the interface instance</span></span>   |
| <span data-ttu-id="68a92-552">nx_ip_driver_physical_ad dress_msw</span><span class="sxs-lookup"><span data-stu-id="68a92-552">nx_ip_driver_physical_ad dress_msw</span></span> | <span data-ttu-id="68a92-553">가장 중요한 32비트 새 실제 주소</span><span class="sxs-lookup"><span data-stu-id="68a92-553">Most significant 32-bits of the new physical address</span></span>  |
| <span data-ttu-id="68a92-554">nx_ip_driver_physical_ad dress_lsw</span><span class="sxs-lookup"><span data-stu-id="68a92-554">nx_ip_driver_physical_ad dress_lsw</span></span> | <span data-ttu-id="68a92-555">최하위 32비트 새 실제 주소</span><span class="sxs-lookup"><span data-stu-id="68a92-555">Least significant 32-bits of the new physical address</span></span>  |
| <span data-ttu-id="68a92-556">nx_ip_driver_status</span><span class="sxs-lookup"><span data-stu-id="68a92-556">nx_ip_driver_status</span></span>                  | <span data-ttu-id="68a92-557">완료 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-557">Completion status.</span></span> <span data-ttu-id="68a92-558">드라이버가 실제 주소를 다시 구성할 수 없는 경우에는 0이 아닌 오류 상태를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-558">If the driver is not able to reconfigure the physical address, it will return a non-zero error status.</span></span> |

### <a name="user-commands"></a><span data-ttu-id="68a92-559">사용자 명령</span><span class="sxs-lookup"><span data-stu-id="68a92-559">User Commands</span></span>    
<span data-ttu-id="68a92-560">이 요청은 ***nx_ip_driver_direct_command*** 서비스 내에서 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-560">This request is made from within the ***nx_ip_driver_direct_command*** service.</span></span> <span data-ttu-id="68a92-561">드라이버는 애플리케이션별 사용자 명령을 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-561">The driver processes the application specific user commands.</span></span> <span data-ttu-id="68a92-562">사용자 명령 요청에는 다음과 같은 NX_IP_DRIVER 멤버가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-562">The following NX_IP_DRIVER members are used for the user command request.</span></span>

| <span data-ttu-id="68a92-563">NX_IP_DRIVER&nbsp;멤버</span><span class="sxs-lookup"><span data-stu-id="68a92-563">NX_IP_DRIVER&nbsp;member</span></span>       | <span data-ttu-id="68a92-564">의미</span><span class="sxs-lookup"><span data-stu-id="68a92-564">Meaning</span></span>                       |
| --------------------------- | ----------------------------- |
| <span data-ttu-id="68a92-565">nx_ip_driver_command</span><span class="sxs-lookup"><span data-stu-id="68a92-565">nx_ip_driver_command</span></span>     | <span data-ttu-id="68a92-566">NX_LINK_USER_COMMAND</span><span class="sxs-lookup"><span data-stu-id="68a92-566">NX_LINK_USER_COMMAND</span></span>       |
| <span data-ttu-id="68a92-567">nx_ip_driver_ptr</span><span class="sxs-lookup"><span data-stu-id="68a92-567">nx_ip_driver_ptr</span></span>         | <span data-ttu-id="68a92-568">IP 인스턴스에 대한 포인터</span><span class="sxs-lookup"><span data-stu-id="68a92-568">Pointer to IP instance</span></span>        |
| <span data-ttu-id="68a92-569">nx_ip_driver_return_ptr</span><span class="sxs-lookup"><span data-stu-id="68a92-569">nx_ip_driver_return_ptr</span></span> | <span data-ttu-id="68a92-570">사용자 정의</span><span class="sxs-lookup"><span data-stu-id="68a92-570">User defined</span></span>       |
| <span data-ttu-id="68a92-571">nx_ip_driver_interface</span><span class="sxs-lookup"><span data-stu-id="68a92-571">nx_ip_driver_interface</span></span>   | <span data-ttu-id="68a92-572">인터페이스 인스턴스에 대한 포인터</span><span class="sxs-lookup"><span data-stu-id="68a92-572">Pointer to the interface instance</span></span>    |
| <span data-ttu-id="68a92-573">nx_ip_driver_status</span><span class="sxs-lookup"><span data-stu-id="68a92-573">nx_ip_driver_status</span></span>      | <span data-ttu-id="68a92-574">완료 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-574">Completion status.</span></span> <span data-ttu-id="68a92-575">드라이버가 사용자 명령을 실행할 수 없는 경우 0이 아닌 오류 상태를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-575">If the driver is not able to execute user commands, it will return a non-zero error status.</span></span> |

> [!IMPORTANT] 
> <span data-ttu-id="68a92-576">이 요청은 NetX Duo에서 내부적으로 사용되지 않으므로 해당 구현은 선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-576">*This request is not used internally by NetX Duo so its implementation is optional*.</span></span>

### <a name="unimplemented-commands"></a><span data-ttu-id="68a92-577">구현되지 않은 명령</span><span class="sxs-lookup"><span data-stu-id="68a92-577">Unimplemented Commands</span></span>  
<span data-ttu-id="68a92-578">네트워크 드라이버에서 구현되지 않은 명령에는 반환 상태 필드가 NX_UNHANDLED_COMMAND로 설정되어 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-578">Commands unimplemented by the network driver must have the return status field set to NX_UNHANDLED_COMMAND.</span></span>

## <a name="driver-capability"></a><span data-ttu-id="68a92-579">드라이버 기능</span><span class="sxs-lookup"><span data-stu-id="68a92-579">Driver Capability</span></span>

<span data-ttu-id="68a92-580">일부 네트워크 인터페이스는 체크섬 오프로드 기능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-580">Some network interfaces offer checksum offload features.</span></span> <span data-ttu-id="68a92-581">디바이스 드라이버는 하드웨어 가속을 이용하여 다양한 체크섬 계산을 실행하는 데 소요되는 CPU 시간을 확보할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-581">Device drivers may take advantage of the hardware accelerations to free up CPU time from running various checksum computations.</span></span>

<span data-ttu-id="68a92-582">하드웨어의 하드웨어 체크섬 지원 수준에 따라 디바이스 드라이버는 사용하도록 설정된 하드웨어 기능을 IP 인스턴스에 알려야 합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-582">Depending the level of hardware checksum support from the hardware, the device driver needs to inform the IP instance which hardware feature is enabled.</span></span> <span data-ttu-id="68a92-583">이러한 방식으로 IP 인스턴스는 하드웨어 기능을 인식하고 최대한 많은 계산을 하드웨어로 오프로드합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-583">This way, the IP instance is aware of the hardware feature, and offload as much computation to the hardware as possible.</span></span> <span data-ttu-id="68a92-584">드라이버는 API ***nx_ip_interface_capability_set*** 을 사용하여 실제 인터페이스에서 처리할 수 있는 모든 기능을 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-584">The driver should use the API ***nx_ip_interface_capability_set*** to set all the features the physical interface is able to handle.</span></span>

<span data-ttu-id="68a92-585">다음과 같은 기능을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-585">The following features can be used:</span></span>

- <span data-ttu-id="68a92-586">NX_INTERFACE_CAPABILITY_IPV4_TX_CHECKSUM</span><span class="sxs-lookup"><span data-stu-id="68a92-586">NX_INTERFACE_CAPABILITY_IPV4_TX_CHECKSUM</span></span>
- <span data-ttu-id="68a92-587">NX_INTERFACE_CAPABILITY_IPV4_RX_CHECKSUM</span><span class="sxs-lookup"><span data-stu-id="68a92-587">NX_INTERFACE_CAPABILITY_IPV4_RX_CHECKSUM</span></span>
- <span data-ttu-id="68a92-588">NX_INTERFACE_CAPABILITY_TCP_TX_CHECKSUM</span><span class="sxs-lookup"><span data-stu-id="68a92-588">NX_INTERFACE_CAPABILITY_TCP_TX_CHECKSUM</span></span>
- <span data-ttu-id="68a92-589">NX_INTERFACE_CAPABILITY_TCP_RX_CHECKSUM</span><span class="sxs-lookup"><span data-stu-id="68a92-589">NX_INTERFACE_CAPABILITY_TCP_RX_CHECKSUM</span></span>
- <span data-ttu-id="68a92-590">NX_INTERFACE_CAPABILITY_UDP_TX_CHECKSUM</span><span class="sxs-lookup"><span data-stu-id="68a92-590">NX_INTERFACE_CAPABILITY_UDP_TX_CHECKSUM</span></span>
- <span data-ttu-id="68a92-591">NX_INTERFACE_CAPABILITY_UDP_RX_CHECKSUM</span><span class="sxs-lookup"><span data-stu-id="68a92-591">NX_INTERFACE_CAPABILITY_UDP_RX_CHECKSUM</span></span>
- <span data-ttu-id="68a92-592">NX_INTERFACE_CAPABILITY_ICMPV4_TX_CHECKSUM</span><span class="sxs-lookup"><span data-stu-id="68a92-592">NX_INTERFACE_CAPABILITY_ICMPV4_TX_CHECKSUM</span></span>
- <span data-ttu-id="68a92-593">NX_INTERFACE_CAPABILITY_ICMPV4_RX_CHECKSUM</span><span class="sxs-lookup"><span data-stu-id="68a92-593">NX_INTERFACE_CAPABILITY_ICMPV4_RX_CHECKSUM</span></span>
- <span data-ttu-id="68a92-594">NX_INTERFACE_CAPABILITY_ICMPV6_TX_CHECKSUM</span><span class="sxs-lookup"><span data-stu-id="68a92-594">NX_INTERFACE_CAPABILITY_ICMPV6_TX_CHECKSUM</span></span>
- <span data-ttu-id="68a92-595">NX_INTERFACE_CAPABILITY_ICMPV6_RX_CHECKSUM</span><span class="sxs-lookup"><span data-stu-id="68a92-595">NX_INTERFACE_CAPABILITY_ICMPV6_RX_CHECKSUM</span></span>
- <span data-ttu-id="68a92-596">NX_INTERFACE_CAPABILITY_IGMP_TX_CHECKSUM</span><span class="sxs-lookup"><span data-stu-id="68a92-596">NX_INTERFACE_CAPABILITY_IGMP_TX_CHECKSUM</span></span>
- <span data-ttu-id="68a92-597">NX_INTERFACE_CAPABILITY_IGMP_RX_CHECKSUM</span><span class="sxs-lookup"><span data-stu-id="68a92-597">NX_INTERFACE_CAPABILITY_IGMP_RX_CHECKSUM</span></span>

<span data-ttu-id="68a92-598">하드웨어에서 수행할 수 있는 체크섬 계산을 위해 드라이버는 하드웨어 또는 버퍼 설명자를 올바르게 설정해야 합니다. 이렇게 하면 하드웨어는 나가는 패킷에 대한 체크섬을 생성하고 헤더에 삽입할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-598">For a checksum computation that can be performed in hardware, the driver must set up the hardware or the buffer descriptors correctly so the checksum for an out-going packet can be generated and inserted into the header by the hardware.</span></span> <span data-ttu-id="68a92-599">패킷을 받으면 하드웨어 체크섬 논리는 체크섬 값을 확인할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-599">On receiving a packet, the hardware checksum logic should be able to verify the checksum value.</span></span> <span data-ttu-id="68a92-600">체크섬 값이 잘못되면 수신된 프레임을 삭제해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-600">If the checksum value is incorrect, the received frame should be discarded.</span></span>

<span data-ttu-id="68a92-601">하드웨어에서 체크섬 계산을 수행하는 기능을 사용하는 경우에도 IP 인스턴스는 체크섬 기능을 계속 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-601">Even with the capability of performing checksum computation in hardware, the IP instance still maintains the checksum capability.</span></span> <span data-ttu-id="68a92-602">특정 시나리오(예: IPsec 보호를 통해 전달되는 UDP 데이터그램)에서는 UDP 프레임을 스택에 전달하기 전에 소프트웨어에서 UDP 체크섬을 계산해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-602">In certain scenarios, for example a UDP datagram going through IPsec protection, the UDP checksum must be computed in software before passing the UDP frame down the stack.</span></span> <span data-ttu-id="68a92-603">대부분의 하드웨어 체크섬 기능은 IPsec에 의해 보호되는 데이터 세그먼트에 대한 체크섬 계산을 지원하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-603">Most hardware checksum feature does not support checksum computation for a segment of data protected by IPsec.</span></span> <span data-ttu-id="68a92-604">조각화가 필요한 UDP 또는 ICMP 프레임의 경우 UDP 또는 ICMP 체크섬을 소프트웨어에서 계산해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-604">For a UDP or ICMP frame that needs to be fragmented, the UDP or ICMP checksum needs to be computed in software.</span></span> <span data-ttu-id="68a92-605">대부분의 하드웨어 체크섬 논리는 데이터를 여러 프레임으로 분할하는 경우를 처리하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-605">Most hardware checksum logic does not handle the case where the data is split into multiple frames.</span></span>

## <a name="driver-output"></a><span data-ttu-id="68a92-606">드라이버 출력</span><span class="sxs-lookup"><span data-stu-id="68a92-606">Driver Output</span></span>  

<span data-ttu-id="68a92-607">이전에 언급한 모든 패킷 전송 요청에는 드라이버에 구현된 출력 함수가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-607">All previously mentioned packet transmit requests require an output function implemented in the driver.</span></span> <span data-ttu-id="68a92-608">특정 전송 논리는 하드웨어마다 다르지만 일반적으로 패킷을 즉시 전송할 하드웨어 용량을 확인하는 것으로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-608">Specific transmit logic is hardware specific, but it usually consists of checking for hardware capacity to send the packet immediately.</span></span> <span data-ttu-id="68a92-609">가능하면 패킷 페이로드(및 패킷 체인의 추가 페이로드)가 하나 이상의 하드웨어 전송 버퍼에 로드되고 전송 작업이 시작됩니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-609">If possible, the packet payload (and additional payloads in the packet  chain) are loaded into one or more of the hardware transmit buffers and a transmit operation is initiated.</span></span> <span data-ttu-id="68a92-610">패킷이 사용 가능한 전송 버퍼에 맞지 않으면 패킷은 큐에 대기되고 전송 버퍼를 사용할 수 있게 되면 전송되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-610">If the packet won't fit in the available transmit buffers, the packet should be queued, and be transmitted when the transmission buffers become available.</span></span>

<span data-ttu-id="68a92-611">권장 전송 큐는 head 포인터와 tail 포인터가 모두 있는 단독으로 연결된 목록입니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-611">The recommended transmit queue is a singly linked list, having both head and tail pointers.</span></span> <span data-ttu-id="68a92-612">새 패킷이 큐의 끝에 추가되고 가장 오래된 패킷을 맨 앞에 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-612">New packets are added to the end of the queue, keeping the oldest packet at the front.</span></span> <span data-ttu-id="68a92-613">*nx_packet_queue_next* 필드는 큐에서 패킷의 다음 링크로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-613">The *nx_packet_queue_next* field is used as the packet's next link in the queue.</span></span> <span data-ttu-id="68a92-614">드라이버는 전송 큐의 head 및 tail 포인터를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-614">The driver defines the head and tail pointers of the transmit queue.</span></span>

> [!CAUTION]  
> <span data-ttu-id="68a92-615">이 큐는 드라이버의 스레드 및 인터럽트 부분에서 액세스되기 때문에 큐 조작 주위에 인터럽트 보호를 배치해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-615">*Because this queue is accessed from thread and interrupt portions of the driver, interrupt protection must be placed around the queue manipulations*.</span></span>

<span data-ttu-id="68a92-616">대부분의 실제 하드웨어 구현은 패킷 전송 완료 시 인터럽트를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-616">Most physical hardware implementations generate an interrupt upon packet transmit completion.</span></span> <span data-ttu-id="68a92-617">이러한 인터럽트를 수신하는 드라이버는 일반적으로 전송 중인 패킷과 연결된 리소스를 릴리스합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-617">When the driver receives such an interrupt, it typically releases the resources associated with the packet just being transmitted.</span></span> <span data-ttu-id="68a92-618">전송 논리가 NX_PACKET 버퍼에서 직접 데이터를 읽는 경우 드라이버는 ***nx_packet_transmit_release*** 서비스를 사용하여 전송 완료 인터럽트와 연결된 패킷을 사용 가능한 패킷 풀로 다시 릴리스해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-618">In case the transmit logic reads data directly from the NX_PACKET buffer, the driver should use the ***nx_packet_transmit_release*** service to release the packet associated with the transmit complete interrupt back to the available packet pool.</span></span> <span data-ttu-id="68a92-619">그런 다음, 드라이버는 전송 대기 중인 추가 패킷의 전송 큐를 검사합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-619">Next, the driver examines the transmit queue for additional packets waiting to be sent.</span></span> <span data-ttu-id="68a92-620">하드웨어 전송 버퍼에 적합한 대기 중인 많은 전송 패킷이 큐에서 제거되고 버퍼에 로드됩니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-620">As many of the queued transmit packets that fit into the hardware transmit buffer(s) are de-queued and loaded into the buffers.</span></span> <span data-ttu-id="68a92-621">그다음에는 다른 전송 작업이 시작됩니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-621">This is followed by initiation of another send operation.</span></span>

<span data-ttu-id="68a92-622">NX_PACKET의 데이터가 전송기 FIFO로 이동되는 즉시(또는 드라이버가 제로 복사 작업을 지원하는 경우 NX_PACKET의 데이터가 전송됨), ***nx_packet_transmit_release.** _를 호출하기 전에 드라이버는 *nx_packet_prepend_ptr* 를 IP 헤더의 시작 부분으로 이동해야 합니다. 이에 따라 _nx_packet_length* 필드를 조정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-622">As soon as the data in the NX_PACKET has been moved into the transmitter FIFO (or in case a driver supports zero-copy operation, the data in NX_PACKET has been transmitted), the driver must move the *nx_packet_prepend_ptr* to the beginning of the IP header before calling ***nx_packet_transmit_release.** _ Remember to adjust _nx_packet_length* field accordingly.</span></span> <span data-ttu-id="68a92-623">IP 프레임이 여러 패킷으로 구성된 경우 패킷 체인의 헤드만 릴리스하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-623">If an IP frame is made up of multiple packets, only the head of the packet chain needs to be released.</span></span>

## <a name="driver-input"></a><span data-ttu-id="68a92-624">드라이버 입력</span><span class="sxs-lookup"><span data-stu-id="68a92-624">Driver Input</span></span>

<span data-ttu-id="68a92-625">수신된 패킷 인터럽트가 수신되면 네트워크 드라이버가 실제 하드웨어 수신 버퍼에서 패킷을 검색하고 유효한 NetX Duo 패킷을 빌드합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-625">Upon reception of a received packet interrupt, the network driver retrieves the packet from the physical hardware receive buffers and builds a valid NetX Duo packet.</span></span> <span data-ttu-id="68a92-626">유효한 NetX Duo 패킷을 빌드하려면 적절한 길이 필드를 설정하고 들어오는 패킷의 크기가 단일 패킷 페이로드보다 큰 경우 여러 패킷을 함께 연결해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-626">Building a valid NetX Duo packet involves setting up the appropriate length field and chaining together multiple packets if the incoming packet's size is greater than a single packet payload.</span></span> <span data-ttu-id="68a92-627">제대로 빌드되면 *prepend_ptr* 가 실제 계층 헤더 다음으로 이동되고 수신 패킷은 NetX Duo로 발송됩니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-627">Once properly built, the *prepend_ptr* is moved after the physical layer header and the receive packet is dispatched to NetX Duo.</span></span>

<span data-ttu-id="68a92-628">NetX Duo는 IP(IPv4 및 IPv6)와 ARP 헤더를 **ULONG** 경계에 맞추는 것으로 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-628">NetX Duo assumes that the IP (IPv4 and IPv6) and ARP headers are aligned on a **ULONG** boundary.</span></span> <span data-ttu-id="68a92-629">따라서 NetX Duo 드라이버는 이 맞춤을 확인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-629">The NetX Duo driver must, therefore, ensure this alignment.</span></span> <span data-ttu-id="68a92-630">이더넷 환경에서는 패킷의 시작부터 이더넷 헤더를 2바이트씩 시작하여 이 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-630">In Ethernet environments this is done by starting the Ethernet header two bytes from the beginning of the packet.</span></span> <span data-ttu-id="68a92-631">*Nx_packet_prepend_ptr* 가 이더넷 헤더를 넘어 이동하는 경우 기본 IP(IPv4 및 IPv6) 또는 ARP 헤더를 4바이트로 맞춥니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-631">When the *nx_packet_prepend_ptr* is moved beyond the Ethernet header, the underlying IP (IPv4 and IPv6) or ARP header is 4-byte aligned.</span></span>

> [!WARNING] 
> <span data-ttu-id="68a92-632">IPv6와 IPv6 이더넷 헤더 간의 중요한 차이점은 아래의 “이더넷 헤더” 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="68a92-632">*See the section "Ethernet Headers" below for important differences between IPv6 and IPv6 Ethernet headers*.</span></span>

<span data-ttu-id="68a92-633">NetX Duo에서 사용할 수 있는 몇 가지 수신 패킷 함수가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-633">There are several receive packet functions available in NetX Duo.</span></span> <span data-ttu-id="68a92-634">수신된 패킷이 ARP 패킷이면 _\***nx_arp_packet_deferred_receive**_ 가 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-634">If the received packet is an ARP packet, _\***nx_arp_packet_deferred_receive**_ is called.</span></span> <span data-ttu-id="68a92-635">수신 패킷이 RARP 패킷이면 _ _*_nx_rarp_packet_deferred_receive_*_ 가 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-635">If the received packet is an RARP packet, _ _*_nx_rarp_packet_deferred_receive_*_ is called.</span></span> <span data-ttu-id="68a92-636">들어오는 IP 패킷을 처리하는 몇 가지 옵션이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-636">There are several options for handling incoming IP packets.</span></span> <span data-ttu-id="68a92-637">IP 패킷을 가장 빠르게 처리할 수 있도록 _ _*_nx_ip_packet_receive_*_ 를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-637">For the fastest handling of IP packets, _ _*_nx_ip_packet_receive_*_ is called.</span></span> <span data-ttu-id="68a92-638">이러한 방식은 오버헤드가 가장 적지만 드라이버의 수신 인터럽트 서비스 처리기(ISR)에서 더 많은 처리를 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-638">This approach has the least overhead, but requires more processing in the driver's receive interrupt service handler (ISR).</span></span> <span data-ttu-id="68a92-639">최소 ISR 처리의 경우 _ \*_nx_ip_packet_deferred_receive_\*\*를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-639">For minimal ISR processing __ *_nx_ip_packet_deferred_receive_*\* is called.</span></span>

<span data-ttu-id="68a92-640">새 수신 패킷이 올바르게 빌드되면 실제 하드웨어의 수신 버퍼가 더 많은 데이터를 수신하도록 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-640">After the new receive packet is properly built, the physical hardware's receive buffers are setup to receive more data.</span></span> <span data-ttu-id="68a92-641">이 경우 NetX Duo 패킷을 할당하고 하드웨어 수신 버퍼에 페이로드 주소를 배치해야 하거나 하드웨어 수신 버퍼에서 설정을 변경하기만 하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-641">This might require allocating NetX Duo packets and placing the payload address in the hardware receive buffer or it may simply amount to changing a setting in the hardware receive buffer.</span></span> <span data-ttu-id="68a92-642">오버런 가능성을 최소화하려면 패킷을 받은 후 최대한 빨리 하드웨어의 수신 버퍼에 사용할 수 있는 버퍼를 포함하는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-642">To minimize overrun possibilities, it is important that the hardware's receive buffers have available buffers as soon as possible after a packet is received.</span></span>

> [!IMPORTANT] 
> <span data-ttu-id="68a92-643">초기 수신 버퍼는 드라이버 초기화 중에 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-643">*The initial receive buffers are setup during driver initialization*.</span></span>

### <a name="deferred-receive-packet-handling"></a><span data-ttu-id="68a92-644">지연된 수신 패킷 처리</span><span class="sxs-lookup"><span data-stu-id="68a92-644">Deferred Receive Packet Handling</span></span>  
<span data-ttu-id="68a92-645">드라이버는 NetX Duo IP 도우미 스레드로 수신 패킷 처리를 연기할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-645">The driver may defer receive packet processing to the NetX Duo IP helper thread.</span></span> <span data-ttu-id="68a92-646">일부 애플리케이션의 경우 이는 삭제된 패킷뿐만 아니라 ISR 처리를 최소화하는 데 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-646">For some applications this may be necessary to minimize ISR processing as well as dropped packets.</span></span> 

<span data-ttu-id="68a92-647">지연된 패킷 처리를 사용하려면 먼저 NetX Duo 라이브러리를 \***NX_DRIVER_DEFERRED_PROCESSING** _으로 정의하여 컴파일해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-647">To use deferred packet handling, the NetX Duo library must first be compiled with \***NX_DRIVER_DEFERRED_PROCESSING** _ defined.</span></span> <span data-ttu-id="68a92-648">그러면 NetX Duo IP 도우미 스레드에 지연된 패킷 논리가 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-648">This adds the deferred packet logic to the NetX Duo IP helper thread.</span></span> <span data-ttu-id="68a92-649">그런 다음, 데이터 패킷을 받으면 드라이버는 __nx_ip_packet_deferred_receive():\*를 호출해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-649">Next, on receiving a data packet, the driver must call __nx_ip_packet_deferred_receive():\*</span></span>

```c
_nx_ip_packet_deferred_receive(ip_ptr, packet_ptr);
```
<span data-ttu-id="68a92-650">지연된 수신 함수는 *packet_ptr* 로 표시되는 수신 패킷을 FIFO(연결된 목록)에 배치하고 IP 도우미 스레드에 알립니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-650">The deferred receive function places the receive packet represented by *packet_ptr* on a FIFO (linked list) and notifies the IP helper thread.</span></span> <span data-ttu-id="68a92-651">실행 후, IP 도우미는 지연된 처리 함수를 반복적으로 호출하여 지연된 각 패킷을 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-651">After executing, the IP helper repetitively calls the deferred handling function to process each deferred packet.</span></span> <span data-ttu-id="68a92-652">지연된 처리기 처리에는 일반적으로 패킷의 실제 계층 헤더(일반적으로 이더넷)를 제거하고 NetX Duo 수신 함수 중 하나로 발송하는 작업이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-652">The deferred handler processing typically includes removing the packet's physical layer header (usually Ethernet) and dispatching it to one of these NetX Duo receive functions:</span></span>

- <span data-ttu-id="68a92-653">***_nx_ip_packet_receive***</span><span class="sxs-lookup"><span data-stu-id="68a92-653">***_nx_ip_packet_receive***</span></span>
- <span data-ttu-id="68a92-654">***_nx_arp_packet_deferred_receive***</span><span class="sxs-lookup"><span data-stu-id="68a92-654">***_nx_arp_packet_deferred_receive***</span></span>
- <span data-ttu-id="68a92-655">***_nx_rarp_packet_deferred_receive***</span><span class="sxs-lookup"><span data-stu-id="68a92-655">***_nx_rarp_packet_deferred_receive***</span></span>

## <a name="ethernet-headers"></a><span data-ttu-id="68a92-656">이더넷 헤더</span><span class="sxs-lookup"><span data-stu-id="68a92-656">Ethernet Headers</span></span> 

<span data-ttu-id="68a92-657">이더넷 헤더에 대한 IPv6와 IPv4의 가장 중요한 차이점 중 하나는 프레임 형식 설정입니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-657">One of the most significant differences between IPv6 and IPv4 for Ethernet Headers is the frame type setting.</span></span> <span data-ttu-id="68a92-658">패킷을 보낼 때 이더넷 드라이버는 나가는 패킷에서 이더넷 프레임 형식을 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-658">When sending out packets, the Ethernet driver is responsible for setting the Ethernet frame type in outgoing packets.</span></span> <span data-ttu-id="68a92-659">IPv6 패킷의 경우 프레임 형식은 0x86DD이어야 합니다. IPv4 패킷의 경우 프레임 형식은 0x0800이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-659">For IPv6 packets, the frame type should be 0x86DD; for IPv4 packets, the frame type should be 0x0800.</span></span>

<span data-ttu-id="68a92-660">다음 코드 세그먼트에서는 이 프로세스를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-660">The following code segment illustrates this process:</span></span>

```c
NX_PACKET *packet_ptr;
packet_ptr = driver_req_ptr -> nx_ip_driver_packet;
if (packet_ptr -> nx_packet_ip_version == NX_IP_VERSION_V4)
{

   /* Set Ethernet frame type to IPv4 /*
   ethernet_frame_ptr -> frame_type = 0x0800;

   /* Swap endian-ness for little endian targets.*/
   NX_CHANGE_USHORT_ENDIAN(ethernet_frame_ptr -> frame_type);
}
else if (packet_ptr -> nx_packet_ip_version == NX_IP_VERSION_V6)
{

   /* Set Ethernet frame type to IPv6. /*
   ethernet_frame_ptr -> frame_type = 0x86DD;

   /* Swap endian-ness for little endian targets.*/
   NX_CHANGE_USHORT_ENDIAN(ethernet_frame_ptr -> frame_type);
}
else
{

   /* Unknown IP version. Free the packet we will not send. */
   nx_packet_transmit_release(packet_ptr);
}
```
<span data-ttu-id="68a92-661">마찬가지로 들어오는 패킷의 경우 이더넷 드라이버는 이더넷 프레임 형식에서 패킷 형식을 결정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-661">Similarly, for incoming packets, the Ethernet driver should determine the packet type from the Ethernet frame type.</span></span> <span data-ttu-id="68a92-662">IPv6(0x86DD), IPv4(0x0800), ARP(0x0806) 및 RARP(0x8035) 프레임 형식을 수락하도록 구현해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-662">It should be implemented to accept IPv6 (0x86DD), IPv4 (0x0800), ARP (0x0806), and RARP (0x8035) frame types.</span></span>

## <a name="example-ram-ethernet-network-driver"></a><span data-ttu-id="68a92-663">예제 RAM 이더넷 네트워크 드라이버</span><span class="sxs-lookup"><span data-stu-id="68a92-663">Example RAM Ethernet Network Driver</span></span>

<span data-ttu-id="68a92-664">NetX Duo 데모 시스템은 ***nx_ram_network_driver.c.*** 파일에 정의된 작은 RAM 기반 네트워크 드라이버와 함께 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-664">The NetX Duo demonstration system is delivered with a small RAM-based network driver, defined in the file ***nx_ram_network_driver.c.***</span></span> <span data-ttu-id="68a92-665">이 드라이버는 IP 인스턴스가 모두 동일한 네트워크에 있다고 가정하고 가상 하드웨어 주소(MAC 주소)를 만들 때마다 각 디바이스 인스턴스에 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-665">This driver assumes the IP instances are all on the same network and simply assigns virtual hardware addresses (MAC addresses) to each device instance as they are created.</span></span> <span data-ttu-id="68a92-666">이 파일은 NetX Duo 실제 네트워크 드라이버의 기본 구조에 대한 모범 예제를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-666">This file provides a good example of the basic structure of NetX Duo physical network drivers.</span></span> <span data-ttu-id="68a92-667">사용자는 이 예제에 나와 있는 드라이버 프레임워크를 사용하여 고유한 네트워크 드라이버를 개발할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-667">Users may develop their own network drivers using the driver framework presented in this example.</span></span>

<span data-ttu-id="68a92-668">네트워크 드라이버의 진입 함수는 IP 인스턴스 만들기 호출에 전달되는 \* **_nx_ram_network_driver(),** _입니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-668">The entry function of the network driver is \***_nx_ram_network_driver(),** _ which is passed to the IP instance create call.</span></span> <span data-ttu-id="68a92-669">추가 네트워크 인터페이스에 대한 진입 함수를 _nx_ip_interface_attach()\* 서비스에 전달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-669">Entry functions for additional network interfaces can be passed into the _nx_ip_interface_attach()\* service.</span></span> <span data-ttu-id="68a92-670">IP 인스턴스가 실행되기 시작하면 드라이버 진입 함수를 호출하여 디바이스를 초기화하고 사용하도록 설정합니다(**NX_LINK_INITIALIZE** 및 **NX_LINK_ENABLE** 참조).</span><span class="sxs-lookup"><span data-stu-id="68a92-670">After the IP instance starts to run, the driver entry function is invoked to initialize and enable the device (refer to the case **NX_LINK_INITIALIZE** and **NX_LINK_ENABLE**).</span></span> <span data-ttu-id="68a92-671">**NX_LINK_ENABLE** 명령을 실행한 후 디바이스는 패킷을 전송하고 수신할 준비가 되어 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-671">After the **NX_LINK_ENABLE** command is issued, the device should be ready to transmit and receive packets.</span></span> 

<span data-ttu-id="68a92-672">IP 인스턴스는 다음 명령 중 하나를 통해 네트워크 패킷을 전송합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-672">The IP instance transmits network packets via one of these commands:</span></span>

|                                 |                                                                |
| ------------------------------- | -------------------------------------------------------------- |
| <span data-ttu-id="68a92-673">***NX_LINK_PACKET_SEND***</span><span class="sxs-lookup"><span data-stu-id="68a92-673">***NX_LINK_PACKET_SEND***</span></span>    | <span data-ttu-id="68a92-674">IPv4 또는 IPv6 패킷이 전송되고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-674">An IPv4 or IPv6 packet is being transmitted,</span></span>                   |
| <span data-ttu-id="68a92-675">***NX_LINK_ARP_SEND***</span><span class="sxs-lookup"><span data-stu-id="68a92-675">***NX_LINK_ARP_SEND***</span></span>       | <span data-ttu-id="68a92-676">ARP 요청 또는 ARP 응답 패킷이 전송되고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-676">An ARP request or ARP response packet is being transmitted,</span></span>    |
| <span data-ttu-id="68a92-677">***NX_LINK_ARP_RARP_SEND***</span><span class="sxs-lookup"><span data-stu-id="68a92-677">***NX_LINK_ARP_RARP_SEND***</span></span> | <span data-ttu-id="68a92-678">역방향 ARP 요청 또는 응답 패킷이 전송되고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-678">A Reverse ARP request or response packet is being transmitted,</span></span> |

<span data-ttu-id="68a92-679">이러한 명령을 처리할 때 네트워크 드라이버는 적절한 이더넷 프레임 헤더를 미리 추가한 다음 전송을 위한 기본 하드웨어로 보내야 합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-679">On processing these commands, the network driver needs to prepend the appropriate Ethernet frame header, and then send it to the underlying hardware for transmission.</span></span> <span data-ttu-id="68a92-680">전송 프로세스 중에 네트워크 드라이버에는 패킷 버퍼 영역의 단독 소유권이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-680">During the transmission process, the network driver has the exclusive ownership of the packet buffer area.</span></span> <span data-ttu-id="68a92-681">따라서 데이터가 전송되고 있는 경우(또는 데이터가 드라이버 내부 전송 버퍼로 복사된 후) 네트워크 드라이버는 먼저 앞에 있는 포인터를 이더넷 헤더를 지나 IP 헤더로 이동하고(그에 따라 패킷 길이 조정), ***nx_packet_transmit_release()*** 서비스를 호출하여 패킷 버퍼를 릴리스해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-681">Therefore once the data is being transmitted (or once the data has been copied into the driver internal transfer buffer), the network driver is responsible for releasing the packet buffer by first moving the prepend pointer past the Ethernet header to the IP header (and adjust packet length accordingly), and then by calling the ***nx_packet_transmit_release()*** service to release the packet.</span></span> <span data-ttu-id="68a92-682">데이터 전송 후 패킷을 해제하지 않으면 패킷이 누출됩니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-682">Not releasing the packet after data transmission will cause packets to leak.</span></span>

<span data-ttu-id="68a92-683">네트워크 디바이스 드라이버는 들어오는 데이터 패킷도 처리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-683">The network device driver is also responsible for handling incoming data packets.</span></span> <span data-ttu-id="68a92-684">RAM 드라이버 예제에서 수신된 패킷은 ***_nx_ram_network_driver_receive()*** 함수에서 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-684">In the RAM driver example, the received packet is processed by the function ***_nx_ram_network_driver_receive()***.</span></span> <span data-ttu-id="68a92-685">디바이스가 이더넷 프레임을 수신하면 드라이버는 NX_PACKET 구조에 데이터를 저장해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-685">Once the device receives an Ethernet frame, the driver is responsible for storing the data in  NX_PACKET structure.</span></span> <span data-ttu-id="68a92-686">NetX Duo는 IP 헤더가 4바이트 맞춤 주소에서 시작한다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-686">Note that NetX Duo assumes the IP header starts from 4-byte aligned address.</span></span> <span data-ttu-id="68a92-687">이더넷 헤더의 길이가 14바이트이기 때문에 드라이버는 IP 헤더가 4바이트 맞춤 주소에서 시작하도록 하기 위해 이더넷 헤더의 시작 부분을 2바이트 맞춤 주소로 저장해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="68a92-687">Since the length of Ethernet header is 14byte, the driver needs to store the starting of the Ethernet header at 2-byte aligned address to guarantee that the IP header starts at 4-byte aligned address.</span></span>