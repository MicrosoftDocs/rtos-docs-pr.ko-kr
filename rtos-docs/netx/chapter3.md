---
title: 3장 - Azure RTOS NetX의 기능 구성 요소
description: 이 장에서는 기능 관점에서 고성능 Azure RTOS NetX TCP/IP 스택에 대한 설명을 포함합니다.
author: philmea
ms.author: philmea
ms.date: 05/19/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 4ebb002bc82d13210acf8db44cafb141d33a1b45fa8710295437e2dd15cbcf22
ms.sourcegitcommit: 93d716cf7e3d735b18246d659ec9ec7f82c336de
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/07/2021
ms.locfileid: "116784344"
---
# <a name="chapter-3---functional-components-of-azure-rtos-netx"></a>3장 - Azure RTOS NetX의 기능 구성 요소

이 장에서는 기능 관점에서 고성능 Azure RTOS NetX TCP/IP 스택에 대한 설명을 포함합니다. 

## <a name="execution-overview"></a>실행 개요

NetX 애플리케이션 내에서는 초기화, 애플리케이션 인터페이스 호출, 내부 IP 스레드, IP 주기적 타이머, 네트워크 드라이버와 같은 5가지 형식의 프로그램이 실행됩니다.

> [!IMPORTANT]
> NetX는 ThreadX를 설치해야 하며 스레드 실행, 일시 중단, 주기적 타이머 및 상호 배제 기능에 따라 달라집니다.

### <a name="initialization"></a>초기화

다른 NetX 서비스를 호출하기 전에 ***nx_system_initialize** _ 서비스를 호출해야 합니다. ThreadX _ *_tx_application_define_** 루틴이나 애플리케이션 스레드에서 시스템 초기화를 호출할 수 있습니다.

***nx_system_initialize** _가 반환되면 시스템이 패킷 풀 및 IP 인스턴스를 만들 준비가 됩니다. IP 인스턴스를 만들려면 기본 패킷 풀이 필요하므로 IP 인스턴스를 만들기 전에 하나 이상의 NetX 패킷 풀이 있어야 합니다. 패킷 풀 및 IP 인스턴스는 ThreadX 초기화 함수인 _ _tx_application_define_* 및 애플리케이션 스레드에서 만들 수 있습니다.

내부적으로 IP 인스턴스는 두 부분을 거쳐 만들어집니다. 첫 번째 부분은 ***tx_application_define*** 에서 또는 애플리케이션 스레드의 컨텍스트로부터 호출자의 컨텍스트 내에서 수행됩니다. 여기에는 IP 데이터 구조를 설정하고 내부 IP 스레드를 비롯한 다양한 IP 리소스를 만드는 작업이 포함됩니다. 두 번째 부분은 내부 IP 스레드에서 초기 실행 중에 수행됩니다. 여기서 IP 만들기의 첫 번째 부분을 수행하는 동안 제공되는 네트워크 드라이버를 먼저 호출합니다. 내부 IP 스레드에서 네트워크 드라이버를 호출하면 드라이버가 초기화 처리 중에 I/O를 수행 및 일시 중단할 수 있습니다. 네트워크 드라이버가 초기화 처리에서 반환되면 IP 생성이 완료됩니다.

> [!IMPORTANT]
> NetX 서비스 **nx_ip_status_check** 는 IP 인스턴스 및 해당 기본 인터페이스 상태에 대한 정보를 가져오는 데 사용할 수 있습니다. 이러한 상태 정보에는 링크를 초기화하고, 사용하도록 설정하고, IP 주소가 확인되는지 여부가 포함됩니다. 이 정보는 새로 만든 IP 인스턴스를 사용해야 하는 애플리케이션 스레드를 동기화하는 데 사용됩니다. 멀티홈 시스템의 경우 아래의 "멀티홈 지원"을 참조하세요. 지정된 인터페이스에 대한 정보를 얻기 위해 **nx_ip_interface_status_check** 를 사용할 수 있습니다.

### <a name="application-interface-calls"></a>애플리케이션 인터페이스 호출

애플리케이션의 호출은 ThreadX RTOS에서 실행되는 애플리케이션 스레드에서 주로 수행됩니다. 그러나 일부 초기화, 만들기, 활성화 서비스는 ***tx_application_define*** 에서 호출될 수 있습니다. 4장의 “허용되는 원본” 섹션은 각 NetX 서비스를 호출할 수 있는 항목을 나타냅니다.

대부분의 경우, 체크섬 계산과 같은 집약적인 작업 처리는 IP 인스턴스에 대한 다른 스레드의 액세스를 차단하지 않고 호출 스레드의 컨텍스트 내에서 수행됩니다. 예를 들어 전송 시에는 기본 IP 전송 함수를 호출하기 전에 ***nx_udp_socket_send*** 서비스 내에서 UDP 체크섬 계산이 수행됩니다. 수신된 패킷에서 UDP 체크섬은 애플리케이션 스레드의 컨텍스트에서 실행되는 ***nx_udp_socket_receive*** 서비스에서 계산됩니다. 이렇게 하면 우선 순위가 낮은 스레드에서 집약적인 체크섬 계산을 처리하므로 더 높은 우선 순위 스레드의 네트워크 요청이 지연되는 것을 방지할 수 있습니다.

IP 주소 및 포트 번호와 같은 값은 호스트 바이트 순서로 API 함수에 전달됩니다. 내부적으로 이러한 값은 호스트 바이트 순서에도 저장됩니다. 이를 통해 개발자는 디버거를 통해 값을 쉽게 볼 수 있습니다. 이러한 값이 전송용 프레임으로 프로그래밍 되면 네트워크 바이트 순서로 변환됩니다.

### <a name="internal-ip-thread"></a>내부 IP 스레드

언급했듯이 NetX의 각 IP 인스턴스는 고유한 스레드를 가지고 있습니다. 내부 IP 스레드의 우선 순위 및 스택 크기는 ***nx_ip_create*** 서비스에 정의됩니다. 내부 IP 스레드가 실행 준비 모드에서 만들어집니다. IP 스레드의 우선 순위가 호출 스레드보다 높으면 IP 만들기 호출 내에서 선점이 발생할 수 있습니다.

내부 IP 스레드의 진입점은 내부 함수 ***_nx_ip_thread_entry*** 에 있습니다. 시작할 때, 내부 IP 스레드는 먼저 애플리케이션별 네트워크 드라이버에 대한 세 번의 호출로 구성된 네트워크 드라이버 초기화를 완료합니다. 첫 번째 호출은 네트워크 드라이버를 IP 인스턴스에 연결한 후 초기화 호출을 통해 네트워크 드라이버가 초기화 프로세스를 수행하게 합니다. 네트워크 드라이버가 초기화에서 반환된 후(하드웨어가 제대로 설정되기를 기다리는 동안 일시 중단될 수 있음) 내부 IP 스레드가 네트워크 드라이버를 다시 호출하여 링크를 사용하도록 설정합니다. 

네트워크 드라이버가 링크 사용 호출에서 반환된 후 내부 IP 스레드는 이 IP 인스턴스에 대한 처리가 필요한 다양한 이벤트를 확인하는 영구 루프 검사를 수행합니다. 이 루프에서 처리되는 이벤트에는 지연된 IP 패킷 수신, IP 패킷 조각 어셈블리, ICMP ping 처리, IGMP 처리, TCP 패킷 큐 처리, TCP 주기적 처리, IP 조각 어셈블리 시간 제한, IGMP 주기적 처리가 포함됩니다. 이벤트에는 IP 네트워크에서 ARP 패킷 처리 및 ARP 정기적 처리와 같은 주소 확인 작업도 포함됩니다.

> [!NOTE]
> 수신 대기 및 연결 해제 콜백을 포함한 NetX 콜백 함수는 원래 호출 스레드가 아닌 내부 IP 스레드에서 호출됩니다. 애플리케이션은 NetX 콜백 함수 내에서 일시 중단되지 않도록 주의해야 합니다.

### <a name="ip-periodic-timers"></a>IP 주기적 타이머
각 IP 인스턴스에는 두 개의 ThreadX 주기적 타이머가 사용됩니다. 첫 번째 타이머는 ARP, IGMP, TCP 시간 제한에 대한 1초 타이머이며, IP 조각 리어셈블 처리도 구동합니다. 두 번째 타이머는 TCP 재전송 시간 제한을 구동하는 100ms 타이머입니다.

### <a name="network-driver"></a>네트워크 드라이버
NetX의 각 IP 인스턴스는 ***nx_ip_create*** 서비스에 지정된 디바이스 드라이버로 식별되는 기본 인터페이스를 포함합니다. 네트워크 드라이버는 패킷 전송, 패킷 수신, 상태 및 제어 요청을 포함한 다양한 NetX 요청을 처리해야 합니다.

멀티홈 시스템의 경우 IP 인스턴스는 각 해당 인터페이스에 대해 이러한 작업을 수행하는 연결된 네트워크 드라이버를 가진 여러 인터페이스를 포함합니다.

또한 네트워크 드라이버는 미디어에서 발생하는 비동기 이벤트도 처리해야 합니다. 미디어의 비동기 이벤트에는 패킷 수신, 패킷 전송 완료, 상태 변경이 포함됩니다. NetX는 다양한 이벤트 처리를 위한 여러 액세스 함수를 포함하는 네트워크 드라이버를 제공합니다. 이러한 함수는 네트워크 드라이버의 인터럽트 서비스 루틴 부분에서 호출되도록 설계되었습니다. IP 네트워크의 경우 네트워크 드라이버가 수신한 모든 ARP 패킷을 * **_nx_arp_packet_deferred_receive** _ 내부 함수로 전달해야 합니다. 모든 RARP 패킷은 __ _nx_rarp_packet_deferred_receive_ _ 내부 함수로 전달되어야 합니다. IP 패킷에는 두 가지 옵션이 있습니다. IP 패킷을 빠르게 디스패치해야 하는 경우 들어오는 IP 패킷을 __ _nx_ip_packet_receive_ _로 전달하여 즉시 처리해야 합니다. 이렇게 하면 NetX의 IP 패킷 처리 성능이 크게 향상됩니다. 그렇지 않으면 네트워크 드라이버가 IP 패킷을 _ * _ _nx_ip_packet_deferred_receive_**로 전달해야 합니다. 이 서비스는 IP 패킷을 지연된 처리 큐에 배치한 다음, 이 큐에서 내부 IP 스레드에 의해 처리되므로 ISR 처리 시간이 최소화됩니다.

네트워크 드라이버는 IP 스레드의 컨텍스트에서 실행되기 위해 인터럽트 처리를 연기할 수도 있습니다. 이 모드에서 ISR은 필요한 정보를 저장하고 내부 함수 ***_nx_ip_driver_deferred_processing*** 을 호출하여 인터럽트 컨트롤러를 승인해야 합니다. 이 서비스는 디바이스 드라이버에 대한 콜백을 예약하여 인터럽트를 유발하는 이벤트 프로세스를 완료하도록 IP 스레드에 알립니다.

일부 네트워크 컨트롤러는 유용한 CPU 리소스를 차지하지 않고도 TCP/IP 헤더 체크섬 계산 및 하드웨어의 유효성 검사를 수행할 수 있습니다. 하드웨어 역량 기능을 활용하기 위해 NetX는 컴파일 시 다양한 소프트웨어 체크섬 계산을 사용하거나 또는 사용하지 않도록 옵션을 제공하고, 런타임에 체크섬 계산을 설정하거나 해제하는 옵션도 제공합니다. NetX 네트워크 드라이버 작성에 대한 자세한 내용은 "[5장 NetX 네트워크 드라이버](chapter5.md)"를 참조하세요.

### <a name="multihome-support"></a>멀티홈 지원
NetX는 단일 IP 인스턴스를 사용하여 여러 실제 디바이스에 연결된 시스템을 지원합니다. 각 실제 인터페이스는 IP 인스턴스의 인터페이스 제어 블록에 할당됩니다. 멀티홈 시스템을 사용하려는 애플리케이션은 시스템에 연결된 실제 디바이스 수로 **NX_MAX_PHSYCIAL_INTERFACES** 값을 정의하고 NetX 라이브러리를 다시 빌드해야 합니다. 기본적으로 **NX_MAX_PHYSICAL_INTERFACES** 는 하나로 설정되고, IP 인스턴스에서 하나의 인터페이스 제어 블록을 만듭니다.

NetX 애플리케이션은 ***nx_ip_create** _ 서비스를 사용하여 기본 디바이스를 위한 단일 IP 인스턴스를 만듭니다. 애플리케이션은 각 추가 네트워크 디바이스에 대해 _ _nx_ip_interface_attach_* 서비스를 사용하여 IP 인스턴스에 디바이스를 연결합니다.

각 네트워크 인터페이스 구조에는 인터페이스 IP 주소, 서브넷 마스크, IP MTU 크기, MAC 계층 주소 정보를 포함하여 IP 제어 블록에 포함된 네트워크 인터페이스에 대한 네트워크 정보의 하위 집합이 포함되어 있습니다.

> [!IMPORTANT]
> 멀티홈을 지원하는 NetX는 이전 버전의 NetX와 호환됩니다. 명시적 인터페이스 정보를 사용하지 않는 서비스는 기본 네트워크 디바이스로 기본 설정됩니다.

기본 인터페이스의 IP 인스턴스 목록에 인덱스 0가 있습니다. IP 인스턴스에 연결된 각 후속 디바이스에는 다음 인덱스가 할당됩니다.

TCP, UDP, ICMP, IGMP를 포함하여 IP 인스턴스를 사용하는 모든 상위 계층 프로토콜 서비스를 연결된 모든 디바이스에서 사용할 수 있습니다.

대부분의 경우 NetX는 패킷을 전송할 때 사용할 가장 적합한 소스 주소를 확인할 수 있습니다. 소스 주소 선택은 대상 주소를 기준으로 합니다. 대상 주소에서 최적의 주소를 결정할 수 없는 경우 애플리케이션에서 사용할 특정 소스 주소를 지정할 수 있도록 NetX 서비스가 제공됩니다. 예를 들어, 멀티홈 시스템에서 애플리케이션은 IP 브로드캐스트 또는 멀티캐스트 대상 주소로 패킷을 전송해야 합니다.

멀티홈 애플리케이션 개발을 위한 서비스는 다음과 같습니다.

nx_igmp_multicast_interface_join nx_ip_driver_interface_direct_command nx_ip_interface_address_get nx_ip_interface_address_set nx_ip_interface_attach nx_ip_interface_info_get nx_ip_interface_status_check nx_ip_raw_packet_interface_send nx_udp_socket_interface_send

이러한 서비스는 "[4장 - Azure RTOS NetX 서비스 설명](chapter4.md)"에 자세히 나와 있습니다.

### <a name="loopback-interface"></a>루프백 인터페이스
루프백 인터페이스는 실제 링크가 연결되어 있지 않은 특수한 네트워크 인터페이스입니다. 루프백 인터페이스를 사용하면 애플리케이션에서 IP 루프백 주소 127.0.0.1을 사용하여 통신할 수 있습니다.

논리적 루프백 인터페이스를 활용하려면 구성 가능한 옵션 ***NX_DISABLE_LOOPBACK_INTERFACE*** 이 설정되지 않았는지 확인합니다.

### <a name="interface-control-blocks"></a>인터페이스 제어 블록
IP 인스턴스의 인터페이스 제어 블록 수는 실제 인터페이스(***NX_MAX_PHYSICAL_INTERFACES** _로 정의됨)의 수와 루프백 인터페이스(사용 가능한 경우) 수를 더한 값과 같습니다. 총 인터페이스 수는 _*_NX_MAX_IP_INTERFACES_**에 정의되어 있습니다.

## <a name="protocol-layering"></a>프로토콜 계층화

NetX에 의해 구현된 TCP/IP는 계층화된 프로토콜로, 더 복잡한 프로토콜이 더 단순한 기본 프로토콜에 기반하여 빌드됩니다. TCP/IP에서 가장 낮은 계층 프로토콜은 ‘링크 계층’에 있으며 네트워크 드라이버에서 처리됩니다. 이 수준은 일반적으로 이더넷을 대상으로 하지만 파이버, 시리얼 또는 거의 모든 실제 미디어를 대상으로 할 수도 있습니다.

링크 계층의 맨 위에는 ‘네트워크 계층’이 있습니다. TCP/IP에서 이것은 기본적으로 네트워크를 통해 간단한 패킷을 최선의 방법으로 주고받는 것을 담당하는 IP입니다. ICMP 및 IGMP와 같은 관리 형식 프로토콜은 일반적으로 IP를 주고받는 경우에도 네트워크 계층으로 분류됩니다.

‘전송 계층’은 네트워크 계층의 맨 위에 있습니다. 이 계층은 네트워크의 호스트 간 데이터 흐름을 관리해야 합니다. NetX에서 지원하는 전송 서비스에는 UDP 및 TCP의 두 가지 형식이 있습니다. UDP 서비스는 연결하지 않고 두 호스트 간에 데이터를 주고받는 최선의 방법을 제공하는 반면, TCP는 두 호스트 엔티티 간에 안정적인 연결 지향 서비스를 제공합니다.

이 계층은 실제 네트워크 데이터 패킷에 반영됩니다. TCP/IP의 각 계층에는 헤더라는 정보 블록이 포함되어 있습니다. 헤더를 사용하여 데이터(및 프로토콜 정보)를 둘러싸는 이 기술을 일반적으로 데이터 캡슐화라고 합니다. 그림 1은 NetX 계층화의 예를 보여주고 그림 2는 전송 중인 UDP 데이터에 대한 결과 데이터 캡슐화의 예를 보여 줍니다.

![프로토콜 계층화](./media/user-guide/protocol-layering.png)

**그림 1. 프로토콜 계층화**

![UDP 데이터 캡슐화](./media/user-guide/udp-data-encapsulation.png)

**그림 2. UDP 데이터 캡슐화**

## <a name="packet-pools"></a>패킷 풀

실시간 네트워킹 애플리케이션에서 신속하고 결정적인 방식으로 패킷을 할당하는 것은 항상 어려운 과제입니다. 이를 염두에 둔 NetX는 고정 크기 네트워크 패킷의 여러 풀을 만들고 관리할 수 있는 기능을 제공합니다.

NetX 패킷 풀은 고정 크기의 메모리 블록으로 구성되므로 내부 조각화 문제가 발생하지 않습니다. 물론 조각화는 본질적으로 비결정적인 동작을 야기합니다.

더불어, NetX 패킷을 할당하고 해제하는 데 필요한 시간은 간단한 연결된 목록 조작에 해당합니다. 또한 패킷 할당 및 할당 해제는 사용 가능한 목록의 맨 위에서 수행됩니다. 이렇게 하면 가장 빠른 연결된 목록 처리를 수행할 수 있습니다.

일반적으로 유연성 부족은 고정 크기 패킷 풀의 주요 단점입니다. 최악의 경우 들어오는 패킷을 처리하는 최적의 패킷 페이로드 크기를 결정하는 것은 어려운 작업입니다. NetX 패킷은 ‘패킷 체인’이라는 옵션 기능을 사용하여 이 문제를 해결합니다. 실제 네트워크 패킷은 함께 연결된 두 개 이상의 NetX 패킷으로 구성될 수 있습니다. 또한 패킷 헤더는 패킷의 맨 위에 대한 포인터를 유지합니다. 추가 프로토콜이 추가되면 이 포인터는 단순히 뒤로 이동하고 새 헤더는 데이터 바로 앞에 작성됩니다. 유연한 패킷 기술이 없으면 스택은 처리 집약적인 새 헤더를 사용하여 다른 버퍼를 할당하고 데이터를 새 버퍼에 복사해야 합니다.

각 패킷 페이로드 크기는 지정된 패킷 풀에 대해 고정되므로 페이로드 크기보다 큰 애플리케이션 데이터에는 여러 패킷이 함께 연결되어 있어야 합니다. 사용자 데이터를 사용하여 패킷을 채울 때 애플리케이션은 ***nx_packet_data_append*** 서비스를 사용해야 합니다. 이 서비스는 애플리케이션 데이터를 패킷으로 이동합니다. 패킷이 사용자 데이터를 저장하기에 충분하지 않은 경우 사용자 데이터를 저장하기 위한 추가 패킷이 할당됩니다. 패킷 체인을 사용하려면 드라이버에서 연결된 패킷으로 수신하거나 전송할 수 있어야 합니다.

각 NetX 패킷 메모리 풀은 공용 리소스입니다. NetX는 패킷 풀의 사용 방법에 제약 조건을 두지 않습니다.

### <a name="packet-pool-memory-area"></a>패킷 풀 메모리 영역
패킷 풀의 메모리 영역은 생성 중에 지정됩니다. ThreadX 및 NetX 개체의 다른 메모리 영역과 마찬가지로 대상의 주소 공간 어디에서나 찾을 수 있습니다. 이는 애플리케이션에 상당한 유연성을 제공하기 때문에 중요한 기능입니다. 예를 들어 통신 제품에 네트워크 버퍼를 위한 고속 메모리 영역이 있다고 가정합니다. 이 메모리 영역은 NetX 패킷 메모리 풀로 만들어 쉽게 활용할 수 있습니다.

### <a name="creating-packet-pools"></a>패킷 풀 만들기
패킷 풀은 초기화 중에 또는 애플리케이션 스레드에서 런타임 중에 만들어집니다. NetX 애플리케이션의 패킷 메모리 풀 수에는 제한이 없습니다.

### <a name="packet-header-nx_packet"></a>패킷 헤더 NX_PACKET
기본적으로 NetX는 패킷 페이로드 영역 바로 앞에 패킷 헤더를 배치합니다. 패킷 메모리 풀은 기본적으로 일련의 패킷이며 헤더 바로 뒤에 패킷 페이로드가 배치됩니다. 패킷 헤더(***NX_PACKET***)와 패킷 풀의 레이아웃은 그림 3에 나와 있습니다.

무복사 작업을 수행할 수 있는 네트워크 디바이스 드라이버의 경우 일반적으로 패킷 페이로드 영역의 시작 주소가 DMA 논리로 프로그래밍이 됩니다. 특정 DMA 엔진은 페이로드 영역에 맞춤 요구 사항이 있습니다.

> [!IMPORTANT]
> *네트워크 드라이버는 패킷의 전송이 완료되면 ***nx_packet_transmit_release** _ 함수를 호출해야 합니다. 이 함수는 사용 가능한 풀에 실제로 다시 배치되기 전에 패킷이 TCP 출력 큐의 일부가 아닌지 확인합니다. 이 함수를 호출하지 않으면 예기치 않은 결과가 발생할 수 있습니다.

![패킷 헤더 및 패킷 풀 레이아웃](./media/user-guide/packet-header-packet-pool-layout.png)

**그림 3. 패킷 헤더 및 패킷 풀 레이아웃**

패킷 헤더의 필드는 다음 표와 같이 정의됩니다. 이 표는 NX_PACKET 구조체에 있는 모든 멤버의 포괄적인 목록은 아닙니다.

| 패킷 헤더          | 용도                                                                                                                                                                                                                                                                                                                            |
|------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| *nx_packet_pool_owner*   | 이 필드는 이 특정 패킷을 소유한 패킷 풀을 가리킵니다. 패킷이 해제되면 이 특정 풀로 해제됩니다. 각 패킷 내부의 풀 소유권을 통해 데이터그램이 여러 패킷 풀에서 여러 패킷을 소유할 수 있습니다.                                                         |
| *nx_packet_next*         | 이 필드는 동일한 프레임 내의 다음 패킷을 가리킵니다. NULL인 경우 프레임의 일부인 추가 패킷이 없습니다. |
| *nx_packet_last*         | 이 필드는 동일한 네트워크 패킷 내의 마지막 패킷을 가리킵니다. NULL인 경우 이 패킷은 전체 네트워크 패킷을 나타냅니다.  |
| *nx_packet_length*       | 이 필드는 nx_packet_next 멤버에 의해 함께 연결된 모든 패킷의 모든 바이트 수를 포함하여 전체 네트워크 패킷의 총 바이트 수를 포함합니다. |
| *nx_packet_ip_interface* | 이 필드는 인터페이스 드라이버에 의해 수신될 때 패킷에 할당되고, NetX에 의해 나가는 패킷에 할당되는 인터페이스 제어 블록입니다. 인터페이스 제어 블록은 네트워크 주소, MAC 주소, IP 주소 등의 인터페이스 및 링크 사용 및 실제 매핑 필요와 같은 인터페이스 상태를 설명합니다. |
| *nx_packet_data_start*   | 이 필드는 이 패킷의 실제 페이로드 영역의 시작을 가리킵니다. NX_PACKET 헤더 바로 뒤에 있을 필요는 없지만 ***nx_packet_pool_create*** 서비스에 대한 기본값입니다. |
| *nx_packet_data_end*     | 이 필드는 이 패킷의 실제 페이로드 영역의 끝을 가리킵니다. 이 필드와 nx_packet_data_start 필드 간의 차이는 페이로드 크기를 나타냅니다. |
| *nx_packet_prepend_ptr*  | 이 필드는 패킷 페이로드 영역의 기존 패킷 데이터(있는 경우) 앞에 프로토콜 헤더나 실제 데이터와 같은 패킷 데이터가 추가되는 위치를 가리킵니다. nx_packet_data_start 포인터 위치보다 크거나 같아야 하며 nx_packet_append_ptr 포인터보다 작거나 같아야 합니다.  성능상의 이유로, 전송을 위해 패킷이 NetX 서비스에 전달될 때 NetX는 앞에 추가 포인터가 긴 단어 맞춤 주소를 가리키는 것으로 가정합니다. |
| *nx_packet_append_ptr*    | 이 필드는 현재 패킷 페이로드 영역에 있는 데이터의 끝을 가리킵니다. nx_packet_prepend_ptr 및 nx_packet_data_end가 가리키는 메모리 위치 사이에 있어야 합니다. 이 필드와 nx_packet_prepend_ptr 필드 간의 차이는 이 패킷의 데이터양을 나타냅니다. |
| *nx_packet_fragment_next* | 이 필드는 전체 패킷을 다시 어셈블할 수 있을 때까지 조각난 패킷을 보관하는 데 사용됩니다. |
| *nx_packet_pad*           | 이 필드는 원하는 맞춤 요구 사항을 달성하기 위해 4바이트 단어로 된 패딩의 길이를 정의합니다. NX_PACKET_HEADER_PAD가 정의되지 않은 경우 이 필드는 제거됩니다. |
|  |  |

### <a name="packet-header-offsets"></a>패킷 헤더 오프셋

패킷 헤더 크기는 헤더 크기를 수용할 수 있는 충분한 공간을 허용하도록 정의됩니다. nx_packet_allocate 서비스는 패킷을 할당하고 지정된 패킷 형식에 따라 패킷의 앞에 추가 포인터를 조정하는 데 사용됩니다. 패킷 형식은 프로토콜 헤더(예: UDP, TCP, ICMP)를 프로토콜 데이터 앞에 삽입하는 데 필요한 오프셋을 NetX에게 알려줍니다.

다음 형식은 패킷의 IP 헤더와 실제 계층(이더넷) 헤더를 고려하도록 NetX에서 정의됩니다. 후자의 경우, 필요한 4바이트 맞춤을 고려하여 16바이트로 가정합니다. IP 패킷은 IP 네트워크의 패킷을 할당하는 애플리케이션에 대해 NetX에서 계속 정의됩니다. 다음 표에서는 기호를 보여 줍니다.

| 패킷 형식   | 값 |
|---------------|-------|
| NX_IP_PACKET  | 0x24  |
| NX_UDP_PACKET | 0x2c  |
| NX_TCP_PACKET | 0x38  |
|               |       |

### <a name="pool-capacity"></a>풀 용량
패킷 풀의 패킷 수는 페이로드 크기와 패킷 풀 만들기 서비스에 제공된 메모리 영역의 총 바이트 수의 함수입니다. 풀의 용량은 패킷 크기(NX_PACKET 헤더의 크기, 페이로드 크기 및 올바른 맞춤 포함)를 제공된 메모리 영역의 총 바이트 수로 나누어 계산합니다.

### <a name="thread-suspension"></a>스레드 일시 중단
빈 풀에서 패킷을 기다리는 동안 애플리케이션 스레드가 일시 중단될 수 있습니다. 패킷이 풀로 반환되면 일시 중단된 스레드에 이 패킷이 제공되고 다시 시작됩니다.

여러 스레드가 동일한 패킷 풀에서 일시 중단되면 일시 중단된 순서대로(FIFO) 다시 시작됩니다.

### <a name="pool-statistics-and-errors"></a>풀 통계 및 오류
사용하도록 설정된 경우 NetX 패킷 관리 소프트웨어 **오류** 는 애플리케이션에 유용할 수 있는 몇 가지 통계 및 오류를 추적합니다. 패킷 풀에 대해 다음 통계 및 오류 보고서가 유지 관리됩니다.

* 풀의 총 패킷
* 풀의 사용 가능한 패킷
* 풀 빈 할당 요청
* 풀 빈 할당 일시 중단
* 잘못된 패킷 릴리스

***NX_DISABLE_PACKET_INFO** _가 정의되어 있지 않은 경우 풀의 총 패킷 수와 사용 가능한 패킷 수를 제외한 모든 통계 및 오류 보고서는 NetX 라이브러리에 내장되어 있습니다. 이 데이터는 애플리케이션이 _ _nx_packet_pool_info_get_* 서비스를 사용하여 사용할 수 있습니다.

### <a name="packet-pool-control-block-nx_packet_pool"></a>패킷 풀 제어 블록 NX_PACKET_POOL

각 패킷 메모리 풀의 특성은 해당 제어 블록에서 찾을 수 있습니다. 이 풀에는 사용 가능한 패킷의 연결된 목록, 사용 가능한 패킷 수, 이 풀의 패킷에 대한 페이로드 크기와 같은 유용한 정보가 포함되어 있습니다. 이 구조는 *nx_api.h* 파일에서 정의됩니다.

패킷 풀 제어 블록은 메모리 내 어디에나 위치할 수 있지만, 제어 블록을 모든 함수의 범위 밖에 정의하여 전역 구조로 만드는 것이 가장 일반적입니다.

## <a name="ip-protocol"></a>IP 프로토콜

NetX의 IP(인터넷 프로토콜) 구성 요소는 인터넷에서 IP 패킷을 주고받는 역할을 합니다. NetX에서 기본 네트워크 드라이버를 활용하여 TCP, UDP, ICMP, IGMP 메시지를 최종적으로 주고받는 구성 요소입니다.

NetX는 IP 프로토콜 (RFC 791)을 지원합니다.

### <a name="ip-addresses"></a>IP 주소

인터넷의 각 호스트에는 IP 주소라는 고유한 32비트 식별자가 있습니다. 그림 4에 설명된 대로 IP 주소에는 5개의 클래스가 있습니다 5개의 IP 주소 클래스의 범위는 다음과 같습니다.

| 클래스 | 범위                        |
|-------|------------------------------|
| A     | 0.0.0.0~127.255.255.255   |
| b     | 128.0.0.0~191.255.255.255 |
| C     | 192.0.0.0~223.255.255.255 |
| D     | 224.0.0.0~239.255.255.255 |
| E     | 240.0.0.0 ~ 247.255.255.255 |

**7비트 24비트**

![IP 주소 구조](./media/user-guide/ip-address-structure.png)

**그림 4. IP 주소 구조**

또한 주소 사양에는 ‘유니캐스트’, ‘브로드캐스트’, ‘멀티캐스트’의 세 가지 형식이 있습니다.   유니캐스트 주소는 인터넷에서 특정 호스트를 식별하는 IP 주소입니다. 유니캐스트 주소는 소스 또는 대상 IP 주소일 수 있습니다. 브로드캐스트 주소는 특정 네트워크 또는 하위 네트워크의 모든 호스트를 식별하고 대상 주소로만 사용할 수 있습니다. 브로드캐스트 주소는 주소의 호스트 ID 부분을 하나로 설정하여 지정합니다. 멀티캐스트 주소(클래스 D)는 인터넷에서 동적 호스트 그룹을 지정합니다. 멀티캐스트 그룹의 멤버는 언제든지 참여하고 나갈 수 있습니다.

> [!IMPORTANT]
> IP를 통한 UDP와 같은 연결 없는 프로토콜만이 브로드캐스트와 멀티캐스트 그룹의 제한된 브로드캐스트 기능을 사용할 수 있습니다.

> [!IMPORTANT]
> *매크로* IP_ADDRESS *는*  ***nx_api.h** _에 정의됩니다. 마침표 대신 쉼표를 사용하여 IP 주소를 쉽게 지정할 수 있습니다. 예를 들어 IP_ADDRESS(128,0,0,0)_는 그림 4에 표시된 첫 번째 클래스 B 주소를 지정합니다.*

### <a name="ip-gateway-address"></a>IP 게이트웨이 주소

네트워크 게이트웨이는 네트워크의 호스트가 로컬 도메인 외부의 대상으로 향하는 패킷을 릴레이 하도록 지원합니다. 각 노드는 네트워크 환경 중 하나 또는 미리 프로그래밍된 고정 라우팅 테이블을 통해 다음 홉을 전송할 대상에 대한 약간의 정보를 가지고 있습니다. 그러나 이러한 접근 방식이 실패할 경우 노드는 패킷을 대상으로 라우팅하는 방법에 대한 자세한 정보가 있는 기본 게이트웨이로 패킷을 전달해야 합니다. 기본 게이트웨이는 IP 인스턴스에 연결된 실제 인터페이스 중 하나를 통해 직접 액세스할 수 있어야 합니다. 애플리케이션은 IP 기본 게이트웨이 주소를 구성하기 위해 ***nx_ip_gateway_address_set*** 를 호출합니다.

### <a name="ip-header"></a>IP 헤더

인터넷에서 IP 패킷을 전송하려면 IP 헤더가 있어야 합니다. 상위 수준의 프로토콜(UDP, TCP, ICMP, IGMP)이 패킷을 전송하기 위해 IP 구성 요소를 호출할 때 IP 전송 모듈은 데이터 앞에 IP 헤더를 배치합니다. 반대로, IP 패킷이 네트워크에서 수신되면, IP 구성 요소는 상위 수준의 프로토콜로 전송되기 전에 패킷에서 IP 헤더를 제거합니다. 그림 5는 IP 헤더의 형식을 보여 줍니다.

![IP 헤더 형식](./media/user-guide/ip-header-format.png)

**그림 5. IP 헤더 형식**

> [!IMPORTANT]
> TCP/IP 구현의 모든 헤더는 big endian 형식이어야 합니다. 이 형식에서 단어의 가장 중요한 바이트는 가장 낮은 바이트 주소에 있습니다. 예를 들어 IP 헤더의 4비트 버전과 4비트 헤더 길이는 헤더의 첫 번째 바이트에 위치해야 합니다.

IP 헤더의 필드는 다음과 같이 정의됩니다.

**IP 헤더 필드 용도**

***4비트 버전*** 이 필드에는 이 헤더가 나타내는 IP 버전이 포함되어 있습니다. NetX에서 지원하는 IP 버전 4의 경우 이 필드의 값은 4입니다.

***4비트 헤더 길이*** 이 필드는 IP 헤더에 있는 32비트 단어 수를 지정합니다. 옵션 단어가 없을 경우 이 필드의 값은 5입니다.

***8비트 TOS(서비스 유형)*** 이 필드는 이 IP 패킷에 대해 요청된 서비스 유형을 지정합니다. 유효한 요청은 다음과 같습니다.

| **TOS 요청**     | **값** |
| ------------------- | --------- |
| 보통              | 0x00      |
| 최소 지연       | 0x10      |
| 최대 데이터        | 0x08      |
| 최대 안정성 | 0x04      |
| 최소 비용        | 0x02      |

***16비트 총 길이*** 이 필드는 IP 헤더를 포함하여 IP 데이터그램의 총 길이(바이트)를 포함합니다. IP 데이터그램은 TCP/IP 인터넷에 있는 기본 정보 단위입니다. 데이터 외에도 대상 및 소스 주소가 포함됩니다. 16비트 필드이기 때문에 IP 데이터그램의 최대 크기는 65,535바이트입니다.

***16비트 ID*** 필드는 호스트에서 전송된 각 IP 데이터그램을 고유하게 식별하는 데 사용되는 숫자입니다. 이 숫자는 일반적으로 IP 데이터그램이 전송된 후에 증가합니다. 특히 수신된 IP 패킷 조각을 어셈블하는 데 유용합니다.

***3비트 플래그*** 이 필드는 IP 조각화 정보를 포함합니다. 비트 14는 “Don't Fragment” 비트입니다. 이 비트가 설정되면 나가는 IP 데이터그램이 조각나지 않습니다. 비트 13은 “More Fragments” 비트입니다. 이 비트가 설정되면 더 많은 조각이 생성됩니다. 이 비트가 0이면 이는 IP 패킷의 마지막 조각입니다.

**IP 헤더 필드 용도**

***13비트 조각 오프셋*** 이 필드에는 조각 오프셋의 상위 13비트가 포함됩니다. 따라서 조각 오프셋은 8바이트 경계에서만 허용됩니다. 조각화된 IP 데이터그램의 첫 번째 조각은 “More Fragments” 비트 집합을 포함하고 오프셋은 0입니다.

***8비트 TTL(Time to Live)*** 이 필드는 데이터그램이 전달할 수 있는 라우터 수를 포함하며, 기본적으로 데이터그램의 수명을 제한합니다.

***8비트 프로토콜*** 이 필드는 IP 데이터그램을 사용하는 프로토콜을 지정합니다. 다음은 유효한 프로토콜과 해당 값의 목록입니다.

| 프로토콜 | 값 |
|----------|-------|
| ICMP     | 0x01  |
| IGMP     | 0x02  |
| TCP      | 0X06  |
| UDP      | 0X11  |
|          |       |


***16비트 체크섬*** 이 필드에는 IP 헤더만 포함하는 16비트 체크섬이 포함됩니다. IP 페이로드를 포함하는 상위 수준 프로토콜에는 추가 체크섬이 있습니다.

***32비트 원본 IP 주소*** 이 필드는 항상 호스트 주소이고 송신자의 IP 주소를 포함합니다.

***32비트 대상 IP 주소*** 이 필드는 주소가 브로드캐스트 또는 멀티캐스트 주소인 경우 수신자 또는 수신자의 IP 주소를 포함합니다.

### <a name="creating-ip-instances"></a>IP 인스턴스 만들기

IP 인스턴스는 초기화 중에 또는 애플리케이션 스레드에서 런타임 중에 만들어집니다. 내부 IP 스레드의 초기 IP 주소, 네트워크 마스크, 기본 패킷 풀, 미디어 드라이버, 메모리 및 우선 순위는 *nx_ip_create* 서비스에 의해 정의됩니다. 애플리케이션에서 IP 주소를 잘못된 주소(0.0.0.0)로 설정한 IP 인스턴스를 초기화하는 경우 인터페이스 주소는 나중에 RARP를 통한 수동 구성이나 DHCP 또는 유사한 프로토콜을 통해 해결하는 것으로 간주합니다.

여러 네트워크 인터페이스가 있는 시스템의 경우 기본 인터페이스는 *nx_ip_create* 를 호출할 때 지정됩니다. 각 추가 인터페이스는 nx_ip_interface_attach를 호출하여 동일한 IP 인스턴스에 연결할 수 있습니다. 이 서비스는 네트워크 인터페이스(예: IP 주소, 네트워크 마스크)에 대한 정보를 인터페이스 제어 블록에 저장하고 드라이버 인스턴스를 IP 인스턴스의 인터페이스 제어 블록과 연결합니다. 드라이버는 데이터 패킷을 수신할 때 인터페이스 정보를 IP 수신 논리로 전달하기 전에 NX_PACKET 구조에 저장해야 합니다. 인터페이스를 연결하기 전에 IP 인스턴스를 이미 만들어야 합니다.

 ### <a name="ip-send"></a>IP 전송
 NetX의 IP 전송 처리는 매우 간소화되었습니다.

패킷의 앞에 추가 포인터는 IP 헤더에 맞게 뒤로 이동합니다. IP 헤더가 완료되고(호출 프로토콜 계층에서 지정한 모든 옵션 포함), IP 체크섬이 인라인으로 계산되며, 패킷이 연결된 네트워크 드라이버로 디스패치됩니다. 또한 나가는 조각화도 IP 전송 처리 내에서 조정됩니다.

IP의 경우 NetX는 대상 IP 주소에 대한 실제 매핑이 필요한 경우 ARP 요청을 시작합니다.

> [!IMPORTANT]
> IP 연결의 경우 큐에 있는 패킷 수가 ARP 큐 깊이(기호에서 정의됨)를 초과할 때까지 IP 주소 확인(예: 실제 매핑)이 필요한 패킷이 ARP 큐에 배치됩니다. 큐 깊이에 도달하면 NetX가 큐에서 가장 오래된 패킷을 제거하고 대기 중인 나머지 패킷에 대한 주소 확인을 계속 기다립니다. 반면 ARP 항목이 확인되지 않으면 ARP 항목에서 보류 중인 패킷은 ARP 항목 시간 초과 시 해제됩니다.

여러 네트워크 인터페이스를 포함하는 시스템의 경우 NetX는 대상 IP 주소를 기반으로 인터페이스를 선택합니다. 선택 프로세스에 적용되는 프로시저는 다음과 같습니다.

1. 대상 주소가 IP 브로드캐스트 또는 멀티캐스트인 경우 유효한 나가는 인터페이스가 지정된 경우 해당 인터페이스를 사용합니다. 그러지 않으면 첫 번째 실제 인터페이스가 사용됩니다.

2. 대상 주소가 고정 라우팅 테이블에 있는 경우 게이트웨이와 연결된 인터페이스가 사용됩니다.

3. 대상이 온-링크인 경우 온-링크 인터페이스가 사용됩니다.

4. 대상 주소가 루프백 주소인 127.0.0.1인 경우 루프백 인터페이스가 사용됩니다.

5. 기본 게이트웨이가 적절히 구성된 경우 기본 게이트웨이와 연결된 인터페이스를 사용하여 패킷을 전송합니다.

6. 위의 모든 작업이 실패하면 출력 패킷이 삭제됩니다.

### <a name="ip-receive"></a>IP 수신

IP 수신 처리는 지연된 수신 패킷 큐에서 패킷을 처리하기 위해 네트워크 드라이버 또는 내부 IP 스레드에서 호출됩니다. IP 수신 처리는 프로토콜 필드를 검사하고 올바른 프로토콜 구성 요소에 대한 패킷의 디스패치를 시도합니다. 패킷이 실제로 디스패치되기 전에 IP 헤더를 지나서 앞에 추가 포인터를 이동하면 IP 헤더가 제거됩니다.

또한 IP 수신 처리는 조각난 IP 패킷을 검색하고, 조각화를 사용하는 경우 조각난 패킷 리어셈블에 필요한 단계를 수행합니다. 조각화가 필요하지만 사용하도록 설정되지 않은 경우 패킷이 삭제됩니다.

NetX는 패킷에 지정된 인터페이스에 따라 적절한 네트워크 인터페이스를 결정합니다. 패킷 인터페이스가 NULL이면 NetX는 기본 인터페이스로 기본 설정됩니다. 이는 레거시 NetX 이더넷 드라이버와의 호환성을 보장하기 위해 수행됩니다.

### <a name="raw-ip-send"></a>원시 IP 전송

원시 IP 패킷은 NetX에서 직접 지원하고 처리하지 않는 상위 계층 프로토콜 페이로드를 포함하는 IP 프레임입니다. 원시 패킷을 통해 개발자는 자신의 IP 기반 애플리케이션을 정의할 수 있습니다. __nx_ip_raw_packet_enabled__ 서비스에서 원시 IP 패킷 처리를 사용하도록 설정한 경우 애플리케이션은 ***nx_ip_raw_packet_send** _ 서비스를 사용하여 원시 IP 패킷을 직접 전송할 수 있습니다. 그러나 대상 주소가 멀티캐스트 또는 브로드캐스트 주소인 경우 NetX는 첫 번째 기본 인터페이스로 기본 설정됩니다. 따라서 보조 인터페이스에서 이러한 패킷을 전송하려면 애플리케이션이 _ _nx_ip_raw_packet_interface_send_* 서비스를 사용하여 나가는 패킷에 사용할 원본 주소를 지정해야 합니다.

### <a name="raw-ip-receive"></a>원시 IP 수신

원시 IP 패킷 처리를 사용하는 경우 애플리케이션은 ***nx_ip_raw_packet_receive** _ 서비스를 통해 원시 IP 패킷을 받을 수 있습니다. 들어오는 모든 패킷은 IP 헤더에 지정된 프로토콜에 따라 처리됩니다. 프로토콜이 UDP, TCP, IGMP 또는 ICMP를 지정하는 경우 NetX는 패킷 프로토콜 유형에 적절한 처리기를 사용하여 패킷을 처리합니다. 프로토콜이 이러한 프로토콜 중 하나가 아니고 원시 IP 수신을 사용하도록 설정한 경우 들어오는 패킷은 원시 패킷 큐에 추가되어 애플리케이션이 _ *_nx_ip_raw_packet_receive_** 서비스를 통해 수신할 수 있을 때까지 대기합니다. 또한 애플리케이션 스레드는 원시 IP 패킷을 기다리는 동안 선택적 시간 제한으로 일시 중단될 수 있습니다.

### <a name="default-packet-pool"></a>기본 패킷 크기

각 IP 인스턴스에는 생성 중에 기본 패킷 풀이 지정됩니다. 이 패킷 풀은 ARP, RARP, ICMP, IGMP, 다양한 TCP 제어 패킷(예: SYN, ACK)에 대해 패킷을 할당하는 데 사용됩니다. NetX에서 패킷을 할당해야 할 때 기본 패킷 풀이 비어 있으면 NetX가 특정 작업을 중단해야 할 수 있으며 가능한 경우 오류 메시지를 반환합니다.

### <a name="ip-helper-thread"></a>IP 도우미 스레드

각 IP 인스턴스에는 도우미 스레드가 있습니다. 이 스레드는 모든 지연된 패킷 처리 및 모든 정기적 처리를 담당합니다. IP 도우미 스레드는 ***nx_ip_create*** 에서 생성됩니다. 여기서 스레드에 스택 및 우선 순위가 부여됩니다. IP 도우미 스레드의 첫 번째 처리 작업은 IP 만들기 서비스와 연결된 네트워크 드라이버 초기화를 완료하는 것입니다. 네트워크 드라이버 초기화가 완료되면 도우미 스레드는 패킷 및 주기적 요청을 처리하기 위해 무한 루프를 시작합니다.

> [!IMPORTANT]
> IP 도우미 스레드에서 설명할 수 없는 동작이 나타나는 경우, IP 만들기 서비스 중에 스택 크기를 늘리는 것이 첫 번째 디버깅 단계입니다. 스택이 너무 작으면 IP 도우미 스레드가 메모리를 덮어쓸 수 있으며 이로 인해 비정상적인 문제가 발생할 수 있습니다.

### <a name="thread-suspension"></a>스레드 일시 중단

애플리케이션 스레드는 원시 IP 패킷을 수신하는 동안 일시 중단될 수 있습니다. 원시 패킷이 수신되면 새 패킷이 일시 중단된 첫 번째 스레드에 제공되고 해당 스레드가 다시 시작됩니다. 패킷을 수신하는 NetX 서비스에는 모두 선택적 일시 중단 시간 제한이 있습니다. 패킷을 수신하거나 시간 제한이 만료되면 애플리케이션 스레드가 적절한 완료 상태로 다시 시작됩니다.

### <a name="ip-statistics-and-errors"></a>IP 통계 및 오류

사용하도록 설정된 경우 NetX는 애플리케이션에 유용할 수 있는 몇 가지 통계 및 오류를 추적합니다. 각 IP 인스턴스에 대해 다음 통계 및 오류 보고서가 유지 관리됩니다.

- 전송된 총 IP 패킷
- 전송된 총 IP 바이트
- 수신된 총 IP 패킷
- 수신된 총 IP 바이트
- 총 IP 잘못된 패킷
- 삭제된 총 IP 수신 패킷
- 총 IP 수신 체크섬 오류
- 삭제된 총 IP 전송 패킷
- 전송된 총 IP 조각
- 수신된 총 IP 조각

이러한 모든 통계 및 오류 보고서는 ***nx_ip_info_get*** 서비스를 사용하여 애플리케이션에서 사용할 수 있습니다.

### <a name="ip-control-block-nx_ip"></a>IP 제어 블록 NX_IP

각 IP 인스턴스의 특성은 해당 제어 블록에서 확인할 수 있습니다. 각 네트워크 디바이스의 IP 주소 및 네트워크 마스크, 인접 IP 및 실제 하드웨어 주소 매핑 표와 같은 유용한 정보를 포함합니다. 이 구조는 ***nx_api.h*** 에 정의됩니다. IP 인스턴스 제어 블록은 메모리의 어디에나 위치할 수 있지만 제어 블록을 모든 함수의 범위 밖에 정의하여 전역 구조로 만드는 것이 가장 일반적입니다.

### <a name="static-ip-routing"></a>고정 IP 라우팅

고정 라우팅 기능을 사용하면 애플리케이션에서 특정 네트워크 외부 대상 IP 주소에 대해 IP 네트워크 및 다음 홉 주소를 지정할 수 있습니다. 고정 라우팅을 사용하도록 설정한 경우 NetX는 고정 라우팅 테이블을 통해 전송할 패킷의 대상 주소와 일치하는 항목을 검색합니다. 일치하는 항목이 없으면 NetX는 실제 인터페이스 목록을 검색하여 대상 IP 주소와 네트워크 마스크를 기반으로 소스 IP 주소와 다음 홉 주소를 선택합니다. 대상이 IP 인스턴스에 연결된 네트워크 드라이버의 IP 주소와 일치하지 않으면 NetX는 기본 게이트웨이에 직접 연결된 인터페이스를 선택하고 인터페이스의 IP 주소를 소스 주소로 사용하고 기본 게이트웨이를 다음 홉으로 사용합니다.

각각 ***nx_ip_static_route_add*** 및 ***nx_ip_static_route_delete** _ 서비스를 사용하여 고정 라우팅 테이블에서 항목을 추가하고 제거할 수 있습니다. 고정 라우팅을 사용하려면 호스트 애플리케이션이 *_NX_ENABLE_IP_STATIC_ROUTING_**을 정의하여 이 기능을 사용하도록 설정해야 합니다.

> [!IMPORTANT]
> 고정 라우팅 테이블에 항목을 추가하는 경우 NetX는 테이블에 이미 있는 지정된 대상 주소와 일치하는 항목을 확인합니다. 항목이 있는 경우 네트워크 마스크에서 더 작은 네트워크(더 긴 접두사)가 있는 항목을 선호합니다.

### <a name="ip-fragmentation"></a>IP 조각화

네트워크 디바이스에는 나가는 패킷의 크기가 제한될 수 있습니다. 이 제한을 MTU(최대 전송 단위)라고 합니다. IP MTU는 링크 계층 드라이버가 IP 패킷을 조각화 하지 않고 전송할 수 있는 가장 큰 IP 프레임 크기입니다. 디바이스 드라이버 초기화 단계에서 드라이버 모듈은 ***nx_ip_interface_mtu_set*** 서비스를 통해 IP MTU 크기를 구성해야 합니다.

권장하지는 않지만 애플리케이션은 디바이스에서 지원되는 기본 IP MTU보다 큰 데이터그램을 생성할 수 있습니다. 이와 같은 IP 데이터그램을 전송하기 전에 IP 계층은 이러한 패킷을 분할해야 합니다. 조각난 IP 프레임을 수신하는 경우, 수신 끝은 조각난 모든 IP 프레임을 동일한 조각화 ID로 저장하고 순서대로 리어셈블해야 합니다. IP 수신 논리가 모든 조각을 수집하여 원래 IP 프레임을 제때 복원할 수 없는 경우 모든 조각이 해제됩니다. 이러한 패킷 손실을 감지하고 그로부터 복구하는 것은 상위 계층 프로토콜의 역할입니다.

IP 조각화 및 리어셈블리 작업을 지원하기 위해 시스템 디자이너는 ***nx_ip_fragment_enable*** 서비스를 사용하여 NetX에서 IP 조각화 기능을 사용하도록 설정해야 합니다. 이 기능을 사용하도록 설정하지 않으면 네트워크 드라이버의 MTU를 초과하는 패킷뿐만 아니라 들어오는 조각난 IP 패킷도 삭제됩니다.

> [!IMPORTANT]
>  **NetX 라이브러리를 빌드할 때 **NX_DISABLE_FRAGMENTATION** 을 정의하여 IP 조각화 논리를 완전히 제거할 수 있습니다. 이렇게 하면 NetX의 코드 크기를 줄일 수 있습니다.*

## <a name="address-resolution-protocol-arp-in-ip"></a>IP의 ARP(주소 확인 프로토콜)

ARP(주소 확인 프로토콜)는 32비트 IP 주소를 기본 실제 미디어(RFC 826)의 주소에 동적으로 매핑하는 역할을 합니다. 이더넷은 가장 일반적인 실제 미디어이며 48비트 주소를 지원합니다. ARP의 필요성은 ***nx_ip_create*** 서비스에 제공된 네트워크 드라이버에 의해 결정됩니다. 물리적 매핑이 필요한 경우 네트워크 드라이버는 인터페이스 구조에서 플래그 ***nx_interface_address_mapping_needed*** 를 설정해야 합니다.

### <a name="arp-enable"></a>ARP 사용
ARP가 제대로 작동하려면 먼저 애플리케이션이 ***nx_arp_enable*** 서비스를 사용하도록 설정해야 합니다. 이 서비스는 ARP 사용 서비스에 제공된 메모리에서 ARP 캐시 영역을 만드는 등 ARP 처리를 위한 다양한 데이터 구조를 설정합니다.

### <a name="arp-cache"></a>ARP 캐시
ARP 캐시는 내부 ARP 매핑 데이터 구조의 배열로 볼 수 있습니다. 각 내부 구조는 IP 주소와 실제 하드웨어 주소 사이의 관계를 유지 관리할 수 있습니다. 또한 각 데이터 구조에는 링크 포인터가 있어 여러 연결된 목록에 포함될 수 있습니다.

매핑이 ARP 테이블에 있는 경우 애플리케이션은 ***nx_arp_ip_address_find** _ 서비스를 사용하여 하드웨어 MAC 주소를 제공하는 방법으로 ARP 캐시에서 IP 주소를 조회할 수 있습니다. 마찬가지로 _ _nx_arp_hardware_address_find_* 서비스는 지정된 IP 주소에 대한 MAC 주소를 반환합니다.


### <a name="arp-dynamic-entries"></a>ARP 동적 항목

기본적으로 ARP 사용 서비스는 ARP 캐시의 모든 항목을 사용 가능한 동적 ARP 항목 목록에 배치합니다. 매핑되지 않은 IP 주소에 대한 전송 요청이 감지되면 이 목록에서 NetX가 동적 ARP 항목을 할당합니다. 할당 후 ARP 항목이 설정되고 실제 미디어로 ARP 요청이 전송됩니다.

***nx_arp_dynamic_entry_set*** 서비스에서 동적 항목을 만들 수도 있습니다.

> [!IMPORTANT]
> 모든 동적 ARP 항목이 사용 중인 경우 오래전에 사용한 ARP 항목이 새 매핑으로 바뀝니다.

### <a name="arp-static-entries"></a>ARP 고정 항목
또한 애플리케이션은 ***nx_arp_static_entry_create*** 서비스를 사용하여 고정 ARP 매핑을 설정할 수 있습니다. 이 서비스는 동적 ARP 항목 목록에서 ARP 항목을 할당하고 애플리케이션에서 제공하는 매핑 정보와 함께 고정 목록에 배치합니다. 고정 ARP 항목에는 재사용 또는 에이징이 적용되지 않습니다. 애플리케이션은 서비스 ***nx_arp_static_entry_delete*** 를 사용하여 고정 항목을 삭제할 수 있습니다.
ARP 테이블의 모든 고정 항목을 제거하기 위해 애플리케이션은 ***nx_arp_static_entries_delete*** 서비스를 사용할 수 있습니다.

### <a name="automatic-arp-entry"></a>자동 ARP 항목
NetX는 ARP 요청에 대한 피어 응답 후 피어의 IP/MAC 매핑을 기록합니다. NetX는 또한 네트워크에서 요청되지 않은 ARP 요청을 기반으로 피어 IP/MAC 주소 매핑을 기록하는 자동 ARP 항목 기능을 구현합니다. 이 기능을 사용하면 ARP 테이블을 피어 정보로 채울 수 있으므로 ARP 요청/응답 주기를 통과하는 데 필요한 지연을 줄일 수 있습니다. 그러나 자동 ARP를 사용하는 경우의 단점은 ARP 테이블이 로컬 링크에 많은 노드가 있는 사용량이 많은 네트워크에서 빠르게 채워지는 경향이 있고, 결국 이로 인해 ARP 항목을 대체하게 된다는 것입니다.

이 기능은 기본적으로 사용하도록 설정됩니다. 이 기능을 사용하지 않으려면 정의된 ***NX_DISABLE_ARP_AUTO_ENTRY*** 기호를 사용하여 NetX 라이브러리를 컴파일해야 합니다.

### <a name="arp-messages"></a>ARP 메시지

앞에서 언급한 대로 IP 작업에서 IP 주소에 대한 매핑이 필요하다는 것을 감지하면 ARP 요청 메시지가 전송됩니다. ARP 요청은 해당 ARP 응답이 수신될 때까지 주기적으로(매 ***NX_ARP_UPDATE_RATE** _초마다) 전송됩니다. ARP 시도가 중단되기 전에 총 _ *_NX_ARP_MAXIMUM_RETRIES_** ARP 요청이 수행됩니다. ARP 응답이 수신되면 관련된 실제 주소 정보는 캐시에 있는 ARP 항목에 저장됩니다.

멀티홈 시스템의 경우 NetX는 지정된 대상 주소에 따라 ARP 요청 및 응답을 보낼 인터페이스를 결정합니다.

> [!IMPORTANT]
> NetX가 ARP 응답을 대기하는 동안 나가는 IP 패킷은 큐에 대기합니다. 큐에 있는 나가는 IP 패킷 수는 상수 **NX_ARP_MAX_QUEUE_DEPTH** 에 의해 정의됩니다.  **

NetX는 로컬 IP 네트워크에 있는 다른 노드의 ARP 요청에도 응답합니다. ARP 요청을 수신하는 인터페이스의 현재 IP 주소와 일치하는 외부 ARP 요청이 이루어지면 NetX는 현재 실제 주소를 포함하는 ARP 응답 메시지를 작성합니다.

이더넷 ARP 요청 및 응답의 형식은 그림 6에 나타나 있으며 아래에 설명되어 있습니다.

| 요청/응답 필드       | 용도    |
|------------------------------|-----------------|
| 이더넷 대상 주소 | 이 6바이트 필드는 ARP 응답의 대상 주소를 포함하며 ARP 요청을 위한 브로드캐스트(모두 포함)입니다. 이 필드는 네트워크 드라이버에 의해 설정됩니다. |
| 이더넷 원본 주소      | 이 6바이트 필드는 ARP 요청 또는 응답의 송신자 주소를 포함하고 네트워크 드라이버에 의해 설정됩니다. |
| 프레임 유형                   | 이 2바이트 필드는 표시되는 이더넷 프레임 형식을 포함하며, ARP 요청 및 응답의 경우 이는 0x0806과 같습니다. 네트워크 드라이버가 설정할 마지막 필드입니다. |
| 하드웨어 종류                | 이 2바이트 필드에는 이더넷에 대해 0x0001인 하드웨어 형식이 포함됩니다. |
| 프로토콜 종류                | 이 2바이트 필드에는 IP 주소에 대해 0x0800인 프로토콜 형식이 포함됩니다. |
| 하드웨어 크기                | 이 1바이트 필드에는 이더넷 주소에 대해 6인 하드웨어 주소 크기가 포함됩니다. |


![ARP 패킷 형식](./media/user-guide/arp-packet-format.png)

**그림 6. ARP 패킷 형식**

| 요청/응답 필드 | 용도  |
|---|---|
| 프로토콜 크기 | 이 1바이트 필드에는 IP 주소에 대해 4인 IP 주소 크기가 포함됩니다.  |
| 작업 코드 | 이 2바이트 필드에는 이 ARP 패킷에 대한 작업이 포함됩니다. ARP 요청은 0x0001 값으로 지정되고, ARP 응답은 0x0002 값으로 표시됩니다.  |
| 송신자 이더넷 주소 | 이 6바이트 필드에는 송신자의 이더넷 주소가 포함됩니다. |
| 송신자 IP 주소 | 이 4바이트 필드에는 송신자의 IP 주소가 포함됩니다. |
| 대상 이더넷 주소 | 이 6바이트 필드에는 대상의 이더넷 주소가 포함됩니다. |
| 대상 IP 주소 | 이 4바이트 필드에는 대상의 IP 주소가 포함됩니다. |

> [!IMPORTANT]
> ARP 요청 및 응답은 이더넷 수준 패킷입니다. 다른 모든 TCP/IP 패킷은 IP 패킷 헤더에서 캡슐화됩니다.

> [!IMPORTANT]
> TCP/IP 구현의 모든 ARP 메시지는 Big Endian 형식이어야 합니다. 이 형식에서 단어의 가장 중요한 바이트는 가장 낮은 바이트 주소에 있습니다.

### <a name="arp-aging"></a>ARP 에이징

NetX는 자동 동적 ARP 항목 무효화를 지원합니다. ***NX_ARP_EXPIRATION_RATE** 는 실제 매핑에 대해 설정된 IP 주소가 유효한 상태로 유지되는 시간(초)을 지정합니다. 만료 후 ARP 항목은 ARP 캐시에서 제거됩니다. 다음번에 해당 IP 주소로 전송하려고 하면 새 ARP 요청이 발생합니다. _ *_NX_ARP_EXPIRATION_RATE_**를 0으로 설정하면 기본 구성인 ARP 에이징을 사용하지 않게 됩니다.

### <a name="arp-defend"></a>ARP 방어

ARP 요청 또는 ARP 응답 패킷이 수신되고 송신자가 이 노드의 IP 주소와 충돌하는 동일한 IP 주소를 가질 때 NetX는 해당 주소에 대한 ARP 요청을 방어 수단으로 전송합니다. 충돌 ARP 패킷이 10초 이내에 두 번 이상 수신되면 NetX는 더 이상 방어 패킷을 전송하지 않습니다. 기본 간격 10 초는 ***NX_ARP_DEFEND_INTERVAL** _로 다시 정의할 수 있습니다. 이 동작은 RFC5227의 2.4(c)에 지정된 정책을 따릅니다. Windows XP에서는 ARP 프로브를 위한 응답으로 ARP 알림을 무시하기 때문에 사용자가 _*_NX_ARP_DEFEND_BY_REPLY_**를 정의하여 ARP 응답을 추가 방어 수단으로 전송할 수 있습니다.

### <a name="arp-statistics-and-errors"></a>ARP 통계 및 오류

사용하도록 설정된 경우 NetX ARP 소프트웨어는 애플리케이션에 유용할 수 있는 몇 가지 통계 및 오류를 추적합니다. 각 IP의 ARP 처리에 대해 다음 통계 및 오류 보고서가 유지 관리됩니다.

- 전송된 총 ARP 요청
- 수신된 총 ARP 요청
- 전송된 총 ARP 응답
- 수신된 총 ARP 응답
- 총 ARP 동적 항목
- 총 ARP 고정 항목
- 총 ARP 오래된 항목
- 총 ARP 잘못된 메시지

이러한 모든 통계 및 오류 보고서는 애플리케이션에서 ***nx_arp_info_get*** 서비스를 통해 사용할 수 있습니다.

## <a name="reverse-address-resolution-protocol-rarp-in-ip"></a>IP의 RARP(역주소 확인 프로토콜)

RARP(역주소 확인 프로토콜)는 호스트의 32비트 IP 주소(RFC 903)에 대한 네트워크 할당을 요청하는 프로토콜입니다. 이 작업은 RARP 요청을 통해 수행되며 네트워크 멤버가 RARP 응답에서 호스트 네트워크 인터페이스에 IP 주소를 할당할 때까지 주기적으로 계속됩니다. 애플리케이션은 IP 주소가 0인 ***nx_ip_create*** 서비스에서 IP 인스턴스를 만듭니다. 애플리케이션에서 RARP를 사용하는 경우 RARP 프로토콜을 사용하여 IP 주소가 0인 인터페이스를 통해 액세스할 수 있는 네트워크 서버에서 IP 주소를 요청할 수 있습니다.

### <a name="rarp-enable"></a>RARP 사용

RARP를 사용하려면 애플리케이션에서 IP 주소가 0인 IP 인스턴스를 만든 다음, ***nx_rarp_enable*** 서비스를 사용하여 RARP를 사용하도록 설정해야 합니다. 멀티홈 시스템의 경우 IP 인스턴스와 연결된 하나 이상의 네트워크 디바이스에 0인 IP 주소가 있어야 합니다. RARP 처리는 네트워크 지정 IP 주소를 사용하는 유효한 RARP 응답이 수신될 때까지 IP 주소가 필요한 NetX 시스템에 대한 RARP 요청 메시지를 주기적으로 전송합니다. 이때 RARP 처리가 완료됩니다.

RARP를 사용하도록 설정한 후에는 모든 인터페이스 주소가 확인되면 자동으로 사용할 수 없게 됩니다. 애플리케이션이 ***nx_rarp_disable*** 서비스를 사용하여 강제로 RARP를 종료할 수 있습니다.

###  <a name="rarp-request"></a>RARP 요청

RARP 요청 패킷의 형식은 [ARP 메시지](#arp-messages) 항목의 그림 6에 표시된 ARP 패킷과 거의 동일합니다. 유일한 차이점은 프레임 유형 필드는 0x8035이고 ‘작업 코드’ 필드는 3이며 RARP 요청을 지정하는 것입니다. 앞에서 언급한 대로 RARP 요청은 네트워크에서 할당된 IP 주소를 가진 RARP 회신이 수신될 때까지 주기적으로(매 ***NX_RARP_UPDATE_RATE*** 초마다) 전송됩니다.

> [!IMPORTANT]
> TCP/IP 구현의 모든 RARP 메시지는 Big Endian 형식이어야 합니다. 이 형식에서 단어의 가장 중요한 바이트는 가장 낮은 바이트 주소에 있습니다.

### <a name="rarp-reply"></a>RARP 응답

RARP 응답 메시지는 네트워크에서 수신되고 이 호스트에 할당된 네트워크 IP 주소를 포함합니다. RARP 응답 패킷의 형식은 그림 6에 표시된 ARP 패킷과 거의 동일합니다. 유일한 차이점은 프레임 유형 필드는 0x8035이고 ‘작업 코드’ 필드는 4이며 RARP 응답을 지정하는 것입니다. 수신 후 IP 주소는 IP 인스턴스에서 설정되고 주기적 RARP 요청은 사용할 수 없으며 IP 인스턴스는 정상적인 네트워크 작업을 수행할 준비가 되었습니다.

멀티홈 호스트의 경우 IP 주소가 요청 네트워크 인터페이스에 적용됩니다. 여전히 IP 주소 할당을 요청하는 다른 네트워크 인터페이스가 있는 경우 모든 인터페이스 IP 주소 요청이 해결될 때까지 주기적인 RARP 서비스는 계속됩니다.

> [!IMPORTANT]
> 애플리케이션은 RARP 처리가 완료될 때까지 IP 인스턴스를 사용하면 안 됩니다. **nx_ip_status_check** 를 사용하여 애플리케이션에서 RARP 완료를 기다릴 수 있습니다. 멀티홈 시스템의 경우 애플리케이션은 해당 인터페이스에서 RARP 처리가 완료될 때까지 요청 인터페이스를 사용하지 않아야 합니다. **nx_ip_interface_status_check** 서비스를 사용하여 보조 디바이스의 IP 주소 상태를 확인할 수 있습니다.

### <a name="rarp-statistics-and-errors"></a>RARP 통계 및 오류

사용하도록 설정된 경우 NetX RARP 소프트웨어는 애플리케이션에 유용할 수 있는 몇 가지 통계 및 오류를 추적합니다. 각 IP의 RARP 처리에 대해 다음 통계 및 오류 보고서가 유지 관리됩니다.

- 전송된 총 RARP 요청
- 수신된 총 RARP 응답
- 총 RARP 잘못된 메시지

이러한 모든 통계 및 오류 보고서는 애플리케이션에서 ***nx_rarp_info_get*** 서비스를 통해 사용할 수 있습니다.

## <a name="internet-control-message-protocol-icmp"></a>ICMP(Internet Control Message Protocol)

IP용 ICMP(Internet Control Message Protocol)는 IP 네트워크 멤버 간의 오류 및 제어 정보를 전달하는 것으로 제한됩니다.

대부분의 다른 애플리케이션 계층(예: TCP/IP) 메시지와 마찬가지로 ICMP 메시지는 ICMP 프로토콜을 지정하는 IP 헤더에 의해 캡슐화됩니다.

### <a name="icmp-statistics-and-errors"></a>ICMP 통계 및 오류

사용하도록 설정된 경우 NetX는 애플리케이션에 유용할 수 있는 몇 가지 ICMP 통계 및 오류를 추적합니다. 각 IP의 ICMP 처리에 대해 다음 통계 및 오류 보고서가 유지 관리됩니다.

- 전송된 총 ICMP Ping
- 총 ICMP Ping 시간 제한
- 일시 중단된 총 ICMP Ping 스레드
- 수신된 총 ICMP Ping 응답
- 총 ICMP 체크섬 오류
- 총 ICMP 처리되지 않은 메시지

이러한 모든 통계 및 오류 보고서는 애플리케이션이 ***nx_icmp_info_get*** 서비스를 사용하여 이용할 수 있습니다.

### <a name="icmp-enable"></a>ICMP 사용
NetX에서 ICMP 메시지를 처리하려면 먼저 애플리케이션이 ***nx_icmp_enable*** 서비스를 호출하여 ICMP를 처리하도록 설정해야 합니다. 이 작업이 완료되면 애플리케이션에서 Ping 요청을 실행하고 들어오는 Ping 패킷을 처리할 수 있습니다.

### <a name="icmp-echo-request"></a>ICMP 에코 요청
에코 요청은 호스트 IP 주소로 식별되는 네트워크에 특정 노드가 있는지 확인하는 데 일반적으로 사용되는 ICMP 메시지의 한 유형입니다. 인기있는 Ping 명령은 ICMP 에코 요청/에코 응답 메시지를 사용하여 구현됩니다. 특정 호스트가 있는 경우 해당 네트워크 스택은 Ping 요청 및 응답을 ping 응답으로 처리합니다. 그림 7에서는 ICMP Ping 메시지 형식에 대해 자세히 나타냅니다.

![ICMP Ping 메시지](./media/user-guide/icmp-ping-message.png)

**그림 7. ICMPv4 Ping 메시지**

> [!IMPORTANT]
> TCP/IP 구현의 모든 ICMP 메시지는 Big Endian 형식이어야 합니다. 이 형식에서 단어의 가장 중요한 바이트는 가장 낮은 바이트 주소에 있습니다.

다음 표에서는 ICMP 헤더 형식에 대해 설명합니다.

| 헤더 필드    | 용도 |
|-----------------|---------------------------------------------------|
| Type            | 이 필드에서는 ICMP 메시지(31-24비트)를 지정합니다. 가장 일반적인 메시지: 0 에코 응답   8 에코 요청 |
| 코드            | 이 필드는 형식 필드(23-16비트)에서 컨텍스트에 따라 다릅니다. 에코 요청 또는 응답의 경우 코드는 0으로 설정됩니다. |
| 체크섬        | 이 필드는 형식 필드에서 시작하는 ICMP 헤더 전체를 포함하여 ICMP 메시지의 보수 합계에 대한 16비트 체크섬을 포함합니다. 체크섬을 생성하기 전에 체크섬 필드가 지워집니다.                 |
| Identification(식별)  | 이 필드는 호스트를 식별하는 ID 값을 포함합니다. 호스트는 에코 응답의 에코 요청에서 추출된 ID를 사용해야 합니다(31-16비트). |
| 시퀀스 번호 | 이 필드는 ID 값을 포함합니다. 호스트는 에코 응답의 에코 요청에서 추출된 ID를 사용해야 합니다(31-16비트). ID 필드와 달리 이 값은 동일한 호스트의 후속 에코 요청에서 변경됩니다(15-0비트). |


### <a name="icmp-echo-response"></a>ICMP 에코 응답
ping 응답은 외부 ping 요청에 대한 응답으로 ICMP 구성 요소에 의해 내부적으로 생성되는 또 다른 형식의 ICMP 메시지입니다. ping 응답에는 승인 외에도 ping 요청에 제공된 사용자 데이터 복사본도 포함됩니다.

## <a name="internet-group-management-protocol-igmp"></a>IGMP(Internet Group Management Protocol)

IGMP(Internet Group Management Protocol)는 IP 멀티캐스트 그룹(RFC 1112와 RFC 2236)을 수신하거나 조인하려는 네트워크 환경 및 라우터와 통신할 수 있는 디바이스를 제공합니다. 멀티캐스트 그룹은 기본적으로 네트워크 멤버의 동적 집합이며 클래스 D IP 주소로 표시됩니다. 멀티캐스트 그룹의 멤버는 언제든지 탈퇴할 수 있고, 새로운 멤버는 언제든지 가입할 수 있습니다. 그룹에 조인하고 탈퇴하는 것과 관련된 조정은 IGMP의 역할입니다.

### <a name="igmp-enable"></a>IGMP 사용

NetX에서 멀티캐스팅 작업을 수행하려면 먼저 애플리케이션이 ***nx_igmp_enable*** 서비스를 호출해야 합니다. 이 서비스는 멀티캐스트 요청에 준비하기 위해 기본적인 IGMP 초기화를 수행합니다.

### <a name="multicast-ip-addressing"></a>멀티캐스트 IP 주소 지정

앞에서 설명한 대로 멀티캐스트 주소는 실제로 58페이지의 그림 4에 나와 있는 것처럼 클래스 D IP 주소입니다. 클래스 D 주소의 하위 28비트는 멀티캐스트 그룹 ID에 해당합니다. 미리 정의된 일련의 멀티캐스트 주소가 있습니다. 그러나 *모든 호스트 주소*(244.0.0.1)는 IGMP 처리에 특히 중요합니다. ‘모든 호스트 주소’는 라우터가 모든 멀티캐스트 멤버를 쿼리하여 자신이 속한 멀티캐스트 그룹을 보고하는 데 사용됩니다.

### <a name="physical-address-mapping-in-ip"></a>IP의 실제 주소 매핑

클래스 D 멀티캐스트 주소는 01.00.5e.00.00.00에서 01.00.5e.7f.ff.ff까지 범위의 실제 이더넷 주소로 직접 매핑됩니다. IP 멀티캐스트 주소의 하단 23비트는 이더넷 주소의 하위 23비트에 직접 매핑됩니다.

### <a name="multicast-group-join"></a>멀티캐스트 그룹 가입

특정 멀티캐스트 그룹에 가입해야 하는 애플리케이션은 ***nx_igmp_multicast_join*** 서비스를 호출하여 이 작업을 수행할 수 있습니다. 이 서비스는 이 멀티캐스트 그룹에 조인하려는 요청 수를 추적합니다. 멀티캐스트 그룹에 조인하려는 첫 번째 애플리케이션 요청이라면 IGMP 보고서는 그룹에 조인하려는 이 호스트의 의도를 나타내는 기본 네트워크에 전송됩니다. 그런 다음, 네트워크 드라이버를 호출하여 이 멀티캐스트 그룹에 대한 이더넷 주소로 패킷을 수신 대기하도록 설정합니다.

멀티홈 시스템에서, 멀티캐스트 그룹이 특정 인터페이스를 통해 접근할 수 있다면, 애플리케이션은 기본 네트워크의 멀티캐스트 그룹으로 제한된 ***nx_igmp_multicast_join*** 대신 ***nx_igmp_multicast_interface_join*** 서비스를 사용해야 합니다.

### <a name="multicast-group-leave"></a>멀티캐스트 그룹 나가기

이전에 가입된 멀티캐스트 그룹을 탈퇴해야 하는 애플리케이션은 ***nx_igmp_multicast_leave*** 서비스를 호출하여 탈퇴할 수 있습니다. 이 서비스는 그룹이 조인된 횟수와 관련된 내부 수를 줄입니다. 그룹에 대한 처리 중인 조인 요청이 없는 경우 네트워크 드라이버를 호출하여 이 멀티캐스트 그룹의 이더넷 주소로 패킷을 수신 대기하지 않도록 설정합니다.

### <a name="multicast-loopback"></a>멀티캐스트 루프백

애플리케이션은 동일한 노드의 소스 중 하나에서 시작된 멀티캐스트 트래픽을 수신하려고 할 수 있습니다. 이렇게 하려면 ***nx_igmp_loopback_enable*** 서비스를 사용하여 IP 멀티캐스트 구성 요소가 루프백을 사용하도록 설정해야 합니다.

### <a name="igmp-report-message"></a>IGMP 보고서 메시지

애플리케이션이 멀티캐스트 그룹에 가입할 때 IGMP 보고서 메시지는 네트워크를 통해 전송되어 특정 멀티캐스트 그룹에 가입하려는 호스트의 의도를 나타냅니다. IGMP 보고서 메시지의 형식은 그림 8에서 확인할 수 있습니다. 멀티캐스트 그룹 주소는 IGMP 보고서 메시지의 그룹 메시지와 대상 IP 주소에 모두 사용됩니다.

![IGMP 보고서 메시지](./media/user-guide/igmp-report-message.png)

**그림 8. IGMP 보고서 메시지**

위의 그림에서(그림 8) IGMP 헤더에는 버전/유형 필드, 최대 응답 시간, 체크섬 필드 및 멀티캐스트 그룹 주소 필드가 포함됩니다. IGMPv1 메시지의 경우 최대 응답 시간 필드는 IGMPv1 프로토콜의 일부가 아니므로 항상 0으로 설정됩니다. 최대 응답 시간 필드는 호스트가 쿼리 형식 IGMP 메시지를 수신할 때 설정되고 호스트가 IGMPv2 프로토콜로 정의된 다른 호스트의 보고서 형식 메시지를 수신할 때 삭제됩니다.

다음은 IGMP 헤더 형식에 대한 설명입니다.

| **헤더 필드**          | **용도** |
|-----------------------|--------------------------------------------------------------------|
| 버전               | 이 필드는 IGMP 버전(31-28비트)을 지정합니다.                                                                               |
| 형식                  | 이 필드는 IGMP 메시지 유형(27-24비트)을 지정합니다.                                                                       |
| 최대 응답 시간 | IGMPv1에서 사용되지 않습니다. IGMPv2에서 이 필드는 최대 응답 시간으로 사용됩니다.                                                      |
| 체크섬              | 이 필드에는 IGMP 버전(0-15비트)으로 시작하는 IGMP 메시지의 1의 보수 합계에 대한 16비트 체크섬이 포함됩니다. |
| 그룹 주소         | 32비트 클래스 D 그룹 IP 주소 |


또한 IGMP 보고서 메시지는 멀티캐스트 라우터에 의해 전송된 IGMP 쿼리 메시지에 응답하여 전송됩니다. 멀티캐스트 라우터는 그룹 멤버 자격이 여전히 필요한 호스트를 확인하기 위해 주기적으로 쿼리 메시지를 전송합니다. 쿼리 메시지는 그림 8에 표시된 IGMP 보고서 메시지와 동일한 형식을 갖습니다. 유일한 차이점은 IGMP 형식이 1과 같고 그룹 주소 필드는 0으로 설정된다는 것입니다. IGMP 쿼리 메시지는 멀티캐스트 라우터에 의해 ‘모든 호스트’ IP 주소로 전송됩니다. 그룹 멤버 자격을 유지 관리하려는 호스트가 다른 IGMP 보고서 메시지를 전송하여 응답합니다.

> [!IMPORTANT]
> TCP/IP 구현의 모든 메시지는 **big endian** 형식이어야 합니다. 이 형식에서 단어의 가장 중요한 바이트는 가장 낮은 바이트 주소에 있습니다.

### <a name="igmp-statistics-and-errors"></a>IGMP 통계 및 오류

사용하도록 설정된 경우 NetX IGMP 소프트웨어는 애플리케이션에 유용할 수 있는 몇 가지 통계 및 오류를 추적합니다. 각 IP의 IGMP 처리에 대해 다음 통계 및 오류 보고서가 유지 관리됩니다.

- 전송된 총 IGMP 보고서
- 수신된 총 IGMP 쿼리
- 총 IGMP 체크섬 오류
- 조인된 총 IGMP 현재 그룹

이러한 모든 통계 및 오류 보고서는 애플리케이션이 ***nx_igmp_info_get*** 서비스를 사용하여 이용할 수 있습니다.

## <a name="user-datagram-protocol-udp"></a>UDP(User Datagram Protocol)

UDP(User Datagram Protocol)는 네트워크 멤버(RFC 768) 간에 가장 간단한 형식으로 데이터를 전송합니다. UDP 데이터 패킷은 한 네트워크 멤버에서 다른 네트워크 멤버로 최상의 방법으로 전송됩니다. 즉, 패킷 수신자의 확인을 위한 기본 제공 메커니즘은 제공되지 않습니다. 또한 UDP 패킷을 전송할 때 미리 연결할 필요가 없습니다. 따라서 UDP 패킷 전송은 매우 효율적입니다.

### <a name="udp-header"></a>UDP 헤더
UDP는 전송 중인 애플리케이션의 데이터 앞에 간단한 패킷 헤더를 배치하고, 수신된 UDP 패킷을 애플리케이션에 전송하기 전에 수신한 패킷에서 유사한 UDP 헤더를 제거합니다. UDP는 패킷을 주고받기 위해 IP 프로토콜을 활용하는데, 이는 패킷이 네트워크에 있을 때 UDP 헤더 앞에 IP 헤더가 있음을 의미합니다. 그림 9는 UDP 헤더의 형식을 보여 줍니다.

![UDP 헤더](./media/user-guide/udp-header.png)

**그림 9. UDP 헤더**

> [!IMPORTANT]
> UDP/IP 구현의 모든 헤더는 big endian 형식이어야 합니다. 이 형식에서 단어의 가장 중요한 바이트는 가장 낮은 바이트 주소에 있습니다.

다음은 UDP 헤더 형식에 대한 설명입니다.

| 헤더 필드                   | 용도 |
|--------------------------------|---------------------------------------------|
| 16비트 원본 포트 번호      | 이 필드에는 UDP 패킷을 전송할 포트가 포함되어 있습니다. 유효한 UDP 포트의 범위는 1에서 0xFFFF까지입니다. |
| 16비트 대상 포트 번호 | 이 필드에는 패킷을 전송할 UDP 포트가 포함되어 있습니다. 유효한 UDP 포트의 범위는 1에서 0xFFFF까지입니다.   |
| 16비트 UDP 길이   | 이 필드에는 UDP 헤더의 크기를 포함하여 UDP 패킷의 바이트 수가 포함됩니다.                                  |
| 16비트 UDP 체크섬 | 이 필드에는 UDP 헤더, 패킷 데이터 영역, 의사 IP 헤더를 포함하여 패킷에 대한 16비트 체크섬이 포함됩니다. |

### <a name="udp-enable"></a>UDP 사용

UDP 패킷을 전송하려면 먼저 ***nx_udp_enable*** 서비스를 호출하여 애플리케이션에서 UDP를 사용하도록 설정해야 합니다. 사용하도록 설정된 후 애플리케이션은 UDP 패킷을 자유롭게 주고받을 수 있습니다.

### <a name="udp-socket-create"></a>UDP 소켓 만들기

UDP 소켓은 초기화 중에 또는 애플리케이션 스레드에 의한 런타임 중에 만들어집니다. 초기 서비스 유형, TTL(Time to Live), 수신 큐 깊이는 ***nx_udp_socket_create*** 서비스에 의해 정의됩니다. 애플리케이션의 UDP 소켓 수에는 제한이 없습니다.

### <a name="udp-checksum"></a>UDP 체크섬

UDP는 IP 의사 헤더(소스 IP 주소, 대상 IP 주소, 프로토콜/길이 IP 단어로 구성), UDP 헤더, UDP 패킷 데이터를 포함하는 1의 보수 16비트 체크섬을 지정합니다. 계산된 UDP 체크섬이 0이면 모두 0으로 저장됩니다(0xFFFF). 전송 소켓에 UDP 체크섬 논리가 사용할 수 없는 경우, 0이 UDP 체크섬 필드에 배치되어 체크섬이 계산되지 않았음을 나타냅니다. UDP 체크섬이 수신자에 의해 계산된 체크섬과 일치하지 않으면 UDP 패킷은 폐기됩니다.

IPv4 네트워크에서 UDP 체크섬은 선택 사항입니다. NetX를 사용하면 애플리케이션이 소켓 단위로 UDP 체크섬 계산을 사용하거나 사용하지 않도록 설정할 수 있습니다. 기본적으로 UDP 소켓 체크섬 논리를 사용할 수 있습니다. 애플리케이션은 ***nx_udp_socket_checksum_disable*** 서비스를 호출하여 특정 UDP 소켓에 대한 체크섬 논리를 사용하지 않도록 설정할 수 있습니다.

특정 이더넷 컨트롤러는 즉시 UDP 체크섬을 생성할 수 있습니다. 시스템이 하드웨어 체크섬 계산 기능을 사용할 수 있는 경우, NetX 라이브러리를 체크섬 논리 없이 빌드할 수 있습니다. UDP 소프트웨어 체크섬을 사용하지 않도록 설정하려면 ***NX_DISABLE_UDP_TX_CHECKSUM*** 및 ***NX_DISABLE_UDP_RX_CHECKSUM* *_([2장](chapter2.md)에 설명됨) 기호를 사용하여 NetX 라이브러리를 빌드해야 합니다.****  서비스를 호출하여 애플리케이션에서 소켓 단위로 IP UDP 체크섬 처리를 사용하지 않도록 설정할 수 있지만 구성 옵션은 NetX에서 UDP 체크섬 논리를 완전히 제거합니다.

### <a name="udp-ports-and-binding"></a>UDP 포트 및 바인딩

UDP 포트는 UDP 프로토콜의 논리적 끝점입니다. NetX의 UDP 구성 요소에는 65,535개의 유효한 포트가 있으며, 범위는 1 ~ 0xFFFF입니다. UDP 데이터를 주고받으려면 먼저 애플리케이션에서 UDP 소켓을 만든 다음 원하는 포트에 바인딩해야 합니다. UDP 소켓을 포트에 바인딩한 후 애플리케이션은 해당 소켓에서 데이터를 주고받을 수 있습니다.

### <a name="udp-fast-pathtrade"></a>UDP 빠른 경로&trade;

UDP 빠른 경로&trade;는 NetX UDP 구현을 통한 낮은 패킷 오버헤드 경로에 대한 이름입니다. UDP 패킷을 전송하려면 ***nx_udp_socket_send** _, __nx_ip_packet_send__, 네트워크 드라이버에 대한 최종 호출과 같은 몇 가지 함수 호출만 필요합니다. _*_nx_udp_socket_send_*_ 는 기존 NetX 애플리케이션에 대해 NetX에서 사용할 수 있으며 IP 패킷에만 적용됩니다. 그러나 기본 방법은 아래에서 설명하는 _ *_nx_udp_socket_send_** 서비스를 사용하는 것입니다. UDP 패킷 수신 시, UDP 패킷은 적절한 UDP 소켓 수신 큐에 배치되거나 네트워크 드라이버 수신 인터럽트 처리에서 단일 함수 호출로 일시 중단된 애플리케이션 스레드에 전달됩니다. UDP 패킷을 주고받기 위해 최적화된 이 논리는 UDP 빠른 경로 기술의 핵심입니다.

### <a name="udp-packet-send"></a>UDP 패킷 전송

IP 네트워크를 통해 UDP 데이터를 전송하는 작업은 ***nx_udp_socket_send** _ 함수를 호출하여 쉽게 수행할 수 있습니다. 호출자는 _IP 주소 * 필드에 IP 버전을 설정해야 합니다. NetX는 대상 IP 주소를 기준으로 전송된 UDP 패킷에 가장 적합한 소스 주소를 결정합니다. 이 서비스는 패킷 데이터 앞에 UDP 헤더를 배치하고 내부 IP 전송 루틴을 사용하여 이를 네트워크로 전송합니다. 모든 UDP 패킷 전송이 즉시 처리되므로 UDP 패킷을 전송할 때 스레드가 일시 중단되지 않습니다.

멀티캐스트 또는 브로드캐스트 대상에 대해 애플리케이션은 NetX 디바이스가 선택할 여러 IP 주소를 가지고 있는 경우 사용할 소스 IP 주소를 지정해야 합니다. 이러한 작업은 ***nx_udp_socket_interface_send.*** 서비스로 수행할 수 있습니다.

> [!IMPORTANT]
> **nx_udp_socket_send** 가 멀티캐스트 또는 브로드캐스트 패킷 전송에 사용되는 경우 첫 번째 인터페이스의 IP 주소가 소스 주소로 사용됩니다.

> [!IMPORTANT]
> 이 소켓에 대해 UDP 체크섬 논리를 사용하는 경우 UDP 또는 IP 데이터 구조에 대한 액세스를 차단하지 않고 호출 스레드의 컨텍스트에서 체크섬 작업이 수행됩니다.

> [!NOTE]
> **NX_PACKET** 구조체에 있는 UDP 페이로드 데이터는 긴 단어 경계에 있어야 합니다. 애플리케이션에서 NetX가 UDP, IP, 실제 미디어 헤더를 배치할 수 있도록 앞에 추가 포인터와 데이터 시작 포인터 사이에 충분한 공간을 남겨 두어야 합니다.

### <a name="udp-packet-receive"></a>UDP 패킷 수신

애플리케이션 스레드는 ***nx_udp_socket_receive*** 를 호출하여 특정 소켓에서 UDP 패킷을 수신할 수 있습니다. 소켓 수신 함수는 소켓의 수신 큐에서 가장 오래된 패킷을 전달합니다. 수신 큐에 패킷이 없는 경우 패킷이 도착할 때까지 호출 스레드가 선택적 시간 제한으로 일시 중단될 수 있습니다.

UDP 수신 패킷 처리(일반적으로 네트워크 드라이버의 수신 인터럽트 처리기에서 호출됨)는 패킷을 UDP 소켓의 수신 큐에 배치하거나 패킷을 대기 중인 첫 번째 일시 중단된 스레드로 전달하는 역할을 합니다. 패킷이 큐에 있는 경우 수신 처리는 소켓과 관련된 최대 수신 큐 깊이도 확인합니다. 새로 큐에 배치된 패킷이 큐 깊이를 초과하면 큐에서 가장 오래된 패킷이 삭제됩니다.

### <a name="udp-receive-notify"></a>UDP 수신 알림

애플리케이션 스레드가 둘 이상의 소켓에서 수신된 데이터를 처리해야 하는 경우 ***nx_udp_socket_receive_notify*** 함수를 사용해야 합니다. 이 함수는 소켓에 대한 수신 패킷 콜백 함수를 등록합니다. 피켓이 소켓에 수신될 때마다 콜백 함수가 실행됩니다.

콜백 함수의 내용은 애플리케이션마다 다릅니다. 그러나 현재 해당 소켓에서 패킷을 사용할 수 있음을 처리 스레드에 알리기 위한 논리를 포함하고 있을 가능성이 높습니다.

### <a name="peer-address-and-port"></a>피어 주소 및 포트

UDP 패킷을 수신하면 애플리케이션에서 ***nx_udp_packet_info_extract*** 서비스를 사용하여 송신자의 IP 주소와 포트 번호를 찾을 수 있습니다. 성공적으로 반환되면 이 서비스는 송신자의 IP 주소, 송신자의 포트 번호, 패킷을 수신한 로컬 인터페이스에 대한 정보를 제공합니다.

### <a name="thread-suspension"></a>스레드 일시 중단

앞에서 설명한 대로 애플리케이션 스레드는 특정 UDP 포트에서 UDP 패킷을 수신하려 하는 동안 일시 중단할 수 있습니다. 해당 포트에서 패킷이 수신되면 패킷이 일시 중단된 첫 번째 스레드에 제공되고 해당 스레드가 다시 시작됩니다. 대부분의 NetX 서비스에서 사용할 수 있는 기능인 UDP 수신 패킷을 일시 중단할 경우 선택적 시간 제한을 사용할 수 있습니다.

### <a name="udp-socket-statistics-and-errors"></a>UDP 소켓 통계 및 오류

사용하도록 설정된 경우 NetX UDP 소프트웨어는 애플리케이션에 유용할 수 있는 몇 가지 통계 및 오류를 추적합니다. 각 IP/UDP 인스턴스에 대해 다음 통계 및 오류 보고서가 유지 관리됩니다.

- 전송된 총 UDP 패킷
- 전송된 총 UDP 바이트
- 수신된 총 UDP 패킷
- 수신된 총 UDP 바이트
- 총 UDP 잘못된 패킷
- 삭제된 총 UDP 수신 패킷
- 총 UDP 수신 체크섬 오류
- 전송된 UDP 소켓 패킷
- 전송된 UDP 소켓 바이트
- 수신된 UDP 소켓 패킷
- 수신된 UDP 소켓 바이트
- 큐에 있는 UDP 소켓 패킷
- 삭제된 UDP 소켓 수신 패킷
- UDP 소켓 체크섬 오류

이 모든 통계 및 오류 보고서는 모든 UDP 소켓을 모은 UDP 통계를 위한 ***nx_udp_info_get*** 서비스와 지정된 UDP 소켓의 UDP 통계를 위한 ***nx_udp_socket_info_get*** 서비스를 통해 애플리케이션에서 사용할 수 있습니다.

### <a name="udp-socket-control-block-nx_udp_socket"></a>UDP 소켓 제어 블록 NX_UDP_SOCKET

각 UDP 소켓의 특성은 관련된 **NX_UDP_SOCKET** 제어 블록에서 찾을 수 있습니다. IP 데이터 구조에 대한 링크, 정신 및 수신 경로에 대한 네트워크 인터페이스, 바인딩된 포트, 수신 패킷 큐와 같은 유용한 정보를 포함합니다. 이 구조는 **_nx_api.h_** 파일에서 정의됩니다.

## <a name="transmission-control-protocol-tcp"></a>TCP(Transmission Control Protocol)

TCP(Transmission Control Protocol)는 두 네트워크 멤버(RFC 793) 간의 신뢰할 수 있는 스트림 데이터 전송을 제공합니다. 한 네트워크 멤버에서 전송된 모든 데이터는 수신 멤버에 의해 확인되고 승인됩니다. 또한 두 멤버는 데이터를 전송하기 전에 연결을 설정해야 합니다. 이로 인해 신뢰할 수 있는 데이터 전송이 가능하지만 앞에서 설명한 UDP 데이터 전송보다 훨씬 많은 오버헤드를 필요로 합니다.

### <a name="tcp-header"></a>TCP 헤더

전송 시 TCP 헤더는 사용자의 데이터 앞에 배치됩니다. 수신 시 TCP 헤더가 들어오는 패킷에서 제거되고 사용자 데이터만 애플리케이션에서 사용할 수 있습니다. TCP는 IP 프로토콜을 활용하여 패킷을 주고받는데, 이는 패킷이 네트워크에 있을 때 TCP 헤더 앞에 IP 헤더가 있다는 것을 의미합니다. 그림 10에서는 TCP 헤더의 형식을 보여줍니다.

![TCP 헤더](./media/user-guide/tcp-header.png)

**그림 10. TCP 헤더**

다음은 TCP 헤더 형식에 대한 설명입니다.

| 헤더 필드 | 용도 |
|---|---|
| 16비트 원본 포트 번호 | 이 필드에는 TCP 패킷이 전송되는 포트가 포함되어 있습니다. 유효한 TCP 포트 범위는 1에서 0xFFFF까지입니다. |
| 16비트 대상 포트 번호 | 이 필드에는 패킷이 전송되는 TCP 포트가 포함되어 있습니다. 유효한 TCP 포트 범위는 1에서 0xFFFF까지입니다. |
| 32비트 시퀀스 번호 | 이 필드에는 연결의 이 끝쪽에서 전송된 데이터의 시퀀스 번호가 포함되어 있습니다. 원래 시퀀스는 두 TCP 노드 간의 초기 연결 시퀀스 중에 설정됩니다. 해당 지점에서 데이터를 전송할 때마다 시퀀스 번호가 전송된 바이트 양만큼 증가합니다. |
| 32비트 승인 번호 | 이 필드에는 연결의 이 쪽에서 마지막으로 수신된 바이트에 해당하는 시퀀스 번호가 포함되어 있습니다. 이는 이전에 전송된 데이터가 연결의 다른 쪽 끝에서 성공적으로 수신되었는지 여부를 확인하는 데 사용됩니다. |
| 4비트 헤더 길이           | 이 필드에는 TCP 헤더의 32비트 단어 수가 포함되어 있습니다. TCP 헤더에 옵션이 없는 경우 이 필드는 5입니다. |
| 6비트 코드 비트               | 이 필드에는 연결과 관련된 다양한 제어 정보를 나타내는 데 사용되는 6개의 서로 다른 코드 비트가 포함되어 있습니다. 제어 비트는 다음과 같이 정의됩니다. |



| 이름 | bit | 의미                                                     |
|------|-----|-------------------------------------------------------------|
| URG  | 21  | 긴급 데이터 표시                                         |
| ACK  | 20  | 승인 번호가 유효합니다.                             |
| PSH  | 19  | 이 데이터를 즉시 처리합니다.                                |
| RST  | 18  | 연결을 다시 설정합니다.                                        |
| SYN  | 17  | 연결 설정에 사용되는 시퀀스 번호를 동기화합니다. |
| FIN  | 16  | 송신자가 전송을 완료했습니다(연결을 닫는 데 사용됨). |

**16비트 창**

이 필드는 흐름 제어에 사용됩니다. 소켓이 현재 수신할 수 있는 바이트의 양이 포함됩니다. 이는 기본적으로 흐름 제어에 사용됩니다. 송신자는 전송할 데이터가 수신자의 수신 가능 창에 맞는지 확인해야 합니다.

| **헤더 필드**          | **용도** |
| ------------------------- | --- |
| **16비트 TCP 체크섬**   | 이 필드에는 TCP 헤더, 패킷 데이터 영역, 의사 IP 헤더를 포함하는 패킷에 대한 16비트 체크섬이 포함됩니다.                |
| **16비트 긴급 포인터** | 이 필드에는 긴급 데이터의 마지막 바이트의 양수 오프셋이 포함됩니다. 이 필드는 URG 코드 비트가 헤더에 설정된 경우에만 유효합니다. |

> [!IMPORTANT]
> TCP/IP 구현의 모든 헤더는 big endian 형식이어야 합니다. 이 형식에서 단어의 가장 중요한 바이트는 가장 낮은 바이트 주소에 있습니다.

### <a name="tcp-enable"></a>TCP 사용

TCP 연결 및 패킷 전송을 사용하려면 먼저 애플리케이션이 nx_tcp_enable 서비스를 호출하여 TCP를 사용하도록 설정해야 합니다. 사용하도록 설정된 후 애플리케이션은 모든 TCP 서비스에 자유롭게 액세스할 수 있습니다.

### <a name="tcp-socket-create"></a>TCP 소켓 만들기

TCP 소켓은 초기화 중에 또는 애플리케이션 스레드에 의한 런타임 중에 만들어집니다. 초기 서비스 형식, TTL(Time to Live), 창 크기는 ***nx_tcp_socket_create*** 서비스에 의해 정의됩니다. 애플리케이션의 TCP 소켓 수에는 제한이 없습니다.

### <a name="tcp-checksum"></a>TCP 체크섬

TCP는 IP 의사 헤더(소스 IP 주소, 대상 IP 주소, 프로토콜/길이 IP 단어로 구성), TCP 헤더, TCP 패킷 데이터를 포함하는 1의 보수 16비트 체크섬을 지정합니다.

특정 네트워크 컨트롤러는 하드웨어에서 TCP 체크섬 계산 및 유효성 검사를 수행할 수 있습니다. 이러한 시스템의 경우, 애플리케이션은 런타임 오버헤드를 줄이기 위해 가능한 한 많은 하드웨어 체크섬 논리를 사용해야 할 수 있습니다. 애플리케이션은 빌드 시 **NX_DISABLE_TCP_TX_CHECKSUM** 및 **NX_DISABLE_TCP_RX_CHECKSUM** 을 정의하여 NetX 라이브러리에서 TCP 체크섬 계산 논리를 모두 사용하지 않도록 설정할 수 있습니다. 이렇게 하면 TCP 체크섬 코드는 컴파일되지 않습니다.

### <a name="tcp-port"></a>TCP 포트

TCP 포트는 TCP 프로토콜의 논리적 연결 지점입니다. NetX의 TCP 구성 요소에는 65,535개의 유효한 포트가 있으며, 범위는 1 ~ 0xFFFF입니다. 한 포트의 데이터를 다른 대상 포트로 전송할 수 있는 UDP와 달리 TCP 포트는 다른 특정 TCP 포트에 연결되며 이 연결이 설정될 때, 연결을 구성하는 두 포트 사이에서만 데이터 전송이 가능합니다.

> [!IMPORTANT]
> TCP 포트는 UDP 포트와 완전히 분리되어 있습니다. 예를 들어, UDP 포트 번호 1은 TCP 포트 번호 1과 관련이 없습니다.

## <a name="client-server-model"></a>클라이언트 서버 모델

데이터 전송에 TCP를 사용하려면 먼저 두 TCP 소켓 사이에 연결을 설정해야 합니다. 연결 설정은 클라이언트 서버 방식으로 수행됩니다. 연결의 클라이언트 쪽은 연결을 시작하는 쪽이고, 서버 쪽은 처리가 완료되기 전에 클라이언트 연결 요청을 기다리기만 합니다.

> [!IMPORTANT]
> 멀티홈 디바이스의 경우 NetX는 연결에 사용할 원본 주소와 연결의 대상 IP 주소를 기준으로 하는 다음 홉 주소를 자동으로 결정합니다.

### <a name="tcp-socket-state-machine"></a>TCP 소켓 상태 시스템

두 TCP 소켓(하나의 클라이언트와 하나의 서버) 간의 연결이 복잡하며 상태 시스템 방식으로 관리됩니다. 각 TCP 소켓은 CLOSED 상태로 시작됩니다. 연결 이벤트를 통해 각 소켓의 상태 시스템은 TCP 데이터 전송의 대부분을 ESTABLISHED 상태로 마이그레이션합니다. 연결의 한쪽이 더 이상 데이터를 전송하지 않으려는 경우 연결이 끊어집니다. 다른 쪽의 연결이 끊긴 후, 결국 TCP 소켓은 CLOSED 상태로 돌아갑니다. 이 프로세스는 TCP 클라이언트와 서버가 연결을 설정하고 닫을 때마다 반복됩니다. 그림 11에서는 TCP 상태 시스템의 다양한 상태를 보여 줍니다.

![TCP 상태 시스템의 상태](./media/user-guide/states-tcp-state-machine.png)

### <a name="figure-11-states-of-the-tcp-state-machine"></a>그림 11. TCP 상태 시스템의 상태

### <a name="tcp-client-connection"></a>TCP 클라이언트 연결

앞에서 설명한 대로 TCP 연결의 클라이언트 측에서 TCP 서버에 대한 연결 요청을 시작합니다. 연결 요청을 하려면 먼저 클라이언트 IP 인스턴스에서 TCP를 사용하도록 설정해야 합니다. 또한 클라이언트 TCP 소켓은 다음에 *nx_tcp_socket_create_ 서비스를 사용하여 만들고 _*nx_tcp_client_socket_bind 서비스를 통해 포트에 바인딩되어야 합니다. 클라이언트 소켓이 바인딩된 후에는 _ _nx_tcp_client_socket_connect_* 서비스를 사용하여 TCP 서버와의 연결을 설정합니다. 연결 시도를 시작하려면 소켓이 CLOSED 상태여야 합니다. 연결 설정은 NetX가 SYN 패킷을 실행한 다음 서버에서 SYN ACK 패킷을 다시 대기하는 것으로 시작하며 이는 연결 요청에 대한 승인을 나타냅니다. SYN ACK가 수신되면 NetX는 ACK 패킷으로 응답하고 클라이언트 소켓을 ESTABLISHED 상태로 수준을 올립니다.

### <a name="tcp-client-disconnection"></a>TCP 클라이언트 연결 끊기

***nx_tcp_socket_disconnect*** 를 호출하여 연결을 닫습니다. 일시 중단이 지정되지 않은 경우 클라이언트 소켓은 RST 패킷을 서버 소켓으로 전송하고 소켓을 CLOSED 상태로 둡니다. 그렇지 않고 일시 중단이 요청되면 다음과 같이 전체 TCP 연결 끊기 프로토콜이 수행됩니다.

- 서버가 이전에 연결 끊기 요청을 시작한 경우(클라이언트 소켓이 이미 FIN 패킷을 수신하여 ACK로 응답하고 CLOSE WAIT 상태에 있음), NetX는 클라이언트 TCP 소켓 상태를 LAST ACK 상태로 승격하고 FIN 패킷을 전송합니다. 그런 다음, 서버로부터 ACK를 기다렸다가 연결을 끊고 CLOSED 상태로 들어갑니다.

- 반면에 클라이언트가 연결 해제 요청을 가장 먼저 시작하는 경우(서버는 연결이 끊기지 않았으며 소켓은 여전히 ESTABLISHED 상태) NetX는 연결을 해제하기 위해 FIN 패킷을 전송하고 서버로부터 FIN과 ACK를 받기 위해 대기한 후 연결을 완전히 끊고 소켓을 CLOSED 상태로 둡니다.

소켓 전송 큐에 여전히 패킷이 있는 경우 NetX는 패킷을 승인할 수 있도록 지정된 시간 제한을 일시 중단합니다. 시간 제한이 만료되면 NetX는 클라이언트 소켓의 전송 큐를 비웁니다.

클라이언트 소켓에서 포트의 바인딩을 해제하기 위해 애플리케이션은 ***nx_tcp_client_socket_unbind*** 를 호출합니다. 포트가 해제되기 전에 소켓이 CLOSED 상태이거나 연결을 끊는 중(TIMED WAIT 상태)이어야 합니다. 그러지 않으면 오류가 반환됩니다.

마지막으로, 애플리케이션이 더 이상 클라이언트 소켓을 필요로 하지 않으면 ***nx_tcp_socket_delete*** 를 호출하여 소켓을 삭제합니다.

### <a name="tcp-server-connection"></a>TCP 서버 연결

TCP 연결의 서버 측은 수동적입니다. 즉, 서버는 클라이언트가 연결 요청을 시작할 때까지 기다립니다. 클라이언트 연결을 허용하려면 먼저 ***nx_tcp_enable** _ 서비스를 호출하여 IP 인스턴스에서 TCP를 사용하도록 설정해야 합니다. 다음으로 애플리케이션은 _ _nx_tcp_socket_create_* 서비스를 사용하여 TCP 소켓을 만들어야 합니다.

서버 소켓이 연결 요청을 수신 대기하도록 설정되어야 합니다. 이 작업은 ***nx_tcp_server_socket_listen*** 서비스를 사용하여 수행됩니다. 이 서비스는 서버 소켓을 LISTEN 상태로 두고 지정된 서버 포트를 소켓에 바인딩합니다.

> [!IMPORTANT]
> 소켓 수신 대기 콜백 루틴을 설정하기 위해 애플리케이션은 **nx_tcp_server_socket_listen** 서비스의 tcp_listen_callback 인수에 대해 적절한 콜백 함수를 지정합니다. 그런 다음, 이 애플리케이션 콜백 함수는 이 서버 포트에서 새로운 연결이 요청될 때마다 NetX에 의해 실행됩니다. 콜백의 처리는 애플리케이션 제어 중입니다.

클라이언트 연결 요청을 수락하기 위해 애플리케이션은 ***nx_tcp_server_socket_accept** _ 서비스를 호출합니다. 수락 서비스를 호출하려면 서버 소켓이 LISTEN 상태 또는 SYN RECEIVED 상태(즉, 서버가 LISTEN 상태이고 연결을 요청하는 클라이언트로부터 SYN 패킷을 수신함)여야 합니다. _ _nx_tcp_server_socket_accept_*에서 성공적으로 반환되면 연결이 설정되었으며 서버 소켓이 ESTABLISHED 상태에 있음을 나타냅니다.

서버 소켓에 유효한 연결이 있으면 추가 클라이언트 연결 요청이 listen_queue_size에 의해 지정된 깊이까지 큐에 대기하고 ***nx_tcp_server_socket_listen** _ 서비스에 전달됩니다. 서버 포트에서 후속 연결을 처리하려면 애플리케이션은 사용 가능한 소켓(즉, CLOSED 상태의 소켓)을 사용하여 _ _nx_tcp_server_socket_relisten_*를 호출해야 합니다. 소켓과 연결된 이전 연결이 완료되고 소켓이 CLOSED 상태인 경우 동일한 서버 소켓을 사용할 수 있습니다.

### <a name="tcp-server-disconnection"></a>TCP 서버 연결 끊기

***nx_tcp_socket_disconnect*** 를 호출하여 연결을 닫습니다. 일시 중단이 지정되지 않은 경우 서버 소켓은 RST 패킷을 클라이언트 소켓으로 전송하고 소켓을 CLOSED 상태로 둡니다 그렇지 않고 일시 중단이 요청되면 다음과 같이 전체 TCP 연결 끊기 프로토콜이 수행됩니다.

- 클라이언트가 이전에 연결 끊기 요청을 시작한 경우(서버 소켓이 이미 FIN 패킷을 수신하여 ACK로 응답하고 CLOSE WAIT 상태에 있음), NetX는 TCP 소켓 상태를 LAST ACK 상태로 승격하고 FIN 패킷을 전송합니다. 그런 다음, 클라이언트로부터 ACK를 기다렸다가 연결을 끊고 CLOSED 상태로 들어갑니다.

- 반면에 서버가 연결 해제 요청을 가장 먼저 시작하는 경우(클라이언트는 연결이 끊기지 않았으며 소켓은 여전히 ESTABLISHED 상태) NetX는 연결을 해제하기 위해 FIN 패킷을 전송하고 클라이언트로부터 FIN과 ACK를 받기 위해 대기한 후 연결을 완전히 끊고 소켓을 CLOSED 상태로 둡니다.

소켓 전송 큐에 여전히 패킷이 있는 경우 NetX는 패킷을 승인할 수 있도록 지정된 시간 제한을 일시 중단합니다. 시간 제한이 만료되면 NetX는 서버 소켓의 전송 큐를 플러시합니다.

연결 끊기 처리가 완료되고 서버 소켓이 CLOSED 상태이면 애플리케이션은 ***nx_tcp_server_socket_unaccept*** 서비스를 호출하여 이 소켓과 서버 포트와의 연결을 종료해야 합니다. ***nx_tcp_socket_disconnect*** 또는 ***nx_tcp_server_socket_accept** _를 오류 상태로 반환하는 경우에도 애플리케이션에서 이 서비스를 호출해야 합니다. _nx_tcp_server_socket_unaccept_ 를 반환한 후, 소켓을 클라이언트나 서버 소켓으로 사용할 수 있으며 더 이상 필요하지 않은 경우에는 삭제 할 수도 있습니다. 동일한 서버 포트에서 다른 클라이언트 연결을 허용하려면 이 소켓에서 ***nx_tcp_server_socket_relisten*** 서비스를 호출해야 합니다.

다음 코드 세그먼트는 일반적인 TCP 서버가 사용하는 호출 시퀀스를 보여줍니다.

```c
/* Set up a previously created TCP socket to listen on port 12 */

nx_tcp_server_socket_listen()

/* Loop to make a (another) connection. */
while(1) {

    /* Wait for a client socket connection request for 100 ticks. */
    nx_tcp_server_socket_accept();

    /* (Send and receive TCP messages with the TCP client) */

    /* Disconnect the server socket. */
    nx_tcp_socket_disconnect();

    /* Remove this server socket from listening on the port. */

    nx_tcp_server_socket_unaccept(&server_socket);

    /* Set up server socket to relisten on the same port for the next
    client. */
    nx_tcp_server_socket_relisten();
}
```

### <a name="mss-validation"></a>MSS 유효성 검사

MSS(최대 세그먼트 크기)는 TCP 호스트가 기본 IP 계층에 의해 조각나지 않고 수신할 수 있는 최대 바이트 수입니다. TCP 연결 설정 단계를 수행하는 동안 양쪽 끝에서 자체 TCP MSS 값을 교환하여 송신자가 수신자의 MSS보다 큰 TCP 데이터 세그먼트를 전송하지 않도록 합니다. NetX TCP 모듈은 연결을 설정하기 전에 피어의 보급된 MSS 값의 유효성을 선택적으로 검사합니다. 기본적으로 NetX는 이러한 검사를 사용하도록 설정하지 않습니다. MSS 유효성 검사를 수행하려는 애플리케이션은 NetX 라이브러리를 빌드할 때 ***NX_ENABLE_TCP_MSS_CHECKING** _를 정의해야 하며 최솟값은 _*_NX_TCP_MSS_MINIMUM_*_ 에 정의되어 있어야 합니다. MSS 값이 _ _NX_TCP_MSS_MINIMUM_* 미만으로 들어오는 TCP 연결이 삭제됩니다.

### <a name="stop-listening-on-a-server-port"></a>서버 포트에서 수신 대기 중지

애플리케이션이 이전에 ***nx_tcp_server_socket_listen** _ 서비스에 대한 호출로 이전에 지정된 서버 포트에서 클라이언트 연결 요청을 더 이상 수신 대기하지 않으려는 경우, 애플리케이션은 _ *_nx_tcp_server_socket_unlisten_** 서비스를 호출하기만 하면 됩니다. 이 서비스는 연결을 기다리는 소켓을 다시 CLOSED 상태로 두고 큐에 있는 클라이언트 연결 요청 패킷을 모두 해제합니다.

### <a name="tcp-window-size"></a>TCP 창 크기

연결의 설정 및 데이터 전송 단계를 수행하는 동안 각 포트는 처리할 수 있는 데이터 양을 보고합니다. 이를 창 크기라고 합니다. 데이터가 수신되고 처리되면 이 창 크기는 동적으로 조정됩니다. TCP에서 송신자는 수신자의 창에 맞는 양의 데이터만 전송할 수 있습니다. 기본적으로 창 크기는 연결의 각 방향에서 데이터 전송을 위한 흐름 제어를 제공합니다.

### <a name="tcp-packet-send"></a>TCP 패킷 전송

***nx_tcp_socket_send*** 함수를 호출하여 TCP 데이터 전송을 쉽게 수행할 수 있습니다. 전송 중인 데이터의 크기가 소켓의 MSS 값 또는 현재 피어 수신 창 크기 중 더 작은 값보다 클 경우, TCP 내부 논리는 전송을 위해 최소 크기(MSS, 피어 수신 창)에 맞는 데이터를 잘라냅니다. 그런 다음, 이 서비스는 체크섬 계산을 포함하여 패킷 앞에 TCP 헤더를 빌드합니다. 수신자의 창 크기가 0이 아닌 경우, 호출자는 수신자 창 크기를 채울 수 있는 만큼의 최대한 많은 데이터를 전송합니다. 수신 창이 0이 되면, 호출자는 이 패킷을 보낼 수 있을 만큼 수신자의 창 크기가 커지기를 일시 중단하고 대기할 수 있습니다. 언제든지 여러 스레드가 동일한 소켓을 통해 데이터를 전송하는 동안 스레드는 일시 중단될 수 있습니다.

> [!IMPORTANT]
> NX_PACKET 구조에 있는 TCP 데이터는 긴 단어 경계에 있어야 합니다. 또한 앞에 추가 포인터와 데이터 시작 포인터 사이에 TCP, IP, 실제 미디어 헤더가 배치될 수 있도록 충분한 공간이 있어야 합니다.

### <a name="tcp-packet-retransmit"></a>TCP 패킷 재전송

이전에 전송된 TCP 패킷은 ACK가 연결의 다른 쪽에서 반환될 때까지 실제로 내부적으로 저장됩니다. 전송된 데이터가 시간 제한 기간 내에 승인되지 않으면 저장된 패킷이 다시 전송되고 다음 시간 제한 기간이 설정됩니다. ACK가 수신되면 내부 전송 큐의 승인 번호로 처리되는 모든 패킷이 최종적으로 해제됩니다.

> [!IMPORTANT]
> *애플리케이션은 ***nx_tcp_socket_send** _ 함수가 NX_SUCCESS와 함께 반환된 후 패킷을 다시 사용하거나 패킷의 내용을 변경하지 않아야 합니다. 전송된 패킷은 결과적으로 다른 끝에서 데이터를 승인한 후 NetX 내부 처리에 의해 해제됩니다.

### <a name="tcp-keepalive"></a>TCP Keepalive

TCP Keepalive 기능을 사용하면 소켓이 적절한 종료(예: 피어 크래시) 없이 피어 연결이 끊어졌는지 여부를 감지하거나 특정 네트워크 모니터링 기능이 장시간 유휴 상태에서 연결이 종료되는 것을 방지할 수 있습니다. TCP Keepalive는 데이터가 없는 TCP 프레임을 주기적으로 전송하고, 시퀀스 번호가 현재 시퀀스 번호보다 작은 값으로 설정됨으로써 작동합니다. 활성 상태의 수신자는 해당 TCP Keepalive 프레임을 수신하면 현재 시퀀스 번호에 대해 ACK로 응답합니다. 이렇게 하면 keepalive 트랜잭션이 완료됩니다.

기본적으로 keepalive 기능은 사용하도록 설정되지 않습니다. 이 기능을 사용하려면 ***NX_ENABLE_TCP_KEEPALIVE** _가 정의된 NetX 라이브러리를 빌드해야 합니다. _ _NX_TCP_KEEPALIVE_INITIAL_* 기호는 keepalive 프레임이 시작되기 전의 비활성 시간(초)을 지정합니다.

### <a name="tcp-packet-receive"></a>TCP 패킷 수신

TCP 수신 패킷 처리(IP 도우미 스레드에서 호출)는 다양한 연결 및 연결 끊기 작업뿐만 아니라 전송 승인 처리도 담당합니다. 또한 TCP 수신 패킷 처리는 수신 데이터가 있는 패킷을 적절한 TCP 소켓의 수신 큐에 배치하거나 패킷을 대기 중인 첫 번째 일시 중단된 스레드에 패킷을 전달하는 역할을 합니다.

### <a name="tcp-receive-notify"></a>TCP 수신 알림

애플리케이션 스레드가 둘 이상의 소켓에서 받은 데이터를 처리해야 하는 경우 ***nx_tcp_socket_receive_notify*** 함수를 사용해야 합니다. 이 함수는 소켓에 대한 수신 패킷 콜백 함수를 등록합니다. 피켓이 소켓에 수신될 때마다 콜백 함수가 실행됩니다.

콜백 함수의 콘텐츠는 애플리케이션에 따라 다르지만, 그 함수는 해당 소켓에서 패킷을 사용할 수 있다는 것을 처리 스레드에 알리는 논리를 포함할 가능성이 큽니다.

### <a name="thread-suspension"></a>스레드 일시 중단

앞에서 설명한 대로 애플리케이션 스레드는 특정 TCP 포트에서 데이터를 수신하는 동안 일시 중단할 수 있습니다. 해당 포트에서 패킷이 수신되면 패킷이 일시 중단된 첫 번째 스레드에 제공되고 해당 스레드가 다시 시작됩니다. 대부분의 NetX 서비스에서 사용할 수 있는 기능인 TCP 수신 패킷을 일시 중단할 경우 선택적 시간 제한을 사용할 수 있습니다.

스레드 일시 중단은 클라이언트와 서버 모두, 클라이언트 바인딩 및 연결 끊기 서비스에도 사용할 수 있습니다.

### <a name="tcp-socket-statistics-and-errors"></a>TCP 소켓 통계 및 오류

사용하도록 설정된 경우 NetX TCP 소프트웨어는 애플리케이션에 유용할 수 있는 몇 가지 통계 및 오류를 추적합니다. 각 IP/TCP 인스턴스에 대해 다음 통계 및 오류 보고서가 유지 관리됩니다.

- 전송된 총 TCP 패킷
- 전송된 총 TCP 바이트
- 수신된 총 TCP 패킷
- 수신된 총 TCP 바이트
- 총 TCP 잘못된 패킷
- 삭제된 총 TCP 수신 패킷
- 총 TCP 수신 체크섬 오류
- 총 TCP 연결
- 총 TCP 연결 끊김
- 삭제된 총 TCP 연결
- 총 TCP 패킷 재전송
- 전송된 TCP 소켓 패킷
- 전송된 TCP 소켓 바이트
- 수신된 TCP 소켓 패킷
- 수신된 TCP 소켓 바이트
- TCP 소켓 패킷 재전송
- 큐에 있는 TCP 소켓 패킷
- TCP 소켓 체크섬 오류
- TCP 소켓 상태
- TCP 소켓 전송 큐 깊이
- TCP 소켓 전송 창 크기
- TCP 소켓 수신 창 크기

이러한 모든 통계 및 오류 보고서는 총 TCP 통계의 경우 ***nx_tcp_info_get** _ 서비스와 소켓당 TCP 통계의 경우 _ _nx_tcp_socket_info_get_* 서비스가 있는 애플리케이션에서 사용할 수 있습니다.

## <a name="tcp-socket-control-block-nx_tcp_socket"></a>TCP 소켓 제어 블록 NX_TCP_SOCKET

각 TCP 소켓의 특징은 연결된 *NX_TCP_SOCKET* 제어 블록에서 찾을 수 있습니다. 여기에는 IP 데이터 구조에 대한 링크, 네트워크 연결 인터페이스, 바인딩된 포트, 수신 패킷 큐와 같은 유용한 정보가 포함됩니다. 이 구조는 ***nx_api.h*** 파일에서 정의됩니다.
