---
title: 3장 - GUIX의 기능 개요
description: 이 장에는 고성능 GUIX 사용자 인터페이스 제품의 기능 개요가 포함되어 있습니다.
author: philmea
ms.author: philmea
ms.date: 05/19/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 37c1103d6b690350b6fa0794b9c719f31a112ff3babf88f125d3735f8ef935b6
ms.sourcegitcommit: 93d716cf7e3d735b18246d659ec9ec7f82c336de
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/07/2021
ms.locfileid: "116785232"
---
# <a name="chapter-3---functional-overview-of-guix"></a>3장 - GUIX의 기능 개요

이 장에는 고성능 GUIX 사용자 인터페이스 제품의 기능 개요가 포함되어 있습니다. 

## <a name="execution-overview"></a>실행 개요

GUIX는 이벤트 구동 프로그래밍 모델을 구현합니다. 이것은 GUIX 프레임워크가 주로 GUIX 이벤트 큐에 푸시되는 이벤트 수신에 의해 구동됨을 의미합니다. 이러한 이벤트의 처리는 GUIX 시스템 초기화 중에 생성된 ThreadX 스레드인 GUIX 스레드의 컨텍스트에서 발생합니다.

GUIX 애플리케이션은 창 및 자식 위젯을 만들기 위한 GUIX API 함수를 호출하여 사용자 인터페이스를 정의하고, 각 창이나 위젯 형식의 색, 스타일, 글꼴 및 기타 다양한 특성을 정의하는 데 사용되는 추가 API 함수를 호출하여 이러한 위젯의 모양을 사용자 지정합니다. GUIX Studio를 사용하여 사용자 인터페이스 화면의 모양을 만드는 경우 GUIX API 함수를 호출하여 화면 표시를 만드는 이러한 많은 작업은 GUIX Studio 애플리케이션을 통해 수행됩니다.

GUIX 애플리케이션은 GUIX 이벤트 큐에서 검색된 이벤트를 처리하여 시스템 사용자 및 외부 비즈니스 논리와 상호 작용합니다.
이러한 이벤트는 일반적으로 GUIX 위젯에 의해 생성되지만 외부 스레드에 의해 생성될 수도 있습니다. 일반적인 GUIX 단추를 누르면 해당 단추는 단추의 부모 창으로 이벤트를 보냅니다. 애플리케이션은 단추 누름 이벤트에 대한 처리기를 제공하여 해당 단추를 누르면 작동합니다.

입력 드라이버와 같은 항목에 대해 추가 GUIX 스레드가 생성되는 경우가 많습니다. 일반적인 터치 스크린 입력 드라이버는 주 GUIX 스레드 외부의 독립 실행형 스레드로 실행됩니다. 터치 입력 드라이버는 GUIX 이벤트 큐에 이벤트를 전송하여 터치 정보를 GUIX 스레드로 보냅니다.

애니메이션과 같은 여러 사용자 인터페이스 작업은 정확한 타이밍 정보를 요구하므로 GUIX는 간단하고 사용하기 쉬운 타이머 인터페이스도 구현합니다. 이 타이머 인터페이스는 ThreadX 타이머 서비스를 기준으로 빌드되며 시스템 시작 시 자동으로 구성됩니다.

대부분의 GUIX 소프트웨어는 하드웨어 종속성에 독립적입니다. 프레임워크에는 하드웨어 관련 입력 드라이버 및 하드웨어 관련 그래픽 드라이버가 필요합니다. 이러한 하드웨어 관련 드라이버가 구현되는 방법에 대한 자세한 내용은 5장에 설명됩니다.

## <a name="initialization"></a>초기화 

서비스 ***gx_system_initialize*** 는 다른 GUIX 서비스를 호출하기 전에 호출해야 합니다. GUIX 시스템 초기화는 ThreadX ***tx_application_define*** 루틴(초기화 컨텍스트) 또는 애플리케이션 스레드에서 호출될 수 있습니다. ***gx_system_initialize*** 함수는 GUIX 이벤트 큐를 만들고, GUIX 타이머 기능을 초기화하고, 주 GUIX 시스템 스레드를 만들고, 애플리케이션을 실행하는 동안 GUIX에서 유지 관리되는 다양한 데이터 구조를 초기화합니다.

***gx_system_initialize*** 가 반환된 후에는 애플리케이션에서 화면 표시, 캔버스, 창, 위젯을 만들고 모든 GUIX 개체의 속성을 사용자 지정할 준비가 완료됩니다. GUIX 개체 만들기 API의 대부분은 ***tx_application_define*** 또는 애플리케이션 스레드에서 호출할 수 있습니다.

## <a name="application-interface-calls"></a>애플리케이션 인터페이스 호출 

애플리케이션에서 수행되는 호출은 주로 ***tx_application_define***(초기화 컨텍스트) 또는 애플리케이션 스레드에서 수행됩니다. 4장에서 설명하는 각 GUIX API의 "허용 위치" 섹션을 참조하여 호출 가능 컨텍스트를 확인하세요.

대부분의 경우 모든 이벤트 처리 및 위젯/창 그리기를 포함하는 처리 집약적 작업은 내부 GUIX 스레드로 지연됩니다.

언제든지 임의 스레드에서 GUIX API 함수를 호출할 수 있습니다.
그러나 일반적으로 사용자 인터페이스 논리에서 시간이 중요한 비즈니스 논리를 분리하는 것이 더 나은 아키텍처가 되는 것으로 간주됩니다. 사용자 인터페이스 그리기 작업은 화면 크기와 CPU 성능에 따라 시간이 오래 걸릴 수 있으므로 일반적으로 그리기 작업이 완료될 때까지 시간이 중요한 스레드가 지연되는 것을 원치 않을 것입니다.

## <a name="internal-guix-thread"></a>내부 GUIX 스레드 

앞서 언급한 것처럼 GUIX에는 대량 GUI 처리를 수행하는 내부 스레드가 있습니다. 이 스레드는 애플리케이션 소프트웨어에서 ***gx_system_initialize** _ 다음에 _*_gx_system_start_**를 호출하여 생성됩니다.

내부 GUIX 스레드의 우선 순위는 `#define GX_SYSTEM_THREAD_PRIORITY`에 따라 결정됩니다. 이 값의 기본값은 16(중간 우선 순위)이지만 gx_port.h 또는 gx_user.h 헤더 파일에서 기본값을 재정의하여 수정할 수 있습니다.

GUIX 스레드 시간 조각은 `#define GX_SYSTEM_THREAD_TIMESLICE`에서 유사하게 정의되며 기본값은 10ms입니다.

시스템 스레드의 스택 크기는 ***gx_port.h*** 헤더 파일에 있는 `#define GX_THREAD_STACK_SIZE`로 결정되지만 헤더 파일에 이 값을 지정하여 재정의할 수도 있습니다.

내부 GUIX 스레드 실행 루프는 세 가지 작업으로 구성됩니다.
먼저 GUIX는 GUIX 이벤트 큐에서 이벤트를 검색하고 GUIX 창 및 위젯에서 처리될 이벤트를 디스패치합니다. 이벤트는 일반적으로 사용자 입력을 처리할 때 정기적 타이머, 입력 디바이스(예: 터치 스크린 또는 키패드)에 의해, 그리고 GUIX 위젯 자체에 의해 GUIX 이벤트 큐에 푸시됩니다. 그런 다음, 모든 이벤트가 처리되면 GUIX는 화면 새로 고침이 필요한지를 확인하고, 새로 고침이 필요하면 더티로 표시된 창 및 위젯의 그리기 기능을 호출하여 디스플레이 그래픽 데이터를 업데이트하는 데 필요한 처리를 수행합니다. 마지막으로 GUIX는 새 입력 이벤트가 도달할 때까지 GUIX 스레드를 일시 중단합니다.

## <a name="event-processing"></a>이벤트 처리 

터치 또는 펜 입력 이벤트는 터치 또는 펜 입력 픽셀 위치 아래에 있는 맨 위 창이나 위젯을 확인하고 해당 창/위젯의 이벤트 처리 함수를 호출하여 처리됩니다. 위젯이 펜 입력 이벤트를 이해하는 경우 해당 위젯 유형에 적절하게 이벤트를 처리합니다. 그렇지 않은 경우 맨 위에 있는 위젯은 처리를 위해 위젯 부모에 터치 또는 펜 입력 이벤트를 전달합니다. 이러한 체인까지의 이벤트 전달은 이벤트가 처리되거나 이벤트가 루트 창에 도달할 때(이 경우 이벤트는 삭제됨)까지 계속됩니다.

키패드 이벤트는 입력 포커스가 있는 창/위젯에 전송됩니다. 입력 포커스 상태는 GUIX gx_system 구성 요소에 의해 유지 관리됩니다.

타이머 이벤트는 처리를 위해 타이머를 소유하는 창 또는 위젯으로 항상 디스패치됩니다.

단추 클릭 이벤트 또는 슬라이더 값 변경 이벤트와 같이 내부적으로 생성된 이벤트는 항상 이벤트를 생성하는 위젯의 부모로 보내집니다. 부모가 이벤트를 처리하지 않으면 터치 또는 펜 입력 이벤트와 유사한 체인으로 전달됩니다.

## <a name="drawing"></a>그리기 

모든 이벤트 처리가 완료되면 GUIX 내부 스레드는 디스플레이 업데이트가 필요한지 여부를 확인하고 업데이트가 필요하면 적절한 창/위젯 그리기 함수가 호출됩니다. 그리기가 완료되면 GUIX 내부 스레드는 다음 GUIX 이벤트가 처리될 수 있게 이벤트 큐에서 대기합니다.

GUIX는 각 위젯 및 캔버스에 대해 다시 그려야 하는 영역인 *더티 영역* 개념을 구현합니다. 위젯은 이전에 더티로 표시된 영역에만 그릴 수 있습니다. 위젯 그리기 함수를 호출하면 모든 그리기 작업은 내부적으로 이전에 정의된 더티 사각형으로 자릅니다.
이 영역 외부의 그리기 시도는 무시됩니다.

위젯 및 창은 API 함수 ***gx_system_dirty_mark*** 를 호출하여 자체적으로 더티로 표시합니다. 이 함수는 전체 위젯 또는 창을 다시 그려야 하는 것으로 표시합니다. 두 번째 함수인 ***gx_system_dirty_partial_add*** 는 창이나 위젯의 일부만 더티로 표시하기 위한 대안으로 호출될 수 있습니다.

위젯을 더티로 표시한 다음, 모든 입력 이벤트가 처리된 경우에만 해당 위젯을 다시 그리는 이러한 모델을 *지연된 그리기* 라고 합니다. GUIX 지연된 그리기 알고리즘 및 더티 목록 유지 관리는 그리기 효율성을 향상시키도록 설계되었습니다. 그리기 작업은 일반적으로 비용이 많이 들기 때문에 GUIX에서는 불필요한 그리기를 방지하기 위해 많은 노력을 기울입니다.

GUIX *캔버스* 로 그리기가 수행됩니다. 캔버스는 그래픽 데이터를 저장하기 위해 예약된 메모리 영역입니다. 시스템 아키텍처 및 메모리 제약 조건에 따라 캔버스를 하드웨어 프레임 버퍼에 직접 연결할 수도 있고 그렇지 않을 수도 있습니다. 그리기를 수행하려면 먼저 ***gx_canvas_drawing_initiate*** API 함수를 호출하여 그리기를 위해 캔버스를 열어야 합니다. 이 API는 그리기를 위해 캔버스를 준비하고 현재 *그리기 컨텍스트* 를 설정했습니다. GUIX에서 시스템 캔버스 새로 고침을 수행하면 캔버스는 그리기를 위해 열리고 위젯 수준 그리기 API를 호출하기 전에 그리기 컨텍스트가 설정됩니다. 따라서 위젯은 위젯 그리기 함수 내에서 캔버스에 그리기를 시작할 필요가 없습니다.

그러나 애플리케이션은 표준 GUIX 지연된 그리기 알고리즘의 흐름 외부에서 캔버스에 즉시 그리기를 수행하려는 경우에는 다른 그리기 API 함수를 호출하기 전에 애플리케이션에서 ***gx_canvas_drawing_initiate*** 를 직접 호출하고, 일단 즉시 그리기가 완료되면 ***gx_canvas_drawing_complete*** 를 호출해야 합니다.

## <a name="user-input"></a>사용자 입력 

GUIX는 미리 정의된 이벤트 유형을 사용하여 터치 스크린, 마우스 및 키보드 디바이스를 지원합니다. 사용자 지정 이벤트 유형을 정의하거나 사용자 지정 입력 디바이스를 미리 정의된 이벤트 유형에 매핑하여 추가 입력 디바이스를 활용할 수 있습니다.

이러한 디바이스와 관련된 작업은 내부 GUIX 스레드가 처리하는 이벤트로 변환됩니다. 터치 스크린을 지원하도록 작성된 드라이버 수준 소프트웨어는 GUIX 이벤트 큐 이벤트를 준비하고, 펜 놓기, 펜 들기 및 펜 끌기 작업으로 전송해야 합니다. 마찬가지로 키패드 입력 드라이버는 키 누름 및 키 놓기 입력에 대한 이벤트를 생성해야 합니다.

## <a name="modal-dialog-execution"></a>모달 대화 상자 실행 

모달 대화 상자 실행은 다른 GUIX 창 또는 위젯이 사용자 입력을 받을 수 있도록 먼저 닫아야 하는 창을 사용자에게 제공하는 것을 의미합니다. 모달 대화 상자는 터치 또는 마우스 입력 이벤트의 x, y 위치에 관계없이 대화 상자 창이 표시되는 동안 모든 사용자 입력을 캡처합니다.

모달 대화 상자는 ***gx_window_create*** 를 호출하고 GUIX API 함수 ***gx_window_execute*** 를 호출하여 일반적인 방식으로 창을 먼저 만든 다음, 애플리케이션 소프트웨어에 의해 트리거됩니다.

***gx_window_execute*** 함수를 호출하면 GUIX가 로컬 이벤트 처리 루프를 시작합니다. ***gx_window_execute*** 함수는 사용자 입력에 의해 또는 ***gx_window_close*** 를 호출하여 대화 상자 창을 닫을 때까지 호출자에게 반환하지 않습니다. 따라서 GUIX 내부 스레드 이외의 스레드에서 ***gx_window_execute*** 함수를 호출하지 않는 것이 중요합니다.

## <a name="periodic-processing"></a>정기적 처리 

디스플레이 효과, 스프라이트 애니메이션 및 애플리케이션 주기적 요청 지원을 제공하기 위해 GUIX는 하나의 ThreadX 타이머를 사용합니다. 이 단일 타이머는 모든 GUIX 시간 관련 요구를 발생시키는 데 사용됩니다. 기본적으로 GUIX 내부 타이머 처리의 빈도는 **_gx_api.h_** 에 정의된 **GX_SYSTEM_TIMER_MS** 상수가 이전에 gx_port.h 또는 gx_user.h 헤더에 정의되지 않는 한, 이 상수를 통해 20ms로 설정됩니다. GUIX 라이브러리를 빌드하거나 ***gx_user.h*** 에서 명시적으로 재정의하여 애플리케이션에서 기본 빈도를 변경할 수 있습니다.

> [!IMPORTANT]
> GUIX 타이머 빈도는 RTOS 타이머 틱으로 표현되고 **GX_SYSTEM_TIMER_TICKS** 상수에 의해 정의됩니다. **GX_SYSTEM_TIMER_TICKS** 값은 **GX_SYSTEM_TIMER_MS** 및 **TX_TIMER_TICKS_PER_SECOND** 를 사용하여 계산됩니다. 사용자는 **gx_port.h** _ 또는 _ *_gx_user.h_**에 이러한 값을 다시 정의하여 GUIX 타이머 빈도 및 해상도를 조정할 수 있습니다.

## <a name="display-driver"></a>디스플레이 드라이버 

디스플레이 드라이버는 일련의 그리기 함수를 핵심 GUIX 코드에 제공하는 일을 담당합니다. 이러한 각 그리기 함수의 구현은 드라이버에 의해 결정되며, 가능한 경우 구현에서는 하드웨어 가속 지원이 활용됩니다. 일반적으로 그리기 함수는 드라이버 아키텍처에 따라 물리적 프레임 버퍼이거나 보조 버퍼일 수 있는 메모리 버퍼에 픽셀 데이터를 기록하는 방식으로 작동합니다. 많은 드라이버는 두 개의 프레임 버퍼를 사용하여 이중 버퍼링을 구현하며, 이러한 버퍼는 버퍼 전환 함수를 호출하여 전환됩니다. GUIX는 이러한 함수를 내부적으로 적절한 시간에 호출합니다. 메모리가 제한된 시스템의 경우 그리기 함수는 단일 메모리 프레임 버퍼에만 쓸 수 있습니다.

GUIX는 모든 지원 색 농도와 형식으로 각 하위 수준 그리기 함수의 기본 소프트웨어 구현을 제공합니다. 이러한 함수는 **GX_DISPLAY** 구조체 내에서 유지 관리되는 함수 포인터를 통해 호출됩니다. 하드웨어 관련 드라이버를 만들면 일반적으로 이러한 일부 함수 포인터를 대상 하드웨어와 관련된 함수로 덮어씁니다.

일반적인 하드웨어 디스플레이 드라이버는 필요한 색 농도와 형식에 대한 기본 GUIX 디스플레이 드라이버를 먼저 만들어 구현됩니다.
그러면 하드웨어 드라이버가 특정 하드웨어 구현을 위해 최적화되거나 사용자 지정해야 하는 함수를 대체합니다.

GUIX는 1-bpp 단색에서 32-bpp a:r:g:b 형식 범위의 픽셀 색 형식을 지원합니다. 또한 GUIX는 광범위한 색 깊이 범주 내에서 r:g:b 대 b:g:r 바이트 순서, 압축된 픽셀 대 단어 맞춤 픽셀 형식, 알파 채널과 같은 많은 변형을 지원합니다. 현재 25개의 고유한 색 형식이 지원되지만 하드웨어 공급업체가 새 변형을 제공하게 되면 이 목록이 증가합니다.

## <a name="display-memory-architectures"></a>디스플레이 메모리 아키텍처

다양한 하드웨어 대상과 디스플레이는 대상의 메모리 제약 조건 및 애플리케이션의 기능 요구 사항에 따라 다양한 디스플레이 메모리 아키텍처를 활용합니다. 여기에서는 일반적인 메모리 아키텍처 중 일부에 대해 간략하게 설명합니다.

모델 1) 프레임 버퍼 없음, 외부 GRAM에 그래픽 데이터가 저장되어 있음:

![프레임 버퍼 없음, 외부 GRAM에 그래픽 데이터가 저장되어 있음](./media/guix/user-guide/no-frame-buffer.png)

위의 모델에서 프레임 버퍼에 대한 메모리가 CPU의 로컬 메모리에 존재하지 않습니다. 모든 그래픽 데이터는 디스플레이 자체에 통합되는 외부 GRAM에 저장됩니다. 외부 GRAM에 대한 인터페이스는 병렬 또는 직렬일 수 있습니다. 이 아키텍처 유형은 매우 저렴합니다. 그러나 그래픽 데이터를 업데이트할 때 원치 않는 분열 효과가 나타날 수 있습니다.

모델 2) 하나의 로컬 프레임 버퍼:

![하나의 로컬 프레임 버퍼](./media/guix/user-guide/one-local-frame-buffer.png)

이 모델에서 그래픽 데이터에 대한 메모리는 CPU에 직접 액세스할 수 있는 임의 액세스 메모리에서 할당됩니다. 타이밍 신호에 따라 그래픽 데이터를 로컬 메모리에서 디스플레이로 반복적으로 전송하기 위한 전용 하드웨어가 있어야 합니다. 이 모델은 그래픽 메모리가 CPU에서 사용할 수 있는 로컬 SRAM 또는 DRAM의 블록이라는 측면에서 모델 1과 다릅니다. 스택 및 프로그램 변수가 있는 것과 동일한 메모리일 수 있습니다.

모델 3) 로컬 프레임 버퍼 + 외부 GRAM:

![로컬 프레임 버퍼 + 외부 GRAM](./media/guix/user-guide/local-frame-buffer-external-gram.png)

모델 3은 처음 두 모델을 조합한 것입니다. 이 모델에서는 하나의 프레임 버퍼를 보유할 수 있는 충분한 로컬 메모리가 있습니다. 또한 디스플레이 디바이스는 외부 GRAM을 제공하며, GRAM에 제공된 데이터를 사용하여 자동으로 새로 고쳐집니다. 이 아키텍처는 로컬 프레임 버퍼의 수정된 부분을 한 블록 전송에서 외부 GRAM으로 전송할 수 있으며, 종종 온보드 DMA 채널을 활용하기 때문에 업데이트 효율성이 향상되는 이점을 얻게 됩니다. 이 모델은 완료된 그래픽 콘텐츠만 외부 GRAM으로 복사되기 때문에 처음 두 모델 중 하나에서 나타날 수 있는 분열 및 깜박임이 해소됩니다.

모델 4) 핑퐁 프레임 버퍼:

![핑퐁 프레임 버퍼](./media/guix/user-guide/ping-pong-frame-buffers.png)

모델 4에서는 두 개의 로컬 프레임 버퍼를 제공하기 위한 충분한 메모리가 있습니다. 이 경우 GUIX는 하나의 프레임 버퍼를 활성 프레임 버퍼로 취급하고 다른 프레임 버퍼를 작업 프레임 버퍼로 취급합니다. 디스플레이 업데이트 또는 그리기 작업이 진행 중인 경우 작업 버퍼에서 진행됩니다. 그리기 작업이 완료되면 버퍼가 전환되고 작업 버퍼가 활성 버퍼가 되며 활성 버퍼가 작업 버퍼가 됩니다. 또한 이 모델에서는 버퍼링된 단일 시스템에서 관찰될 수 있는 화면 깜박임 및 분열이 해소됩니다.

모델 5) 캔버스가 합성된 핑퐁 버퍼:

![캔버스가 합성된 핑퐁 버퍼](./media/guix/user-guide/ping-pong-buffers-canvas-composting.png)

모델 5에서는 사용 가능한 메모리 한도까지 여러 캔버스를 만들 수 있습니다. 애플리케이션에서 정의한 대로 캔버스를 겹치거나 혼합하여 캔버스 합성을 만들 수 있습니다. 화면 새로 고침 작업 후 새 합성이 만들어지면 표준 핑퐁 버퍼 아키텍처와 동일한 작업에서 활성 및 작업 합성 버퍼가 전환됩니다. 모델 5에서는 캔버스를 최종 출력 합성으로 혼합하여 화면 페이드 및 혼합 작업을 수행할 수 있는 기능을 추가합니다.

모델 6) 외부 GRAM으로 캔버스 합성:

![외부 GRAM으로 캔버스 합성](./media/guix/user-guide/canvas-compositing-external-gram.png)

모델 6은 모델 5에서 약간 변형된 것으로, 하나의 합성 버퍼만 필요하고 해당 합성 버퍼는 외부 GRAM으로 전송됩니다. 이 모델은 전체 화면 혼합 및 오버레이도 지원합니다.

## <a name="string-encoding"></a>문자열 인코딩 

GUIX는 기본적으로 UTF8 형식 문자열 인코딩을 지원합니다. ***gx_user.h*** 헤더 파일에 **GX_DISABLE_UTF8_SUPPORT** 를 정의하여 UTF8 문자열 인코딩에 대한 지원을 사용하지 않도록 설정할 수 있습니다. UTF8 인코딩이 사용하지 않도록 설정된 경우 GUIX는 내부적으로 표준 8비트 ASCII와 라틴어-1 코드 페이지 문자 인코딩만 사용합니다. UTF8 문자열 인코딩을 사용하지 않도록 설정하면 GUIX 라이브러리 공간은 약간 더 작아지고, 문자열 처리 및 텍스트 그리기 함수의 런타임 실행 속도도 약간 더 빨라집니다.

UTF8 문자열 인코딩에는 다음과 같은 특징이 있습니다.

  - ASCII 문자열은 표준 7비트 ASCII 인코딩보다 더 많은 스토리지 공간을 사용하지 않습니다.

  - 대부분의 ANSI-C 문자열 함수는 수정 없이 UTF8 문자열 인코딩에서 작동합니다.

간지 문자 집합을 포함하여 전 세계의 모든 활성 문자 집합은 UTF8 문자열 인코딩을 사용하여 나타낼 수 있습니다.

### <a name="static-and-dynamic-strings"></a>정적 및 동적 문자열 

텍스트 표시를 지원하는 GUIX 위젯에 할당된 문자열은 일반적으로 아래에 설명된 GUIX 문자열 테이블의 일부로 상수 스토리지에 배치되는 정적으로 정의된 문자열 상수 및 **sprintf** _ 또는 _*_gx_utility_ltoa_**와 같은 서비스를 사용하여 런타임에 생성되는 동적으로 정의된 문자열일 수 있습니다.

동적 문자열의 예에는 GUIX 프롬프트 위젯 내에 숫자로 표시되는 값 또는 사용자의 위치 및 형식 기본 설정에 따라 동적으로 서식이 지정되는 "시간/날짜" 문자열이 포함될 수 있습니다. 런타임에 **GX_PROMPT** 또는 **GX_TEXT_BUTTON 위젯** 과 같은 GUIX 위젯에 할당될 문자열을 만드는 경우 이러한 런타임 생성 문자열(예: 전역 문자 배열)에 대해 스토리지를 정적으로 할당하도록 선택하거나
동적 메모리 할당자 함수를 정의 및 설치하고, 할당된 텍스트 문자열의 프라이빗 사본을 만들도록 해당 위젯에 지시하는 **GX_STYLE_TEXT_COPY** 스타일을 사용할 수 있습니다.

자동 문자 배열과 같은 임시 스토리지를 사용하여 동적으로 생성된 문자열을 저장한 다음, **GX_STYLE_TEXT_COPY** 스타일이 없는 위젯에 이 문자열을 할당하는 것은 프로그래밍 오류입니다. 이 스타일을 사용하도록 설정하지 않으면 위젯은 제공된 문자열 포인터를 복사하고 문자열 데이터를 정적으로 할당해야 합니다. 그러지 않으면 위젯 문자열 포인터가 가비지 데이터를 가리켜 예기치 않은 결과를 생성합니다.

### <a name="passing-gx_string-arguments"></a>GX_STRING 인수 전달 

GX_STRING 매개 변수를 허용하는 GUIX API 함수는 항상 **GX_STRING.gx_string_ptr** 필드로 가리키는 문자열의 길이가 **GX_STRING.gx_string_length** 필드의 값과 일치하도록 합니다. 두 필드가 일치하지 않으면 **GX_INVALID_STRING_LENGTH** 오류가 반환되고, 문자열 할당을 수락하지 않으면서 호출되는 API가 반환됩니다.

안전 고려 사항의 경우 GUIX 소프트웨어는 내부적으로 ***strlen** _ 또는 _ *_strcpy_**와 같은 표준 C 문자열 함수를 사용하지 않습니다. 이러한 함수는 문자열 데이터를 동적으로 가져올 때 악의적인 공격(일반적으로 연결된 애플리케이션에서 주로 발생)에 취약한 것으로 알려져 있습니다.

GUIX 라이브러리 릴리스는 매개 변수로 (`GX_CONST GX_CHAR *text`)를 수락하는 릴리스 5.6에서 정의된 API 함수 이전에 릴리스됩니다. 이전 버전과의 호환성을 위해 계속 지원되는 이러한 함수는 더 이상 사용되지 않으며 (`GX_CONST GX_STRING *string`)을 입력 매개 변수로 수락하는 기본 설정 API 함수로 대체되었습니다.

기본적으로 더 이상 사용되지 않는 텍스트 처리 API를 사용하여 이전에 작성된 모든 애플리케이션을 GUIX 라이브러리에 대한 최신 업데이트로 완전히 빌드할 수 있습니다. 더 이상 사용되지 않는 텍스트 처리 API를 사용하지 않도록 설정하려면 **GX_DISABLE_DEPRECATED_STRING_API** 를 **_gx_user.h_ *_ 헤더 파일에 추가해야 합니다. 모든 새 애플리케이션은 _* GX_DISABLE_DEPRECATED_STRING_API** 를 정의해야 하며 대체 API 함수만 사용해야 합니다. GUIX 라이브러리 버전 릴리스 5.6 이상용 GUIX Studio에서 생성된 모든 출력 파일은 대체 API 함수만 활용합니다.

다음 표에서는 더 이상 사용되지 않고 새로 정의된 대체 API 함수 이름을 나열합니다.

| **더 이상 사용되지 않는 함수 이름**              | **대체 이름**                              |
| ------------------------------------------ | ----------------------------------------------- |
| gx_binres_language_table_load          | gx_binres_language_table_load_ext          |
| gx_canvas_rotated_text_draw            | gx_canvas_rotated_text_draw_ext            |
| gx_canvas_text_draw                     | gx_canvas_text_draw_ext                     |
| gx_context_string_get                   | gx_context_string_get_ext                   |
| gx_display_language_table_get          | gx_display_language_table_get_ext          |
| gx_display_language_table_set          | gx_display_language_table_set_ext          |
| gx_display_string_get                   | gx_display_string_get_ext                   |
| gx_display_string_table_get            | gx_display_string_table_get_ext            |
| gx_multi_line_text_button_text_set   | gx_multi_line_text_button_text_set_ext   |
| gx_multi_line_text_input_char_insert | gx_multi_line_text_input_char_insert_ext |
| gx_multi_line_text_input_text_set    | gx_multi_line_text_input_text_set_ext    |
| gx_multi_line_text_view_text_set     | gx_multi_line_text_view_text_set_ext     |
| gx_prompt_text_get                      | gx_prompt_text_get_ext                      |
| gx_prompt_text_set                      | gx_prompt_text_set_ext                      |
| gx_single_line_text_input_text_set   | gx_single_line_text_input_text_set_ext   |
| gx_system_string_width_get             | gx_system_string_width_get_ext             |
| gx_system_version_string_get           | gx_system_version_string_get_ext           |
| gx_text_button_text_get                | gx_text_button_text_get_ext                |
| gx_text_button_text_set                | gx_text_button_text_set_ext                |
| gx_text_scroll_wheel_callback_set     | gx_text_scroll_wheel_callback_set_ext     |
| gx_utility_string_to_alphamap          | gx_utility_string_to_alphamap_ext          |
| gx_widget_string_get                    | gx_widget_string_get_ext                    |
| gx_widget_text_blend                    | gx_widget_text_blend_ext                    |
| gx_widget_text_draw                     | gx_widget_text_draw_ext                     |

### <a name="guix-string-table"></a>GUIX 문자열 테이블 

GUIX 문자열 테이블 및 문자열 리소스는 GUIX 디스플레이 인스턴스에 등록됩니다.

다중 디스플레이 시스템에 표시되는 각 디스플레이에는 고유한 문자열 테이블이 있으며 각 디스플레이는 선택된 자체 언어로 실행할 수 있습니다. 다른 GUIX 리소스 종류(색, 글꼴 및 pixelmap)는 각 디스플레이 색 형식과 색 깊이에만 국한되므로 GUIX 디스플레이 구성 요소를 통해 유지 관리됩니다.

애플리케이션 문자열 테이블을 수동으로 만들 수 있지만, 대부분의 경우 디스플레이 문자열 테이블은 GUIX Studio 애플리케이션에서 프로젝트 리소스 파일의 일부로 정의됩니다. 사용 가능한 언어는 리소스 헤더 파일에도 정의되어 있습니다. 디스플레이 문자열 테이블은 애플리케이션 문자열에 대한 다중 열 포인터 테이블입니다. 문자열 테이블의 각 열은 애플리케이션에서 지원하는 하나의 언어를 나타냅니다.
애플리케이션에서 하나의 언어(예: 영어)만 지원하는 경우 문자열 테이블에는 열이 하나만 있습니다. 그래도 애플리케이션 소프트웨어를 수정하지 않고 언제든지 다른 언어를 추가적으로 지원할 수 있습니다.

활성 문자열 테이블은 ***gx_display_string_table_set*** API 함수를 호출하여 할당합니다. 이 함수는 GUIX Studio에서 생성한 시작 코드에 의해 자동으로 호출되지만 애플리케이션에서 직접 호출하여 활성 문자열 테이블을 변경할 수도 있습니다.

활성 언어는 ***gx_display_active_language_set*** API 함수를 호출하여 할당됩니다. 이 함수는 디스플레이 문자열 테이블에서 활성 상태인 열을 결정합니다.

이 함수가 호출되면 **GX_EVENT_LANGUAGE_CHANGE** 이벤트가 표시되는 모든 GUIX 위젯으로 전송되어 새로 활성화된 문자열 데이터를 표시하도록 업데이트할 수 있습니다.

위젯 및 애플리케이션 소프트웨어는 문자열 ID 값과 ***gx_display_string_get_ext*** 또는 ***gx_widget_string_get_ext*** API 함수를 사용하여 정적으로 정의된 문자열을 확인합니다. 이러한 함수는 지정된 문자열 ID와 연결된 **GX_STRING** 과 현재 활성화된 언어를 반환합니다.

### <a name="bi-directional-text-display"></a>양방향 텍스트 표시 

GUIX는 양방향 텍스트 지원에 대한 두 가지 전략을 제공합니다.

한 가지 옵션은 GUIX Studio 애플리케이션 내에서 양방향 텍스트 재정렬을 수행하는 것입니다. 이 옵션을 사용하면 GUIX Studio는 디스플레이 순서대로 출력 파일에 양방향 텍스트를 생성합니다. 이 솔루션은 런타임 성능에 영향을 주지 않으며 GUIX 런타임 라이브러리를 추가하지 않아도 됩니다. GUIX Studio에서 displayorder 양방향 텍스트 문자열을 생성하도록 하려면 GUIX Studio 언어 구성 대화 상자에서 **표시 순서로 양방향 텍스트 생성** 확인란을 선택해야 합니다.

![언어 구성](./media/guix/user-guide/configure-languages.png)

이러한 옵션을 선택하면 생성된 리소스 파일에 표시 순서로 생성된 양방향 문자열이 포함되며 GUIX 런타임 라이브러리 내에 추가 처리가 필요하지 않습니다.

두 번째 옵션은 런타임에 양방향 텍스트를 다시 정렬하는 것입니다. 이 옵션은 GUIX Studio 애플리케이션에서 생성되지 않고 동적으로 정의된 양방향 텍스트 문자열을 처리해야 하는 애플리케이션에서 지원됩니다. 이 경우 GUIX 런타임 라이브러리는 각 텍스트 문자열을 그리기 전에 양방향 텍스트를 다시 정렬해야 합니다. 이 솔루션에는 런타임 성능 및 메모리에 영향을 미칩니다. 양방향 텍스트 다시 정렬 프로세스에는 충분한 동적 메모리를 사용할 수 있어야 합니다. 이 솔루션을 사용하려면 GUIX 라이브러리를 빌드할 때 조건부 GX_DYNAMIC_BIDI_TEXT_SUPPORT를 정의해야 합니다. 런타임에 양방향 텍스트 지원을 사용/사용하지 않도록 설정하기 위해 두 개의 API 함수 ***gx_system_bidi_text_enable*** 및 ***gx_system_bidi_text_disable*** 이 제공됩니다.

**GX_DYNAMIC_BIDI_TEXT_SUPPORT** 를 사용하는 작업과 표시 순서대로 양방향 텍스트를 생성하도록 GUIX Studio를 구성하는 작업을 둘 중 하나만 수행해야 합니다. 양방향 텍스트 문자열 처리를 위해 둘 중 한 가지 전략을 선택해야 합니다.

## <a name="memory-usage"></a>메모리 사용량 

GUIX는 애플리케이션과 함께 상주합니다. 그 결과, GUIX의 정적 메모리(또는 고정 메모리) 사용량은 개발 도구(예: 컴파일러, 링커 및 로케이터)에 의해 결정됩니다. 동적 메모리(또는 런타임 메모리) 사용량은 애플리케이션에서 직접 제어합니다.

### <a name="static-memory-usage"></a>정적 메모리 사용량 

대부분의 개발 도구는 애플리케이션 프로그램 이미지를 명령어, 상수, 초기화된 데이터, 초기화되지 않은 데이터, GUIX 스레드 스택이라는 5가지 기본 영역으로 나눕니다.      아래 그림은 이러한 메모리 영역의 가능한 레이아웃을 보여줍니다.

![메모리 레이아웃](./media/guix/user-guide/memory-area-example.png)

이것은 단지 예제일 뿐이라는 것을 이해해야 합니다. 실제 정적 메모리 레이아웃은 프로세서, 개발 도구, 기본 하드웨어 및 애플리케이션 자체에 따라 다릅니다.

명령어 영역에는 프로그램의 모든 프로세서 명령이 포함됩니다. 이 영역은 종종 ROM에 있습니다.

상수 영역에는 GUIX에서 기본 설정과 모든 애플리케이션 리소스(이미지, 문자열, 글꼴 및 색)를 포함하는 다양한 컴파일된 상수가 포함되어 있습니다. 또한 이 영역에는 초기화된 데이터 영역의 "초기 복사본"이 포함됩니다. 컴파일러의 초기화 과정에서 상수 영역의 이 부분은 RAM에 초기화된 전역 데이터를 설정하는 데 사용됩니다. 상수 영역은 일반적으로 가장 크고 명령 영역을 따르며, ROM에 있는 경우가 많습니다.

GUIX pixelmap 및 글꼴에는 일반적으로 많은 양의 상수 데이터 스토리지가 필요합니다. 이러한 대량 정적 데이터 영역은 일반적으로 ROM 또는 FLASH에 저장됩니다.

GUIX 스레드 스택은 다음과 같이 ***gx_system .h*** 파일에서 초기화되지 않은 데이터 영역 내에 전역 변수로 정의됩니다.

```C
_gx_system_thread_stack[GX_THREAD_STACK_SIZE];
```

**GX_THREAD_STACK_SIZE** 는 **_gx_port.h_** 에 정의되어 있지만 ***gx_user.h*** 헤더 파일이나 프로젝트 옵션 또는 명령줄 매개 변수를 통해 이 기호를 정의하여 애플리케이션에서 재정의할 수 있습니다. 스택 크기는 최악의 이벤트 처리 및 중첩된 그리기 호출을 처리할 수 있을 만큼 커야 합니다.

### <a name="dynamic-memory-usage"></a>동적 메모리 사용량 

앞서 언급했듯이 동적 메모리 사용량은 애플리케이션에서 직접 제어합니다. 캔버스 등과 연결된 제어 블록 및 메모리는 대상의 메모리 공간 어디에나 배치할 수 있습니다. 이 기능은 런타임에 다양한 형식의 실제 메모리를 쉽게 활용할 수 있기 때문에 중요합니다.

예를 들어 대상 하드웨어 환경에 빠른 메모리와 느린 메모리가 모두 있다고 가정하겠습니다. 애플리케이션에 그리기를 위한 추가 성능이 필요한 경우에는 최상의 성능을 위해 캔버스 메모리를 고속 메모리 영역에 명시적으로 배치할 수 있습니다.

몇 가지 선택적 GUIX 서비스 및 기능에는 일반적으로 힙이라고 하는 런타임 동적 메모리 할당 메커니즘이 필요합니다. 이러한 서비스와 기능은 모두 선택적이며 많은 GUIX 애플리케이션은 힙을 사용하지 않으며 런타임 메모리 할당 메커니즘을 정의하지 않습니다.

런타임 메모리를 할당해야 하는 서비스를 사용하는 경우 메모리를 동적으로 할당하거나 해제해야 하는 경우 GUIX에서 호출하는 함수를 설치해야 합니다. 이러한 함수를 원하는 대로 구현할 수 있습니다. 이 경우에도 동적 메모리 풀의 위치는 애플리케이션을 통해 제어됩니다. 동적 메모리 할당에 대한 지원을 설치하기 위해 애플리케이션은 프로그램 시작 중에 ***GX_SYSTEM_MEMORY_ALLOCATOR_SET*** API 서비스를 호출하여 메모리 할당 및 메모리 사용 가능 서비스를 정의해야 합니다. 전체 예제는 이 API의 설명서를 참조하세요.

런타임 메모리 할당 및 할당 취소 서비스를 필요로 하는 GUIX 서비스에는 다음이 포함됩니다.

  - 외부 스토리지의 이진 리소스를 GUIX 런타임 환경으로 로드

  - 소프트웨어 런타임 jpeg 이미지 디코더

  - 소프트웨어 런타임 png 이미지 디코더

  - GX_STYLE_TEXT_COPY에서 텍스트 위젯 사용

  - 런타임 pixemap 크기 조정 및 순환 유틸리티 함수
  - 런타임 화면 및 위젯 제어 블록 할당

더 작은 애플리케이션의 경우 GUIX 리소스는 일반적으로 애플리케이션 이미지의 일부로 컴파일되고 정적으로 링크되며, 이진 리소스 설치는 필요하지 않습니다. 이진 리소스를 사용하면 애플리케이션에서 런타임에 플래시 드라이브 또는 URL과 같은 일부 스토리지 위치에서 로드된 리소스(글꼴, 이미지, 언어)를 설치할 수 있습니다.

런타임 jpeg 및 png 디코더는 선택적 구성 요소입니다. 대부분의 GUIX 애플리케이션에서는 GUIX Studio 도구를 사용하여 필요한 모든 이미지 파일을 미리 디코딩하고 독점 GUIX Pixemap 데이터 리소스로 저장할 수 있습니다. 이러한 서비스는 jpeg 및/또는 PNG 이미지를 pixelmap 형식으로 변환해야 하는 애플리케이션이 완전하게 기능하기 위해 제공됩니다.

**GX_STYLE_TEXT_COPY** 를 사용하여 특정 위젯이 동적으로 할당된 텍스트의 전용 복사본을 유지하도록 지정할 수 있습니다. 이 옵션을 사용하려면 사용 전에 메모리 할당 메커니즘을 설치해야 합니다. 텍스트 형식 위젯을 만들 때 이 스타일 플래그를 제공하지 **<span class="underline">않으면</span>** 애플리케이션에서 동적으로 생성되고 할당된 모든 텍스트 문자열에 대해 정적 스토리지 영역을 할당해야 합니다. 이 경우 자동 변수를 사용하여 런타임에 생성된 문자열 데이터를 저장하면 안 됩니다. **GX_STYLE_TEXT_COPY** 스타일이 사용하도록 설정되는 경우 각 위젯은 할당된 텍스트의 고유한 복사본을 만들기 때문에 자동 변수를 사용하여 GUIX 위젯에 할당된 문자열 데이터를 저장할 수 있습니다.

Pixelmap 크기 조정 및 순환 유틸리티 함수는 변환된 결과 Pixelmap을 애플리케이션에서 사용할 수 있는 새로운 Pixelmap으로 반환합니다.
이러한 서비스를 사용하는 경우 이러한 런타임에서 생성된 pixelmap 데이터 블록을 보유할 수 있는 충분한 동적 메모리가 있어야 합니다.

마지막으로 GUIX 스크린과 위젯에 대한 제어 블록은 정적 또는 동적으로 할당될 수 있습니다. 작은 애플리케이션의 경우 프로그램 시작 시 모든 애플리케이션 화면을 만들고 정적으로 할당된 제어 블록을 사용하는 것이 일반적입니다. 더 큰 애플리케이션의 경우에는 필요에 따라 화면 및 자식 위젯 컨트롤을 동적으로 만드는 것이 일반적입니다. 동적으로 할당된 제어 블록은 GUIX Studio 속성 보기에서 **런타임 할당** 확인란을 선택하거나 표준 API를 통해 위젯을 만들 때 스타일 플래그 **GX_STYLE_DYNAMICALLY_ALLOCATED** 를 전달하여 지정합니다. 동적으로 할당된 위젯 제어 블록을 사용하려면 메모리 할당 및 할당 취소 서비스가 위에서 설명한 대로 정의되어 있어야 합니다.

## <a name="guix-components"></a>GUIX 구성 요소 

GUIX API는 GUIX 시스템의 기본 구성 요소에 해당하는 몇 가지 기본 그룹으로 나뉘어 구성되어 있습니다. 기본 구성 요소는 다음과 같습니다.

| 구성 요소  | Description  |
| ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| GX_SYSTEM  | 초기화, 이벤트, 타이머, 문자열 테이블 및 표시되는 위젯 계층 구조 관리를 담당하는 GUIX 시스템 구성 요소입니다.                                                                                                                                                                                                                                                                      |
| GX_CANVAS  | 그리기 영역입니다. 캔버스는 하드웨어 프레임 버퍼의 씬 추상화일 수도 있고 순수한 메모리 캔버스일 수도 있습니다. 캔버스 형식은 gx_canvas_create API 함수에 전달된 매개 변수에 의해 결정됩니다.                                                                                                                                                                                   |
| GX_CONTEXT | 그리기 컨텍스트 구성 요소입니다. 그리기 컨텍스트는 현재 그리기 작업의 화면, 캔버스, 브러시 및 클리핑 영역에 대한 정보를 포함합니다.                                                                                                                                                                                                                                      |
| GX_DISPLAY | 애플리케이션 및 GUIX 위젯이 캔버스에서 그리기를 수행할 수 있도록 하는 API 및 드라이버 수준 구현을 제공합니다. GX_DISPLAY는 캔버스의 필수 색 형식을 사용하여 각 캔버스에 그래픽을 올바르게 렌더링하도록 구현됩니다. GX_DISPLAY 구성 요소는 각 디스플레이에 연결된 캔버스에 대한 위젯 그리기에서 사용할 수 있는 리소스(색, 글꼴 및 pixelmap)도 관리합니다. |
| GX_WIDGET  | 표시되는 기본 위젯 개체 및 관련된 API입니다. 모든 GUIX 위젯 형식은 기본 GX_WIDGET 형식을 기준으로 하거나 이러한 형식에서 파생됩니다.                                                                                                                                                                                                                                                                      |
| GX_UTILITY | 사각형 작업을 위한 유틸리티 함수, 문자열 변환 함수 및 ANSI가 아닌 수학적 함수가 이 그룹에 포함되어 있습니다.                                                                                                                                                                                                                                                         |

이러한 기본 구성 요소 외에도 GUIX에는 라이브러리에 제공되는 각 위젯 형식에 고유한 API가 포함되어 있습니다. 이러한 API는 이 사용자 가이드의 4장 "GUIX 서비스 설명"에 설명되어 있습니다.

## <a name="guix-system-component"></a>GUIX 시스템 구성 요소

GUIX 시스템 구성 요소는 UI 애플리케이션에 전역적인 여러 서비스를 제공합니다. 이러한 서비스에는 *초기화, 이벤트 관리, 디스플레이 관리, 리소스 관리, 타이머 관리* 및 *위젯 관리* 가 포함되어 있습니다. 각 서비스는 애플리케이션을 구성하는 데 필수적이며, 이러한 서비스에 대한 자세한 내용은 다음 하위 섹션을 참조하세요.

### <a name="initialization"></a>초기화 

GUIX 초기화는 ThreadX ***tx_application_define*** 루틴(초기화 컨텍스트) 또는 애플리케이션 스레드에서 애플리케이션에 의해 호출될 수 있는 서비스 ***gx_system_initialize*** 를 호출하는 애플리케이션에서 수행됩니다. ***gx_system_initialize*** 함수는 모든 전역 GUIX 데이터 구조를 초기화하고 GUIX 시스템 뮤텍스, 이벤트 큐, 타이머 및 스레드를 만듭니다. ***gx_system_initialize*** 가 반환되면 애플리케이션은 GUIX를 사용할 수 있습니다.

### <a name="thread-processing"></a>스레드 처리 

초기화 중에 생성된 내부 GUIX 스레드는 GUIX에서 대부분의 처리를 담당합니다. 이 스레드의 처리는 먼저 기본 디스플레이 드라이버에 필요한 추가 초기화를 완료합니다. 이 작업이 완료되면 GUIX 스레드는 먼저 GUIX 이벤트 큐에 있는 모든 이벤트를 처리한 후 필요한 경우 화면을 새로 고치는 루프를 시작합니다. 화면 새로 고침은 표시되며, 더티로 표시된(다시 그려야 함) 내용에 따라 필요한 GUIX 그리기 함수를 실행합니다. 디스플레이에 이벤트가 없고 새로 고칠 항목이 없으면 GUIX 스레드는 일시 중단되고 다음 GUIX 이벤트가 도달할 때까지 대기합니다.

### <a name="rtos-binding"></a>RTOS 바인딩 

GUIX 시스템 구성 요소는 기본적으로 스레드 서비스, 이벤트 큐 서비스 및 타이머 서비스와 같은 서비스에 대해 ThreadX 실시간 운영 체제를 사용하도록 구성됩니다. 전처리기 지시문 GX_DISABLE_THREADX_BINDING을 사용하고 GUIX 라이브러리를 다시 빌드하여 GUIX를 다른 운영 체제로 쉽게 이식할 수 있습니다. 그러면 GUIX 소스 코드에서 ThreadX 종속성이 제거되고 애플리케이션 개발자가 대상 시스템에서 제공하는 RTOS를 사용하여 필요한 운영 체제 서비스를 구현할 수 있습니다. [부록 F - GUIX RTOS 바인딩 서비스](appendix-f.md)는 Threadx 운영 체제 이외의 운영 체제에 GUIX를 이식하도록 구현해야 하는 서비스를 설명합니다.

### <a name="multithread-safety"></a>다중 스레드 보안 

GUIX API는 다른 애플리케이션 스레드뿐만 아니라 GUIX 스레드 컨텍스트에서 사용할 수 있습니다. 애플리케이션 스레드는 공유 변수에 액세스하고 GUIX API 함수를 사용하여 이벤트를 보내고 받는 방법으로 GUIX 스레드와 상호 작용할 수 있습니다. GUIX는 다중 스레드 리소스 보호를 위해 내부 ThreadX 뮤텍스를 사용합니다. 또한 GUIX는 화면 새로 고침 작업이 시작된 후 표시되는 위젯의 내부 구조가 수정되지 않도록 합니다. 그리기 작업이 진행 중인 동안 표시되는 개체의 트리를 수정하는 API가 차단되고, 화면 새로 고침이 완료되면 해제됩니다.

### <a name="system-timers"></a>시스템 타이머 

GUIX는 GUIX 창에 표시되는 데이터의 주기적인 업데이트에 자주 사용되는 주기적인 타이머를 애플리케이션에 제공합니다. 이 작업은 GUIX 시스템 수준 효과(예: 화면 페이드 인/페이드 아웃)를 수행하는 데에도 사용되는 ThreadX 정기 타이머를 통해 수행됩니다.

애플리케이션은 타이머를 만들고 GUIX에서 내부적으로 사용되는 것과 동일한 타이머 기능을 활용할 수 있습니다. 물론, 필요한 경우 애플리케이션은 ThreadX 타이머를 직접 만들고 사용할 수도 있습니다. GUIX 타이머의 장점은 사용하기 쉬우며 GUIX 이벤트 기반 처리 시스템 내에서 작동 하도록 미리 구성되어 있다는 것입니다.

GUIX 타이머를 만들고 시작하려면 애플리케이션이 ***gx_system_timer_start*** 함수를 호출해야 합니다. 이 함수에 대한 매개 변수에는 호출 위젯에 대한 포인터, 타이머 ID(하나의 위젯이 여러 타이머를 시작하도록 허용), 초기 및 다시 예약 시간 제한 값이 포함됩니다. 다시 예약 시간 제한 값이 0이면 타이머가 한 번만 실행되며, 일단 만료되고 나면 활성 타이머 목록에서 자동으로 삭제됩니다.

시작되면 GUIX 타이머는 타이머 다시 예약 값에 따라 한 번 또는 주기적으로 타이머 소유자에게 GX_EVENT_TIMEOUT 이벤트를 전송합니다. API 함수 ***GX_SYSTEM_TIMER_STOP*** 을 호출하여 GUIX 타이머를 중지할 수 있습니다.

### <a name="pen-speed-configuration"></a>펜 속도 구성 

GUIX 시스템 구성 요소는 펜 속도 추적과 관련된 구성 정보를 포함합니다. GUIX는 터치 입력 드라이버(있는 경우)에서 생성되는 PEN_DOWN 이벤트의 속도와 거리에 따라 **GX_EVENT_VERTICAL_FLICK** 및 **GX_EVENT_HORIZONTAL_FLICK** 이벤트를 내부적으로 생성했습니다. 애플리케이션은 **_gx_system_pen_configure_** API 함수를 사용하여 내부적으로 생성된 이러한 이벤트를 트리거하는 데 필요한 최소 거리와 속도를 구성할 수 있습니다.

### <a name="screen-stack"></a>화면 스택 

GUIX 시스템 구성 요소는 GUIX 화면 스택과 관련된 서비스를 제공합니다. 이 스택은 애플리케이션에서 런타임에 화면을 푸시, 팝업 및 검색할 수 있는 가상 위젯 스택을 지원하는 선택적 기능입니다. 화면 스택은 사용자가 메뉴 시스템에서 다양한 상태에 도달할 수 있는 경로가 달라질 수 있는 복잡한 메뉴 시스템을 관리하는 데 유용합니다. 메뉴 시스템에서 이전 상태로 돌아가는 작업은 먼저 이전 화면 상태를 푸시한 다음, 새 화면을 표시하고 현재 화면을 닫을 때 새 화면이 화면 스택에서 이전 상태를 팝업하도록 허용하여 쉽게 수행할 수 있습니다.

### <a name="clipboard-maintenance"></a>클립보드 유지 관리 

GUIX는 런타임 실행 동안 텍스트를 복사하고 붙여 넣기 위한 클립보드를 지원합니다. 이 지원은 GUIX 시스템 구성 요소에서 제공합니다.

### <a name="dirty-list-maintenance"></a>더티 목록 유지 관리 

GUIX는 상태가 변경되거나 새로 표시되기 때문에 다시 그려야 하는 더티 위젯의 목록을 유지 관리합니다. 이 더티 목록은 각 UI가 변경될 때마다 캔버스를 새로 고치지 않고, GUIX에서 한번의 캔버스 새로 고침 작업을 수행하여 모든 현재 변경 내용을 UI 상태에 반영하도록 함으로써 그리기 성능을 향상시킵니다.
이 더티 목록은 GUIX 시스템 구성 요소에서 유지 관리합니다.

### <a name="animation-control-block-pool"></a>애니메이션 제어 블록 풀 

애플리케이션은 종종 동시에 여러 애니메이션 시퀀스를 실행하려고 합니다. GUIX는 애플리케이션에서 할당하고 사용할 수 있는 애니메이션 제어 블록 풀을 유지 관리합니다. 이렇게 하면 애플리케이션에서 이러한 제어 블록을 정적으로 정의하지 않아도 되며, 애플리케이션에서 정의할 수 있는 모든 애니메이션에 대해 고유한 애니메이션 제어 블록을 정의하는 대신, 여러 번 다시 사용할 수 있습니다. 애니메이션 제어 블록 풀도 GUIX 시스템 구성 요소에서 유지 관리합니다.

### <a name="system-error-handling"></a>시스템 오류 처리 

GUIX 시스템 오류 처리기는 애플리케이션이 API 관점에서 확인하기가 더 어려울 수 GUIX의 내부 시스템 오류를 찾는 데 도움을 주기 위해 제공됩니다. GUIX 내부에서 시스템 오류가 발생할 때마다 내부 ***_gx_system_error_process*** 함수가 호출됩니다. 이 함수는 제공된 오류 코드를 저장하고 검색된 시스템 오류의 총 수를 증가시킵니다. 시스템 오류 변수는 다음과 같이 정의됩니다.

UINT **_gx_system_last_error**

ULONG **_gx_system_error_count**

GUIX 애플리케이션이 이상하게 작동하는 경우 디버거의 오류 개수 변수를 확인하는 것이 유용합니다. 설정된 경우 문제를 해결하는 좋은 방법은 ***_gx_system_error_process*** 함수에서 중단점을 설정하고 호출되는 시기/위치를 확인하는 것입니다.

## <a name="guix-canvas-component"></a>GUIX 캔버스 구성 요소

캔버스 구성 요소는 모든 캔버스 관련 처리를 담당합니다. 캔버스는 사실상 가상 프레임 버퍼입니다. 애플리케이션은 그래픽 출력을 생성하기 위해 캔버스를 하나 이상 만들어야 합니다.
일반적으로 시스템에서 지원하는 각 물리적 디스플레이에 대해 캔버스를 하나 이상 만듭니다.

모든 GUIX 그리기는 캔버스에서 발생합니다. 좀 더 단순하거나 메모리가 제한되는 시스템의 경우 표시되는 프레임 버퍼에 직접 연결될 수 있는 캔버스는 하나 뿐이지만, 더 많은 메모리와 고급 그래픽 요구 사항이 있는 시스템에는 여러 캔버스가 필요할 수 있습니다. 한 디스플레이에 여러 개의 캔버스를 사용할 수 있도록 설정하면 화면 및 창 페이드 인 및 페이드 아웃 효과와 같은 기능을 사용할 수 있습니다.
캔버스는 단순형 또는 관리형의 두 가지 주요 유형 중 하나일 수 있습니다.

단순형 캔버스는 애플리케이션에서 사용하는 화면 밖 그리기 영역입니다.
GUIX는 단순형 캔버스에서는 직접 아무 작업도 수행하지 않지만 애플리케이션은 단순형 캔버스를 사용하여 복잡한 그리기를 화면 밖 버퍼로 렌더링한 다음, 필요할 때 이 화면 밖 버퍼를 사용하여 표시되는 캔버스를 새로 고칠 수 있습니다.

관리형 캔버스는 GUIX에 의해 하드웨어 프레임 버퍼 내에 자동으로 표시됩니다. 관리형 캔버스는 여러 개의 관리형 캔버스를 지원하기에 충분한 메모리가 있는 시스템을 위한 복합 캔버스를 빌드하기 위해 포함되었습니다. 관리형 캔버스에는 GUIX에서 유지되는 Z 순서가 적용되며 모든 관리형 캔버스에는 뷰 클리핑이 적용됩니다.

캔버스는 좀 더 일반적이라는 측면에서 프레임 버퍼와 다릅니다. 메모리 제한 시스템에서 캔버스는 하나만 있을 수 있으며 이 캔버스의 메모리는 표시되는 프레임 버퍼 메모리일 수 있습니다. 그러나 고급 그래픽 오버레이 및 여러 캔버스를 지원하는 보다 복잡한 시스템의 경우 관리형 캔버스에는 하드웨어 프레임 버퍼 메모리와 구분되는 자체 메모리 영역이 할당됩니다.
이러한 관리형 캔버스는 프레임 버퍼를 새로 고치거나 전환 작업을 수행하는 동안 표시되는 프레임 버퍼로 렌더링됩니다.

여러 그래픽 계층(예: 겹치는 여러 프레임 버퍼)을 지원하는 하드웨어의 경우 애플리케이션은 ***gx_canvas_hardware_layer_bind*** API를 사용하여 하나 이상의 캔버스를 하드웨어 그래픽 계층에 바인딩할 수 있습니다. 이 서비스는 캔버스에 특정 하드웨어 그래픽 계층에 연결되어 있음을 알리고, 연결되면 이 캔버스는 캔버스 표시 여부(즉, gx_canvas_show, gx_canvas_hide), 캔버스 알파 혼합(즉, ***gx_canvas_alpha_set***) 및 디스플레이 내의 캔버스 오프셋(***gx_canvas_offset_set***)에 대한 하드웨어 지원을 활용하려고 합니다.

가장 간단한 단일 캔버스/단일 프레임 버퍼 조직 이외의 아키텍처에서 캔버스 크기는 애플리케이션에서 결정되며 프레임 버퍼의 고정 크기와 다를 수 있습니다.
애플리케이션에서 선택한 오프셋이 될 수도 있습니다. Z 순서와 같은 기타 정보는 캔버스 내에서 유지 관리됩니다. 캔버스 그리기가 완료되면 캔버스의 내용이 디스플레이 드라이버에 의해 물리적 디스플레이로 전송됩니다. 별도 캔버스 및 프레임 버퍼 메모리 영역에 충분한 메모리가 없는 일부 시스템에서 캔버스 업데이트는 실제로 디스플레이 드라이버를 통해 물리적 디스플레이로 직접 수행됩니다.

### <a name="canvas-creation"></a>캔버스 만들기 

캔버스 개체는 초기화 동안 또는 애플리케이션 스레드를 실행하는 동안 언제든지 만들 수 있습니다. 애플리케이션에서 만들 수 있는 스레드 수에는 제한이 없습니다. 그러나 대부분의 애플리케이션은 모든 GUIX 그리기에 대해 캔버스 개체를 하나만 만듭니다.

### <a name="canvas-control-block"></a>캔버스 제어 블록 

각 캔버스 개체의 특성은 제어 블록 **GX_CANVAS** 에서 찾을 수 있으며 **_gx_api.h_** 에 정의됩니다. 캔버스 개체에 필요한 메모리는 애플리케이션에서 제공하며 메모리의 어느 위치에나 있을 수 있습니다. 그러나 캔버스 개체 제어 블록과 그리기 영역을 함수 범위 외부에서 정의하여 전역 구조체로 만드는 것이 가장 일반적입니다.

### <a name="canvas-alpha-channel"></a>캔버스 알파 채널

GUIX는 픽셀당 혼합 비율을 지정하는 비트맵 알파 채널, 16bpp 이상 색 깊이에서 브러시의 혼합 비율을 지정하는 브러시 알파, 오버레이 캔버스의 혼합 비율을 지정하는 캔버스 알파를 비롯한 여러 수준에서 전경색과 배경색의 알파 혼합을 지원합니다.

캔버스의 알파 값은 프레임 버퍼 내에 표시하기 위해 함께 합성되는 여러 캔버스가 있는 경우에 사용됩니다. 캔버스가 다른 캔버스 위에 오도록 캔버스 Z 순서를 지정하는 경우 캔버스 알파 값을 설정하여 해당 캔버스와 뒤에 놓인 캔버스를 혼합할 수 있습니다. 캔버스의 알파 값을 빠르게 수정하면 "페이드 인" 화면 전환 효과를 제공할 수 있지만 캔버스 알파는 여러 가지 방법으로 사용할 수 있습니다.

gx_canvas_hardware_layer_bind()를 사용하여 캔버스를 하드웨어 그래픽 계층에 바인딩하면 GUIX는 하드웨어 지원을 활용하여 캔버스 알파 혼합을 구현함으로써 오버레이 캔버스 혼합과 관련된 소프트웨어 오버헤드를 최소화합니다.

알파 값의 범위는 0에서 255까지입니다. 여기서 값 0은 픽셀이 완전히 투명한 것을 의미하고 0보다 큰 값은 덜 투명한 캔버스를 늘립니다. 알파 값은 캔버스 혼합에 대한 하드웨어 지원이 제공되지 않을 경우 16bpp 이상에서 실행되는 화면 드라이버에 대해서만 지원될 수 있습니다.

### <a name="canvas-offset"></a>캔버스 오프셋 

***Gx_canvas_offset_set*** API 서비스를 호출하여 표시되는 프레임 버퍼 내에서 캔버스를 오프셋할 수 있습니다. 캔버스 오프셋은 일반적으로 스프라이트 애니메이션을 구현하는 데 사용됩니다. ***gx_canvas_hardware_layer_bind*** API 함수를 호출하여 캔버스를 하드웨어 그래픽 레이어에 바인딩하면 GUIX는 하드웨어 지원을 활용하여 캔버스 오프셋 변경을 구현하려고 시도함으로써 캔버스 위치 이동과 관련된 소프트웨어 오버헤드를 최소화합니다.

### <a name="canvas-drawing"></a>캔버스 그리기 

GUIX 캔버스 구성 요소는 애플리케이션에 완전한 그리기 API를 제공합니다. ***gx_canvas_line_draw*** 또는 ***gx_canvas_pixelmap_draw*** 같은 그리기 API를 호출하려면 먼저 ***gx_canvas_drawing_initiate*** API 함수를 호출하여 그리기를 위한 대상 캔버스를 열어야 합니다. 이 함수는 그리기를 위해 캔버스를 준비하고 ***그리기 컨텍스트*** 를 만듭니다.

***gx_canvas_line_draw** _ 또는 _*_gx_canvas_text_draw_*_ 와 같이 캔버스로 렌더링되는 그리기 API는 현재 그리기 컨텍스트 브러시에 있는 매개 변수를 사용하여 선 스타일, 두께 및 색을 정의합니다. 이러한 브러시 매개 변수는 _*_gx_canvas_drawing_initiate_**를 호출하여 그리기 컨텍스트를 설정한 후에 _*_gx_context_brush_define_*_, _*_gx_context_brush_set_**, ***gx_context_brush_style_set**_ 및 유사한 API 함수를 호출하여 수정됩니다.

GUIX가 지연된 캔버스 새로 고침 작업의 일부로 창 및 위젯 그리기 함수를 호출하는 경우 위젯 그리기 함수 호출 전에 그리기 위해 대상 캔버스를 엽니다. 따라서 대상 캔버스를 여는 데는 표준 위젯 그리기 함수가 필요하지 않습니다. 이 작업은 이미 수행되었기 때문입니다.

경우에 따라 애플리케이션에서 캔버스에 즉시 그리기를 강제로 적용할 수 있습니다. 이 경우 애플리케이션은 다음 단계를 수행할 수 있습니다.

1. ***gx_canvas_drawing_initiate*** API 함수를 호출하여 대상 캔버스와 애플리케이션이 그리려는 캔버스 내의 사각형을 전달합니다. 

2. 원하는 그리기를 수행하기 위해 캔버스 그리기 API를 제한없이 호출할 수 있습니다.

3. ***gx_canvas_drawing_complete*** API 함수를 호출하여 그리기가 완료되었음을 알립니다. 이렇게 하면 시스템 메모리 아키텍처에 따라, 캔버스가 표시되는 프레임 버퍼로 플러시되거나 버퍼 전환 작업이 트리거됩니다.

### <a name="drawing-apis"></a>그리기 API 

GUIX에서 화면에 모든 시각적 요소를 그리기 위해 몇 가지 주요 그리기 기본 형식이 필요합니다. 이러한 그리기 API를 일반적으로 사용자 지정 위젯 그리기 함수의 일부로 애플리케이션 소프트웨어에서 호출할 수도 있습니다. 이러한 GUIX 캔버스 그리기 API는 매개 변수 유효성 검사 및 클리핑을 수행한 다음, 잘린 그리기 좌표를 하드웨어 및 색 형식의 특정 그리기 구현을 위해 디스플레이 드라이버에 전달합니다. 이러한 그리기 API 함수는 다음과 같이 정의됩니다.

- gx_canvas_alpha_set
- gx_canvas_arc_draw
- gx_canvas_block_move
- gx_canvas_circle_draw
- gx_canvas_ellipse_draw
- gx_canvas_glyphs_draw
- gx_canvas_hardware_layer_bind
- gx_canvas_hide
- gx_canvas_line_draw
- gx_canvas_offset_set
- gx_canvas_pie_draw
- gx_canvas_pixel_draw
- gx_canvas_pixelmap_blend
- gx_canvas_pixelmap_rotate
- gx_canvas_pixelmap_tile
- gx_canvas_polygon_draw
- gx_canvas_rectangle_draw
- gx_canvas_rotated_text_draw
- gx_canvas_shift
- gx_canvas_show
- gx_canvas_text_draw

그리기 API는 GUIX 캔버스 API를 통해 호출되며 모든 그리기는 gx_canvas_* API 함수를 사용하여 수행됩니다. 그리기는 현재 그리기 컨텍스트에서 현재 브러시를 사용하여 수행됩니다. 위의 셰이프 그리기 함수는 현재 브러시에서 정의한 대로 윤곽선으로 표시하거나, 단색으로 채우거나, pixelmap으로 채울 수 있습니다. 셰이프 윤곽선 너비, 색 또는 채우기를 수정하려면 gx_context_brush_* API 함수를 사용하여 현재 그리기 컨텍스트 내의 브러시를 정의합니다.

위의 애플리케이션 수준 그리기 API는 캔버스에 실제 그리기를 수행하지 않고, 디스플레이 드라이버 수준 그리기 함수를 호출하기 전에 호출자의 매개 변수를 확인합니다. 드라이버 수준 그리기 함수는 실제로 캔버스 메모리에 픽셀 데이터를 씁니다.

GUIX는 픽셀당 1, 2, 4, 8, 16, 24 및 32비트(bpp)를 비롯한 다양한 색 깊이에 대해 스톡 또는 제네릭 디스플레이 드라이버 그리기 함수를 제공합니다. 경우에 따라 기본 소프트웨어 그리기 구현이 2D 그리기 가속기를 제공하는 하드웨어 대상을 위해 하드웨어 가속 구현으로 대체됩니다.

### <a name="color-depth"></a>색 농도 

GUIX은 색 농도를 최대 32bpp, 단색 및 회색조까지 지원합니다. 이것은 주로 기본 물리적 디스플레이의 용량에 의해 결정되는 색 농도 유형으로, 캔버스 그리기 영역에 필요한 메모리 양에도 영향을 줍니다. 다음은 지원되는 색 농도와 색 농도 내의 변형에 대한 간략한 설명 목록입니다.

| 색&nbsp;형식       | Description                                                                                                   |
| ------------------ | -------------------------------------------------------------------------------------------------------------------------------- |
| 1비트 단색   | 픽셀당 1비트 압축 형식입니다.                                                                                                   |
| 2비트 회색조    | 바이트당 4개 픽셀로 압축된 4개의 회색 수준입니다.                                                                                      |
| 4비트 회색조    | 바이트당 2개 픽셀로 압축된 16개의 회색 수준입니다.                                                                                      |
| 4비트 색        | VGA 형식의 평면 메모리 구성입니다.                                                                                         |
| 8비트 회색조    | 256 회색 수준                                                                                                                  |
| 8비트 색상표 모드 | 픽셀당 1바이트가 색상표 인덱스로 사용                                                                                           |
| 8비트 r:g:b 모드   | 덜 일반적으로 사용되는 2:3:2 r:g:b 형식입니다.                                                                                         |
| 16비트             | 각 픽셀에는 2바이트가 필요합니다. r:g:b 또는 b:g:r 바이트 순서일 수 있습니다. 일반적으로 5:6:5 구조체이지만 5:5:5 구조체 또는 4:4:4:4 a:r:g:b 구조체일 수도 있습니다. |
| 24비트             | 각 픽셀에는 3바이트(압축 형식) 또는 4바이트(압축 해제 형식)가 필요합니다. 하드웨어에 필요한 r:g:b 또는 b:g:r 바이트 순서일 수 있습니다. |
| 32비트             | 각 픽셀에는 알파 채널에 4바이트가 필요합니다. a:r:g:b 또는 b:g:r:a 바이트 순서일 수 있으며 하드웨어에 의해 결정됩니다.              |

### <a name="mouse-support"></a>마우스 지원 

GUIX는 원하는 캔버스에서의 마우스 커서 그리기를 지원합니다. 마우스 커서는 소프트웨어에서 그리거나 하드웨어 커서 오버레이를 통해 지원될 수 있습니다. 두 경우 모두, 마우스 커서 지원과 관련된 애플리케이션에 제공되는 API가 소프트웨어 마우스 커서 그리기와 하드웨어 마우스 커서 그리기 둘 다에서 동일합니다.

GUIX 마우스 지원은 `#define GX_MOUSE_SUPPORT`가 GUIX 라이브러리를 빌드하기 전에 gx_user.h 헤더 파일에 정의되어 있는 경우에만 사용할 수 있습니다.

애플리케이션은 ***gx_canvas_mouse_define*** API 함수를 사용하여 마우스 커서 및 핫스팟을 정의해야 합니다. 이 API는 커서 이미지를 그려야 하는 캔버스에 대한 포인터와 왼쪽 위 모서리 이미지를 기준으로 마우스 커서 이미지와 마우스 이미지의 핫스팟을 정의하는 **GX_MOUSE_CURSOR_INFO** 구조체에 대한 포인터를 받습니다.

## <a name="guix-display-component"></a>GUIX 디스플레이 구성 요소 

디스플레이 구성 요소는 하나 이상의 캔버스, 위젯 및 창을 포함하는 모든 디스플레이 개체의 처리를 관리하기 때문에 GUIX의 기본 구성 요소입니다. 또한 디스플레이 구성 요소는 일련의 함수 포인터를 통해 각 디스플레이와 연결된 기본 하드웨어 화면 드라이버와 상호 작용합니다.

### <a name="display-creation"></a>디스플레이 만들기 

디스플레이 개체는 초기화 동안 또는 애플리케이션 스레드를 실행하는 동안 언제든지 만들 수 있습니다. 일반적으로 애플리케이션은 각 물리적 화면을 관리하는 하나의 디스플레이 개체를 만듭니다. GUIX Studio를 사용하여 애플리케이션을 정의했으며 물리적 디스플레이를 사용할 수 있는 경우 gx_studio_display_configure API 함수를 사용하여 각 디스플레이를 만들고 초기화합니다.

### <a name="display-control-block"></a>디스플레이 제어 블록 

각 디스플레이 개체의 특성은 해당 제어 블록 ***GX_DISPLAY** 에서 찾을 수 있으며 *_gx_api_**에 정의됩니다. 디스플레이 개체에 필요한 메모리는 애플리케이션에서 제공하며 메모리의 어느 위치에나 있을 수 있습니다. 그러나 함수 범위 외부에서 정의하여 디스플레이 제어 블록이 전역 구조를 차단하도록 하는 것이 가장 일반적입니다.

### <a name="resource-management"></a>리소스 관리 

리소스는 애플리케이션에 필요한 UI 구성 요소이지만 애플리케이션 코드가 아닙니다. 리소스는 애플리케이션 데이터이며 일반적으로 정적으로 정의됩니다. 리소스 종류에는 pixelmap, 글꼴, 색 및 문자열이 포함됩니다. 이러한 리소스는 일반적으로 애플리케이션 소프트웨어를 변경하지 않고 언제든지 변경할 수 있습니다. 애플리케이션 소프트웨어를 변경하게 되면 소프트웨어를 다시 테스트하고 확인하는 과정이 필요하게 되므로 애플리케이션 코드를 변경할 필요가 없도록 리소스의 스토리지와 참조를 애플리케이션 소프트웨어와 분리하는 것이 중요합니다.

GUIX ***디스플레이*** 모듈은 디스플레이의 색 농도와 형식에 따라 달라지는 모든 리소스에 대한 리소스 관리 기능을 제공합니다. 이러한 기능에는 활성 pixelmap 테이블, 활성 글꼴 테이블 및 활성 색상표를 유지 관리하는 작업이 포함됩니다. 일반적으로 문자열 리소스는 색 농도 및 형식에 따라 변경할 필요가 없으므로 GUIX 시스템 모듈에서 이러한 문자열 테이블 리소스를 유지 관리합니다.

애플리케이션 소프트웨어는 리소스 테이블의 인덱스에 해당하는 리소스 ID를 기준으로 리소스를 참조합니다. 이렇게 하면 테이블이 변경될 수 있습니다. 예를 들어, 제품이 "주간 모드"에서 "야간 모드"로 변경될 경우 색 테이블은 변경될 수 있지만 색 ID 값은 동일하게 유지됩니다.

애플리케이션 리소스는 GUIX Studio 애플리케이션에서 리소스 파일(또는 리소스 파일 세트)에 기록됩니다. 기본 색, pixelmap 및 글꼴은 새 GUIX Studio 프로젝트를 만들 때 자동으로 제공되지만 이러한 기본값은 애플리케이션의 모양과 느낌을 정의하면서 쉽게 바뀝니다.

색, 글꼴 및 pixelmap에 대한 리소스 ID는 활성 디스플레이 구성 요소가 알려질 때까지 실제 색, 글꼴 또는 pixelmap 값으로 확인할 수 없다는 점에 유의해야 합니다. GUIX 아키텍처는 여러 활성 디스플레이를 지원하므로 위젯 및 관련된 리소스 ID를 특정 디스플레이로 확인할 수 있는 경우에만 리소스 ID를 리소스 값으로 확인할 수 있습니다. 이 속성을 동적 바인딩이라고 합니다. 텍스트 색과 같은 속성의 리소스 ID(예: 리소스 ID **GX_COLOR_ID_TEXT**)는 한 디스플레이에서는 흰색을 나타내는 16비트 R:G:B 값으로 확인될 수 있지만, 다른 디스플레이에서는 단색 검정 색 값으로 확인될 수 있습니다.

실제로 리소스 값에 리소스 ID를 동적으로 바인딩하는 것은 애플리케이션 소프트웨어 및 GUIX 내부 구성 요소가 활성 그리기 컨텍스트 내에서 리소스 ID를 리소스 값으로만 확인해야 함을 의미합니다. 활성 그리기 컨텍스트는 GUIX가 각 리소스 ID를 특정 리소스 값으로 확인할 수 있도록 현재 활성 디스플레이를 지정합니다. 애플리케이션 소프트웨어가 그리기 컨텍스트 외부에서 특정 리소스 값을 찾아야 하는 경우 표시되는 위젯에 대해서도 이 작업을 수행할 수 있습니다. 표시되는 위젯은 루트 창에 연결되어 해당 위젯에 대한 활성 캔버스 및 디스플레이를 확인하는 데도 사용될 수 있습니다.

위젯이 만들어졌지만 아직 표시되지 않은 경우(즉, 루트 창이나 기타 표시되는 부모 항목에 연결되지 않은 경우) 해당 위젯에 연결된 리소스 ID는 특정 디스플레이에 할당된 리소스 테이블에 직접 인덱싱되는 경우가 아니면 특정 리소스 값으로 확인될 수 없습니다. 애플리케이션 소프트웨어에서 특정 리소스 테이블에 직접 액세스하는 것은 안전할 수 있지만 내부 GUIX 라이브러리 소프트웨어에서는 절대 액세스하면 안 됩니다.

### <a name="widget-defaults"></a>위젯 기본값 

또한 GUIX 디스플레이 구성 요소는 다양한 위젯 특성에 대한 기본 정의를 제공합니다. 애플리케이션에서 다르게 지정되지 않은 경우 이러한 시스템 특성을 사용하여 위젯/창을 만듭니다. 이러한 시스템 특성은 주로 시스템 리소스 테이블에서 유지 관리되는 글꼴, 색 및 비트맵으로 구성됩니다. 기본 스크롤 막대 모양에 대한 추가 특성도 GUIX 디스플레이 구성 요소에서 유지 관리합니다.

기본 색 설정은 각 디스플레이에 할당된 색 테이블 및 미리 정의된 기본 색 ID로 정의됩니다. 이러한 기본 색 ID는 다음과 같습니다.

| 색 ID | Description |
| ------------------ | -------------------------------------------------------------------------------------------------------------------------------- |
| GX_COLOR_ID_CANVAS | 기본 캔버스(예: 표시 배경) 색 |
| GX_COLOR_ID_WIDGET_FILL | 기본 위젯 채우기 색 |
| GX_COLOR_ID_WINDOW_FILL | 기본 창 채우기 색 |
| GX_COLOR_ID_DISABLED_FILL | 사용하지 않도록 설정된 기본 위젯 채우기 색 |
| GX_COLOR_ID_DEFAULT_BORDER | 기본 위젯 테두리 색 |
| GX_COLOR_ID_WINDOW_BORDER | 기본 창 테두리 색 |
| GX_COLOR_ID_TEXT | 기본 텍스트 색 |
| GX_COLOR_ID_SELECTED_TEXT | 선택한 기본 텍스트 색 |
| GX_COLOR_ID_DISABLED_TEXT | 사용하지 않도록 설정된 기본 색 |
| GX_COLOR_ID_SELECTED_TEXT_FILL | 선택한 기본 텍스트 채우기 색 |
| GX_COLOR_ID_READONLY_TEXT | 기본 읽기 전용 텍스트 색 |
| GX_COLOR_ID_READONLY_FILL | 기본 읽기 전용 텍스트 채우기 색 |
| GX_COLOR_ID_SCROLL_FILL |    스크롤 막대 채우기 색 |
| GX_COLOR_ID_SCROLL_BUTTON | 스크롤 막대 단추 채우기 색 |
| GX_COLOR_ID_SHADOW | 기본 그림자 색 |
| GX_COLOR_ID_SHINE | 기본 강조 색 |
| GX_COLOR_ID_BUTTON_BORDER | 단추 위젯 테두리 색 |
| GX_COLOR_ID_BUTTON_UPPER | 단추 위젯 위쪽 채우기 색 |
| GX_COLOR_ID_BUTTON_LOWER | 단추 위젯 아래쪽 채우기 색 |
| GX_COLOR_ID_BUTTON_TEXT | 단추 위젯 텍스트 색 |
| GX_COLOR_ID_TEXT_INPUT_TEXT | 텍스트 입력 위젯 텍스트 색 |
| GX_COLOR_ID_TEXT_INPUT_FILL | 텍스트 입력 채우기 색 |
| GX_COLOR_ID_SLIDER_TICK | 슬라이더 눈금 표시를 그리는 데 사용되는 색 |
| GX_COLOR_ID_SLIDER_GROOVE_BOTTOM | 슬라이더 홈 양각을 그리는 데 사용되는 색 |
| GX_COLOR_ID_SLIDER_NEEDLE_OUTLINE | 니들 윤곽선을 그리는 데 사용되는 색 |
| GX_COLOR_ID_SLIDER_NEEDLE_FILL | 슬라이더 니들을 채우는 데 사용되는 색 |
| GX_COLOR_ID_SLIDER_NEEDLE_LINE1 | 니들 강조 표시를 그리는 데 사용되는 색 |
| GX_COLOR_ID_SLIDER_NEEDLE_LINE2 | 니들 그림자를 그리는 데 사용되는 색입니다. |

이러한 색 ID 값은 각 디스플레이에 할당된 색상표로 정의된 특정 색 값에 매핑됩니다. 이러한 기본값을 ***gx_display_color_table_set*** API 함수를 호출하여 단일 디스플레이 그룹으로 변경할 수 있습니다. GUIX Studio를 사용하는 경우 애플리케이션에서 ***gx_studio_display_configure*** 함수를 호출하면 디스플레이 색상표가 자동으로 초기화됩니다.

GUIX 디스플레이 구성 요소는 기본 글꼴 테이블도 유지 관리합니다. 기본 글꼴 테이블은 애플리케이션에서 특별히 지정하지 않은 경우 각 위젯 유형에 사용되는 글꼴을 정의합니다. 미리 정의된 디스플레이 글꼴 테이블 ID는 다음 값을 포함합니다.

| 글꼴&nbsp;ID | Description |
| ------------------ | --------------------------------------------------------------------------------------------------------------------------------|
| GX_FONT_ID_DEFAULT | 특정 글꼴을 정의하지 않을 때 사용되는 기본 글꼴 |
| GX_FONT_ID_BUTTON | 단추의 모든 텍스트에 사용되는 기본 글꼴 |
| GX_FONT_ID_TEXT_INPUT | 텍스트 편집 필드에 사용되는 기본 글꼴 |

텍스트 형식 위젯에 사용되는 글꼴 ID는 각 텍스트 관련 위젯 유형에 대해 제공되는 **gx_<widget_type>_font_set** API를 사용하여 다시 할당할 수 있습니다. **gx_display_font_table_set** API 함수를 호출하여 전체 글꼴 테이블을 다시 할당할 수 있습니다.

### <a name="scrollbar-appearance"></a>스크롤 막대 모양 

GUIX 디스플레이는 해당 디스플레이에 대한 기본 스크롤 막대 모양 설정도 유지 관리합니다. 이러한 설정은 아래에 정의된 **GX_SCROLLBAR_APPEARANCE** 구조로 정의됩니다. GUIX 디스플레이는 세로 스크롤 막대에 대한 하나의 스크롤 막대 모양 구조와 가로 스크롤 막대에 대한 두 번째 구조를 유지합니다. 애플리케이션은 **GX_SCROLLBAR_APPEARANCE** 구조체를 초기화하고 API 함수 ***gx_display_scroll_appearance_set*** 을 호출하여 디스플레이에 대한 기본 스크롤 막대 모양을 수정할 수 있습니다.

```c
typedef struct GX_SCROLLBAR_APPEARANCE_STRUCT
{
    GX_VALUE       gx_scroll_width;
    GX_VALUE       gx_scroll_thumb_width;
    GX_VALUE       gx_scroll_thumb_travel_min;
    GX_VALUE       gx_scroll_thumb_travel_max;
    GX_UBYTE       gx_scroll_thumb_border_style;
    GX_RESOURCE_ID gx_scroll_fill_pixelmap;
    GX_RESOURCE_ID gx_scroll_thumb_pixelmap;
    GX_RESOURCE_ID gx_scroll_up_pixelmap;
    GX_RESOURCE_ID gx_scroll_down_pixelmap;
    GX_RESOURCE_ID gx_scroll_thumb_color;
    GX_RESOURCE_ID gx_scroll_thumb_border_color;
    GX_RESOURCE_ID gx_scroll_button_color;
} GX_SCROLLBAR_APPEARANCE;
```
| GX_SCROLLBAR_APPEARANCE 구조체 멤버 | Description |
| --- | --- |
| gx_scroll_width | 세로 스크롤 막대의 너비 또는 가로 스크롤 막대의 높이(픽셀)입니다. |
| gx_scroll_thumb_width | 엘리베이터 및 끝 단추의 너비(픽셀)입니다. |
| gx_scroll_thumb_travel_max | 스크롤 막대의 끝에서 최대 엄지 단추 이동 지점까지의 오프셋입니다. |
| gx_scroll_fill_pixelmap | 스크롤 배경을 채우는 데 사용되는 Pixelmap입니다. |
| gx_scroll_thumb_pixelmap | 스크롤 엄지 단추를 그리는 데 사용되는 Pixelmap입니다. |
| gx_scroll_up_pixelmap | 위로 스크롤 단추를 그리는 데 사용되는 Pixelmap입니다. |
| gx_scroll_down_pixelmap | 아래로 스크롤 단추를 그리는 데 사용되는 Pixelmap입니다. |
| gx_scroll_fill_color | 스크롤 막대 배경을 채우는 데 사용되는 색의 색 ID입니다. |
| gx_scroll_button_color | 스크롤 막대 엄지 단추를 채우는 데 사용되는 색의 색 ID입니다. |

글꼴, 색 및 스타일에 대한 이러한 기본 설정 외에도 애플리케이션은 각 위젯 형식에서 제공하는 API를 사용하여 필요에 따라 사례별로 매개 변수를 지정할 수 있습니다.

### <a name="skinning-and-themes"></a>스키닝 및 테마

스키닝을 사용하면 GUIX 위젯 및 창이 기본 모양을 쉽게 변경할 수 있습니다. 즉, 한 곳에서 "스킨"을 변경하면 연결된 모든 위젯 및 창의 기본 모양이 변경됩니다.

GUIX 애플리케이션을 다시 스키닝하려면 GUIX 디스플레이 리소스 테이블에 새 색, 글꼴 및/또는 pixelmap 테이블을 제공해야 합니다. 모든 GUIX 위젯은 해당 색, 비트맵 또는 글꼴을 리소스 ID로 참조하므로 새 리소스 테이블을 제공하면 원하는 디스플레이에 자체적으로 그려질 때 모든 GUIX 위젯이 자동으로 새 색 및 pixelmap을 사용하기 시작합니다.

멋진 모양을 제공하기 위해 함께 작동하도록 디자인된 새로운 글꼴, 색 및 pixelmap 세트를 *테마* 라고 합니다. 테마는 리소스 테이블 세트와 각 리소스 테이블의 크기를 정의합니다. GUIX Studio 애플리케이션을 사용하여 모든 디스플레이에 대해 제한 없는 수의 테마를 정의할 수 있습니다. 시작 테마 인덱스를 GUIX Studio 생성 함수 ***gx_studio_display_configure*** 에 전달해야 합니다. 이 함수는 만든 디스플레이에 초기 테마를 설치합니다. 모든 디스플레이의 활성 테마는 ***gx_display_theme_install*** 함수를 호출하여 언제든지 변경할 수 있습니다.

### <a name="root-window"></a>루트 창

애플리케이션에서 만든 표시되는 각 캔버스에 대해 애플리케이션은 해당 캔버스에 대해 루트 창도 하나 만들어야 합니다. 이 특수 창은 기본적으로 모든 최상위 애플리케이션 창 및 위젯의 컨테이너 역할을 합니다. 루트 창은 캔버스 배경을 그리며, **GX_WINDOW** 클래스에서 파생되므로 배경 무늬가 있을 수 있습니다. 디스플레이 또는 캔버스의 배경색을 변경하려면 해당 캔버스에 연결된 루트 창의 채우기 색을 변경하기만 하면 됩니다.

***gx_studio_display_configure*** 라는 GUIX Studio 생성 함수를 사용하여 디스플레이를 구성하는 경우 각 디스플레이의 캔버스 및 루트 창이 이 초기화 함수의 일부로 생성됩니다.

### <a name="anti-aliasing"></a>앤티앨리어싱 

앤티앨리어싱은 선, 곡선 및 글꼴을 부드럽게 하는 데 사용되는 GUIX의 선택적 기능입니다. 앤티앨리어싱은 16bpp 이상의 색 농도를 활용하여 디스플레이 드라이버에서 실행될 때만 지원됩니다.

활성 브러시에서 **GX_BRUSH_ALIAS** 플래시를 설정하여 앤티앨리어싱된 선 그리기를 사용할 수 있습니다. 이러한 방식은 다각형 또는 원의 테두리로 그린 선뿐만 아니라 직접 그린 선에도 적용됩니다.

앤티앨리어싱된 텍스트 그리기는 GUIX Studio 애플리케이션에서 생성하는 앤티앨리어싱 글꼴을 사용하여 지원됩니다. 글꼴을 만들 때 글꼴이 앤티앨리어싱 또는 바이너리 중 어떤 방식으로 생성되어야 하는지를 지정합니다.
GUIX의 앤티앨리어싱 글꼴은 각 픽셀에 대해 16가지 수준의 투명도를 활용합니다.

### <a name="clipping"></a>클리핑 

클리핑은 GUIX 디스플레이 구성 요소에서 내부적으로, 그리고 GUIX 위젯에서 유지 관리되는 부모-자식 아키텍처에 따라 창 및 위젯 계층에서 지원됩니다. 창이나 위젯을 해당 위젯의 영역 외부에 그릴 수 없으며, 창은 해당 위젯의 부모 영역 외부에 절대 그릴 수 없습니다.

따라서 위젯을 캔버스 메모리 외부에 있는 픽셀 좌표에 그려 메모리 손상이나 시스템 오류를 야기하는 상황이 방지됩니다. 위젯은 위젯의 영역, 위젯의 부모 영역 또는 캔버스 범위를 벗어나 그릴 수 없습니다.

또한 위젯은 이전에 더티로 표시된 영역에만 그릴 수 있습니다. 따라서 창의 구석만 표시되는 경우처럼 전체 창이 그려지지 않습니다. 실제로 새로 고쳐야 하는 창의 부분만 더티로 표시되므로 창 그리기 함수는 실제로 더티 영역의 픽셀만 새로 고칩니다.

GUIX 디스플레이 구성 요소는 드라이버 수준 그리기 함수를 호출하기 전에 이러한 클리핑 알고리즘을 적용합니다.

### <a name="views"></a>보기 

GUIX는 항상 각 루트 창 및 루트 창의 각 자식 창에 대한 뷰 세트를 유지 관리합니다. 뷰는 창 위치 및 Z 순서로 변경되는 런타임에 결정되는 동적 클리핑 영역입니다.
GUIX는 뷰를 사용하여 배경의 창이나 위젯이 전경의 창이나 위젯 위에 그려지지 않도록 합니다. 뷰는 Z-순서 규칙을 적용합니다. 또한 뷰는 배경의 창을 보이지 않는 캔버스 영역에 그리지 않도록 한다는 측면에서 효율적입니다. 창이 다른 창으로 완전히 덮이면 덮인 창을 캔버스에 그리려고 해도 그렇게 되지 않습니다.

### <a name="display-driver-interface"></a>디스플레이 드라이버 인터페이스 

GUIX 디스플레이 드라이버는 기본 물리적 화면과의 모든 상호 작용을 담당합니다. 디스플레이 드라이버에는 초기화, 그리기 및 프레임 버퍼 디스플레이의 세 가지 기본 기능이 있습니다.
초기화는 물리적 디스플레이 하드웨어를 준비하고, 물리적 디스플레이 하드웨어의 속성을 GUIX에 알리고, 사용해야 하는 특정 그리기 함수를 GUIX에 알립니다. 기본 디스플레이 드라이버 초기화는 GUIX ***gx_display_create*** 함수에서 호출됩니다. 또한 GUIX 스레드는 스레드 컨텍스트에서 보조 디스플레이 드라이버 초기화도 호출합니다. 이 보조 디스플레이 드라이버는 초기화하는 동안 RTOS 서비스가 필요한 경우(예: 초기화 프로세스의 단계 간 지연을 위한 ***tx_thread_sleep*** 요청 또는 디바이스 인터럽트)에만 필요합니다.

초기화가 완료되면 디스플레이 드라이버는 물리적 디스플레이 하드웨어에서 수행할 수 있는 모든 직접 그리기를 진행합니다.
마지막으로 디스플레이 드라이버는 프레임 버퍼를 표시합니다.

## <a name="guix-widget-component"></a>GUIX 위젯 구성 요소

GUIX 위젯은 표시되는 그래픽 요소입니다. 타이머 및 수학 유틸리티 함수와 같이 표시되지 않는 GUIX 구성 요소가 있습니다.
그러나 표시되는 모든 구성 요소는 기본 GUIX 위젯 구성 요소에서 파생됩니다. GUIX 위젯은 GUIX 디스플레이의 기본 구성 요소입니다. 다른 모든 그래픽 요소는 기본 위젯 기능에서 파생됩니다.

GUIX 위젯은 상속을 완벽하게 지원하는 개체 지향 방식으로 구현됩니다. 이를 위해 ANSI C를 사용하므로 메모리 및 처리 요구 사항을 최소화할 수 있습니다. **GX_BUTTON** 과 같은 특정 위젯을 사용하는 경우 기본 **GX_WIDGET** 과 같은 다른 위젯에서 *파생* 된다는 것은 **GX_BUTTON** 제어 구조체에 **GX_WIDGET** 의 모든 멤버 변수 및 함수 포인터가 포함되어 있고 **GX_BUTTON** 에만 적용되는 몇 가지 추가 변수가 있다는 것을 의미합니다. GUIX는 이러한 방식으로 위젯의 계층을 구성하므로 더 복잡한 위젯은 항상 더 간단한 위젯을 기준으로 합니다. 이 계층형 파생 모델을 통해 위젯 매개 변수를 수정하는 데 사용되는 API를 보다 쉽게 학습할 수 있습니다. 단추의 색을 수정하려는 경우 위젯 색을 수정하는 데 사용하는 것과 동일한 API, 즉 ***gx_widget_fill_color_set*** 을 사용합니다.

표시되는 위젯의 구성은 자식 위젯을 부모에 연결하는 트리 구조 목록을 사용하여 부모-자식 방식으로 유지 관리됩니다. 자식은 그릴 수 있는 뷰 및 그리는 캔버스와 같은 특성을 부모로부터 상속합니다.
자식 위젯은 자체 자식 위젯이 있을 수 있으며 이러한 자식 역시 부모로부터 다양한 특성을 상속합니다. 다양한 GUIX API 호출을 통해 모든 위젯의 특성을 명시적으로 재정의할 수 있습니다.

### <a name="widget-creation"></a>위젯 만들기 

위젯 개체는 초기화 동안 또는 애플리케이션 스레드를 실행하는 동안 언제든지 만들 수 있습니다. 애플리케이션에서 만들 수 있는 위젯 개체 수에는 제한이 없습니다. 대상 하드웨어의 메모리 제한 내에서 위젯에 포함될 수 있는 자식 수에도 제한이 없습니다.

각 위젯 유형에는 ***gx_button_create** _ 또는 _ *_gx_prompt_create_**와 같은 고유한 만들기 함수가 있습니다. 이러한 함수에 대한 처음 세 매개 변수인 위젯 제어 구조체에 대한 포인터, 위젯 이름에 대한 문자열 포인터 및 위젯의 부모에 대한 포인터는 항상 동일합니다. 각 만들기 함수에는 특정 위젯 형식의 요구 사항에 따라 제한 없는 수의 추가 매개 변수를 포함할 수 있습니다.

### <a name="widget-control-block"></a>위젯 제어 블록 

각 위젯 개체의 특성은 해당 제어 블록 **GX_WIDGET** 에서 찾을 수 있으며 **_gx_api.h_** 에 정의됩니다. 위젯 개체에 필요한 메모리는 애플리케이션이 제공하며 메모리의 어느 위치에나 있을 수 있습니다. 그러나 함수 범위 외부에서 정의하여 위젯 개체 제어 블록이 전역 구조를 차단하도록 하는 것이 가장 일반적입니다. GUIX Studio를 사용하는 경우 위젯 제어 블록은 Studio 생성 사양 파일 내에서 정적으로 할당되거나 애플리케이션을 통해 동적으로 할당될 수 있습니다.

### <a name="dynamic-widget-control-block-allocation-and-de-allocation"></a>동적 위젯 제어 블록 할당 및 할당 취소 

동적 제어 블록 할당을 사용하는 경우 GUIX에서 위젯 제어 블록에 필요한 메모리를 할당하고 해제하는 데 사용하는 두 가지 함수를 정의해야 합니다. 메모리 관리용 함수는 ***gx_system_memory_allocator_set*** API 함수를 통해 GUIX 시스템 구성 요소에 전달됩니다. 이 함수를 사용하면 두 개의 함수 포인터를 GUIX에 전달할 수 있습니다. 첫 번째는 메모리 할당 함수에 대한 포인터이고 두 번째는 메모리 해제 함수에 대한 포인터입니다. ThreadX 바이트 풀을 사용하여 이러한 함수를 구현하는 경우가 가장 많지만 GUIX 디자인을 사용하면 원하는 방식으로 동적 메모리 관리를 구현할 수 있습니다.

Studio 위젯 속성 필드에서 "동적으로 할당" 옵션을 선택하면 Studio에서 생성된 애플리케이션 사양 파일 내에서 동적 위젯 할당이 주로 사용됩니다. 그러나 애플리케이션 내에서 동적 제어 블록 할당을 사용할 수도 있습니다. 애플리케이션 내에서 동적 제어 블록 할당을 사용하는 경우 ***gx_widget_allocate** _ API 함수를 호출하여 위젯 제어 블록을 할당해야 합니다. 그런 다음, 위젯을 만들 때 사용자가 _ *GX_WIDGET_STYLE_DYNAMICALLY_ALLOCATED** 스타일 플래그(기타 필요한 스타일 플래그와 함께)를 위젯 만들기 함수로 전달하도록 해야 합니다. 이 플래그는 위젯을 위젯 상태 필드에 동적으로 할당된 것으로 표시하는 데 사용 됩니다. **_gx_widget_delete_** 를 사용하여 나중에 위젯을 삭제하는 경우, GUIX는 이 상태 필드를 확인하고 메모리 누수가 없도록 메모리 할당 취소 함수를 자동으로 호출합니다.

> [!IMPORTANT]
> 동적으로 할당된 제어 블록을 사용하여 만든 위젯은 메모리 손실을 방지하기 위해 **GX_WIDGET_STYLE_DYNAMICALLY_ALLOCATED** 스타일 플래그를 사용하여 만들어야 합니다.

### <a name="types"></a>형식

GUIX는 다양한 기능을 갖춘 기본 제공 위젯 세트를 제공합니다. 앞에서 설명한 것처럼 모든 특수 위젯은 기본 위젯에서 파생됩니다. 다음은 GUIX의 기본 제공 위젯 목록입니다.

**GX_TYPE_WIDGET**

**GX_TYPE_BUTTON**

**GX_TYPE_TEXT_BUTTON**

**GX_TYPE_MULTI_LINE_TEXT_BUTTON**

**GX_TYPE_RADIO_BUTTON**

**GX_TYPE_CHECKBOX**

**GX_TYPE_PIXELMAP_BUTTON**

**GX_TYPE_ICON_BUTTON**

**GX_TYPE_ICON**

**GX_TYPE_SPRITE**

**GX_TYPE_SLIDER**

**GX_TYPE_PIXELMAP_SLIDER**

**GX_TYPE_VERTICAL_SCROLL**

**GX_TYPE_HORIZONTAL_SCROLL**

**GX_TYPE_PROGRESS_BAR**

**GX_TYPE_PROMPT**

**GX_TYPE_NUMERIC_PROMPT**

**GX_TYPE_PIXELMAP_PROMPT**

**GX_TYPE_NUMERIC_PIXELMAP_PROMPT**

**GX_TYPE_SINGLE_LINE_TEXT_INPUT**

**GX_TYPE_MULTI_LINE_TEXT_VIEW**

**GX_TYPE_MULTI_LINE_TEXT_INPUT**

**GX_TYPE_WINDOW**

**GX_TYPE_ROOT_WINDOW**

**GX_TYPE_VERTICAL_LIST**

**GX_TYPE_HORIZONTAL_LIST**

**GX_TYPE_POPUP_LIST**

**GX_TYPE_DROP_LIST**

**GX_TYPE_LINE_CHART**

**GX_TYPE_DIALOG**

**GX_TYPE_KEYBOARD**

**GX_TYPE_SCROLL_WHEEL**

**GX_TYPE_TEXT_SCROLL_WHEEL**

**GX_TYPE_STRING_SCROLL_WHEEL**

**GX_TYPE_NUMERIC_SCROLL_WHEEL**

**GX_TYPE_CIRCULAR_GAUGE**

**GX_TYPE_RADIAL_PROGRESS_BAR**

**GX_TYPE_RADIAL_SLIDER**

**GX_TYPE_MENU_LIST**

**GX_TYPE_MENU**

**GX_TYPE_ACCORDION_MENU**

**GX_TYPE_TREE_VIEW**


### <a name="styles"></a>스타일

위젯 스타일은 앞에서 설명한 대로 특정 위젯 형식에 대한 속성 뿐만 아니라 테두리 속성(볼록, 오목, 가늘게, 굵게 또는 테두리 없음)과 같은 항목으로 구성됩니다. 위젯 스타일 플래그는 위젯의 모양을 수정하는 가장 간단한 방법을 제공합니다.
초기 위젯 스타일은 항상 위젯 유형 특정 만들기 함수로 전달되는 매개 변수입니다.

### <a name="colors"></a>색 

위젯은 시스템 색 테이블에 정의된 색을 사용하여 자신을 그립니다.
색 ID는 캔버스 배경, 기본 위젯 채우기 색, 단추 채우기 색, 텍스트 위젯 채우기 색, 창 채우기 색 및 기타 여러 기본 색 값에 대해 정의됩니다. 또한 **GX_WINDOW** 개체는 창 클라이언트가 채워질 때 비트맵 또는 배경 화면을 표시하도록 지원합니다.

기본 색 구성표를 변경하는 가장 간단한 방법은 GUIX Studio를 사용하여 요구 사항을 충족하는 색 구성표를 만들거나 정의하는 것입니다.
GX_COLOR 값의 배열을 만들고 gx_system_color_table_set API 함수를 호출하여 색 구성표를 수동으로 정의할 수도 있습니다.

### <a name="event-notification"></a>이벤트 알림 

GUIX 이벤트는 특정 작업을 수행하고 사용자 입력 및 내부 시스템 상태 변경 내용을 위젯에 알리기 위해 하나 이상의 위젯에 대해 수행되는 요청입니다. 예를 들어, 위젯이 포커스를 얻으면 **GX_EVENT_FOCUS_GAINED** 가 ***gx_system_event_send*** API 서비스를 통해 위젯에 전송됩니다.

이벤트는 GUIX 이벤트 큐를 통해 전달되며 각 이벤트는 **GX_EVENT** 데이터 구조의 인스턴스입니다. **GX_EVENT** 데이터 구조는 ***gx_api.h*** 에 정의되어 있지만 구조체에서 가장 중요한 필드는 **gx_event_type**, **gx_event_sender**, **gx_event_target** 및 **gx_event_payload** 입니다.

**gx_event_type** 필드는 특정 이벤트 클래스를 식별하는 데 사용됩니다. 이벤트 유형은 **GX_EVENT_PEN_DOWN** 이벤트인지 또는 **GX_EVENT_TIMER** 이벤트인지를 나타냅니다. **gx_event_payload** 는 다양한 데이터 필드의 합집합이며 모든 이벤트 유형에 유효하지는 않습니다.
다른 이벤트 데이터 필드를 검사하기 전에 이벤트 유형 필드를 먼저 사용합니다.

**gx_event_sender** 필드는 이벤트가 자식-위젯 알림인 경우 이벤트를 생성한 위젯의 ID를 포함합니다.

**gx_event_target** 필드를 사용하여 사용자 정의 이벤트를 특정 창이 나 위젯에 라우팅할 수 있습니다. 특정 창에 이벤트를 보내려면 창에 고유한 ID 값을 지정하고(정확하게 식별할 수 있도록), 이벤트를 빌드할 때 **gx_event_target** 필드에 창 ID 값을 입력해야 합니다. 대상 ID를 모르는 경우나 입력 포커스가 있는 위젯에 이벤트를 라우팅하도록 하려면 **gx_event_target** 필드를 0으로 설정해야 합니다.

마지막으로 **gx_event_payload** 필드는 다양한 데이터 형식의 합집합입니다. **GX_EVENT_PEN_DOWN** 및 **GX_EVENT_PEN_UP** 이벤트의 경우 **gx_event_pointdata** 필드에 펜 위치의 x, y 픽셀 좌표가 포함됩니다. 타이머 이벤트의 경우 **gx_event_timer_id** 필드에 만료된 타이머의 ID가 포함됩니다. 다른 페이로드 데이터 필드는 다른 이벤트 유형에 활용됩니다. 미리 정의된 이벤트 유형 및 해당 페이로드 필드의 전체 목록은 [부록 E - GUIX 이벤트 설명](appendix-e.md)에 정의되어 있습니다.

애플리케이션은 상수 **GX_FIRST_APP_EVENT** 다음에 나오는 숫자로 시작하는 고유한 사용자 지정 이벤트를 추가할 수도 있습니다. 이 상수 이후의 모든 이벤트 번호는 애플리케이션 사용을 위해 예약됩니다. 물론 애플리케이션의 위젯 이벤트 처리기에서는 이러한 애플리케이션 이벤트를 처리해야 합니다.

### <a name="event-processing"></a>이벤트 처리 

***gx_<widget-type>_event_process*** 라는 모든 위젯에 대한 기본 위젯 이벤트 처리 함수가 있습니다. 대부분의 경우 애플리케이션은 지정된 위젯의 이벤트 처리를 신경쓸 필요가 없습니다. 그러나 애플리케이션은 사용자 지정 또는 보완 이벤트 처리가 필요한 경우 GUIX API ***gx_widget_event_process_set*** 을 통해 기본 처리 함수를 자체 함수로 재정의할 수 있습니다. 이 함수는 API에 지정된 이벤트 함수 처리 함수를 사용하여 기본 이벤트 처리 함수를 재정의합니다.

> [!IMPORTANT]
> 애플리케이션 이벤트 처리 함수는 기본 ***gx_widget_event_process*** 처리를 직접 호출하여 기본 처리를 활용할 수 있습니다(즉, 처리를 복제하지 않음).

이벤트 처리는 내부 GUIX 시스템 스레드의 컨텍스트와는 별개로 호출됩니다. 이러한 방식으로 이벤트 처리를 진행하기 위한 스택 요구 사항은 GUIX 스레드에만 적용됩니다.

### <a name="implementing-custom-event-processing-example"></a>사용자 지정 이벤트 처리 구현(예제) 

GUIX 시스템의 위젯 또는 창에 대해 사용자 고유의 이벤트 처리 함수를 제공할 수 있습니다. 사용자 고유의 사용자 지정 위젯 유형을 만드는 경우 일반적으로 위젯 생성 함수에 사용자 지정 이벤트 처리기를 설치합니다. 기존 위젯 또는 창의 작업을 확장하거나 수정하는 경우 위젯 또는 창이 만들어진 후에 gx_widget_event_process_set API 함수를 호출할 수 있습니다. 자식 컨트롤에 의해 생성되는 이벤트를 처리하기 위해 거의 항상 최상위 창(화면이라고도 함)에 대한 고유한 이벤트 처리를 제공하게 됩니다. 화면의 자식 컨트롤에 의해 생성되는 이벤트 처리는 GUIX 애플리케이션에 기능을 추가하는 기본적인 방법입니다.

예를 들어, "main_menu"라는 최상위 화면을 정의한다고 가정합니다.
이 화면은 GUIX Studio를 사용하여 정의하거나 애플리케이션 코드에서 만들 수 있습니다. GUIX Studio 내에서 화면을 정의하는 경우 해당 화면에 대한 Studio 속성 필드에 이벤트 처리기의 이름을 입력하면 Studio에서 생성된 사양 코드가 이벤트 처리기를 자동으로 설치합니다. 이 경우 사용자 지정 이벤트 처리기 ***main_menu_event_handler*** 를 호출하고 다음과 같이 코딩해야 합니다.

```C
int main_menu_item; /* example: variable to keep track of selected item */

UINT main_menu_event_handler(GX_WINDOW *main_screen, GX_EVENT *event_ptr)
{
    UINT status = GX_SUCCESS;

    switch(event_ptr->gx_event_type)
    {
    /* this is an example for catching events from a child button */
    case GX_SIGNAL(IDB_CHILD_BUTTON, GX_EVENT_CLICKED):
        /* insert your button handler code here */
        break;

    case GX_EVENT_SHOW:
        /* add functionality to the show event handler */
        /* first, do default processing */
        status = gx_window_event_process(main_screen, event_ptr); /* note 1 */

        /* now add my own processing */
        main_menu_item = 0;
        break;

    default:
        /* pass all other events to base processing function */
        status = gx_window_event_process(main_screen, event_ptr); /* note 1 */
        break;
    }
    return status;
}
```

위의 예제에서 **GX_EVENT_SHOW** 와 같은 시스템 이벤트(상태 변경을 위젯에 알리기 위해 내부적으로 생성된 이벤트)의 경우 애플리케이션에서 이러한 이벤트를 기본 위젯 이벤트 처리 함수에 전달하여 정상적인 처리가 수행되도록 해야 합니다. 그러면 애플리케이션은 필요에 따라 추가 논리를 추가할 수 있습니다. 애플리케이션에서 처리하지 않은 모든 이벤트(위의 기본 사례)도 기본 이벤트 처리 함수에 전달되어야 합니다. 이 예제는 **GX_WINDOW** 기반 최상위 화면에 대한 것이므로 기본 이벤트 처리 함수는 gx_window_event_process입니다.

### <a name="drawing-function"></a>그리기 함수 

모든 위젯 그리기는 이벤트 처리와는 별도로 수행됩니다. 일반적으로 CPU 주기 측면에서 그리기가 비용이 많이 들기 때문에 이렇게 하는 것이 더 효율적입니다. 지연된 그리기 알고리즘을 구현하면 그리기를 수행하기 전에 처리 중인 모든 이벤트 및 연결된 디스플레이 변경을 완료할 수 있으므로 그리기가 낭비되는 것을 방지할 수 있습니다. 이벤트 처리와 마찬가지로, 대부분의 위젯을 위한 ***gx_<widget-type>_draw*** 라는 기본 위젯 그리기 함수가 있습니다. 여기서 xxx는 위젯 형식입니다. 대부분의 경우 애플리케이션은 지정된 위젯의 그리기 함수를 신경쓸 필요가 없습니다. 그러나 애플리케이션은 사용자 지정 또는 보완 그리기가 필요한 경우 GUIX API ***gx_widget_draw_set*** 을 통해 기본 그리기 함수를 자체 함수로 재정의할 수 있습니다. 이 함수를 사용하면 애플리케이션에서 위젯에 대해 고유한 사용자 지정 그리기 함수를 제공할 수 있습니다. 이를 통해 애플리케이션에서 완전히 새로운 위젯 형식을 정의할 수 있게 됩니다.

> [!IMPORTANT]
> 애플리케이션 그리기 함수는 재정의된 그리기 함수에서 직접 호출하여 기본 그리기의 이점(예: 중복 코딩 없음)을 활용할 수 있습니다.

위젯 그리기는 내부 GUIX 시스템 스레드의 컨텍스트와는 별개로 호출됩니다. 따라서 그리기를 수행하는 데 필요한 타이밍 및 스택 요구 사항이 GUIX 스레드에만 적용됩니다.

### <a name="implementing-custom-drawing-example"></a>사용자 지정 그리기 구현(예제) 

모든 위젯의 그리기 함수는 GX_WIDGET 제어 블록의 멤버인 간접 함수 포인터를 통해 참조됩니다. GUIX Studio를 사용하여 위젯을 정의하는 경우 위젯 속성의 "그리기 함수" 매개 변수에 함수 이름을 입력하여 자체 함수 포인터를 설치할 수 있습니다. 그러면 위젯이 생성될 때 Studio에서 함수 포인터를 설치합니다. 애플리케이션 코드에서 위젯을 만드는 경우 위젯을 만든 후에 ***gx_widget_draw_set*** API 함수를 사용하여 사용자 지정 그리기 함수를 설치해야 합니다.

이 예제에서는 단추의 모양을 사용자 지정하려 한다고 가정해 보겠습니다. 단추는 **GX_TEXT_BUTTON** 과 매우 유사하지만 단추를 누를 때 단추의 오른쪽 가운데 부분에 녹색의 작은 "LED_ON" 비트맵이 그려지고, 단추를 뗄 때 작은 "LED_OFF" 비트맵이 그려집니다. 아래 그림처럼 보이는 단추를 만들려고 합니다.

![켜짐에 해당하는 녹색 단추의 스크린샷](./media/guix/image4.jpg) 사용자 지정 단추 "켜짐"

![꺼짐에 해당하는 빨간색 단추의 스크린샷](./media/guix/image5.jpg) 사용자 지정 단추 "꺼짐"

이 경우 다음과 같이 표시되는 단추 그리기 함수를 작성합니다.

```C
UINT my_button_draw(GX_TEXT_BUTTON *button)
{
    GX_PIXELMAP *map;
    ULONG button_style;
    INT xpos;
    INT ypos;

    /* first, do the normal text button drawing */
    gx_text_button_draw(button);

    /* now add our extra pixelmap */

    gx_widget_style_get(button, &button_style);

    if (button_style & GX_STYLE_BUTTON_PUSHED)
    {
        /* use the ON pixelmap */
        gx_context_pixelmap_get(GX_PIXELMAP_ID_LED_ON, &map);
    }
    else
    {
        /* use the OFF pixelmap */
        gx_context_pixelmap_get(GX_PIXELMAP_ID_LED_OFF, &map);
    }
    if (map)
    {
        /* draw it 20 pixels in from right edge */
        xpos = button->gx_widget_size.gx_rectangle_right;
        xpos -= map->gx_pixelmap_width + 20;

        /* and draw 10 pixels from the top edge */
        ypos = button->gx_widget_size.gx_rectangle_top + 10;

        /* draw the extra pixelmap on top of the button */
        gx_canvas_pixelmap_draw(xpos, ypos, map);
    }
}
```

## <a name="guix-drawing-context-component"></a>GUIX 그리기 컨텍스트 구성 요소 

GUIX가 각 캔버스 새로 고침 작업을 수행하면 그리기 컨텍스트가 런타임에 동적으로 만들어집니다. 그리기 컨텍스트는 현재 그리기 작업을 수행하는 데 사용되는 캔버스, 화면 드라이버 및 브러시를 함께 연결합니다.

그리기 컨텍스트는 **GX_DRAW_CONTEXT** 구조체로 정의됩니다.
이 구조체에는 현재 그리기 작업의 클리핑 및 뷰를 정의하고, 현재 캔버스를 정의하고, 현재 화면 드라이버를 사용 중인 것으로 정의하는 변수가 포함되어 있습니다. **GX_DRAW_CONTEXT** 구조체는 그리기에 사용 되는 브러시도 포함합니다. 그리기 컨텍스트 브러시는 사용자 지정 그리기 함수에서 직접 사용하게 되는 멤버입니다. 브러시 구조는 아래 코드와 같이 정의됩니다.

```C
typedef struct GX_BRUSH_STRUCT
{
    GX_PIXELMAP *gx_brush_pixelmap;
    GX_FONT     *gx_brush_font;
    ULONG        gx_brush_line_pattern;
    ULONG        gx_brush_pattern_mask;
    GX_COLOR     gx_brush_fill_color;  
    GX_COLOR     gx_brush_line_color;  
    UINT         gx_brush_style;
    GX_VALUE     gx_brush_width;
    UCHAR        gx_brush_alpha;  
} GX_BRUSH;
```

**gx_brush_pixelmap** 필드는 사각형 및 다각형 채우기에 사용할 pixelmap을 정의합니다. **gx_brush_style** 에 **GX_BRUSH_PIXELMAP** 스타일이 포함되어 있지 않으면 이 멤버가 사용되지 않습니다.

**gx_brush_font** 멤버는 텍스트 그리기에 사용되는 글꼴을 정의합니다.
**gx_brush_line_pattern** 멤버는 파선에 사용되는 패턴을 정의합니다.
**gx_brush_style** 멤버는 브러시 특성을 완전히 정의하기 위해 OR로 연결될 수 있는 스타일 플래그 세트입니다. 사용 가능한 브러시 스타일 플래그는 다음과 같습니다.

**GX_BRUSH_OUTLINE**  
**GX_BRUSH_SOLID_FILL**  
**GX_BRUSH_PIXELMAP_FILL**  
**GX_BRUSH_ALIAS**  
**GX_BRUSH_UNDERLINE**  
**GX_BRUSH_ROUND**

**gx_brush_width** 멤버는 선 그리기의 줄 또는 윤곽선이 있는 도형 그리기의 윤곽선 너비를 정의합니다.

**gx_brush_line_color** 멤버는 줄 그리기 및 텍스트 그리기의 전경색을 정의합니다.

**gx_brush_fill_color** 멤버는 도형 채우기에 사용되는 단색 채우기 색을 정의합니다. GUIX 컨텍스트 구성 요소는 활성 컨텍스트 내에서 현재 브러시를 매우 쉽게 수정할 수 있도록 하기 위해 디자인된 API 세트를 제공합니다. 이러한 API에는 **gx_context_brush_define**, **gx_context_line_color_set**, **gx_context_fill_color_set**, **gx_context_font_set** 등이 포함됩니다.

부모 개체의 그리기 컨텍스트는 개체 자식로 상속됩니다. 실제로 부모 그리기 컨텍스트의 복제본은 해당 그리기 함수가 호출될 때 자식 개체로 상속됩니다. 자식은 부모 그리기에 영향을 주지 않으면서 컨텍스트를 수정할 수 있지만, 원할 경우 브러시 색, 스타일 등의 부모 정보를 상속할 수도 있습니다.

## <a name="guix-window-component"></a>GUIX 창 구성 요소 

창 구성 요소는 GUIX의 모든 창 처리를 담당합니다. GUIX 창은 기본적으로 하나 이상의 자식 위젯을 포함할 수 있는 고유한 디스플레이 영역입니다. GUIX에서 창은 실제로 기본 위젯 개체의 한 가지 특수한 형태에 불과합니다.

GUIX 창은 상속을 완벽하게 지원하는 개체 지향 방식으로 구현됩니다. 이 작업은 ANSI C를 사용하여 수행되며, 결과적으로 메모리 및 처리 요구 사항이 최소화됩니다.

GUIX 창은 주로 가로 및 세로 스크롤에 대한 지원을 추가하여 GUIX 위젯의 기능을 확장합니다. GUIX 창 개체는 스크롤 막대를 자동으로 만들고 표시하며, 스크롤 막대 입력에 응답할 수 있습니다. 이동 가능한 창에는 펜 입력 이벤트를 기준으로 창을 이동하거나 끌 수 있는 기본 제공 이벤트 처리 기능도 있습니다.
마지막으로 GUIX 창은 창 Z 순서 맨 앞으로 창을 이동하여 수신 입력 포커스에 대응합니다.

GUIX 창에는 창 테두리 및 스크롤 막대와 같은 비클라이언트 개체가 사용 가능한 영역에서 제거되면 창의 내부 부분이 되는 ‘클라이언트 영역’ 개념이 있습니다. 클라이언트 영역 자식 위젯은 창 클라이언트 영역까지 잘립니다. 그렇지만 스크롤 막대와 같은 비클라이언트 자식 항목은 클라이언트 영역 외부에 그릴 수 있지만 여전히 창 외부 차원까지 잘립니다.

창은 부모-자식 방식으로 유지 관리됩니다. 이러한 방식에서 자식은 부모의 특성을 상속합니다. 자식 창은 자체 자식 창이 있을 수 있으며 이러한 자식 역시 부모로부터 다양한 특성을 상속합니다. 다양한 GUIX API 호출을 통해 모든 창의 특성을 명시적으로 재정의할 수 있습니다.

### <a name="window-creation"></a>창 만들기 

창 개체는 초기화 동안 또는 애플리케이션 스레드를 실행하는 동안 언제든지 만들 수 있습니다. 애플리케이션에서 만들 수 있는 창 개체 수에는 제한이 없습니다. 또한 창에 포함될 수 있는 자식 창의 수에도 제한이 없습니다.

### <a name="window-control-block"></a>창 제어 블록 

각 창 개체의 특성은 해당 제어 블록 **GX_WINDOW** 에서 찾을 수 있으며 **_gx_api.h_** 에 정의됩니다. 창 개체에 필요한 메모리는 애플리케이션이 제공하며 메모리의 어느 위치에나 있을 수 있습니다. 그러나 함수 범위 외부에서 정의하여 창 개체 제어 블록이 전역 구조를 차단하도록 하는 것이 가장 일반적입니다.

### <a name="root-window"></a>루트 창 

GUIX에는 각 캔버스에 대한 루트 창이라는 항목이 필요합니다. 루트 창은 테두리가 없고 연결된 캔버스와 동일한 차원이 있습니다. 주로 모든 첫 번째 수준 위젯 및 창에 대한 컨테이너로 사용됩니다. 일반적으로 루트 창은 화면 및 캔버스를 만든 직후에 API 함수 ***gx_window_root_create*** 를 통해 애플리케이션에서 만듭니다. Studio에서 생성한 gx_studio_display_configure 함수를 사용하는 경우 이 함수에 대한 마지막 매개 변수로 전달된 위치에서 루트 창의 주소를 반환할 수 있습니다.

루트 창은 기본적으로 이동 가능하지 않으며, 가장 간단한 경우에는 루트 창이 캔버스의 크기가 됩니다. 결과적으로 루트 창은 디스플레이 배경을 그리므로 디스플레이 배경색을 변경하거나 배경 무늬를 표시하려면 루트 창에 색 또는 배경 무늬를 할당합니다.

루트 창이 이동 가능한 경우 자식 창처럼 캔버스에서의 위치를 변경하는 것이 아니라 캔버스 자체를 이동하여 이동합니다.
이 기능을 사용하면 GUIX 루트 창에서 하드웨어 오프셋 레지스터가 있는 여러 프레임 버퍼를 지원하는 하드웨어를 활용할 수 있습니다.

### <a name="background"></a>배경 

창 배경은 단색 또는 비트맵 이미지 중 하나입니다. 초기 창 세트에 대한 기본값을 제공하는 기본 창 배경이 시스템 수준에 있습니다. 물론 모든 창 배경은 GUIX API를 통해 변경할 수 있습니다.

창의 단색 배경을 변경하려면 ***gx_widget_fill_color_set*** API를 사용합니다. 창에 배경 무늬를 할당하려면 ***gx_window_wallpaper_set*** API를 사용합니다.

### <a name="scrolling"></a>스크롤 

GUIX는 창 자식을 표시하는 데 필요한 영역이 창의 현재 크기를 가로 및/또는 세로로 초과하는 경우 표준 창 스크롤을 지원합니다. 스크롤을 사용하려면 애플리케이션에서 원하는 스크롤 막대를 만들어 창에 연결해야 합니다.

GUIX 창 구성 요소는 창 클라이언트 영역의 크기와 모든 자식 위젯의 범위를 기준으로 하는 기본 스크롤 구현을 제공합니다. 애플리케이션은 특정 창에 대해 ***gx_window_scroll_info_get*** 함수를 재정의하여 자체 스크롤 구현 및 해석을 제공할 수도 있습니다.

### <a name="event-notification"></a>이벤트 알림 

기본 창 이벤트 처리 함수는 주로 스크롤 및 크기 조정 이벤트를 처리하는 GX_WIDGET 이벤트 처리와 다릅니다. GX_WINDOW는 스크롤 및 크기 조정 이벤트를 위한 기본 처리기를 제공합니다.

애플리케이션은 상수 **GX_FIRST_APP_EVENT** 다음에 나오는 숫자로 시작하는 고유한 사용자 지정 이벤트를 추가할 수도 있습니다. 이 상수 이후의 모든 이벤트 번호는 애플리케이션 사용을 위해 예약됩니다. 물론 애플리케이션의 창 이벤트 처리기에서는 이러한 애플리케이션 이벤트를 처리해야 합니다.

### <a name="event-processing"></a>이벤트 처리 

다른 모든 위젯 유형과 마찬가지로 ***gx_window_event_process*** 라는 모든 창에 대한 기본 창 이벤트 처리 함수가 있습니다. 일반적으로 이 이벤트 처리 함수는 만드는 창에서 사용자 고유의 이벤트 처리기를 사용하여 재정의합니다. 이러한 방식으로 창 자식 컨트롤이 생성하는 이벤트를 기준으로 이벤트에 대응하고 작업을 수행합니다.

이벤트 처리기를 재정의하는 경우 GUIX 시스템 이벤트에 대한 기본 ***gx_window_event_process*** 함수를 호출하여 이벤트 처리기에 추가하는 작업 외에 기본 이벤트 처리가 발생할 수 있도록 하는 것이 중요합니다. 예를 들어, **GX_EVENT_SHOW** 이벤트에 대한 사용자 지정 처리기를 제공하고 이 이벤트를 ***gx_window_event_process*** 에 전달하지 않으면 창이 표시되지 않습니다.
창에 대한 사용자 지정 이벤트 처리기를 제공하려면 ***gx_widget_event_process_set*** 함수를 사용하여 이벤트 처리기의 주소를 정의합니다. 이 함수는 API에 지정된 이벤트 함수 처리 함수를 사용하여 기본 이벤트 처리 함수를 재정의합니다.

> [!IMPORTANT]
> 애플리케이션 이벤트 처리 함수는 기본 ***gx_window_event_process*** 를 직접 호출하여 기본 처리를 활용할 수 있습니다(즉, 처리를 복제하지 않음).

이벤트 처리는 내부 GUIX 시스템 스레드의 컨텍스트와는 별개로 호출됩니다. 이러한 방식으로 이벤트 처리를 진행하기 위한 스택 요구 사항은 GUIX 스레드에만 적용됩니다.

## <a name="guix-image-reader-component"></a>GUIX 이미지 판독기 구성 요소 

이미지 판독기 구성 요소는 원시 압축 이미지를 GUIX pixelmap 형식으로 압축 해제하는 유틸리티 및 API 함수를 제공합니다. JPEG 및 PNG 형식 원시 이미지 데이터가 지원되며 추가 형식이 후속 릴리스에 추가로 지원될 예정입니다.

대부분의 GUIX 애플리케이션에서 GUIX 이미지 판독기 구성 요소는 필요하지 않습니다. 대부분의 애플리케이션은 GUIX Studio 애플리케이션을 사용하여 JPEG 및 PNG 형식 그래픽 자산을 GUIX 호환 가능 **GX_PIXELMAP** 리소스로 변환합니다. GUIX 이미지 판독기 구성 요소는 원시 그래픽 자산이 런타임에만 알려져 있거나 시스템 스토리지 제약 조건으로 인해 리소스가 **GX_PIXELMAP** 형식으로 저장되지 않는 경우에 사용됩니다. JPEG 및 PNG 형식 이미지 데이터는 일반적으로 **GX_PIXELMAP** 형식보다 더 간결하지만 이러한 이미지 형식의 압축 풀기 및 색 공간 변환을 동적으로 수행하는 것과 관련해서 상당한 런타임 오버헤드가 발생합니다.

원시 형식 JPEG 또는 PNG 이미지가 gx_canvas_pixelmap_draw API 함수에 전달되면 GUIX는 JPEG 또는 PNG 데이터를 동적으로 압축 해제하고 그립니다. 이러한 방식은 런타임 그리기 속도에 상당히 부정적인 영향을 미칠 수 있으며, 하드웨어 지원 JPEG 또는 PNG 압축 해제를 지원하는 하드웨어 대상을 사용하지 않는 한, 원시 형식 이미지 데이터를 gx_canvas_pixelmap_draw 함수에 전달하는 것은 권장되지 않습니다.

> [!IMPORTANT]
> 원시 JPEG 또는 PNG 형식의 이미지를 gx_canvas_pixelmap_draw API에 전달하면 대부분의 대상 하드웨어에 대해 상당한 런타임 오버헤드가 발생합니다.

대신 이미지 판독기 구성 요소를 사용하여 런타임에 원시 JPEG 및 PNG 데이터를 GX_PIXELMAP 형식으로 변환할 수 있습니다.
이러한 방식으로 생성된 Pixelmap은 Studio에서 생성되고 리소스 파일 내에 포함되는 Pixelmap처럼 사용하고 그릴 수 있습니다. 따라서 애플리케이션은 이미지 압축 풀기, 디더링 및 색 공간 변환을 한번만(일반적으로 프로그램 시작 시) 수행하면 되며 이미지를 그릴 때마다 수행할 필요가 없습니다.

이미지 판독기 구성 요소 함수는 다음과 같습니다.

***gx_image_reader_create***  
***gx_image_reader_palette_set***  
***gx_image_reader_start***

## <a name="guix-animation-component"></a>GUIX 애니메이션 구성 요소 

GUIX 애니메이션 구성 요소는 화면 및 위젯 전환을 자동화하는 데 사용되는 함수 및 서비스 세트입니다. GUIX 애니메이션 구성 요소는 모든 위젯 유형의 페이드 인, 페이드 아웃, 이동 또는 슬라이드 유형 애니메이션을 지원합니다.

페이드 유형 애니메이션은 페이딩 위젯의 내부 알파 값을 변경하거나(**GX_BRUSH_ALPHA_SUPPORT** 를 사용하도록 설정한 경우), 별도의 메모리 캔버스에 위젯 컬렉션을 그린 후 배경과 혼합하는 방식으로 지원할 수 있습니다. 여러 하드웨어 그래픽 계층을 지원하는 하드웨어 대상의 경우 부드러운 페이딩 효과는 이 캔버스 혼합 방식을 사용할 때 가장 잘 지원되며 코어 CPU 대역폭도 거의 필요하지 않습니다. 여러 그래픽 계층을 지원하지 않는 하드웨어 대상의 경우 16bpp 이상 색 깊이에서 GUIX 브러시 알파 값을 사용하여 혼합할 수 있습니다.

애니메이션에서 별도의 그리기 캔버스를 사용해야 하는 경우 GUIX 애니메이션 구성 요소는 이 목적을 위해 API 서비스 gx_animation_canvas_define을 제공합니다. 다른 애니메이션 형식에는 별도의 캔버스가 필요하지 않지만 가능한 경우 사용될 수 있습니다. 이 경우 여러 하드웨어 화면에 대한 기본 하드웨어 지원을 최대한 활용할 수 있습니다.

애니메이션을 제어하는 변수는 두 개의 제어 블록으로 정의됩니다. 먼저 애니메이션 컨트롤러를 정의하는 **GX_ANIMATION** 제어 블록이 있습니다. 이 애니메이션 컨트롤러는 사용자가 정의하는 애니메이션 시퀀스를 실행하는 구동 엔진입니다. 단일 애니메이션 컨트롤러를 여러 번 다시 사용해서 다양한 애니메이션 시퀀스를 실행할 수 있습니다. 여러 애니메이션 시퀀스를 동시에 실행 야 하는 경우 여러 **GX_ANIMATION** 애니메이션 컨트롤러를 만들 수 있습니다.

체GUIX 시스템 구성 요소는 재사용이 가능한 **GX_ANIMATION** 제어 구조체 블록을 제공할 수 있습니다. 이 블록은 애니메이션이 필요할 때 애플리케이션에서 요청할 수 있으며 애니메이션 시퀀스가 완료되면 시스템 풀에 자동으로 반환됩니다. 따라서 애플리케이션에서는 구현될 수 있는 모든 애니메이션에 대한 **GX_ANIMATION** 구조체를 정적으로 정의하지 않아도 됩니다. 이 **GX_ANIMATION** 구조체 풀의 크기는 기본적으로 6으로 설정되는 상수 **GX_ANIMATION_POOL_SIZE** 로 정의됩니다. 즉, 기본적으로 6개의 동시 애니메이션이 시스템 풀에서 할당될 수 있습니다. 이 상수는 gx_user.h 헤더 파일에서 다시 정의할 수 있습니다. 이 경우 더 많은 동시 애니메이션이 필요합니다. **GX_ANIMATION_POOL_SIZE** 를 0으로 설정하면 GUIX 시스템 구성 요소가 애니메이션 풀 또는 관련 서비스를 제공하지 않습니다.

애니메이션을 정의하는 데 사용되는 두 번째 제어 블록 또는 구조체는 **GX_ANIMATION_INFO** 구조체입니다. 이 구조체는 특정 애니메이션 시퀀스 하나를 정의하는 데 사용됩니다. gx_animation_start API 서비스를 사용하여 애니메이션 시퀀스를 시작하기 위해 이 정보 구조를 애니메이션 컨트롤러에 제공합니다. **GX_ANIMATION_INFO** 구조체에는 다음 필드가 포함됩니다.

```C
typedef struct GX_ANIMATION_INFO_STRUCT
{
    GX_WIDGET *gx_animation_target;
    GX_WIDGET *gx_animation_parent;
    GX_WIDGET *gx_animation_screen_list;
    USHORT gx_animation_style;
    USHORT gx_animation_id;
    USHORT gx_animation_start_delay;
    USHORT gx_animation_frame_interval;
    GX_POINT gx_animation_start_position;
    GX_POINT gx_animation_end_position;
    GX_UBYTE gx_animation_start_alpha;
    GX_UBYTE gx_animation_end_alpha;
    GX_UBYTE gx_animation_steps;
} GX_ANIMATION_INFO;
```

**gx_animation_target** 멤버는 애니메이션 컨트롤러에서 작업할 대상 위젯을 정의합니다.

**gx_animation_parent** 멤버는 애니메이션 시퀀스가 완료될 때 대상 위젯이 연결되는 부모 위젯을 정의합니다(있는 경우). gx_animation_parent는 애니메이션이 완료될 때 생성되는 GX_ANIMATION_COMPLETE 이벤트의 수신자이기도 합니다.

**gx_animation_screen_list** 멤버는 펜 입력 구동 화면 슬라이드 애니메이션에 대한 위젯 목록을 정의합니다. 위젯 목록은 GX_NULL 포인터로 종료해야 하며 목록의 각 위젯은 gx_animation_parent와 동일한 x, y 차원이어야 합니다.

**gx_animation_style** 은 수행할 애니메이션 형식과 관련 옵션을 정의하는 비트 마스크입니다. 애니메이션 스타일 플래그에는 다음이 포함됩니다.

| 애니메이션&nbsp;스타일&nbsp;플래그 | Description |
| --- | --- |
| GX_ANIMATION_TRANSLATE | 슬라이드 또는 페이드 형식 애니메이션을 요청합니다. |
| GX_ANIMATION_SCREEN_DRAG | 펜 입력 구동 화면 끌기 애니메이션을 요청합니다. |

다음 플래그를 **SCREEN_DRAG** 형식 애니메이션과 함께 사용할 수 있습니다.

| 화면&nbsp;끌기&nbsp;플래그 | Description |
| --- | --- |
| GX_ANIMATION_WRAP | 화면 목록이 끝에서 시작까지 다시 래핑됩니다. |
| GX_ANIMATION_HORIZONTAL | 가로 방향으로 화면 끌기를 허용합니다.  |
| GX_ANIMATION_VERTICAL | 세로 방향으로 화면 끌기를 허용합니다. |

다음 플래그는 변환 애니메이션과 함께 사용할 수 있습니다.

| 애니메이션&nbsp;변환&nbsp;플래그 | Description |
| --- | --- |
| GX_ANIMATION_DETACH | 애니메이션이 완료되면 애니메이션 부모 항목에서 애니메이션 대상을 분리합니다. GUIX Studio에서 생성된 자동화 이벤트 처리를 통해 대상이 동적으로 할당되고 만들어진 경우에는 분리된 후 삭제됩니다. |
| GX_ANIMATION_TRANSLATE | 애니메이션 형식은 타이머 기반 애니메이션입니다. 애플리케이션은 대상 위젯에 대한 시작 및 끝 위치와 시작 및 끝 알파 값을 정의하고, 애니메이션 관리자는 애니메이션 실행을 구동하게 될 타이머를 만듭니다.
| GX_ANIMATION_SCREEN_DRAG | 이 애니메이션 형식은 펜 입력 이벤트에 의해 구동된다는 점에서 **TRANSLATE** 애니메이션과 다릅니다. 이 애니메이션은 사용자가 펜 또는 스타일러스를 입력 터치 스크린에서 끌 때 터치 스크린 입력을 따르면서 대상 위젯을 살짝 밉니다. 이러한 유형의 애니메이션을 활용하려면 애플리케이션에서 **_gx_animation_drag_enable_** API를 호출하여 이 애니메이션을 사용하도록 설정해야 합니다. |

**gx_animation_id** 값은 **GX_ANIMATION_COMPLETE** 이벤트의 event.gx_event_sender 필드에서 애니메이션 부모 항목으로 다시 전달됩니다. 애니메이션 부모 항목은 이 값을 사용하여 완료를 보고하는 자식 애니메이션을 확인합니다. 이 값은 0일 수 있으며, ID 값이 0인 애니메이션은 **ANIMATION_COMPLETE** 이벤트를 전혀 생성하지 않습니다.

**gx_animation_start_delay** 값은 **_gx_animation_start_ *_가 호출된 후, 애니메이션을 실제로 실행하기 전에 연기할 타이머 틱 수를 나타내는 GUIX 틱 수입니다. _* _gx_animation_start_** 를 호출한 직후에 애니메이션을 시작하려면 이 값을 0으로 지정할 수 있습니다.

**gx_animation_frame_interval** 필드는 애니메이션 시퀀스의 각 프레임 사이에서 지연되는 GUIX 타이머 틱 수(기본 OS 틱 속도의 배수)를 정의합니다. 최소값은 1입니다.

**gx_animation_start_position** 은 변환 애니메이션에 대한 대상 위젯의 왼쪽 위 시작 지점을 정의합니다.

**gx_animation_end_position** 은 변환 형식 애니메이션에 대한 대상 위젯의 왼쪽 위 끝 위치를 정의합니다.

**gx_animation_start_alpha** 필드는 변환 형식 애니메이션에 대한 시작 캔버스 알파 값을 정의합니다.

**gx_animation_end_alpha** 필드는 변환 형식 애니메이션에 대한 끝 캔버스 알파 값을 정의합니다.

**gx_animation_steps** 필드는 컨트롤러에서 변환 애니메이션에 대해 실행해야 하는 단계 또는 프레임 수를 정의합니다. 단계가 더 많으면 슬라이드가 더 부드럽게 진행되고 페이드 모양이 생성되지만 더 큰 시스템 대역폭이 필요합니다.

애플리케이션에서 애니메이션 효과를 구현하려면 먼저 ***gx_animation_create*** 를 호출하여 애니메이션 컨트롤러를 초기화해야 합니다. 애니메이션이 보조 캔버스를 사용하는 경우 gx_animation_canvas_define을 호출하여 이 캔버스를 초기화합니다. 다음으로 **GX_ANIMATION_INFO** 구조체를 초기화하여 수행할 특정 형식의 애니메이션 및 기타 애니메이션 매개 변수를 정의해야 합니다. 마지막으로 gx_animation_start를 호출하여 애니메이션 시퀀스를 트리거합니다.

애니메이션 컨트롤러는 애니메이션 시퀀스를 완료하면 부모 위젯에 **GX_ANIMATION_COMPLETE** 이벤트를 전송하여 해당 시점에 애니메이션 캔버스의 원하는 정리가 수행될 수 있도록 합니다.

## <a name="guix-utility-component"></a>GUIX 유틸리티 구성 요소 

유틸리티 구성 요소는 GUIX의 모든 일반 유틸리티 함수를 담당합니다. 유용한 유틸리티에 해당하는 일반적인 함수이며 애플리케이션 또는 내부 GUIX 코드의 어디에서나 호출할 수 있습니다. 유틸리티 구성 요소 함수에는 다음이 포함됩니다.

***gx_utility_canvas_to_bmp***

***gx_utility_circle_point_get***

***gx_utility_alphamap_create***

***gx_utility_gradient_create***

***gx_utility_gradient_delete***

***gx_utlity_ltoa***

***gx_utility_math_acos***

***gx_utility_math_asin***

***gx_utility_math_cos***

***gx_utility_math_sin***

***gx_utility_math_sqrt***

***gx_utility_pixelmap_resize***

***gx_utility_pixelmap_rotate***

***gx_utility_pixelmap_simple_rotate***

***gx_utility_rectangle_center***

***gx_utility_rectangle_center_find***

***gx_utility_rectangle_combine***

***gx_utility_rectangle_compare***

***gx_utility_rectangle_define***

***gx_utility_rectangle_overlap_detect***

***gx_utility_rectangle_point_detect***

***gx_utility_rectangle_resize***

***gx_utility_rectangle_shift***

***gx_utility_string_to_alphamap***
