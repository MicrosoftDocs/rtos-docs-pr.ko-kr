---
title: 2장 - Azure RTOS NetX 설치 및 사용
description: 이 장에서는 고성능 네트워크 스택인 Azure RTOS NetX의 설치, 설정, 사용과 관련된 다양한 문제에 대해 설명합니다.
author: philmea
ms.author: philmea
ms.date: 05/19/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 80d6ba18f47ad2b017dfa32260c83ba074a6dbac
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/22/2021
ms.locfileid: "104810453"
---
# <a name="chapter-2---installation-and-use-of-azure-rtos-netx"></a><span data-ttu-id="8b699-103">2장 - Azure RTOS NetX 설치 및 사용</span><span class="sxs-lookup"><span data-stu-id="8b699-103">Chapter 2 - Installation and Use of Azure RTOS NetX</span></span>

<span data-ttu-id="8b699-104">이 장에서는 고성능 네트워크 스택인 Azure RTOS NetX의 설치, 설정, 사용과 관련된 다양한 문제에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-104">This chapter contains a description of various issues related to installation, setup, and use of the high-performance network stack Azure RTOS NetX.</span></span>

## <a name="host-considerations"></a><span data-ttu-id="8b699-105">호스트 고려 사항</span><span class="sxs-lookup"><span data-stu-id="8b699-105">Host Considerations</span></span>

<span data-ttu-id="8b699-106">임베디드 개발은 일반적으로 Windows 또는 Linux(Unix) 호스트 컴퓨터에서 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-106">Embedded development is usually performed on Windows or Linux (Unix) host computers.</span></span> <span data-ttu-id="8b699-107">애플리케이션이 컴파일되고 연결된 후 호스트에서 실행 파일이 생성되면 실행을 위해 대상 하드웨어로 다운로드됩니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-107">After the application is compiled, linked, and the executable is generated on the host, it is downloaded to the target hardware for execution.</span></span>

<span data-ttu-id="8b699-108">일반적으로 대상 다운로드는 개발 도구의 디버거 내에서 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-108">Usually the target download is done from within the development tool's debugger.</span></span> <span data-ttu-id="8b699-109">다운로드 후 디버거는 대상 실행 제어(이동, 중지, 중단점 등)뿐만 아니라 메모리 및 프로세서 레지스터에 대한 액세스를 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-109">After download, the debugger is responsible for providing target execution control (go, halt, breakpoint, etc.) as well as access to memory and processor registers.</span></span>

<span data-ttu-id="8b699-110">대부분의 개발 도구 디버거는 JTAG(IEEE 1149.1) 및 BDM(백그라운드 디버그 모드)과 같은 OCD(온칩 디버그) 연결을 통해 대상 하드웨어와 통신합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-110">Most development tool debuggers communicate with the target hardware via on-chip debug (OCD) connections such as JTAG (IEEE 1149.1) and Background Debug Mode (BDM).</span></span> <span data-ttu-id="8b699-111">디버거는 ICE(In-Circuit Emulation) 연결을 통해 대상 하드웨어와 통신하기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-111">Debuggers also communicate with target hardware through In-Circuit Emulation (ICE) connections.</span></span> <span data-ttu-id="8b699-112">OCD 및 ICE 연결 둘 다 대상 상주 소프트웨어에 대한 침입이 최소화된 강력한 솔루션을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-112">Both OCD and ICE connections provide robust solutions with minimal intrusion on the target resident software.</span></span>

<span data-ttu-id="8b699-113">호스트에서 사용되는 리소스의 경우 NetX 소스 코드는 ASCII 형식으로 전달되며 호스트 컴퓨터 하드 디스크에 약 1MB의 공간이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-113">As for resources used on the host, the source code for NetX is delivered in ASCII format and requires approximately 1 Mbytes of space on the host computer's hard disk.</span></span>

## <a name="target-considerations"></a><span data-ttu-id="8b699-114">대상 고려 사항</span><span class="sxs-lookup"><span data-stu-id="8b699-114">Target Considerations</span></span>

<span data-ttu-id="8b699-115">NetX를 사용하려면 대상에 5~45KB의 ROM(읽기 전용 메모리)이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-115">NetX requires between 5 KBytes and 45 KBytes of Read-Only Memory (ROM) on the target.</span></span> <span data-ttu-id="8b699-116">NetX 스레드 스택 및 기타 글로벌 데이터 구조에 사용할 1~5KB의 RAM(Random Access Memory)도 대상에 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-116">Another 1 to 5 KBytes of the target's Random Access Memory (RAM) are required for the NetX thread stack and other global data structures.</span></span>

<span data-ttu-id="8b699-117">NetX는 두 개의 ThreadX 타이머 개체와 하나의 ThreadX 뮤텍스 개체도 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-117">In addition, NetX requires the use of two ThreadX timer objects and one ThreadX mutex object.</span></span> <span data-ttu-id="8b699-118">이러한 기능은 NetX 프로토콜 스택 내의 정기적인 처리 요구 사항 및 스레드 보호에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-118">These facilities are used for periodic processing needs and thread protection inside the NetX protocol stack.</span></span>

## <a name="product-distribution"></a><span data-ttu-id="8b699-119">제품 배포</span><span class="sxs-lookup"><span data-stu-id="8b699-119">Product Distribution</span></span>

<span data-ttu-id="8b699-120">Azure RTOS NetX는 <https://github.com/azure-rtos/netx/>에 있는 퍼블릭 소스 코드 리포지토리에서 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-120">Azure RTOS NetX can be obtained from our public source code repository at <https://github.com/azure-rtos/netx/>.</span></span>

<span data-ttu-id="8b699-121">다음은 리포지토리에 있는 몇 가지 중요한 파일 목록입니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-121">The following is a list of several important files in the repository:</span></span>

- <span data-ttu-id="8b699-122">***nx_api.h***: 모든 시스템 등식, 데이터 구조 및 서비스 프로토타입이 포함되어 있는 C 헤더 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-122">***nx_api.h***: C header file containing all system equates, data structures, and service prototypes.</span></span>
- <span data-ttu-id="8b699-123">***nx_port.h***: 모든 개발 도구와 대상별 데이터 정의 및 구조가 포함되어 있는 C 헤더 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-123">***nx_port.h***: C header file containing all development tool- and target-specific data definitions and structures.</span></span>  
- <span data-ttu-id="8b699-124">***demo_netx.c***: 소규모 데모 애플리케이션이 포함되어 있는 C 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-124">***demo_netx.c***: C file containing a small demo application.</span></span>
- <span data-ttu-id="8b699-125">***nx.a(또는 nx.lib)** _: _standard* 패키지와 함께 배포되는 NetX C 라이브러리의 이진 버전입니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-125">***nx.a (or nx.lib)** _: Binary version of the NetX C library that is distributed with the _standard* package.</span></span>             |

## <a name="netx-installation"></a><span data-ttu-id="8b699-126">NetX 설치</span><span class="sxs-lookup"><span data-stu-id="8b699-126">NetX Installation</span></span>

<span data-ttu-id="8b699-127">GitHub 리포지토리를 로컬 머신에 복제하여 NetX를 설치할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-127">You can installed NetX by cloning the GitHub repository to your local machine.</span></span> <span data-ttu-id="8b699-128">다음은 PC에서 NetX 리포지토리의 복제본을 만들기 위한 일반적인 구문입니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-128">The following is typical syntax for creating a clone of the NetX repository on your PC:</span></span>

```c
    git clone https://github.com/azure-rtos/netx
```

<span data-ttu-id="8b699-129">또는 GitHub 기본 페이지의 **다운로드** 단추를 사용하여 리포지토리의 복사본을 다운로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-129">Alternatively you can download a copy of the repository using the **Download** button on the GitHub main page.</span></span>

<span data-ttu-id="8b699-130">또한 온라인 리포지토리의 프런트 페이지에서 NetX 라이브러리를 빌드하기 위한 지침을 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-130">You will also find instructions for building the NetX library on the front page of the online repository.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="8b699-131">애플리케이션 소프트웨어는 NetX 라이브러리 파일(일반적으로 ***nx.a** _ 또는 _*_nx.lib_*_)과 C 포함 파일 _*_nx_api.h 및 nx_port.h_\*\*에 액세스할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-131">Application software needs access to the NetX library file (usually ***nx.a** _ or _*_nx.lib_*_) and the C include files _*_nx_api.h, and nx_port.h_\*\*.</span></span> <span data-ttu-id="8b699-132">이렇게 하려면 개발 도구에 대한 적절한 경로를 설정하거나 해당 파일을 애플리케이션 개발 영역으로 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-132">This is accomplished either by setting the appropriate path for the development tools or by copying these files into the application development area.</span></span>

## <a name="using-netx"></a><span data-ttu-id="8b699-133">NetX 사용</span><span class="sxs-lookup"><span data-stu-id="8b699-133">Using NetX</span></span>

<span data-ttu-id="8b699-134">NetX를 사용하려면 컴파일하는 동안 및 NetX 라이브러리 _*_nx.a_*_(또는 _ *_nx.lib_*)\*와 연결하는 동안 \***nx_api.h** _가 애플리케이션 코드에 포함되어 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-134">To use NetX, the application code must include ***nx_api.h** _ during compilation and link with the NetX library _*_nx.a_*_ (or _ *_nx.lib_*)*.</span></span>

<span data-ttu-id="8b699-135">NetX 애플리케이션을 빌드하는 데 필요한 네 가지 단계는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-135">The following are the four required steps for building a NetX application:</span></span>

1. <span data-ttu-id="8b699-136">NetX 서비스 또는 데이터 구조를 사용하는 모든 애플리케이션 파일에 ***nx_api.h*** 파일을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-136">Include the ***nx_api.h*** file in all application files that use NetX services or data structures.</span></span>
1. <span data-ttu-id="8b699-137">_ *_tx_application_define_*\* 함수 또는 애플리케이션 스레드에서 \***nx_system_initialize** _를 호출하여 NetX 시스템을 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-137">Initialize the NetX system by calling ***nx_system_initialize** _ from the _ *_tx_application_define_** function or an application thread.</span></span>  
1. <span data-ttu-id="8b699-138">***nx_system_initialize*** 를 호출한 후 IP 인스턴스를 만들고 ARP(주소 확인 프로토콜) 및 소켓(필요한 경우)을 사용하도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-138">Create an IP instance, enable the Address Resolution Protocol (ARP), if necessary, and any sockets after ***nx_system_initialize*** is called.</span></span>  
1. <span data-ttu-id="8b699-139">애플리케이션 원본을 컴파일하고 NetX 런타임 라이브러리 ***nx.a** _(또는 _*_nx.lib_\*\*)와 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-139">Compile application source and link with the NetX runtime library ***nx.a** _ (or _*_nx.lib_\*\*).</span></span> <span data-ttu-id="8b699-140">결과 이미지를 대상으로 다운로드하여 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-140">The resulting image can be downloaded to the target and executed!</span></span>

## <a name="troubleshooting"></a><span data-ttu-id="8b699-141">문제 해결</span><span class="sxs-lookup"><span data-stu-id="8b699-141">Troubleshooting</span></span>

<span data-ttu-id="8b699-142">각 NetX 포트는 실제 네트워크에서 또는 시뮬레이션된 네트워크 드라이버를 통해 실행되는 하나 이상의 샘플과 함께 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-142">Each NetX port is delivered with one or more samples that execute on an actual network or via a simulated network driver.</span></span> <span data-ttu-id="8b699-143">항상 샘플 시스템을 먼저 실행하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-143">It is always a good idea to get the sample  system running first.</span></span>

<span data-ttu-id="8b699-144">샘플 시스템이 제대로 실행되지 않으면 다음 작업을 수행하여 문제의 범위를 좁힙니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-144">If the sample system does not run properly, perform the following operations to narrow the problem:</span></span>

1. <span data-ttu-id="8b699-145">샘플이 어느 정도 실행되고 있는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-145">Determine how much of the sample is running.</span></span>
2. <span data-ttu-id="8b699-146">모든 새 애플리케이션 스레드의 스택 크기를 늘립니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-146">Increase stack sizes in any new application threads.</span></span>
3. <span data-ttu-id="8b699-147">구성 옵션 섹션에 나열된 적절한 디버그 옵션을 사용하여 NetX 라이브러리를 다시 컴파일합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-147">Recompile the NetX library with the appropriate debug options listed in the configuration option section.</span></span>
4. <span data-ttu-id="8b699-148">**NX_IP** 구조를 검사하여 패킷이 송신 또는 수신되고 있는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-148">Examine the **NX_IP** structure to see if packets are being sent or received.</span></span>
5. <span data-ttu-id="8b699-149">기본 패킷 풀을 검사하여 사용할 수 있는 패킷이 있는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-149">Examine the default packet pool to see if there are available packets.</span></span>
6. <span data-ttu-id="8b699-150">네트워크 드라이버가 IP 연결이 필요한 애플리케이션의 4바이트 경계에 ARP 및 IP 패킷을 해당 헤더와 함께 제공하는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-150">Ensure the network driver is supplying ARP and IP packets with its headers on 4-byte boundaries for applications requiring IP connectivity.</span></span>
7. <span data-ttu-id="8b699-151">최근 변경 내용을 일시적으로 무시하여 문제가 사라지거나 달라지는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-151">Temporarily bypass any recent changes to see if the problem disappears or changes.</span></span> <span data-ttu-id="8b699-152">이러한 정보는 지원 엔지니어에게 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-152">Such information should prove useful to our support engineers.</span></span>

<span data-ttu-id="8b699-153">[고객 지원 센터](about-this-guide.md) 항목에 설명된 절차에 따라 문제 해결 단계에서 수집한 정보를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-153">Follow the procedures outlined in the [Customer Support Center](about-this-guide.md) topic to send the information gathered from the troubleshooting steps.</span></span>

## <a name="configuration-options"></a><span data-ttu-id="8b699-154">구성 옵션</span><span class="sxs-lookup"><span data-stu-id="8b699-154">Configuration Options</span></span>

<span data-ttu-id="8b699-155">NetX를 사용하여 NetX 라이브러리 및 애플리케이션을 빌드할 때 몇 가지 구성 옵션이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-155">There are several configuration options when building the NetX library and the application using NetX.</span></span> <span data-ttu-id="8b699-156">구성 옵션은 달리 지정되지 않은 경우 애플리케이션 원본, 명령줄 또는 ***nx_user.h*** 포함 파일 내에 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-156">The configuration options can be defined in the application source, on the command line, or within the ***nx_user.h*** include file, unless otherwise specified.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="8b699-157">_ \*NX_INCLUDE_USER_DEFINE_FILE\*\*이 정의된 애플리케이션 및 NetX 라이브러리가 빌드되어 있는 경우에만 \***nx_user.h** _에 정의된 옵션이 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-157">Options defined in ***nx_user.h** _ are applied only if the application and NetX library are built with _ *NX_INCLUDE_USER_DEFINE_FILE** defined.</span></span>

<span data-ttu-id="8b699-158">다음 섹션에는 NetX에서 사용할 수 있는 구성 옵션이 나열되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-158">The following sections list the configuration options available in NetX.</span></span>

### <a name="system-configuration-options"></a><span data-ttu-id="8b699-159">시스템 구성 옵션</span><span class="sxs-lookup"><span data-stu-id="8b699-159">System Configuration Options</span></span>  

| <span data-ttu-id="8b699-160">옵션</span><span class="sxs-lookup"><span data-stu-id="8b699-160">Option</span></span>  | <span data-ttu-id="8b699-161">Description</span><span class="sxs-lookup"><span data-stu-id="8b699-161">Description</span></span>  |
|---|---|
| <span data-ttu-id="8b699-162">X_DEBUG</span><span class="sxs-lookup"><span data-stu-id="8b699-162">X_DEBUG</span></span> | <span data-ttu-id="8b699-163">정의된 경우 RAM 이더넷 네트워크 드라이버에서 제공되는 선택적 출력 디버그 정보를 사용하도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-163">Defined, enables the optional print debug information available from the RAM Ethernet network driver.</span></span> |
| <span data-ttu-id="8b699-164">NX_DISABLE_ERROR_CHECKING</span><span class="sxs-lookup"><span data-stu-id="8b699-164">NX_DISABLE_ERROR_CHECKING</span></span> | <span data-ttu-id="8b699-165">정의된 경우 기본 NetX 오류 검사 API를 제거하여 성능을 개선합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-165">Defined, removes the basic NetX error checking API and improves performance.</span></span> <span data-ttu-id="8b699-166">오류 검사를 사용하지 않도록 설정해도 영향을 받지 않는 API 반환 코드는 API 정의에 굵은 서체로 나열됩니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-166">API return codes that are not affected by disabling error checking are listed in bold typeface in the API definition.</span></span> <span data-ttu-id="8b699-167">이 정의는 일반적으로 애플리케이션을 디버그한 후 사용되거나 정의를 사용하면 성능은 개선되고 코드 크기는 감소하는 경우 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-167">This define is typically used after the application is debugged and when its use improves performance and decreases code size.</span></span> |
| <span data-ttu-id="8b699-168">NX_DRIVER_DEFERRED_PROCESSING</span><span class="sxs-lookup"><span data-stu-id="8b699-168">NX_DRIVER_DEFERRED_PROCESSING</span></span> | <span data-ttu-id="8b699-169">정의된 경우 지연된 네트워크 드라이버 패킷 처리를 사용하도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-169">Defined, enables deferred network driver packet handling.</span></span> <span data-ttu-id="8b699-170">이렇게 하면 네트워크 드라이버에서 IP 인스턴스에 패킷을 배치하고 NetX 내부 IP 도우미 스레드에서 실제 처리 루틴이 호출되도록 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-170">This allows the network driver to place a packet on the IP instance and have the real processing routine called from the NetX internal IP helper thread.</span></span> |
| <span data-ttu-id="8b699-171">NX_ENABLE_EXTENDED_NOTIFY_SUPPORT</span><span class="sxs-lookup"><span data-stu-id="8b699-171">NX_ENABLE_EXTENDED_NOTIFY_SUPPORT</span></span> | <span data-ttu-id="8b699-172">스택에서 더 많은 콜백 후크를 사용하도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-172">Enables more callback hooks in the stack.</span></span> <span data-ttu-id="8b699-173">이러한 콜백 함수는 BSD 래퍼 계층에서 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-173">These callback functions are used by the BSD wrapper layer.</span></span> <span data-ttu-id="8b699-174">이 옵션은 기본적으로 정의되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-174">By default this option is not defined.</span></span> |
| <span data-ttu-id="8b699-175">NX_ENABLE_SOURCE_ADDRESS_CHECK</span><span class="sxs-lookup"><span data-stu-id="8b699-175">NX_ENABLE_SOURCE_ADDRESS_CHECK</span></span> | <span data-ttu-id="8b699-176">정의된 경우 수신 패킷의 원본 주소를 확인할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-176">Defined, enables the source address of incoming packet to be checked.</span></span> <span data-ttu-id="8b699-177">이 옵션은 기본적으로 사용하지 않도록 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-177">By default this option is disabled.</span></span> |
| <span data-ttu-id="8b699-178">NX_LITTLE_ENDIAN</span><span class="sxs-lookup"><span data-stu-id="8b699-178">NX_LITTLE_ENDIAN</span></span> | <span data-ttu-id="8b699-179">정의된 경우 little endian 환경에서 필요한 바이트 스와핑을 수행하여 프로토콜 헤더가 적절한 big endian 형식인지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-179">Defined, performs the necessary byte swapping on little endian environments to ensure the protocol headers are in proper big endian format.</span></span> <span data-ttu-id="8b699-180">기본값은 일반적으로 ***nx_port.h*** 에 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-180">Note the default is typically setup in ***nx_port.h***.</span></span> |
| <span data-ttu-id="8b699-181">NX_MAX_PHYSICAL_INTERFACES</span><span class="sxs-lookup"><span data-stu-id="8b699-181">NX_MAX_PHYSICAL_INTERFACES</span></span> | <span data-ttu-id="8b699-182">디바이스의 총 실제 네트워크 인터페이스 수를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-182">Specifies the total number of physical network interfaces on the device.</span></span> <span data-ttu-id="8b699-183">기본값은 1이고 ***nx_api.h*** 에 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-183">The default value is 1 and is defined in ***nx_api.h***.</span></span> <span data-ttu-id="8b699-184">디바이스에는 하나 이상의 실제 인터페이스가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-184">A device must have at least one physical interface.</span></span> <span data-ttu-id="8b699-185">루프백 인터페이스는 포함되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-185">Note this does not include the loopback interface.</span></span> |
| <span data-ttu-id="8b699-186">NX_PHYSICAL_HEADER</span><span class="sxs-lookup"><span data-stu-id="8b699-186">NX_PHYSICAL_HEADER</span></span> | <span data-ttu-id="8b699-187">프레임의 실제 헤더 크기(바이트)를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-187">Specifies the size in bytes of the physical header of the frame.</span></span> <span data-ttu-id="8b699-188">기본값은 16이며(32비트 경계에 맞춘 일반적인 14바이트 이더넷 프레임 기준) \***nx_api.h** _에 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-188">The default value is 16 (based on a typical 14-byte Ethernet frame aligned to 32-bit boundary) and is defined in \***nx_api.h** _.</span></span> <span data-ttu-id="8b699-189">애플리케이션은 _ *_nx_user.h_\*\*에서와 같이 _*_nx_api.h_\*_ 가 포함되기 전에 값을 정의하여 이 기본값을 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-189">The application can override the default by defining the value before _*_nx_api.h_*_ is included, such as in _ *_nx_user.h_*.\*</span></span> |

### <a name="arp-configuration-options"></a><span data-ttu-id="8b699-190">ARP 구성 옵션</span><span class="sxs-lookup"><span data-stu-id="8b699-190">ARP Configuration Options</span></span>  

| <span data-ttu-id="8b699-191">옵션</span><span class="sxs-lookup"><span data-stu-id="8b699-191">Option</span></span>  | <span data-ttu-id="8b699-192">Description</span><span class="sxs-lookup"><span data-stu-id="8b699-192">Description</span></span>  |
|---|---|
| <span data-ttu-id="8b699-193">NX_ARP_DEFEND_BY_REPLY</span><span class="sxs-lookup"><span data-stu-id="8b699-193">NX_ARP_DEFEND_BY_REPLY</span></span> | <span data-ttu-id="8b699-194">정의된 경우 NetX에서 ARP 응답을 송신하여 해당 IP 주소를 방어할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-194">Defined, allows NetX to defend its IP address by sending an ARP response.</span></span> |
| <span data-ttu-id="8b699-195">NX_ARP_DEFEND_INTERVAL</span><span class="sxs-lookup"><span data-stu-id="8b699-195">NX_ARP_DEFEND_INTERVAL</span></span> | <span data-ttu-id="8b699-196">충돌하는 주소가 표시된 수신 ARP 메시지에 응답하여 ARP 모듈이 다음 방어 패킷을 송신하는 간격(초)을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-196">Defines the interval, in seconds, the ARP module sends out the next defend packet in response to an incoming ARP message that indicates an address in conflict.</span></span> |
| <span data-ttu-id="8b699-197">NX_ARP_DISABLE_AUTO_ARP_ENTRY</span><span class="sxs-lookup"><span data-stu-id="8b699-197">NX_ARP_DISABLE_AUTO_ARP_ENTRY</span></span> | <span data-ttu-id="8b699-198">**NX_DISABLE_ARP_AUTO_ENTRY** 로 이름이 바뀌었습니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-198">Renamed to **NX_DISABLE_ARP_AUTO_ENTRY**.</span></span> <span data-ttu-id="8b699-199">아직 지원되는 옵션이지만 새 디자인에서는 **NX_DISABLE_ARP_AUTO_ENTRY** 를 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-199">Although it is still being supported, new designs are encouraged to use **NX_DISABLE_ARP_AUTO_ENTRY**.</span></span>
| <span data-ttu-id="8b699-200">NX_ARP_EXPIRATION_RATE</span><span class="sxs-lookup"><span data-stu-id="8b699-200">NX_ARP_EXPIRATION_RATE</span></span> | <span data-ttu-id="8b699-201">ARP 항목이 유효한 상태로 유지되는 시간(초)을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-201">Specifies the number of seconds ARP entries remain valid.</span></span> <span data-ttu-id="8b699-202">기본값인 0을 사용하면 ARP 항목 만료 또는 에이징을 사용하지 않도록 설정하며 기본값은 \***nx_api.h** _에 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-202">The default value of zero disables expiration or aging of ARP entries and is defined in \***nx_api.h** _.</span></span> <span data-ttu-id="8b699-203">애플리케이션은 _ \*_nx_api.h_\*\*가 포함되기 전에 값을 정의하여 이 기본값을 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-203">The application can override the default by defining the value before _ *_nx_api.h_*\* is included.</span></span>
| <span data-ttu-id="8b699-204">NX_ARP_MAC_CHANGE_NOTIFICATION_ENABLE</span><span class="sxs-lookup"><span data-stu-id="8b699-204">NX_ARP_MAC_CHANGE_NOTIFICATION_ENABLE</span></span> | <span data-ttu-id="8b699-205">**NX_ENABLE_ARP_MAC_CHANGE_NOTIFICATION** 으로 이름이 바뀌었습니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-205">Renamed to **NX_ENABLE_ARP_MAC_CHANGE_NOTIFICATION**.</span></span> <span data-ttu-id="8b699-206">아직 지원되는 옵션이지만 새 디자인에서는 **NX_ENABLE_ARP_MAC_CHANGE_NOTIFICATION** 을 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-206">Although it is still being supported, new designs are encouraged to use **NX_ENABLE_ARP_MAC_CHANGE_NOTIFICATION**.</span></span> |
| <span data-ttu-id="8b699-207">NX_ARP_MAX_QUEUE_DEPTH</span><span class="sxs-lookup"><span data-stu-id="8b699-207">NX_ARP_MAX_QUEUE_DEPTH</span></span> | <span data-ttu-id="8b699-208">ARP 응답을 기다리는 동안 큐에 대기될 수 있는 최대 패킷 수를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-208">Specifies the maximum number of packets that can be queued while waiting for an ARP response.</span></span> <span data-ttu-id="8b699-209">기본값은 4이고 ***nx_api.h*** 에 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-209">The default value is 4 and is defined in ***nx_api.h***.</span></span> |
| <span data-ttu-id="8b699-210">NX_ARP_MAXIMUM_RETRIES</span><span class="sxs-lookup"><span data-stu-id="8b699-210">NX_ARP_MAXIMUM_RETRIES</span></span> | <span data-ttu-id="8b699-211">ARP 응답 없이 수행되는 최대 ARP 재시도 수를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-211">Specifies the maximum number of ARP retries made without an ARP response.</span></span> <span data-ttu-id="8b699-212">기본값은 18이고 \***nx_api.h** _에 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-212">The default value is 18 and is defined in \***nx_api.h** _.</span></span> <span data-ttu-id="8b699-213">애플리케이션은 _\*_nx_api.h_\*\*를 포함하기 전에 값을 정의하여 이 기본값을 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-213">The application can override the default by defining the value before including _\*_nx_api.h_\*\*.</span></span> |
| <span data-ttu-id="8b699-214">NX_ARP_UPDATE_RATE</span><span class="sxs-lookup"><span data-stu-id="8b699-214">NX_ARP_UPDATE_RATE</span></span> | <span data-ttu-id="8b699-215">ARP 재시도 간 시간(초)을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-215">Specifies the number of seconds between ARP retries.</span></span> <span data-ttu-id="8b699-216">기본값은 10으로, 10초를 나타내며 \***nx_api.h** _에 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-216">The default value is 10, which represents 10 seconds, and is defined in \***nx_api.h** _.</span></span> <span data-ttu-id="8b699-217">애플리케이션은 _\*_nx_api.h_\*\*를 포함하기 전에 값을 정의하여 이 기본값을 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-217">The application can override the default by defining the value before including _\*_nx_api.h_\*\*.</span></span> |
| <span data-ttu-id="8b699-218">NX_DISABLE_ARP_AUTO_ENTRY</span><span class="sxs-lookup"><span data-stu-id="8b699-218">NX_DISABLE_ARP_AUTO_ENTRY</span></span> | <span data-ttu-id="8b699-219">정의된 경우 ARP 캐시에 ARP 요청 정보를 입력할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-219">Defined, disables entering ARP request information in the ARP cache.</span></span> |
| <span data-ttu-id="8b699-220">NX_DISABLE_ARP_INFO</span><span class="sxs-lookup"><span data-stu-id="8b699-220">NX_DISABLE_ARP_INFO</span></span> | <span data-ttu-id="8b699-221">정의된 경우 ARP 정보를 수집할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-221">Defined, disables ARP information gathering.</span></span> |
| <span data-ttu-id="8b699-222">NX_ENABLE_ARP_MAC_CHANGE_NOTIFICATION</span><span class="sxs-lookup"><span data-stu-id="8b699-222">NX_ENABLE_ARP_MAC_CHANGE_NOTIFICATION</span></span> | <span data-ttu-id="8b699-223">정의된 경우 MAC 주소가 업데이트된 것이 검색되면 ARP에서 콜백 알림 함수를 호출하도록 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-223">Defined, allows ARP to invoke a callback notify function on detecting the MAC address is updated.</span></span> |

### <a name="icmp-configuration-options"></a><span data-ttu-id="8b699-224">ICMP 구성 옵션</span><span class="sxs-lookup"><span data-stu-id="8b699-224">ICMP Configuration Options</span></span>  

| <span data-ttu-id="8b699-225">옵션</span><span class="sxs-lookup"><span data-stu-id="8b699-225">Option</span></span>  | <span data-ttu-id="8b699-226">Description</span><span class="sxs-lookup"><span data-stu-id="8b699-226">Description</span></span>  |
|---|---|
| <span data-ttu-id="8b699-227">NX_DISABLE_ICMP_INFO</span><span class="sxs-lookup"><span data-stu-id="8b699-227">NX_DISABLE_ICMP_INFO</span></span> | <span data-ttu-id="8b699-228">정의된 경우 ICMP 정보를 수집할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-228">Defined, disables ICMP information gathering.</span></span> |
| <span data-ttu-id="8b699-229">NX_DISABLE_ICMP_RX_CHECKSUM</span><span class="sxs-lookup"><span data-stu-id="8b699-229">NX_DISABLE_ICMP_RX_CHECKSUM</span></span> | <span data-ttu-id="8b699-230">수신된 ICMP 패킷에 대한 ICMP 체크섬 계산을 사용하지 않도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-230">Disables the ICMP checksum computation on received ICMP packets.</span></span> <span data-ttu-id="8b699-231">이 옵션은 네트워크 인터페이스 드라이버가 ICMP 체크섬을 확인할 수 있고 애플리케이션에서 IP 조각화 기능을 사용하지 않는 경우에 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-231">This option is useful when the network interface driver is able to verify the ICMP checksum, and the application does not use the IP fragmentation feature.</span></span> <span data-ttu-id="8b699-232">이 옵션은 기본적으로 정의되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-232">By default this option is not defined.</span></span> |
| <span data-ttu-id="8b699-233">NX_DISABLE_ICMP_TX_CHECKSUM</span><span class="sxs-lookup"><span data-stu-id="8b699-233">NX_DISABLE_ICMP_TX_CHECKSUM</span></span> | <span data-ttu-id="8b699-234">전송된 ICMP 패킷에 대한 ICMP 체크섬 계산을 사용하지 않도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-234">Disables ICMP checksum computation on transmitted ICMP packets.</span></span> <span data-ttu-id="8b699-235">이 옵션은 네트워크 인터페이스 드라이버가 ICMP 체크섬을 계산할 수 있으나 애플리케이션이 IP 조각화 기능을 사용하지 않는 경우에 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-235">This option is useful where the network interface driver is able to compute the ICMP checksum, and the application does not use the IP fragmentation feature.</span></span> <span data-ttu-id="8b699-236">이 옵션은 기본적으로 정의되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-236">By default this option is not defined.</span></span> |

### <a name="igmp-configuration-options"></a><span data-ttu-id="8b699-237">IGMP 구성 옵션</span><span class="sxs-lookup"><span data-stu-id="8b699-237">IGMP Configuration Options</span></span>  

| <span data-ttu-id="8b699-238">옵션</span><span class="sxs-lookup"><span data-stu-id="8b699-238">Option</span></span>  | <span data-ttu-id="8b699-239">Description</span><span class="sxs-lookup"><span data-stu-id="8b699-239">Description</span></span>  |
|---|---| 
| <span data-ttu-id="8b699-240">NX_DISABLE_IGMP_INFO</span><span class="sxs-lookup"><span data-stu-id="8b699-240">NX_DISABLE_IGMP_INFO</span></span> | <span data-ttu-id="8b699-241">정의된 경우 IGMP 정보를 수집할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-241">Defined, disables IGMP information gathering.</span></span> |
| <span data-ttu-id="8b699-242">NX_DISABLE_IGMPV2</span><span class="sxs-lookup"><span data-stu-id="8b699-242">NX_DISABLE_IGMPV2</span></span> | <span data-ttu-id="8b699-243">정의된 경우 IGMPv2 지원을 사용하지 않도록 설정하므로 NetX에서 IGMPv1만 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-243">Defined, disables IGMPv2 support, and NetX supports IGMPv1 only.</span></span> <span data-ttu-id="8b699-244">기본적으로 이 옵션은 설정되어 있지 않으며 ***nx_api.h*** 에 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-244">By default this option is not set and is defined in ***nx_api.h***.</span></span> |
| <span data-ttu-id="8b699-245">NX_MAX_MULTICAST_GROUPS</span><span class="sxs-lookup"><span data-stu-id="8b699-245">NX_MAX_MULTICAST_GROUPS</span></span> | <span data-ttu-id="8b699-246">가입할 수 있는 최대 멀티캐스트 그룹 수를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-246">Specifies the maximum number of multicast groups that can be joined.</span></span> <span data-ttu-id="8b699-247">기본값은 7이며 \***nx_api.h** _에 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-247">The default value is 7 and is defined in \***nx_api.h** _.</span></span> <span data-ttu-id="8b699-248">애플리케이션은 _ \*_nx_api.h_\*\*가 포함되기 전에 값을 정의하여 이 기본값을 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-248">The application can override the default by defining the value before _ *_nx_api.h_*\* is included.</span></span> |

### <a name="ip-configuration-options"></a><span data-ttu-id="8b699-249">IP 구성 옵션</span><span class="sxs-lookup"><span data-stu-id="8b699-249">IP Configuration Options</span></span>

| <span data-ttu-id="8b699-250">옵션</span><span class="sxs-lookup"><span data-stu-id="8b699-250">Option</span></span>  | <span data-ttu-id="8b699-251">Description</span><span class="sxs-lookup"><span data-stu-id="8b699-251">Description</span></span>  |
|---|---|
| <span data-ttu-id="8b699-252">NX_DISABLE_FRAGMENTATION</span><span class="sxs-lookup"><span data-stu-id="8b699-252">NX_DISABLE_FRAGMENTATION</span></span> | <span data-ttu-id="8b699-253">정의된 경우 IP 조각화 및 리어셈블리 논리를 사용하지 않도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-253">Defined, disables IP fragmentation and reassembly logic.</span></span> |
| <span data-ttu-id="8b699-254">NX_DISABLE_IP_INFO</span><span class="sxs-lookup"><span data-stu-id="8b699-254">NX_DISABLE_IP_INFO</span></span> | <span data-ttu-id="8b699-255">정의된 경우 IP 정보를 수집할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-255">Defined, disables IP information gathering.</span></span> |
| <span data-ttu-id="8b699-256">NX_DISABLE_IP_RX_CHECKSUM</span><span class="sxs-lookup"><span data-stu-id="8b699-256">NX_DISABLE_IP_RX_CHECKSUM</span></span> | <span data-ttu-id="8b699-257">정의된 경우 수신된 IP 패킷의 체크섬 논리를 사용하지 않도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-257">Defined, disables checksum logic on received IP packets.</span></span> <span data-ttu-id="8b699-258">네트워크 디바이스에서 IP 헤더 체크섬을 확인할 수 있고 애플리케이션에서 IP 조각화를 사용하지 않는 경우에 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-258">This is useful if the network device is able to verify the IP header checksum, and the application does not use IP fragmentation.</span></span> |
| <span data-ttu-id="8b699-259">NX_DISABLE_IP_TX_CHECKSUM</span><span class="sxs-lookup"><span data-stu-id="8b699-259">NX_DISABLE_IP_TX_CHECKSUM</span></span> | <span data-ttu-id="8b699-260">정의된 경우 송신된 IP 패킷의 체크섬 논리를 사용하지 않도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-260">Defined, disables checksum logic on IP packets sent.</span></span> <span data-ttu-id="8b699-261">기본 네트워크 디바이스에서 IP 헤더 체크섬을 생성할 수 있고 애플리케이션에서 IP 조각화를 사용하지 않는 경우에 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-261">This is useful in situations in which the underlying network device is capable of generating the IP header checksum, and the application does not use IP fragmentation.</span></span> |
| <span data-ttu-id="8b699-262">NX_DISABLE_LOOPBACK_INTERFACE</span><span class="sxs-lookup"><span data-stu-id="8b699-262">NX_DISABLE_LOOPBACK_INTERFACE</span></span> | <span data-ttu-id="8b699-263">정의된 경우 루프백 인터페이스에 대해 NetX 지원을 사용하지 않도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-263">Defined, disables NetX support for the loopback interface.</span></span> |
| <span data-ttu-id="8b699-264">NX_DISABLE_RX_SIZE_CHECKING</span><span class="sxs-lookup"><span data-stu-id="8b699-264">NX_DISABLE_RX_SIZE_CHECKING</span></span> | <span data-ttu-id="8b699-265">정의된 경우 수신된 패킷에서 크기 검사를 사용하지 않도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-265">Defined, disables the size checking on received packets.</span></span> |
| <span data-ttu-id="8b699-266">NX_ENABLE_IP_STATIC_ROUTING</span><span class="sxs-lookup"><span data-stu-id="8b699-266">NX_ENABLE_IP_STATIC_ROUTING</span></span> | <span data-ttu-id="8b699-267">정의된 경우 대상 주소에 특정한 다음 홉 주소를 할당할 수 있는 IP 고정 라우팅을 사용하도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-267">Defined, enables IP static routing in which a destination address can be assigned a specific next hop address.</span></span> <span data-ttu-id="8b699-268">기본적으로 IP 고정 라우팅은 사용하지 않도록 설정되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-268">By default IP static routing is disabled.</span></span> |
| <span data-ttu-id="8b699-269">NX_IP_PERIODIC_RATE</span><span class="sxs-lookup"><span data-stu-id="8b699-269">NX_IP_PERIODIC_RATE</span></span> | <span data-ttu-id="8b699-270">정의된 경우 1초 동안의 ThreadX 타이머 틱 수를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-270">Defined, specifies the number of ThreadX timer ticks in one second.</span></span> <span data-ttu-id="8b699-271">기본값은 ThreadX 기호 **TX_TIMER_TICKS_PER_SECOND** 에서 파생되며 기본적으로 100(10ms 타이머)으로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-271">The default value is derived from the ThreadX symbol **TX_TIMER_TICKS_PER_SECOND,** which by default is set to 100 (10ms timer).</span></span> <span data-ttu-id="8b699-272">NetX 모듈의 나머지 부분도 **NX_IP_PERIODIC_RATE**\* 에서 타이밍 정보가 파생되므로 이 값을 수정하는 경우 애플리케이션에서 주의를 기울여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-272">Applications shall exercise caution when modifying this value, as the rest of the NetX modules derive timing information from **NX_IP_PERIODIC_RATE\*.**</span></span> |
| <span data-ttu-id="8b699-273">NX_IP_ROUTING_TABLE_SIZE</span><span class="sxs-lookup"><span data-stu-id="8b699-273">NX_IP_ROUTING_TABLE_SIZE</span></span> | <span data-ttu-id="8b699-274">정의된 경우 지정된 대상 주소의 발신 인터페이스 및 다음 홉 주소 목록에 해당하는 IP 고정 라우팅 테이블의</span><span class="sxs-lookup"><span data-stu-id="8b699-274">Defined, sets the maximum number of entries in the IP static routing table, which is a list of an outgoing interface and the next hop</span></span>
<span data-ttu-id="8b699-275">최대 항목 수를 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-275">addresses for a given destination address.</span></span> <span data-ttu-id="8b699-276">기본값은 8이며 \***nx_api.h** _에 정의됩니다. 이 기호는 _ \*NX_ENABLE_IP_STATIC_ROUTING\*\*이 정의된 경우에만 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-276">The default value is 8 and is defined in ***nx_api.h.** _ This symbol is used only if _ *NX_ENABLE_IP_STATIC_ROUTING** is defined.</span></span> |

### <a name="packet-configuration-options"></a><span data-ttu-id="8b699-277">패킷 구성 옵션</span><span class="sxs-lookup"><span data-stu-id="8b699-277">Packet Configuration Options</span></span>  

| <span data-ttu-id="8b699-278">옵션</span><span class="sxs-lookup"><span data-stu-id="8b699-278">Option</span></span>  | <span data-ttu-id="8b699-279">Description</span><span class="sxs-lookup"><span data-stu-id="8b699-279">Description</span></span>  |
|---|---|
| <span data-ttu-id="8b699-280">NX_DISABLE_PACKET_INFO</span><span class="sxs-lookup"><span data-stu-id="8b699-280">NX_DISABLE_PACKET_INFO</span></span> | <span data-ttu-id="8b699-281">정의된 경우 패킷 풀 정보를 수집할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-281">Defined, disables packet pool information gathering.</span></span> | 
| <span data-ttu-id="8b699-282">NX_PACKET_HEADER_PAD</span><span class="sxs-lookup"><span data-stu-id="8b699-282">NX_PACKET_HEADER_PAD</span></span> | <span data-ttu-id="8b699-283">정의된 경우 NX_PACKET 제어 블록의 끝에 패딩을 사용하도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-283">Defined, enables padding towards the end of the NX_PACKET control block.</span></span> <span data-ttu-id="8b699-284">패딩할 **ULONG** 워드 수는 **NX_PACKET_HEADER_PAD_SIZE** 로 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-284">The number of **ULONG** words to pad is defined by **NX_PACKET_HEADER_PAD_SIZE**.</span></span> |
| <span data-ttu-id="8b699-285">NX_PACKET_HEADER_PAD_SIZE</span><span class="sxs-lookup"><span data-stu-id="8b699-285">NX_PACKET_HEADER_PAD_SIZE</span></span> | <span data-ttu-id="8b699-286">NX_PACKET 구조에 패딩할 **ULONG** 단어 수를 설정하여 패킷 페이로드 영역을 원하는 맞춤에서 시작할 수 있도록</span><span class="sxs-lookup"><span data-stu-id="8b699-286">Sets the number of **ULONG** words to be padded to the NX_PACKET structure, allowing the packet payload area to start at the desired</span></span>
<span data-ttu-id="8b699-287">합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-287">alignment.</span></span> <span data-ttu-id="8b699-288">이 기능은 수신 버퍼 설명자가 NX_PACKET 페이로드 영역을 직접 가리키며 네트워크 인터페이스 수신 논리 또는 캐시 작업 논리에서 특정 맞춤 요구 사항을 충족하는 버퍼 시작 주소가 필요한 경우에 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-288">This feature is useful when receive buffer descriptors point directly into NX_PACKET payload area, and the network interface receive logic or the cache operation logic expects the buffer starting address to meet certain alignment requirements.</span></span> <span data-ttu-id="8b699-289">이 값은 **NX_PACKET_HEADER_PAD** 가 정의된 경우에만 유효합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-289">This value becomes valid only when **NX_PACKET_HEADER_PAD** is defined.</span></span> |

### <a name="rarp-configuration-options"></a><span data-ttu-id="8b699-290">RARP 구성 옵션</span><span class="sxs-lookup"><span data-stu-id="8b699-290">RARP Configuration Options</span></span>  

| <span data-ttu-id="8b699-291">옵션</span><span class="sxs-lookup"><span data-stu-id="8b699-291">Option</span></span>  | <span data-ttu-id="8b699-292">Description</span><span class="sxs-lookup"><span data-stu-id="8b699-292">Description</span></span>  |
|---|---|
| <span data-ttu-id="8b699-293">NX_DISABLE_RARP_INFO</span><span class="sxs-lookup"><span data-stu-id="8b699-293">NX_DISABLE_RARP_INFO</span></span> | <span data-ttu-id="8b699-294">정의된 경우 RARP 정보를 수집할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-294">Defined, disables RARP information gathering.</span></span> |

### <a name="tcp-configuration-options"></a><span data-ttu-id="8b699-295">TCP 구성 옵션</span><span class="sxs-lookup"><span data-stu-id="8b699-295">TCP Configuration Options</span></span>

| <span data-ttu-id="8b699-296">옵션</span><span class="sxs-lookup"><span data-stu-id="8b699-296">Option</span></span>  | <span data-ttu-id="8b699-297">Description</span><span class="sxs-lookup"><span data-stu-id="8b699-297">Description</span></span>  |
|---|---|
| <span data-ttu-id="8b699-298">NX_DISABLE_RESET_DISCONNECT</span><span class="sxs-lookup"><span data-stu-id="8b699-298">NX_DISABLE_RESET_DISCONNECT</span></span> | <span data-ttu-id="8b699-299">정의된 경우 제공되는 시간 제한 값이 **NX_NO_WAIT** 로 지정되면 연결 해제 중에 초기화 처리를 사용하지 않도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-299">Defined, disables the reset processing during disconnect when the timeout value supplied is specified as **NX_NO_WAIT**.</span></span> |
| <span data-ttu-id="8b699-300">NX_DISABLE_TCP_INFO</span><span class="sxs-lookup"><span data-stu-id="8b699-300">NX_DISABLE_TCP_INFO</span></span> | <span data-ttu-id="8b699-301">정의된 경우 TCP 정보를 수집할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-301">Defined, disables TCP information gathering.</span></span> |
| <span data-ttu-id="8b699-302">NX_DISABLE_TCP_RX_CHECKSUM</span><span class="sxs-lookup"><span data-stu-id="8b699-302">NX_DISABLE_TCP_RX_CHECKSUM</span></span> | <span data-ttu-id="8b699-303">정의된 경우 수신된 TCP 패킷의 체크섬 논리를 사용하지 않도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-303">Defined, disables checksum logic on received TCP packets.</span></span> <span data-ttu-id="8b699-304">이 기능은 링크 계층에 안정적인 체크섬 또는 CRC 처리가 있거나 인터페이스 드라이버가 하드웨어의 TCP 체크섬을 확인할 수 있는 경우에만 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-304">This is only useful in situations in which the link-layer has reliable checksum or CRC processing, or the interface driver is able to verify the TCP checksum in hardware.</span></span> |
| <span data-ttu-id="8b699-305">NX_DISABLE_TCP_TX_CHECKSUM</span><span class="sxs-lookup"><span data-stu-id="8b699-305">NX_DISABLE_TCP_TX_CHECKSUM</span></span> | <span data-ttu-id="8b699-306">정의된 경우 TCP 패킷 송신에 체크섬 논리를 사용하지 않도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-306">Defined, disables checksum logic for sending TCP packets.</span></span> <span data-ttu-id="8b699-307">수신 네트워크 노드에 수신된 TCP 체크섬 논리가 사용하지 않도록 설정되어 있거나 기본 네트워크 드라이버가 TCP 체크섬을 생성할 수 있는 경우에만 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-307">This is only useful in situations in which the receiving network node has the received TCP checksum logic disabled or the underlying network driver is capable of generating the TCP checksum.</span></span> |
| <span data-ttu-id="8b699-308">NX_ENABLE_TCP_KEEPALIVE</span><span class="sxs-lookup"><span data-stu-id="8b699-308">NX_ENABLE_TCP_KEEPALIVE</span></span> | <span data-ttu-id="8b699-309">정의된 경우 선택적 TCP 연결 유지 타이머를 사용하도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-309">Defined, enables the optional TCP keepalive timer.</span></span> <span data-ttu-id="8b699-310">기본 설정은 사용하지 않도록 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-310">The default settings is not enabled.</span></span> |
| <span data-ttu-id="8b699-311">NX_ENABLE_TCP_MSS_CHECKING</span><span class="sxs-lookup"><span data-stu-id="8b699-311">NX_ENABLE_TCP_MSS_CHECKING</span></span> | <span data-ttu-id="8b699-312">정의된 경우 TCP 연결을 수락하기 전에 최소 피어 MSS 확인을 사용하도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-312">Defined, enables the verification of minimum peer MSS before accepting a TCP connection.</span></span> <span data-ttu-id="8b699-313">이 기능을 사용하려면 **NX_ENABLE_TCP_MSS_MINIMUM** 기호가 정의되어 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-313">To use this feature, the symbol **NX_ENABLE_TCP_MSS_MINIMUM** must be defined.</span></span> <span data-ttu-id="8b699-314">이 옵션은 기본적으로 사용하도록 설정되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-314">By default, this option is not enabled.</span></span> |
<span data-ttu-id="8b699-315">NX_ENABLE_TCP_WINDOW_SCALING</span><span class="sxs-lookup"><span data-stu-id="8b699-315">NX_ENABLE_TCP_WINDOW_SCALING</span></span> | <span data-ttu-id="8b699-316">TCP 애플리케이션의 창 크기 조정 옵션을 사용하도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-316">Enables the window scaling option for TCP applications.</span></span> <span data-ttu-id="8b699-317">정의된 경우 TCP 연결 단계에서 창 크기 조정 옵션을 협상하고 애플리케이션에서 64K보다 큰 창 크기를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-317">If defined, the window scaling option is negotiated during the TCP connection phase, and the application is able to specify a window size larger than 64K.</span></span> <span data-ttu-id="8b699-318">기본 설정은 사용하지 않도록 설정됩니다(정의되지 않음).</span><span class="sxs-lookup"><span data-stu-id="8b699-318">The default setting is not enabled (not defined).</span></span> |
| <span data-ttu-id="8b699-319">NX_MAX_LISTEN_REQUESTS</span><span class="sxs-lookup"><span data-stu-id="8b699-319">NX_MAX_LISTEN_REQUESTS</span></span> | <span data-ttu-id="8b699-320">최대 서버 수신 대기 요청 수를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-320">Specifies the maximum number of server listen requests.</span></span> <span data-ttu-id="8b699-321">기본값은 10이며 \***nx_api.h** _에 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-321">The default value is 10 and is defined in \***nx_api.h** _.</span></span> <span data-ttu-id="8b699-322">애플리케이션은 _ \*_nx_api.h_\*\*가 포함되기 전에 값을 정의하여 이 기본값을 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-322">The application can override the default by defining the value before _ *_nx_api.h_*\* is included.</span></span> |
| <span data-ttu-id="8b699-323">NX_TCP_ACK_EVERY_N_PACKETS</span><span class="sxs-lookup"><span data-stu-id="8b699-323">NX_TCP_ACK_EVERY_N_PACKETS</span></span> | <span data-ttu-id="8b699-324">ACK 송신 전 수신할 TCP 패킷 수를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-324">Specifies the number of TCP packets to receive before sending an ACK.</span></span> <span data-ttu-id="8b699-325">**NX_TCP_IMMEDIATE_ACK** 는 사용하도록 설정되어 있지만 **NX_TCP_ACK_EVERY_N_PACKETS** 는 사용하도록 설정되어 있지 않은 경우 이전 버전과의 호환성을 위해 이 값이 자동으로 1로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-325">Note if **NX_TCP_IMMEDIATE_ACK** is enabled but **NX_TCP_ACK_EVERY_N_PACKETS** is not, this value is automatically set to 1 for backward compatibility.</span></span> |
| <span data-ttu-id="8b699-326">NX_TCP_ACK_TIMER_RATE</span><span class="sxs-lookup"><span data-stu-id="8b699-326">NX_TCP_ACK_TIMER_RATE</span></span> | <span data-ttu-id="8b699-327">TCP 지연 ACK 처리의 타이머 속도를 계산하기 위해 시스템 틱 수(NX_IP_PERIODIC_RATE)를 나누는 방법을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-327">Specifies how the number of system ticks (NX_IP_PERIODIC_RATE) is divided to calculate the timer rate for the TCP delayed ACK processing.</span></span> <span data-ttu-id="8b699-328">기본값은 5로, 200ms를 나타내며 \***nx_tcp.h** _에 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-328">The default value is 5, which represents 200ms, and is defined in \***nx_tcp.h** _.</span></span> <span data-ttu-id="8b699-329">애플리케이션은 _\*_nx_api.h_\*\*를 포함하기 전에 값을 정의하여 이 기본값을 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-329">The application can override the default by defining the value before including _\*_nx_api.h_\*\*.</span></span> |
| <span data-ttu-id="8b699-330">NX_TCP_ENABLE_KEEPALIVE</span><span class="sxs-lookup"><span data-stu-id="8b699-330">NX_TCP_ENABLE_KEEPALIVE</span></span> | <span data-ttu-id="8b699-331">**NX_ENABLE_TCP_KEEPALIVE** 로 이름이 변경되었습니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-331">Renamed to **NX_ENABLE_TCP_KEEPALIVE**.</span></span> <span data-ttu-id="8b699-332">아직 지원되는 옵션이지만 새 디자인에서는 **NX_ENABLE_TCP_KEEPALIVE** 를 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-332">Although it is still being supported, new designs are encouraged to use **NX_ENABLE_TCP_KEEPALIVE**.</span></span> |
| <span data-ttu-id="8b699-333">NX_TCP_ENABLE_WINDOW_SCALING</span><span class="sxs-lookup"><span data-stu-id="8b699-333">NX_TCP_ENABLE_WINDOW_SCALING</span></span> | <span data-ttu-id="8b699-334">**NX_ENABLE_TCP_WINDOW_SCALING** 으로 이름이 변경되었습니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-334">Renamed to **NX_ENABLE_TCP_WINDOW_SCALING**.</span></span> <span data-ttu-id="8b699-335">아직 지원되는 옵션이지만 새 디자인에서는 **NX_ENABLE_TCP_WINDOW_SCALING** 을 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-335">Although it is still being supported, new designs are encouraged to use **NX_ENABLE_TCP_WINDOW_SCALING**.</span></span> |
| <span data-ttu-id="8b699-336">NX_TCP_FAST_TIMER_RATE</span><span class="sxs-lookup"><span data-stu-id="8b699-336">NX_TCP_FAST_TIMER_RATE</span></span> | <span data-ttu-id="8b699-337">빠른 TCP 타이머 속도를 계산하기 위해 NetX 내부 틱 수(NX_IP_PERIODIC_RATE)를 나누는 방법을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-337">Specifies how the number of NetX internal ticks (NX_IP_PERIODIC_RATE) is divided to calculate the fast TCP timer rate.</span></span> <span data-ttu-id="8b699-338">빠른 TCP 타이머는 지연 ACK 타이머를 포함하여 다양한 TCP 타이머를 구동하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-338">The fast TCP timer is used to drive the various TCP timers, including the delayed ACK timer.</span></span> <span data-ttu-id="8b699-339">기본값은 10으로, 100ms를 나타내며 ThreadX 타이머가 10ms로 실행되고 있다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-339">The default value is 10, which represents 100ms assuming the ThreadX timer is running at 10ms.</span></span> <span data-ttu-id="8b699-340">이 값은 \***nx_tcp.h** _에 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-340">This value is defined in \***nx_tcp.h** _.</span></span> <span data-ttu-id="8b699-341">애플리케이션은 _\*_nx_api.h_\*\*를 포함하기 전에 값을 정의하여 이 기본값을 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-341">The application can override the default by defining the value before including _\*_nx_api.h_\*\*.</span></span> |
| <span data-ttu-id="8b699-342">NX_TCP_IMMEDIATE_ACK</span><span class="sxs-lookup"><span data-stu-id="8b699-342">NX_TCP_IMMEDIATE_ACK</span></span> | <span data-ttu-id="8b699-343">정의된 경우 선택적으로 TCP 즉시 ACK 응답 처리를 사용하도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-343">Defined, enables the optional TCP immediate ACK response processing.</span></span> <span data-ttu-id="8b699-344">이 기호를 정의하는 것은 **NX_TCP_ACK_EVERY_N_PACKETS** 를 1로 정의하는 것과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-344">Defining this symbol is equivalent to defining **NX_TCP_ACK_EVERY_N_PACKETS** to be 1.</span></span> |
| <span data-ttu-id="8b699-345">NX_TCP_KEEPALIVE_INITIAL</span><span class="sxs-lookup"><span data-stu-id="8b699-345">NX_TCP_KEEPALIVE_INITIAL</span></span> | <span data-ttu-id="8b699-346">연결 유지 타이머가 활성화되기 전의 비활성 시간(초)을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-346">Specifies the number of seconds of inactivity before the keepalive timer activates.</span></span> <span data-ttu-id="8b699-347">기본값은 7200으로, 2시간을 나타내며 \***nx_tcp.h** _에 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-347">The default value is 7200, which represents 2 hours, and is defined in \***nx_tcp.h** _.</span></span> <span data-ttu-id="8b699-348">애플리케이션은 _\*_nx_api.h_\*\*를 포함하기 전에 값을 정의하여 이 기본값을 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-348">The application can override the default by defining the value before including _\*_nx_api.h_\*\*.</span></span> |
| <span data-ttu-id="8b699-349">NX_TCP_KEEPALIVE_RETRIES</span><span class="sxs-lookup"><span data-stu-id="8b699-349">NX_TCP_KEEPALIVE_RETRIES</span></span> | <span data-ttu-id="8b699-350">연결이 끊어진 것으로 간주하기 전 허용되는 연결 유지 재시도 수를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-350">Specifies how many keepalive retries are allowed before the connection is deemed broken.</span></span> <span data-ttu-id="8b699-351">기본값은 10으로, 10번의 재시도를 나타내며 \***nx_tcp.h** _에 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-351">The default value is 10, which represents 10 retries, and is defined in \***nx_tcp.h** _.</span></span> <span data-ttu-id="8b699-352">애플리케이션은 _ \*_nx_api.h_\*\*가 포함되기 전에 값을 정의하여 이 기본값을 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-352">The application can override the default by defining the value before _ *_nx_api.h_*\* is included.</span></span> |
| <span data-ttu-id="8b699-353">NX_TCP_KEEPALIVE_RETRY</span><span class="sxs-lookup"><span data-stu-id="8b699-353">NX_TCP_KEEPALIVE_RETRY</span></span> | <span data-ttu-id="8b699-354">연결의 상대방이 응답하지 않는다고 가정하는 연결 유지 타이머의 재시도 간 간격(초)을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-354">Specifies the number of seconds between retries of the keepalive timer assuming the other side of the connection is not responding.</span></span> <span data-ttu-id="8b699-355">기본값은 75로, 재시도 간 간격이 75초임을 나타내며 \***nx_tcp.h** _에 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-355">The default value is 75, which represents 75 seconds between retries, and is defined in \***nx_tcp.h** _.</span></span> <span data-ttu-id="8b699-356">애플리케이션은 _ \*_nx_api.h_\*\*가 포함되기 전에 값을 정의하여 이 기본값을 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-356">The application can override the default by defining the value before _ *_nx_api.h_*\* is included.</span></span> |
| <span data-ttu-id="8b699-357">NX_TCP_MAX_OUT_OF_ORDER_PACKETS</span><span class="sxs-lookup"><span data-stu-id="8b699-357">NX_TCP_MAX_OUT_OF_ORDER_PACKETS</span></span> | <span data-ttu-id="8b699-358">TCP 소켓 수신 큐에 보관할 수 있는 순서가 잘못된 TCP 패킷의 최대 수를 정의하는 기호입니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-358">Symbol that defines the maximum number of out-of-order TCP packets that can be kept in the TCP socket receive queue.</span></span> <span data-ttu-id="8b699-359">이 기호를 사용하면 TCP 수신 소켓에서 큐에 대기되는 패킷 수를 제한하여 패킷 풀이 부족해지는 것을 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-359">This symbol can be used to limit the number of packets queued in the TCP receive socket, preventing the packet pool from being starved.</span></span> <span data-ttu-id="8b699-360">기본적으로 이 기호는 정의되지 않으므로 TCP 소켓에서 큐에 대기되는, 순서가 잘못된 패킷 수에는 제한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-360">By default this symbol is not defined, thus there is no limit on the number of out of order packets being queued in the TCP socket.</span></span> |
| <span data-ttu-id="8b699-361">NX_TCP_MAXIMUM_RETRIES</span><span class="sxs-lookup"><span data-stu-id="8b699-361">NX_TCP_MAXIMUM_RETRIES</span></span> | <span data-ttu-id="8b699-362">연결이 끊어진 것으로 간주하기 전 허용되는 데이터 전송 재시도 수를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-362">Specifies how many data transmit retries are allowed before the connection is deemed broken.</span></span> <span data-ttu-id="8b699-363">기본값은 10으로, 10번의 재시도를 나타내며 \***nx_tcp.h** _에 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-363">The default value is 10, which represents 10 retries, and is defined in \***nx_tcp.h** _.</span></span> <span data-ttu-id="8b699-364">애플리케이션은 _\*_nx_api.h_\*\*를 포함하기 전에 값을 정의하여 이 기본값을 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-364">The application can override the default by defining the value before including _\*_nx_api.h_\*\*.</span></span> |
| <span data-ttu-id="8b699-365">NX_TCP_MAXIMUM_TX_QUEUE</span><span class="sxs-lookup"><span data-stu-id="8b699-365">NX_TCP_MAXIMUM_TX_QUEUE</span></span> | <span data-ttu-id="8b699-366">TCP 송신 요청을 일시 중단하거나 거부하기 전 TCP 전송 큐의 최대 크기를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-366">Specifies the maximum depth of the TCP transmit queue before TCP send requests are suspended or rejected.</span></span> <span data-ttu-id="8b699-367">기본값은 20으로, 언제든지 최대 20개의 패킷이 전송 큐에 있을 수 있음을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-367">The default value is 20, which means that a maximum of 20 packets can be in the transmit queue at any given time.</span></span> <span data-ttu-id="8b699-368">패킷은 패킷 데이터의 일부 또는 전체에 적용되는 ACK를 연결 상대방으로부터 수신할 때까지 전송 큐에 남아 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-368">Note packets stay in the transmit queue until an ACK that covers some or all of the packet data is received from the other side of the connection.</span></span> <span data-ttu-id="8b699-369">이 상수는 \***nx_tcp.h** _에 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-369">This constant is defined in \***nx_tcp.h** _.</span></span> <span data-ttu-id="8b699-370">애플리케이션은 _\*_nx_api.h_\*\*를 포함하기 전에 값을 정의하여 기본값을 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-370">The application can override the default by defining the value before it includes _\*_nx_api.h_\*\*.</span></span> |
| <span data-ttu-id="8b699-371">X_TCP_MSS_CHECKING_ENABLED</span><span class="sxs-lookup"><span data-stu-id="8b699-371">X_TCP_MSS_CHECKING_ENABLED</span></span> | <span data-ttu-id="8b699-372">**NX_ENABLE_TCP_MSS_CHECKING** 으로 이름이 변경되었습니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-372">Renamed to **NX_ENABLE_TCP_MSS_CHECKING**.</span></span> <span data-ttu-id="8b699-373">아직 지원되는 옵션이지만 새 디자인에서는 **NX_ENABLE_TCP_MSS_CHECKING** 을 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-373">Although it is still being supported, new designs are encouraged to use **NX_ENABLE_TCP_MSS_CHECKING**.</span></span> |
| <span data-ttu-id="8b699-374">NX_TCP_MSS_MINIMUM</span><span class="sxs-lookup"><span data-stu-id="8b699-374">NX_TCP_MSS_MINIMUM</span></span> | <span data-ttu-id="8b699-375">NetX TCP 모듈에서 수락하는 최소 MSS 값을 정의하는 기호입니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-375">Symbol that defines the minimal MSS value NetX TCP module accepts.</span></span> <span data-ttu-id="8b699-376">이 기능은 **NX_ENABLE_TCP_MSS_CHECK** 를 통해 사용하도록 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-376">This feature is enabled by **NX_ENABLE_TCP_MSS_CHECK**</span></span> |
| <span data-ttu-id="8b699-377">NX_TCP_RETRY_SHIFT</span><span class="sxs-lookup"><span data-stu-id="8b699-377">NX_TCP_RETRY_SHIFT</span></span> | <span data-ttu-id="8b699-378">재시도 간 재전송 시간 제한 기간이 변경되는 방법을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-378">Specifies how the retransmit timeout period changes between retries.</span></span> <span data-ttu-id="8b699-379">이 값이 0이면 초기 재전송 시간 제한과 이어지는 재전송 시간 제한이 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-379">If this value is 0, the initial retransmit timeout is the same as subsequent retransmit timeouts.</span></span> <span data-ttu-id="8b699-380">이 값이 1이면 각각의 이어지는 재전송 시간 제한이 2배로 길어집니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-380">If this value is 1, each successive retransmit is twice as long.</span></span> <span data-ttu-id="8b699-381">이 값이 2이면 각각의 이어지는 재전송 시간 제한이 4배로 길어집니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-381">If this value is 2, each subsequent retransmit timeout is four times as long.</span></span> <span data-ttu-id="8b699-382">기본값은 0이며 \***nx_tcp.h** _에 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-382">The default value is 0 and is defined in \***nx_tcp.h** _.</span></span> <span data-ttu-id="8b699-383">애플리케이션은 _\*_nx_api.h_\*\*를 포함하기 전에 값을 정의하여 이 기본값을 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-383">The application can override the default by defining the value before including _\*_nx_api.h_\*\*.</span></span> |
| <span data-ttu-id="8b699-384">NX_TCP_TRANSMIT_TIMER_RATE</span><span class="sxs-lookup"><span data-stu-id="8b699-384">NX_TCP_TRANSMIT_TIMER_RATE</span></span>| <span data-ttu-id="8b699-385">TCP 전송 재시도 처리에 대한 타이머 속도를 계산하기 위해 시스템 틱 수(**NX_IP_PERIODIC_RATE**)를 나누는 방법을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-385">Specifies how the number of system ticks **NX_IP_PERIODIC_RATE**) is divided to calculate the timer rate for the TCP transmit retry processing.</span></span> <span data-ttu-id="8b699-386">기본값은 1로, 1초를 나타내며 **_nx_tcp.h_ *_에 정의됩니다. 애플리케이션은 _* _nx_api.h_** 를 포함하기 전에 값을 정의하여 이 기본값을 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-386">The default value is 1, which represents 1 second, and is defined in **_nx_tcp.h_*_. The application can override the default by defining the value before it includes _*_nx_api.h_**.</span></span> |

### <a name="udp-configuration-options"></a><span data-ttu-id="8b699-387">UDP 구성 옵션</span><span class="sxs-lookup"><span data-stu-id="8b699-387">UDP Configuration Options</span></span>
| <span data-ttu-id="8b699-388">옵션</span><span class="sxs-lookup"><span data-stu-id="8b699-388">Option</span></span>  | <span data-ttu-id="8b699-389">Description</span><span class="sxs-lookup"><span data-stu-id="8b699-389">Description</span></span>  |
|---|---|
| <span data-ttu-id="8b699-390">NX_DISABLE_UDP_INFO</span><span class="sxs-lookup"><span data-stu-id="8b699-390">NX_DISABLE_UDP_INFO</span></span> | <span data-ttu-id="8b699-391">정의된 경우 UDP 정보를 수집할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-391">Defined, disables UDP information gathering.</span></span> |
| <span data-ttu-id="8b699-392">NX_DISABLE_UDP_RX_CHECKSUM</span><span class="sxs-lookup"><span data-stu-id="8b699-392">NX_DISABLE_UDP_RX_CHECKSUM</span></span> | <span data-ttu-id="8b699-393">정의된 경우 수신 UDP 패킷의 UDP 체크섬 계산을 사용하지 않도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-393">Defined, disables the UDP checksum computation on incoming UDP packets.</span></span> <span data-ttu-id="8b699-394">네트워크 인터페이스 드라이버가 하드웨어의 UDP 헤더 체크섬을 확인할 수 있고 애플리케이션이 IP 조각화 논리를 사용하도록 설정하지 않는 경우에 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-394">This is useful if the network interface driver is able to verify UDP header checksum in hardware, and the application does not enable IP fragmentation logic.</span></span> |
| <span data-ttu-id="8b699-395">NX_DISABLE_UDP_TX_CHECKSUM</span><span class="sxs-lookup"><span data-stu-id="8b699-395">NX_DISABLE_UDP_TX_CHECKSUM</span></span> | <span data-ttu-id="8b699-396">정의된 경우 발신 UDP 패킷의 UDP 체크섬 계산을 사용하지 않도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-396">Defined, disables the UDP checksum computation on outgoing UDP packets.</span></span> <span data-ttu-id="8b699-397">네트워크 인터페이스 드라이버가 UDP 헤더 체크섬을 계산하여 데이터를 전송하기 전 IP 헤드에 값을 삽입할 수 있으며 애플리케이션이 IP 조각화 논리를 사용하도록 설정하지 않는 경우에 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-397">This is useful if the network interface driver is able to compute UDP header checksum and insert the value in the IP head before transmitting the data, and the application does not enable IP fragmentation logic.</span></span> |

## <a name="netx-version-id"></a><span data-ttu-id="8b699-398">NetX 버전 ID</span><span class="sxs-lookup"><span data-stu-id="8b699-398">NetX Version ID</span></span>

<span data-ttu-id="8b699-399">사용자 및 애플리케이션 소프트웨어 둘 다 런타임 중에 NetX의 현재 버전을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-399">The current version of NetX is available to both the user and the application software during runtime.</span></span> <span data-ttu-id="8b699-400">프로그래머는 **nx_port.h** 파일에서 NetX 버전을 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-400">The programmer can obtain the NetX version from the **nx_port.h** file.</span></span> <span data-ttu-id="8b699-401">또한 이 파일에는 해당 포트의 버전 기록이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-401">In addition, this file  contains a version history of the corresponding port.</span></span> <span data-ttu-id="8b699-402">애플리케이션 소프트웨어는 **_nx_port.h_** 에서 전역 문자열 **_nx_version_id** 를 검사하여 NetX 버전을 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-402">Application software can obtain the NetX version by examining the global string **_nx_version_id** in **_nx_port.h_**.</span></span>  

<span data-ttu-id="8b699-403">애플리케이션 소프트웨어는 ***nx_api.h***에 정의되어 있는 아래에 표시된 상수에서 릴리스 정보를 가져올 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-403">Application software can also obtain release information from the constants shown below, which are defined in \***nx_api.h**.\*</span></span>

<span data-ttu-id="8b699-404">이러한 상수는 이름과 제품 주 버전 및 부 버전별로 현재 제품 릴리스를 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="8b699-404">These constants identify the current product release by name and the product major and minor version.</span></span>

```c
#define EL_PRODUCT_NETX

#define NETX_MAJOR_VERSION

#define NETX_MINOR_VERSION
```