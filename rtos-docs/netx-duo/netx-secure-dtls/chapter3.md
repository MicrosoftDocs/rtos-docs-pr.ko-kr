---
title: 챕터 3 - Azure RTOS NetX Secure DTLS의 기능 설명
description: 이 챕터에는 Azure RTOS NetX Secure DTLS에 대한 기능 설명이 포함되어 있습니다.
author: philmea
ms.author: philmea
ms.date: 06/04/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 347bd83fa8c72ced2e8678a92ec5c5f8393c136d
ms.sourcegitcommit: 60ad844b58639d88830f2660ab0c4ff86b92c10f
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/07/2021
ms.locfileid: "106550204"
---
# <a name="chapter-3-functional-description-of-azure-rtos-netx-secure-dtls"></a><span data-ttu-id="5739e-103">챕터 3: Azure RTOS NetX Secure DTLS의 기능 설명</span><span class="sxs-lookup"><span data-stu-id="5739e-103">Chapter 3: Functional description of Azure RTOS NetX Secure DTLS</span></span>

## <a name="execution-overview"></a><span data-ttu-id="5739e-104">실행 개요</span><span class="sxs-lookup"><span data-stu-id="5739e-104">Execution Overview</span></span>

<span data-ttu-id="5739e-105">이 챕터에는 Azure RTOS NetX Secure DTLS에 대한 기능 설명이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-105">This chapter contains a functional description of Azure RTOS NetX Secure DTLS.</span></span> <span data-ttu-id="5739e-106">NetX Secure DTLS 애플리케이션에는 초기화 및 애플리케이션 인터페이스 호출이라는 두 가지 주요 프로그램 실행 형식이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-106">There are two primary types of program execution in a NetX Secure DTLS application: initialization and application interface calls.</span></span> 

<span data-ttu-id="5739e-107">NetX Secure는 ThreadX 및 NetX/NetXDuo가 있다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-107">NetX Secure assumes the existence of ThreadX and NetX/NetXDuo.</span></span> <span data-ttu-id="5739e-108">ThreadX에서 스레드 실행, 일시 중단, 주기적인 타이머 및 상호 제외 기능이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-108">From ThreadX, it requires thread execution, suspension, periodic timers, and mutual exclusion facilities.</span></span> <span data-ttu-id="5739e-109">NetX/NetXDuo에서는 UDP 및 IP 네트워킹 기능과 드라이버가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-109">From NetX/NetXDuo it requires the UDP and IP networking facilities and drivers.</span></span>

## <a name="datagram-transport-layer-security-dtls-and-transport-layer-security-tls"></a><span data-ttu-id="5739e-110">DTLS(데이터그램 전송 계층 보안) 및 TLS(전송 계층 보안)</span><span class="sxs-lookup"><span data-stu-id="5739e-110">Datagram Transport Layer Security (DTLS) and Transport Layer Security (TLS)</span></span>

<span data-ttu-id="5739e-111">NetX Secure DTLS는 RFC 6347에 정의된 데이터그램 전송 계층 보안 프로토콜 버전 1.2를 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-111">NetX Secure DTLS implements the Datagram Transport Layer Security protocol version 1.2 defined in RFC 6347.</span></span> <span data-ttu-id="5739e-112">DTLS 버전 1.0은 RFC 4347에서 정의되었으며 TLS 버전 1.1에 해당합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-112">DTLS version 1.0 was defined in RFC 4347 and corresponded to TLS version 1.1.</span></span> <span data-ttu-id="5739e-113">DTLS는 기본적으로 TLS의 확장이므로 다음 버전에서 해당 TLS 버전과 동일한 버전 번호를 사용하도록 결정되었습니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-113">Due to DTLS being essentially an extension to TLS, it was decided that the next version would use the same version number as the corresponding TLS version.</span></span> <span data-ttu-id="5739e-114">따라서 DTLS 버전 1.2가 TLS 버전 1.2에 해당하므로 DTLS 버전 1.1은 없습니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-114">Thus, there is no DTLS version 1.1 as DTLS version 1.2 corresponds to TLS version 1.2.</span></span>

> [!NOTE]
> <span data-ttu-id="5739e-115">NetX Secure는 DTLS 버전 1.2를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-115">NetX Secure supports DTLS version 1.2.</span></span> <span data-ttu-id="5739e-116">DTLS 1.0(RFC 4347)은 현재 지원되지 **않습니다**.</span><span class="sxs-lookup"><span data-stu-id="5739e-116">DTLS 1.0 (RFC 4347) is **not** currently supported.</span></span>

<span data-ttu-id="5739e-117">SSL(*Secure Sockets Layer*)은 RFC 2246에서 표준이 되기 전 TLS의 원래 이름이며 "SSL"이 TLS 프로토콜의 일반적인 이름으로 사용되는 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-117">*Secure Sockets Layer* (SSL) was the original name of TLS before it became a standard in RFC 2246 and “SSL” is often used as a generic name for the TLS protocols.</span></span> <span data-ttu-id="5739e-118">SSL의 마지막 버전은 3.0이고 TLS 1.0을 SSL 버전 3.1이라고 하는 경우도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-118">The last version of SSL was 3.0, and TLS 1.0 is sometimes referred to as SSL version 3.1.</span></span> <span data-ttu-id="5739e-119">공식 "SSL" 프로토콜의 모든 버전은 더 이상 사용되지 않고 안전하지 않은 것으로 간주되며 현재 NetX Secure는 SSL 구현을 제공하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-119">All versions of the official “SSL” protocol are considered obsolete and insecure and currently NetX Secure does not provide an SSL implementation.</span></span>

<span data-ttu-id="5739e-120">TLS는 TLS 클라이언트와 서버 간의 TLS *핸드셰이크* 중에 만들어지는 *세션 키* 를 생성하는 프로토콜을 지정하며, 이러한 키는 TLS *세션* 중에 애플리케이션에서 보낸 데이터를 암호화하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-120">TLS specifies a protocol to generate *session keys* which are created during the TLS *handshake* between a TLS client and server and those keys are used to encrypt data sent by the application during the TLS *session.*</span></span>

<span data-ttu-id="5739e-121">기본 보안 메커니즘을 프로토콜 간에 공유하므로 DTLS가 TLS와 긴밀하게 결합되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-121">DTLS is closely coupled with TLS, as the underlying security mechansims are shared between the protocols.</span></span> <span data-ttu-id="5739e-122">그러나 TLS는 패킷 전송 및 순서를 보장하는 전송 계층 프로토콜(실제로는 거의 항상 TCP)을 통해 작동하도록 설계되었으며 UDP처럼 신뢰할 수 없는 프로토콜에서는 작동하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-122">However, TLS is designed to work over a transport layer protocol that provides guarantees about packet delivery and order (almost always TCP in practice) and will not function over an unreliable protocol like UDP.</span></span> <span data-ttu-id="5739e-123">정확하게 말하자면, DTLS가 도입된 UDP 때문입니다. DTLS는 UDP 및 유사한 프로토콜의 신뢰할 수 없는 특성을 처리하도록 설계되었습니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-123">It is precisely because of UDP that DTLS was introduced: DTLS was designed handle the unreliable nature of UDP and similar protocols.</span></span> <span data-ttu-id="5739e-124">이를 위해 TCP처럼 신뢰할 수 있는 프로토콜과 비슷하게 순서 및 안정성 논리(예: 삭제된 데이터 재전송)를 포함시킵니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-124">It does this by including ordering and reliability logic (e.g. retransmission of dropped data) similar to reliable protocols like TCP.</span></span>

<span data-ttu-id="5739e-125">TLS에 대한 전체 설명은 NetX Secure TLS 사용자 가이드의 챕터 3에 포함되어 있으며, 이 문서에서는 TLS와 DTLS의 차이점을 집중적으로 다룹니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-125">A complete discussion of TLS is included in Chapter 3 of the NetX Secure TLS User’s Guide, so this document will focus on the differences between TLS and DTLS.</span></span>

### <a name="dtls-record-header"></a><span data-ttu-id="5739e-126">DTLS 레코드 헤더</span><span class="sxs-lookup"><span data-stu-id="5739e-126">DTLS Record header</span></span>

<span data-ttu-id="5739e-127">그림 1처럼 유효한 모든 DTLS 레코드에는 DTLS 헤더가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-127">Any valid DTLS record must have a DTLS header, as shown in Figure 1.</span></span> <span data-ttu-id="5739e-128">헤더는 TLS와 동일하며 아래 설명처럼 16비트 *epoch* 필드 및 48비트 *시퀀스 번호* 필드가 새로 추가되었습니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-128">The header is the same as TLS with the addition of two new fields: the 16-bit *epoch* and the 48-bit *sequence number*, described below.</span></span>

![DTLS 레코드 헤더의 다이어그램](media/image2.png)

<span data-ttu-id="5739e-130">**그림 1 - DTLS 레코드 헤더**</span><span class="sxs-lookup"><span data-stu-id="5739e-130">**Figure 1 - DTLS record header**</span></span>

<span data-ttu-id="5739e-131">TLS 레코드 헤더의 필드는 다음과 같이 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-131">The fields of the TLS record header are defined as follows:</span></span>

| <span data-ttu-id="5739e-132">TLS 헤더 필드</span><span class="sxs-lookup"><span data-stu-id="5739e-132">TLS Header Field</span></span> | <span data-ttu-id="5739e-133">목적</span><span class="sxs-lookup"><span data-stu-id="5739e-133">Purpose</span></span>  |
| ---------------- | --------- |
| <span data-ttu-id="5739e-134">**8비트 메시지 유형**</span><span class="sxs-lookup"><span data-stu-id="5739e-134">**8-bit Message Type**</span></span> | <span data-ttu-id="5739e-135">이 필드에는 전송되는 DTLS 레코드 형식이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-135">This field contains the type of DTLS record being sent.</span></span> <span data-ttu-id="5739e-136">유효한 형식은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-136">Valid types are as follows:</span></span><br /><span data-ttu-id="5739e-137">- ChangeCipherSpec: 0x14</span><span class="sxs-lookup"><span data-stu-id="5739e-137">- ChangeCipherSpec: 0x14</span></span><br /><span data-ttu-id="5739e-138">- 경고: 0x15</span><span class="sxs-lookup"><span data-stu-id="5739e-138">- Alert: 0x15</span></span><br /><span data-ttu-id="5739e-139">- 핸드셰이크: 0x16</span><span class="sxs-lookup"><span data-stu-id="5739e-139">- Handshake: 0x16</span></span><br /><span data-ttu-id="5739e-140">- 애플리케이션 데이터: 0x17</span><span class="sxs-lookup"><span data-stu-id="5739e-140">- Application Data: 0x17</span></span><br /> |
| <span data-ttu-id="5739e-141">**16비트 프로토콜 버전**</span><span class="sxs-lookup"><span data-stu-id="5739e-141">**16-bit Protocol Version**</span></span> | <span data-ttu-id="5739e-142">이 필드에는 DTLS 프로토콜 버전이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-142">This field contains the DTLS protocol version.</span></span> <span data-ttu-id="5739e-143">유효한 값은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-143">Valid values are as follows:</span></span><br /><span data-ttu-id="5739e-144">- DTLS 1.1: 0xFEFD</span><span class="sxs-lookup"><span data-stu-id="5739e-144">- DTLS 1.1: 0xFEFD</span></span> |
|  <span data-ttu-id="5739e-145">**16비트 Epoch**</span><span class="sxs-lookup"><span data-stu-id="5739e-145">**16-bit Epoch**</span></span> |  <span data-ttu-id="5739e-146">이 필드에는 암호화 상태가 바뀔 때마다(예: 새 세션 키를 생성하는 경우) 증가하는 카운터인 DTLS "epoch"가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-146">This field contains the DTLS “epoch” which is a counter that is incremented each time the encryption state is changed (e.g. when generating new session keys).</span></span>  |
|  <span data-ttu-id="5739e-147">**48비트 시퀀스 번호**</span><span class="sxs-lookup"><span data-stu-id="5739e-147">**48-bit Sequence Number**</span></span> |  <span data-ttu-id="5739e-148">이 필드에는 특정 레코드를 식별하는 시퀀스 번호가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-148">This field contains a sequence number which identifies this particular record.</span></span> <span data-ttu-id="5739e-149">DTLS에서 레코드 순서를 유지하고 재전송이 필요한지 확인하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-149">It is used by DTLS to maintain record ordering and check for retransmission need.</span></span> |
|  <span data-ttu-id="5739e-150">**16비트 길이**</span><span class="sxs-lookup"><span data-stu-id="5739e-150">**16-bit Length**</span></span> |  <span data-ttu-id="5739e-151">이 필드에는 DTLS 레코드에 캡슐화된 데이터의 길이가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-151">This field contains the length of the data encapsulated in the DTLS record.</span></span>  |

### <a name="dtls-handshake-record-header"></a><span data-ttu-id="5739e-152">DTLS 핸드셰이크 레코드 헤더</span><span class="sxs-lookup"><span data-stu-id="5739e-152">DTLS Handshake Record header</span></span>

<span data-ttu-id="5739e-153">그림 2처럼 유효한 모든 DTLS 핸드셰이크 레코드에는 DTLS 핸드셰이크 헤더가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-153">Any valid DTLS handshake record must have a DTLS Handshake header, as shown in Figure 2.</span></span>

![DTLS 핸드셰이크 레코드 헤더의 다이어그램](media/image3.png)

<span data-ttu-id="5739e-155">**그림 2 - DTLS 핸드셰이크 레코드 헤더**</span><span class="sxs-lookup"><span data-stu-id="5739e-155">**Figure 2 - DTLS Handshake record header**</span></span>

<span data-ttu-id="5739e-156">DTLS 핸드셰이크 레코드 헤더의 필드는 다음과 같이 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-156">The fields of the DTLS Handshake record header are defined as follows:</span></span>

| <span data-ttu-id="5739e-157">TLS 헤더 필드</span><span class="sxs-lookup"><span data-stu-id="5739e-157">TLS Header Field</span></span> | <span data-ttu-id="5739e-158">목적</span><span class="sxs-lookup"><span data-stu-id="5739e-158">Purpose</span></span>  |
| ---------------- | ------------------------------------------------ |
| <span data-ttu-id="5739e-159">**8비트 메시지 유형**</span><span class="sxs-lookup"><span data-stu-id="5739e-159">**8-bit Message Type**</span></span> | <span data-ttu-id="5739e-160">이 필드에는 전송되는 DTLS 레코드 형식이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-160">This field contains the type of DTLS record being sent.</span></span> <span data-ttu-id="5739e-161">유효한 형식은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-161">Valid types are as follows:</span></span><br /><span data-ttu-id="5739e-162">- ChangeCipherSpec: 0x14</span><span class="sxs-lookup"><span data-stu-id="5739e-162">- ChangeCipherSpec: 0x14</span></span><br /><span data-ttu-id="5739e-163">- 경고: 0x15</span><span class="sxs-lookup"><span data-stu-id="5739e-163">- Alert: 0x15</span></span><br /><span data-ttu-id="5739e-164">- 핸드셰이크: 0x16</span><span class="sxs-lookup"><span data-stu-id="5739e-164">- Handshake: 0x16</span></span><br /><span data-ttu-id="5739e-165">- 애플리케이션 데이터: 0x17</span><span class="sxs-lookup"><span data-stu-id="5739e-165">- Application Data: 0x17</span></span> |
|  <span data-ttu-id="5739e-166">**16비트 Epoch**</span><span class="sxs-lookup"><span data-stu-id="5739e-166">**16-bit Epoch**</span></span> | <span data-ttu-id="5739e-167">이 필드에는 암호화 상태가 바뀔 때마다(예: 새 세션 키를 생성하는 경우) 증가하는 카운터인 DTLS "epoch"가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-167">This field contains the DTLS “epoch” which is a counter that is incremented each time the encryption state is changed (e.g. when generating new session keys).</span></span> |
|  <span data-ttu-id="5739e-168">**48비트 시퀀스 번호**</span><span class="sxs-lookup"><span data-stu-id="5739e-168">**48-bit Sequence Number**</span></span> | <span data-ttu-id="5739e-169">이 필드에는 특정 레코드를 식별하는 시퀀스 번호가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-169">This field contains a sequence number which identifies this particular record.</span></span> <span data-ttu-id="5739e-170">DTLS에서 레코드 순서를 유지하고 재전송이 필요한지 확인하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-170">It is used by DTLS to maintain record ordering and check for retransmission need.</span></span> |
|  <span data-ttu-id="5739e-171">**16비트 프로토콜 버전**</span><span class="sxs-lookup"><span data-stu-id="5739e-171">**16-bit Protocol Version**</span></span> | <span data-ttu-id="5739e-172">이 필드에는 DTLS 프로토콜 버전이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-172">This field contains the DTLS protocol version.</span></span> <span data-ttu-id="5739e-173">유효한 값은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-173">Valid values are as follows:</span></span><br /><span data-ttu-id="5739e-174">- DTLS 1.1: 0xFEFD</span><span class="sxs-lookup"><span data-stu-id="5739e-174">- DTLS 1.1: 0xFEFD</span></span> |
| <span data-ttu-id="5739e-175">**16비트 길이**</span><span class="sxs-lookup"><span data-stu-id="5739e-175">**16-bit Length**</span></span> | <span data-ttu-id="5739e-176">이 필드에는 DTLS 레코드에 캡슐화된 데이터의 길이가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-176">This field contains the length of the data encapsulated in the DTLS record.</span></span> |
| <span data-ttu-id="5739e-177">**8비트 핸드셰이크 유형**</span><span class="sxs-lookup"><span data-stu-id="5739e-177">**8-bit Handshake Type**</span></span> | <span data-ttu-id="5739e-178">이 필드는 핸드셰이크 메시지 유형을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-178">This field contains the handshake message type.</span></span> <span data-ttu-id="5739e-179">유효한 값은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-179">Valid values are as follows:</span></span><br /><span data-ttu-id="5739e-180">- HelloRequest: 0x00</span><span class="sxs-lookup"><span data-stu-id="5739e-180">- HelloRequest: 0x00</span></span><br /><span data-ttu-id="5739e-181">- ClientHello: 0x01</span><span class="sxs-lookup"><span data-stu-id="5739e-181">- ClientHello: 0x01</span></span><br /><span data-ttu-id="5739e-182">- ServerHello: 0x02</span><span class="sxs-lookup"><span data-stu-id="5739e-182">- ServerHello: 0x02</span></span><br /><span data-ttu-id="5739e-183">- Certificate: 0x0B</span><span class="sxs-lookup"><span data-stu-id="5739e-183">- Certificate: 0x0B</span></span><br /><span data-ttu-id="5739e-184">- ServerKeyExchange: 0x0C</span><span class="sxs-lookup"><span data-stu-id="5739e-184">- ServerKeyExchange: 0x0C</span></span><br /><span data-ttu-id="5739e-185">- CertificateRequest: 0x0D</span><span class="sxs-lookup"><span data-stu-id="5739e-185">- CertificateRequest: 0x0D</span></span><br /><span data-ttu-id="5739e-186">- ServerHelloDone: 0x0E</span><span class="sxs-lookup"><span data-stu-id="5739e-186">- ServerHelloDone: 0x0E</span></span><br /><span data-ttu-id="5739e-187">- CertificateVerify: 0x0F</span><span class="sxs-lookup"><span data-stu-id="5739e-187">- CertificateVerify: 0x0F</span></span><br /><span data-ttu-id="5739e-188">- ClientKeyExchange: 0x10</span><span class="sxs-lookup"><span data-stu-id="5739e-188">- ClientKeyExchange: 0x10</span></span><br /><span data-ttu-id="5739e-189">- Finished: 0x14</span><span class="sxs-lookup"><span data-stu-id="5739e-189">- Finished: 0x14</span></span> |
| <span data-ttu-id="5739e-190">**24비트 길이**</span><span class="sxs-lookup"><span data-stu-id="5739e-190">**24-bit Length**</span></span> | <span data-ttu-id="5739e-191">이 필드는 핸드셰이크 메시지 데이터의 길이를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-191">This field contains the length of the handshake message data.</span></span> |
| <span data-ttu-id="5739e-192">**16비트 시퀀스 번호**</span><span class="sxs-lookup"><span data-stu-id="5739e-192">**16-bit Sequence Number**</span></span> | <span data-ttu-id="5739e-193">이 필드에는 시퀀스 번호가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-193">This field contains a sequence number.</span></span> |

### <a name="the-dtls-handshake-and-dtls-session"></a><span data-ttu-id="5739e-194">DTLS 핸드셰이크 및 DTLS 세션</span><span class="sxs-lookup"><span data-stu-id="5739e-194">The DTLS Handshake and DTLS Session</span></span>

<span data-ttu-id="5739e-195">그림 3은 일반적인 DTLS 핸드셰이크입니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-195">A typical DTLS handshake is shown in Figure 3.</span></span> <span data-ttu-id="5739e-196">일반적인 TLS 핸드셰이크와 거의 같지만 결정적인 차이점이 있습니다. ClientHello 메시지가 처음으로 전송되면 서버에서는 "쿠키"가 포함된 새 DTLS 관련 메시지인 *HelloVerifyRequest* 로 응답합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-196">It is nearly identical to the typical TLS handshake with an important difference – when the ClientHello message is first sent, the server responds with a new DTLS-specific message, *HelloVerifyRequest* which contains a “cookie”.</span></span> <span data-ttu-id="5739e-197">DTLS 클라이언트에서는 핸드셰이크를 진행하려면 해당 쿠키가 포함된 두 번째 ClientHello 메시지로 응답해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-197">The DTLS Client must respond with a second ClientHello message containing that cookie before the handshake can proceed.</span></span> <span data-ttu-id="5739e-198">UDP가 비연결형 프로토콜이므로 특정 DoS(서비스 거부) 공격을 방지하기 위해 이 메커니즘이 DTLS에 추가되었습니다(TCP는 전용 연결/포트가 필요하므로 TLS에서는 동일한 문제가 발생하지 않음).</span><span class="sxs-lookup"><span data-stu-id="5739e-198">This mechanism was added to DTLS to prevent certain Denial of Service (DoS) attacks since UDP is a connectionless protocol (TCP requires a dedicated connection/port so TLS does not suffer from the same issue).</span></span>

<span data-ttu-id="5739e-199">DTLS 핸드셰이크는 클라이언트에서 DTLS 서버에 *ClientHello* 메시지를 보내서 DTLS 세션을 시작하려 한다는 의도를 알릴 때 시작됩니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-199">A DTLS handshake begins when the Client sends a *ClientHello* message to a DTLS server, indicating its desire to start a DTLS session.</span></span> <span data-ttu-id="5739e-200">이 메시지에는 클라이언트가 세션에 사용할 암호화에 대한 정보와 함께 나중에 핸드셰이크에서 세션 키를 생성하는 데 사용되는 정보가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-200">The message contains information about the encryption the client would like to use for the session, along with information used to generate the session keys later in the handshake.</span></span> <span data-ttu-id="5739e-201">세션 키가 생성될 때까지 DTLS 핸드셰이크의 모든 메시지는 암호화되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-201">Until the session keys are generated, all messages in the DTLS handshake are not encrypted.</span></span> <span data-ttu-id="5739e-202">위에서 언급했듯이, DTLS 서버는 ClientHello에 대한 응답으로 HelloVerifyRequest를 전송하여 클라이언트가 두 번째 업데이트된 ClientHello로 응답하도록 강제할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-202">As mentioned above, the DTLS Server may send a HelloVerifyRequest in response to the ClientHello, forcing the client to respond with a second updated ClientHello.</span></span>

<span data-ttu-id="5739e-203">두 번째 ClientHello 메시지가 수신되면 DTLS 서버는 쿠키를 확인하고, 쿠키가 올바른 경우 클라이언트에서 제공하는 암호화 옵션의 선택 항목을 나타내는 ServerHello 메시지로 응답합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-203">Upon receiving the second ClientHello message, the DTLS Server will verify the cookie and if correct will respond with a ServerHello message indicating a selection from the encryption options provided by the client.</span></span> <span data-ttu-id="5739e-204">ServerHello 뒤에는 Certificate 메시지가 오며, 여기에는 클라이언트에서 서버의 ID를 인증하기 위해 서버가 제공하는 디지털 인증서가 포함됩니다(X.509 확인을 사용하는 경우).</span><span class="sxs-lookup"><span data-stu-id="5739e-204">The ServerHello is followed by a Certificate message, in which the server provides a digital certificate to authenticate its identity to the client (if X.509 verification is used).</span></span> <span data-ttu-id="5739e-205">마지막으로 서버는 ServerHelloDone 메시지를 보내서 더 이상 보낼 메시지가 없음을 알립니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-205">Finally, the server sends a ServerHelloDone message to indicate it has no more messages to send.</span></span> <span data-ttu-id="5739e-206">서버에서는 필요하다면 ServerHello 다음에 다른 메시지를 보낼 수도 있고, 경우에 따라 Certificate 메시지를 보내지 않을 수도 있기 때문에(예: 미리 공유한 키가 사용되는 경우) ServerHelloDone 메시지가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-206">The server may optionally send other messages following the ServerHello and in some cases it may not send a Certificate message (such as when Pre-Shared Keys are used), hence the need for the ServerHelloDone message.</span></span>

<span data-ttu-id="5739e-207">클라이언트가 서버의 모든 메시지를 수신하면 세션 키를 생성하기에 충분한 정보를 갖게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-207">Once the client has received all the server’s messages, it has enough information to generate the session keys.</span></span> <span data-ttu-id="5739e-208">TLS/DTLS는 고정 크기이며 암호화가 활성화되면 필요한 모든 키를 생성하기 위해 시드로 사용되는 *Pre-Master Secret* 이라는 임의 데이터의 공유 비트를 생성하여 이 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-208">TLS/DTLS does this by creating a shared bit of random data called the *Pre-Master Secret*, which is a fixed-size and is used as a seed to generate all the keys needed once encryption is enabled.</span></span> <span data-ttu-id="5739e-209">Pre-Master Secret은 Hello 메시지에 지정된 공개 키 알고리즘(예: RSA)(공개 키 알고리즘에 대한 자세한 내용은 아래 참조) 및 서버가 인증서에서 제공한 공개 키를 사용하여 암호화됩니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-209">The Pre-Master Secret is encrypted using the public key algorithm (e.g. RSA) specified in the Hello messages (see below for information on public key algorithms) and the public key provided by the server in its certificate.</span></span> <span data-ttu-id="5739e-210">PSK(미리 공유한 키)라는 선택적 TLS/DTLS 기능을 사용하면 인증서를 사용하는 대신 호스트 간에 공유되는 비밀 값(일반적으로 물리적 전송 또는 기타 보안 방법을 통해)을 사용하는 암호 그룹을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-210">An optional TLS/DTLS feature called Pre-Shared Keys (PSK) enables ciphersuites that do not use a certificate but instead use a secret value shared between the hosts (usually through physical transfer or other secured method).</span></span> <span data-ttu-id="5739e-211">PSK를 사용하면 미리 공유한 비밀 키를 사용하여 Pre-Master Secret이 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-211">When PSK is enabled, the pre-shared secret key is used to generate the Pre-Master Secret.</span></span> <span data-ttu-id="5739e-212">아래의 "인증 방법"에서 미리 공유한 키 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="5739e-212">See the section on Pre-Shared Keys in “Authentication Methods” below.</span></span>

<span data-ttu-id="5739e-213">일반적인 TLS/DTLS 핸드셰이크에서, 암호화된 Pre-Master Secret은 ClientKeyExchange 메시지에 포함되어 서버로 전송됩니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-213">In a usual TLS/DTLS handshake, the encrypted Pre-Master Secret is sent to the server in the ClientKeyExchange message.</span></span> <span data-ttu-id="5739e-214">서버에서는 ClientKeyExchange 메시지를 받으면 자체 프라이빗 키를 사용하여 Pre-Master Secret을 해독하고 TLS/DTLS 클라이언트와 병렬로 세션 키 생성을 진행합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-214">The server, upon receiving the ClientKeyExchange message, decrypts the Pre-Master Secret using its private key and proceeds to generate the session keys in parallel with the TLS/DTLS client.</span></span>

<span data-ttu-id="5739e-215">세션 키가 생성되면 Hello 메시지에서 선택한 프라이빗 키 알고리즘(예: AES)을 사용하여 모든 추가 메시지를 암호화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-215">Once the session keys are generated, all further messages can be encrypted using the private-key algorithm (e.g. AES) selected in the Hello messages.</span></span> <span data-ttu-id="5739e-216">클라이언트와 서버 모두에서 ChangeCipherSpec이라는 암호화되지 않은 마지막 메시지 하나를 보내서 모든 추가 메시지가 암호화된다는 것을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-216">One final un-encrypted message called ChangeCipherSpec is sent by both the client and server to indicate that all further messages will be encrypted.</span></span>

<span data-ttu-id="5739e-217">클라이언트와 서버 모두에서 보낸 첫 번째 암호화된 메시지는 Finished라는 최종 TLS 핸드셰이크 메시지이기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-217">The first encrypted message sent by both the client and server is also the final TLS handshake message, called Finished.</span></span> <span data-ttu-id="5739e-218">이 메시지는 송수신한 모든 핸드셰이크 메시지의 해시를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-218">This message contains a hash of all the handshake messages received and sent.</span></span> <span data-ttu-id="5739e-219">이 해시는 핸드셰이크의 어떤 메시지도 변조되거나 손상(보안 위반 가능성을 나타냄)되지 않았다는 것을 확인하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-219">This hash is used to verify that none of the messages in the handshake have been tampered with or corrupted (indicating a possible breach of security).</span></span>

<span data-ttu-id="5739e-220">Finished 메시지를 받고 핸드셰이크 해시가 확인되면, TLS/DTLS 세션이 시작되고 애플리케이션은 데이터 송수신을 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-220">Once the Finished messages are received and the handshake hashes are verified, the TLS/DTLS session begins, and the application begins sending and receiving data.</span></span> <span data-ttu-id="5739e-221">TLS/DTLS 세션 중에 양쪽에서 전송된 모든 데이터는 먼저 Hello 메시지에서 선택한 해시 알고리즘을 사용하여 해시되고(메시지 무결성을 제공하기 위해) 생성된 세션 키와 함께 선택한 프라이빗 키 알고리즘을 사용하여 암호화됩니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-221">All data sent by either side during the TLS/DTLS session is first hashed using the hash algorithm chosen in the Hello messages (to provide message integrity) and encrypted using the chosen private-key algorithm with the generated session keys.</span></span>

<span data-ttu-id="5739e-222">마지막으로, TLS/DTLS 세션은 클라이언트나 서버에서 종료하기로 선택하는 경우에만 성공적으로 종료될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-222">Finally, a TLS/DTLS session can only be successfully ended if either the Client or Server chooses to do so.</span></span> <span data-ttu-id="5739e-223">잘린 세션은 보안 위반으로 간주되며(모든 송신 데이터가 수신되는 것을 공격자가 막으려고 시도할 수 있기 때문에) 따라서 둘 중 한쪽에서 세션을 종료하려고 하면 CloseNotify 경고라는 특별한 알림이 전송됩니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-223">A truncated session is considered a security breach (since an attacker may be attempting to prevent all the data being sent from being received) so a special notification is sent when either side wants to end the session, called a CloseNotify alert.</span></span> <span data-ttu-id="5739e-224">세션 종료에 성공하려면 클라이언트와 서버 모두 CloseNotify 경고를 보내고 처리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-224">Both the client and server must send and process a CloseNotify alert for a successful session shutdown.</span></span>

![일반적인 DTLS 핸드셰이크 세션의 다이어그램](media/image4.png)

<span data-ttu-id="5739e-226">**그림 3 - 일반적인 DTLS 핸드셰이크**</span><span class="sxs-lookup"><span data-stu-id="5739e-226">**Figure 3- Typical DTLS handshake**</span></span>

### <a name="initialization"></a><span data-ttu-id="5739e-227">초기화</span><span class="sxs-lookup"><span data-stu-id="5739e-227">Initialization</span></span>

<span data-ttu-id="5739e-228">NetX Secure DTLS를 사용하기 전에 NetX 또는 NetXDuo 스택을 초기화해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-228">The NetX or NetXDuo stack must be initialized prior to using NetX Secure DTLS.</span></span> <span data-ttu-id="5739e-229">UDP 작업에 사용할 TCP/IP 스택을 제대로 초기화하는 방법에 대한 자세한 내용은 NetX 또는 NetXDuo 사용자 가이드를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="5739e-229">Refer to the NetX or NetXDuo User Guide for information on how to properly initialize the TCP/IP stack for UDP operation.</span></span>

<span data-ttu-id="5739e-230">NetX UDP가 초기화되면 DTLS를 사용하도록 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-230">Once NetX UDP has been initialized, DTLS can be enabled.</span></span> <span data-ttu-id="5739e-231">내부적으로 모든 DTLS 네트워크 트래픽 및 처리는 사용자의 개입 없이 NetX/NetXDuo 스택에서 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-231">Internally, all DTLS network traffic and processing is handled by the NetX/NetXDuo stack without requiring user intervention.</span></span> <span data-ttu-id="5739e-232">단, DTLS에는 기본 네트워크 스택과 별도로 처리해야 하는 요구 사항이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-232">However, DTLS has some specific requirements that must be handled separately from the underlying network stack.</span></span> <span data-ttu-id="5739e-233">DTLS 클라이언트 작업의 경우 \***NX_SECURE_DTLS_SESSION** _이라는 매개 변수가 DTLS 제어 블록에 할당됩니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-233">DTLS Client operation these parameters are assigned to the DTLS control block called \***NX_SECURE_DTLS_SESSION** _.</span></span> <span data-ttu-id="5739e-234">DTLS 서버 작업의 경우 제어 블록을 _ \*_NX_SECURE_DTLS_SERVER_\*\*라고 하며, 여기에는 단일 UDP 포트에서 여러 DTLS 세션을 처리하는 데 필요한 인프라가 포함되어 있습니다. 이는 각 TLS 세션이 단일 TCP 포트에 바인딩되는 TLS와 다른 점입니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-234">For DTLS Server operation, control block is called _ *_NX_SECURE_DTLS_SERVER_*\* and it contains the infrastructure needed to handle multiple DTLS sessions on a single UDP port – note that this is different from TLS where a each TLS session is bound to a single TCP port.</span></span>

<span data-ttu-id="5739e-235">DTLS의 두 가지 모드인 서버 모드 및 클라이언트 모드는 애플리케이션에서 활성화할 수 있으며(단, NetX 소켓당 한 가지 모드만 가능), 각 모드의 고유한 요구 사항이 아래에 자세히 설명되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-235">The two DTLS modes, Server and Client, may be enabled in an application (but only one mode per NetX socket), and each have their own specific requirements, detailed below.</span></span>

### <a name="initialization--dtls-server"></a><span data-ttu-id="5739e-236">초기화 – DTLS 서버</span><span class="sxs-lookup"><span data-stu-id="5739e-236">Initialization – DTLS Server</span></span>

<span data-ttu-id="5739e-237">NetX Secure DTLS 서버 모드는 기본 네트워크 전송 프로토콜에 UDP를 사용하기 때문에 TLS 서버 모드와 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-237">NetX Secure DTLS Server mode differs from TLS Server mode due to the use of UDP for the underlying network transport protocol.</span></span> <span data-ttu-id="5739e-238">TCP를 사용하는 경우 TLS 세션 동안 포트가 단일 원격 호스트에 바인딩됩니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-238">With TCP, the port is bound to a single remote host for the duration of the TLS session.</span></span> <span data-ttu-id="5739e-239">UDP는 원격 호스트와 관련된 개념이 없으므로 여러 호스트의 DTLS 요청을 동일한 UDP 인터페이스에서 모두 수신합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-239">UDP has no notion of state with regard to the remote host so DTLS requests from different hosts will all be received on the same UDP interface.</span></span> <span data-ttu-id="5739e-240">따라서 DTLS는 TLS 및 TCP를 사용하는 것처럼 소켓에 의존하지 말고 세션 상태를 유지해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-240">Therefore, DTLS must maintain session state rather than relying on the socket as with TLS and TCP.</span></span> <span data-ttu-id="5739e-241">이러한 이유로 DTLS 서버 제어 블록(NX_SECURE_DTLS_SERVER)은 원격 호스트 정보(IP 주소 및 포트)와 DTLS 세션의 매핑을 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-241">For this reason, the DTLS Server control block (NX_SECURE_DTLS_SERVER) maintains a mapping of remote host information (IP address and port) to DTLS sessions.</span></span> <span data-ttu-id="5739e-242">DTLS 서버에 할당된 UDP 소켓으로 들어오는 모든 데이터는 원격 호스트에 따라 기존 또는 새 DTLS 세션에 매핑됩니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-242">All incoming data on the UDP socket assigned to a DTLS Server will be mapped to an existing or new DTLS session based on the remote host.</span></span> <span data-ttu-id="5739e-243">이러한 이유로 DTLS 서버를 만들려면 TLS 및 DTLS 클라이언트에 필요한 것보다 많은 추가 매개 변수가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-243">For this reason, the DTLS server creation requires several additional parameters beyond what TLS and DTLS Client need.</span></span>

<span data-ttu-id="5739e-244">DTLS 서버 제어 블록, TLS ciphersuite 및 cipher scratchspace/metadata buffer 외에도 DTLS 서버에는 DTLS 세션을 유지하기 위한 버퍼와 수신 DTLS 레코드를 해독하는 데 사용되는 패킷 리어셈블리 버퍼가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-244">In addition to the DTLS Server control block, TLS ciphersuites, and cipher scratchspace/metadata buffer, DTLS Servers require a buffer to maintain DTLS sessions and a packet reassembly buffer used to decrypt incoming DTLS records.</span></span>

<span data-ttu-id="5739e-245">세션 버퍼 외에도 DTLS 서버에는 연결하는 TLS 클라이언트에서 TLS 서버를 식별하는 데 사용되는 문서인 *디지털 인증서* 와 인증서에 해당하는 *프라이빗 키*(일반적으로 RSA 암호화 알고리즘에 사용)가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-245">In addition to the session buffers, DTLS Servers require a *Digital Certificate*, which is a document used to identify the TLS server to the connecting TLS client, and the certificates corresponding *Private Key*, usually for the RSA encryption algorithm.</span></span> <span data-ttu-id="5739e-246">International Telecommunications Union X.509 표준은 TLS/DTLS에서 사용하는 인증서 형식을 지정하며 X.509 디지털 인증서를 만들 수 있는 다양한 유틸리티가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-246">The International Telecommunications Union X.509 standard specifies the certificate format used by TLS/DTLS and there are numerous utilities for creating X.509 digital certificates.</span></span>

<span data-ttu-id="5739e-247">NetX Secure DTLS의 경우 X.509 인증서는 DER(Distinguished Encoding Rules) 형식인 ASN.1을 사용하여 이진으로 인코딩해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-247">For NetX Secure DTLS, the X.509 certificate must be binary-encoded using the Distinguished Encoding Rules (DER) format of ASN.1.</span></span> <span data-ttu-id="5739e-248">DER은 인증서에 사용되는 표준 TLS 네트워크 이진 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-248">DER is the standard TLS over-the-wire binary format for certificates.</span></span>

<span data-ttu-id="5739e-249">제공된 인증서와 연결된 프라이빗 키는 DER 인코딩 PKCS#1 형식이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-249">The private key associated with the provided certificate must be in DER-Encoded PKCS#1 format.</span></span> <span data-ttu-id="5739e-250">프라이빗 키는 디바이스에서만 사용되며 네트워크를 통해 전송되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-250">The private key is only used on the device and will never be transmitted over the wire.</span></span> <span data-ttu-id="5739e-251">프라이빗 키는 TLS/DTLS 통신 보안에 중요하므로 안전하게 보관해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-251">Keep private keys safe as they provide the security for TLS/DTLS communications!</span></span>

<span data-ttu-id="5739e-252">DTLS 서버 인증서를 초기화하려면 애플리케이션에서 ***nx_secure_x509_certificate_intialize*** 서비스를 사용하여 DER 인코딩 X.509 인증서 및 선택적 DER 인코딩 PKCS#1 RSA 프라이빗 키 데이터를 포함하는 버퍼에 대한 포인터를 제공해야 합니다. 이 서비스는 **NX_SECURE_X509_CERT** 구조를 TLS에서 사용할 적절한 인증서 데이터로 채우는 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-252">To initialize the DTLS Server certificate, the application must provide a pointer to a buffer containing the DER-encoded X.509 certificate and optional DER-encoded PKCS#1 RSA private key data using the ***nx_secure_x509_certificate_intialize*** service, which populates the **NX_SECURE_X509_CERT** structure with the appropriate certificate data for use by TLS.</span></span>

<span data-ttu-id="5739e-253">서버 인증서가 초기화되면 ***nx_secure_dtls_server_local_certificate_add*** 서비스를 사용하여 TLS 제어 블록에 인증서를 추가해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-253">Once the server certificate has been initialized, it must be added to the TLS control block using the ***nx_secure_dtls_server_local_certificate_add*** service.</span></span>

<span data-ttu-id="5739e-254">서버 인증서가 DTLS 서버 제어 블록에 추가되면 보안 DTLS 통신에 서버를 사용할 수 있습니다(위 예제 참조).</span><span class="sxs-lookup"><span data-stu-id="5739e-254">Once the server’s certificate has been added to the DTLS Server control block, the server can be used for secure DTLS communications (see example above).</span></span>

### <a name="initialization--dtls-client"></a><span data-ttu-id="5739e-255">초기화 – DTLS 클라이언트</span><span class="sxs-lookup"><span data-stu-id="5739e-255">Initialization – DTLS Client</span></span>

<span data-ttu-id="5739e-256">NetX Secure DTLS 클라이언트 모드는 UDP 소켓을 통해 원격 호스트로 나가는 단일 연결만 있으므로 DTLS 서버에 비해 작업이 간단합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-256">NetX Secure DTLS Client mode is simple in operation compared to the DTLS server since there is only a single outgoing connection to the remote host over the UDP socket.</span></span>

<span data-ttu-id="5739e-257">DTLS 클라이언트를 설정하려면 신뢰할 수 있는 CA(인증 기관)의 X.509 인코딩 디지털 인증서 컬렉션인 *신뢰할 수 있는 인증서 저장소* 가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-257">To setup a DTLS Client, it requires a *Trusted Certificate Store*, which is a collection of X.509-encoded digital certificates from trusted Certificate Authorities (CA’s).</span></span> <span data-ttu-id="5739e-258">이러한 인증서는 DTLS 프로토콜이 "신뢰할 수 있는" 프로토콜로써 DTLS 서버 엔터티에서 제공하는 인증서를 NetX Secure DTLS 클라이언트 애플리케이션에 인증하기 위한 기본으로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-258">These certificates are assumed by the DTLS protocol to be “trusted” and serve as the basis for authenticating certificates provided by DTLS server entities to the NetX Secure DTLS Client application.</span></span>

<span data-ttu-id="5739e-259">신뢰할 수 있는 CA 인증서는 *자체 서명* 되는 경우도 있고 다른 CA에서 서명하는 경우도 있으며, 어떤 경우든 해당 인증서를 *ICA(중간 CA)* 라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-259">A trusted CA certificate may either be *self-signed* or signed by another CA, in which case that certificate is called an *Intermediate CA* (ICA).</span></span> <span data-ttu-id="5739e-260">일반적인 TLS/DTLS 애플리케이션에서 서버는 해당 서버 인증서와 함께 ICA 인증서를 제공하지만, 인증이 성공하기 위한 유일한 요구 사항은 발급자 체인(다른 인증서에 서명하는 데 사용되는 인증서)을 서버 인증서에서 신뢰할 수 있는 인증서 저장소의 신뢰할 수 있는 CA 인증서까지 추적할 수 있어야 한다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-260">In a typical TLS/DTLS application, the server provides the ICA certificates along with its server certificate, but the only requirement for successful authentication is that a chain of issuers (certificates used to sign other certificates) can be traced from the server certificate back to a trusted CA certificate in the Trusted Certificate Store.</span></span> <span data-ttu-id="5739e-261">이 체인을 *신뢰 체인* 또는 *인증서 체인* 이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-261">This chain is known as a *chain of trust* or *certificate chain*.</span></span>

<span data-ttu-id="5739e-262">신뢰할 수 있는 CA 또는 ICA 인증서를 초기화하려면 애플리케이션에서 ***nx_secure_x509_certificate_intialize** _ 서비스를 사용하여 DER 인코딩 X.509 인증서를 포함하는 버퍼에 대한 포인터를 제공해야 합니다. 이 서비스는 _ *NX_SECURE_X509_CERT** 구조를 TLS에서 사용할 적절한 인증서 데이터로 채우는 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-262">To initialize a trusted CA or ICA certificate, the application must provide a pointer to a buffer containing the DER-encoded X.509 certificate using the ***nx_secure_x509_certificate_intialize** _ service, which populates the _ *NX_SECURE_X509_CERT** structure with the appropriate certificate data for use by TLS.</span></span>

<span data-ttu-id="5739e-263">또한 DTLS 클라이언트는 들어오는 서버 인증서를 할당할 공간(미리 공유한 키 모드를 사용하지 않는다고 가정) 및 패킷을 암호 해독할 DTLS 레코드로 어셈블하기 위한 버퍼가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-263">The DTLS Client also needs space for the incoming server certificate to be allocated (assuming a Pre-Shared Key mode is not being used) and a buffer for assembling packets into DTLS records to be decrypted.</span></span> <span data-ttu-id="5739e-264">이러한 버퍼는 ***nx_secure_dtls_session_create*** 서비스에 매개 변수로 전달됩니다(자세한 내용은 API 참조에서 확인).</span><span class="sxs-lookup"><span data-stu-id="5739e-264">These buffers are passed in as parameters to the ***nx_secure_dtls_session_create*** service (see API reference for more information).</span></span>

<span data-ttu-id="5739e-265">그러면 초기화된 신뢰할 수 있는 인증서가 ***nx_secure_dtls_session_trusted_certificate_add*** 서비스를 사용하여 만든 DTLS 세션 제어 블록에 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-265">Trusted certificates that have been initialized are then added to the created DTLS session control block using the ***nx_secure_dtls_session_trusted_certificate_add*** service.</span></span> <span data-ttu-id="5739e-266">인증서를 추가하지 못하면 DTLS 프로토콜이 원격 서버 호스트를 인증할 방법이 없기 때문에 DTLS 클라이언트 세션이 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-266">Failure to add a certificate will cause the DTLS Client session to fail as there will be no way for the DTLS protocol to authenticate remote server hosts.</span></span>

<span data-ttu-id="5739e-267">신뢰할 수 있는 인증서 저장소를 만든 후에는 세션을 사용하여 보안 TLS 클라이언트 연결을 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-267">Once the Trusted Certificate Store has been created the session may be used to establish a secure TLS Client connection.</span></span>

### <a name="application-interface-calls"></a><span data-ttu-id="5739e-268">애플리케이션 인터페이스 호출</span><span class="sxs-lookup"><span data-stu-id="5739e-268">Application Interface Calls</span></span>

<span data-ttu-id="5739e-269">NetX Secure DTLS 애플리케이션은 일반적으로 ThreadX RTOS에서 실행되는 애플리케이션 스레드 내에서 함수 호출을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-269">NetX Secure DTLS applications will typically make function calls from within application threads running under the ThreadX RTOS.</span></span> <span data-ttu-id="5739e-270">일부 초기화, 특히 기본 네트워크 통신 프로토콜(예: UDP 및 IP)에 대한 초기화는 ***tx_application_define*** 에서 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-270">Some initialization, particularly for the underlying network communications protocols (e.g. UDP and IP) may be called from \***tx_application_define\*.**</span></span> <span data-ttu-id="5739e-271">네트워크 통신 초기화에 대한 자세한 내용은 NetX/NetXDuo 사용자 가이드를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="5739e-271">See the NetX/NetXDuo User Guide for more information on initializing network communications.</span></span>

<span data-ttu-id="5739e-272">DTLS는 프로세서 사용량이 많은 작업인 암호화 루틴을 많이 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-272">DTLS makes heavy use of encryption routines which are processor-intensive operations.</span></span> <span data-ttu-id="5739e-273">일반적으로 이러한 작업은 호출 스레드의 컨텍스트 내에서 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-273">Generally, these operations will be performed within the context of calling thread.</span></span>

### <a name="dtls-session-start"></a><span data-ttu-id="5739e-274">DTLS 세션 시작</span><span class="sxs-lookup"><span data-stu-id="5739e-274">DTLS Session Start</span></span>

<span data-ttu-id="5739e-275">DTLS가 작동하려면 기본 전송 계층 네트워크 프로토콜이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-275">DTLS requires an underlying transport-layer network protocol in order to function.</span></span> <span data-ttu-id="5739e-276">일반적으로 사용되는 프로토콜은 TCP입니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-276">The protocol typically used is TCP.</span></span> <span data-ttu-id="5739e-277">NetX Secure TLS 세션을 설정하려면 **NX_UDP_SOCKET** 을 만들어서 DTLS 클라이언트용 **_nx_secure_dtls_client_session_start_** 서비스에 전달해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-277">In order to establish a NetX Secure TLS session an **NX_UDP_SOCKET** must be created and passed into the **_nx_secure_dtls_client_session_start_** service for DTLS Clients.</span></span>

<span data-ttu-id="5739e-278">DTLS 서버는 다르게 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-278">DTLS Servers operate differently.</span></span> <span data-ttu-id="5739e-279">들어오는 DTLS 클라이언트 요청에 사용되는 UDP 소켓은 NX_SECURE_DTLS_SERVER 제어 블록에 포함되어 있으며 로컬 UDP 포트를 매개 변수로 사용하는 \***nx_secure_dtls_server_create** _ 호출에서 초기화됩니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-279">The UDP socket used for incoming DTLS Client requests is contained within the NX_SECURE_DTLS_SERVER control block and is initialized in the call to \***nx_secure_dtls_server_create** _, which takes the local UDP port as a parameter.</span></span> <span data-ttu-id="5739e-280">그 후 들어오는 요청을 처리하기 위해 _*_nx_secure_dtls_server_start_*_ 서비스를 사용하여 DTLS 서버를 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-280">The service _*_nx_secure_dtls_server_start_*_ is then used to start the DTLS Server to handle incoming requests.</span></span> <span data-ttu-id="5739e-281">들어오는 모든 요청은 _nx_secure_dtls_server_create\*에 제공(하나는 연결용, 하나는 알림 수신용으로 제공)되는 콜백 루틴에서 처리됩니다. 연결 알림이 수신될 때(DTLS에서 연결 알림 콜백을 호출) \***nx_secure_dtls_server_session_start**_ 를 호출하여 DTLS 세션 처리를 시작하는 것은 애플리케이션의 몫입니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-281">All incoming requests are handled in callback routines provided to _nx_secure_dtls_server_create\*: one for connections and one for receive notifications. It is up to the application to handle starting the DTLS session when a connection notification is received (the connect notify callback is invoked by DTLS) by calling \***nx_secure_dtls_server_session_start**_.</span></span> <span data-ttu-id="5739e-282">또한 애플리케이션에서는 DTLS 핸드셰이크 완료 이후에 수신 알림 콜백이 호출될 때 _\*_nx_secure_dtls_session_receive_\*\*를 호출하여 들어오는 데이터를 처리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-282">The application also must handle incoming data when the receive notify callback is invoked (which follows a completed DTLS handshake) by calling _\*_nx_secure_dtls_session_receive_\*\*.</span></span> <span data-ttu-id="5739e-283">자세한 내용은 위의 예제와 위에서 설명한 각 서비스의 API 참조에서 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-283">The details of this are provided in the example above and in the API reference for each of the above mentioned services.</span></span>

### <a name="dtls-packet-allocation"></a><span data-ttu-id="5739e-284">DTLS 패킷 할당</span><span class="sxs-lookup"><span data-stu-id="5739e-284">DTLS Packet Allocation</span></span>

<span data-ttu-id="5739e-285">NetX Secure DTLS는 DTLS 헤더의 공간이 올바르게 할당되도록 _*_nx_packet_allocate_*_ 서비스 대신 _ *_nx_secure_dtls_packet_allocate_*\* 서비스를 호출해야 한다는 점을 제외하고 NetX/NetXDuo TCP와 동일한 패킷 구조(\***NX_PACKET** _)를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-285">NetX Secure DTLS uses the same packet structure as NetX/NetXDuo TCP (***NX_PACKET** _) except that instead of calling the _*_nx_packet_allocate_*_ service, the _ *_nx_secure_dtls_packet_allocate_** service must be called so that space for the DTLS header may be allocated properly.</span></span>

### <a name="dtls-session-send"></a><span data-ttu-id="5739e-286">DTLS 세션 보내기</span><span class="sxs-lookup"><span data-stu-id="5739e-286">DTLS Session Send</span></span>

<span data-ttu-id="5739e-287">TLS 세션이 시작되면 애플리케이션에서 ***nx_secure_dtls_session_send*** 서비스를 사용하여 데이터를 보낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-287">Once the TLS session has started, the application may send data using the ***nx_secure_dtls_session_send*** service.</span></span> <span data-ttu-id="5739e-288">송신 서비스는 동일하게 ***nx_udp_socket_send** _ 서비스를 사용하며 전송되는 데이터, 대상 IP 주소 및 대상 UDP 포트를 포함하는 _ *_NX_PACKET_** 데이터 구조를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-288">The send service is identical in use to the ***nx_udp_socket_send** _ service, taking an _ *_NX_PACKET_** data structure containing the data being sent, a target IP address, and a target UDP port.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="5739e-289">nx_secure_dtls_session_send를 사용하여 데이터를 보낼 때 세션을 즉시 새 주소 및 UDP 포트로 이동하는 메커니즘을 사용하지 않는 이상(일반적이지 않음) DTLS 세션을 설정할 때 사용한 IP 주소와 포트를 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-289">When sending data using nx_secure_dtls_session_send, it is important to use the same IP address and port that were used to establish the DTLS session, unless there is a mechanism in place to move the session to a new address and UDP port on-the-fly (this is not common).</span></span>

<span data-ttu-id="5739e-290">DTLS를 통해 전송되는 모든 데이터는 전송되기 전에 NX Secure DTLS 스택 및 구성된 암호화 루틴을 통해 암호화됩니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-290">Any data sent over DTLS will be encrypted by the NX Secure DTLS stack and the configured encryption routines before being sent.</span></span>

### <a name="dtls-session-receive"></a><span data-ttu-id="5739e-291">DTLS 세션 받기</span><span class="sxs-lookup"><span data-stu-id="5739e-291">DTLS Session Receive</span></span>

<span data-ttu-id="5739e-292">DTLS 세션이 시작되면 애플리케이션에서 \***nx_secure_Dtls_session_receive** _ 서비스를 사용하여 데이터 수신을 시작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-292">Once the DTLS session has started, the application may begin receiving data using the \***nx_secure_Dtls_session_receive** _ service.</span></span> <span data-ttu-id="5739e-293">DTLS 세션 보내기와 마찬가지로 이 서비스는 동일하게 _\*_nx_udp_socket_receive_\*\*를 사용하지만, 들어오는 데이터는 DTLS 스택에서 암호 해독되고 확인된 후 패킷 구조에 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-293">Like the DTLS Session send, this service is identical in use to _\*_nx_udp_socket_receive_\*\*, except that the incoming data is decrypted and verified by the DTLS stack before being returned in the packet structure.</span></span>

### <a name="tls-session-close"></a><span data-ttu-id="5739e-294">TLS 세션 닫기</span><span class="sxs-lookup"><span data-stu-id="5739e-294">TLS Session Close</span></span>

<span data-ttu-id="5739e-295">DTLS 세션이 완료되면 DTLS 클라이언트와 서버가 서로 CloseNotify 경고를 보내서 세션을 종료해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-295">Once a DTLS session is complete, both the DTLS client and server must send a CloseNotify alert to the other side to shut down the session.</span></span> <span data-ttu-id="5739e-296">양쪽에서 경고를 수신하고 처리해야만 세션이 종료됩니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-296">Both sides must receive and process the alert to ensure a successful session shutdown.</span></span>

<span data-ttu-id="5739e-297">원격 호스트에서 CloseNotify 경고를 보내면 ***nx_secure_dtls_session_receive** _ 서비스는 경고를 처리하고, 해당 경고를 다시 원격 호스트로 보내고, _*_NX_SECURE_TLS_SESSION_CLOSED_\*\* 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-297">If the remote host sends a CloseNotify alert, any calls to the ***nx_secure_dtls_session_receive** _ service will process the alert, send the corresponding alert back to the remote host, and return a value of _*_NX_SECURE_TLS_SESSION_CLOSED_\*\*.</span></span> <span data-ttu-id="5739e-298">세션이 종료되면 해당 DTLS 세션을 통해 데이터를 보내거나 받으려는 모든 시도가 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-298">Once the session is closed, any further attempts to send or receive data with that DTLS session will fail.</span></span>

<span data-ttu-id="5739e-299">애플리케이션에서 TLS 세션을 닫으려면 \***nx_secure_dtls_session_end** _ 서비스를 호출해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-299">If the application wishes to close the TLS session, the \***nx_secure_dtls_session_end** _ service must be called.</span></span> <span data-ttu-id="5739e-300">그러면 이 서비스에서 CloseNotify 경고를 보내고 응답 CloseNotify를 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-300">The service will send the CloseNotify alert and process the response CloseNotify.</span></span> <span data-ttu-id="5739e-301">응답이 수신되지 않으면 DTLS 세션이 완전히 종료되지 않았으며 보안 위반 가능성이 있음을 알리는 _ *_NX_SECURE_TLS_SESSION_CLOSE_FAIL_*\* 오류 값이 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-301">If the response is not received, an error value of _ *_NX_SECURE_TLS_SESSION_CLOSE_FAIL_*\* will be returned, indicating that the DTLS session was not cleanly shutdown, a possible security breach.</span></span>

### <a name="tlsdtls-alerts"></a><span data-ttu-id="5739e-302">TLS/DTLS 경고</span><span class="sxs-lookup"><span data-stu-id="5739e-302">TLS/DTLS Alerts</span></span>

<span data-ttu-id="5739e-303">TLS/DTLS는 최대 보안을 제공하도록 설계되었으므로 프로토콜의 모든 이상 동작이 잠재적 보안 위반으로 간주됩니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-303">TLS/DTLS is designed to provide maximum security, so any errant behavior in the protocol is considered a potential security breach.</span></span> <span data-ttu-id="5739e-304">이러한 이유로 모든 메시지 처리 또는 암호화/암호 해독 오류는 치명적인 오류로 간주되어 핸드셰이크 또는 세션이 즉시 종료됩니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-304">For this reason, any errors in message processing or encryption/decryption are considered fatal errors that terminate the handshake or session immediately.</span></span>

<span data-ttu-id="5739e-305">로컬 애플리케이션에서 오류를 처리하는 것은 비교적 간단하지만, 원격 호스트는 상황을 올바르게 처리하고 추가로 발생할 수 있는 보안 위반을 방지하려면 오류가 발생한 사실을 알아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-305">While handling errors in a local application is relatively straightforward, the remote host needs to know that an error has occurred in order to properly handle the situation and prevent any further possible security breaches.</span></span> <span data-ttu-id="5739e-306">이러한 이유로 TLS/DTLS는 오류 발생 시 원격 호스트에 *경고* 메시지를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-306">For this reason, TLS/DTLS will send an *Alert* message to the remote host upon any error.</span></span>

<span data-ttu-id="5739e-307">경고는 다른 TLS/DTLS 메시지와 동일한 방식으로 처리되며, 공격자가 제공된 경고 유형에서 정보를 수집하지 못하도록 세션이 열린 동안 암호화됩니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-307">Alerts are treated in the same manner as any other TLS/DTLS messages and are encrypted during the session to prevent an attacker from gathering information from the type of alert provided.</span></span> <span data-ttu-id="5739e-308">핸드셰이크 중에 전송되는 경고는 잠재적 공격자가 얻을 수 있는 정보의 양을 제한하기 위해 그 범위가 제한됩니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-308">During the handshake, the alerts sent are limited in scope to limit the amount of information that could be obtained by a potential attacker.</span></span>

<span data-ttu-id="5739e-309">TLS/DTLS 세션을 닫는 데 사용되는 CloseNotify 경고는 유일하게 심각하지 않은 경고입니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-309">The CloseNotify alert, used to close the TLS/DTLS session, is the only non-fatal alert.</span></span> <span data-ttu-id="5739e-310">CloseNotify는 경고로 간주되고 경고 메시지를 보내기는 하지만, 오류가 발생했음을 알리지 않는다는 점에서 다른 경고와는 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-310">While it is considered an alert and sent as an alert message, a CloseNotify is unlike other alerts in that it does not indicate an error has occurred.</span></span>

### <a name="tlsdtls-session-renegotiation-and-resumption"></a><span data-ttu-id="5739e-311">TLS/DTLS 세션 다시 협상 및 다시 시작</span><span class="sxs-lookup"><span data-stu-id="5739e-311">TLS/DTLS Session Renegotiation and Resumption</span></span>

<span data-ttu-id="5739e-312">TLS는 기존 TLS 세션의 컨텍스트 내에서 TLS 세션 매개 변수를 재협상하는 "다시 협상"이라는 개념을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-312">TLS supports the notion of “renegotiation” which is simply a renegotiation of the TLS session parameters within the context of an existing TLS session.</span></span>

<span data-ttu-id="5739e-313">TLS 세션 *다시 시작* 은 세션 *다시 협상* 과 비슷한 점이 있지만 혼동해서는 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-313">TLS session *resumption* should not be confused with session *renegotiation*, despite some similarities.</span></span> <span data-ttu-id="5739e-314">세션 *다시 협상* 은 기존 TLS 세션 내에서 새 핸드셰이크를 시작하는 반면, 세션 *다시 시작* 은 TLS 핸드셰이크를 완전히 수행하지 않고 닫힌 TLS 세션을 다시 시작하며 전적으로 선택적 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-314">Where session *renegotiation* involves starting a new handshake within an existing TLS session, session *resumption* is a purely optional feature that involves restarting a closed TLS session without performing a complete TLS handshake.</span></span>

<span data-ttu-id="5739e-315">NX Secure DTLS는 원격 호스트에서 들어오는 다시 협상 요청을 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-315">NX Secure DTLS handles incoming renegotiation requests from remote hosts.</span></span> <span data-ttu-id="5739e-316">세션 다시 시작을 지원하지 **않습니다**.</span><span class="sxs-lookup"><span data-stu-id="5739e-316">It does **not** support session resumption.</span></span> <span data-ttu-id="5739e-317">이러한 기능에 대한 자세한 설명은 NetX Secure TLS 사용자 가이드의 챕터 3에서 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-317">A more complete discussion of these features can be found in Chapter 3 of the NetX Secure TLS User Guide.</span></span>

### <a name="protocol-layering"></a><span data-ttu-id="5739e-318">프로토콜 계층화</span><span class="sxs-lookup"><span data-stu-id="5739e-318">Protocol Layering</span></span>

<span data-ttu-id="5739e-319">TLS 프로토콜(및 그에 따른 DTLS)은 전송 계층(예: TCP 또는 UDP)과 애플리케이션 계층 간의 네트워킹 스택에 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-319">The TLS protocol (and therefore DTLS as well) fits into the networking stack between the transport layer (e.g. TCP or UDP) and the application layer.</span></span> <span data-ttu-id="5739e-320">TLS는 경우에 따라 전송 계층 프로토콜(따라서 *전송 계층* 보안)로 간주되지만, 기본 네트워크 프로토콜과 관련하여 애플리케이션으로 작동하기 때문에 애플리케이션 계층으로 그룹화되는 경우도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-320">TLS is sometimes considered a transport-layer protocol (hence *Transport Layer* Security) but because it acts as an application with regard to the underlying network protocols it is sometimes grouped into the application layer.</span></span>

<span data-ttu-id="5739e-321">TLS를 사용하려면 TCP와 같은 순서 및 무손실 전송을 지원하는 전송 계층 프로토콜이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-321">TLS requires a transport layer protocol that supports in-order and lossless delivery, such as TCP.</span></span> <span data-ttu-id="5739e-322">이러한 요구 사항 때문에 데이터그램 전송을 보장하지 않는 TLS는 UDP에서 실행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-322">Due to this requirement, TLS cannot run on top of UDP since UDP does not guarantee delivery of datagrams.</span></span> <span data-ttu-id="5739e-323">*DTLS* 는 TLS의 수정 버전으로, UDP와 같은 데이터그램 프로토콜을 통해 TLS를 보호해야 하는 애플리케이션에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-323">*DTLS* is a modified version of TLS, is used for applications that need the security of TLS over a datagram protocol like UDP.</span></span>

![TLS 프로토콜 계층화의 다이어그램](media/image6.png)

<span data-ttu-id="5739e-325">**그림 4 - TCP/IP, UDP 및 TLS/DTLS 프로토콜 계층**</span><span class="sxs-lookup"><span data-stu-id="5739e-325">**Figure 4- TCP/IP, UDP and TLS/DTLS protocol layers**</span></span>

## <a name="network-communications-security-and-encryption"></a><span data-ttu-id="5739e-326">네트워크 통신 보안 및 암호화</span><span class="sxs-lookup"><span data-stu-id="5739e-326">Network Communications Security and Encryption</span></span>

<span data-ttu-id="5739e-327">공용 네트워크와 인터넷을 통해 통신을 보호하는 것은 매우 중요한 토픽이자 수많은 서적, 기사 및 솔루션의 주제입니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-327">Securing communications over public networks and the Internet is a critically important topic and the subject of vast numbers of books, articles, and solutions.</span></span> <span data-ttu-id="5739e-328">이 토픽은 매우 복잡하지만, 의도한 대상만 정보에 액세스하거나 정보를 변경할 수 있도록 네트워크를 통해 정보 보내기라는 간단한 개념으로 정리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-328">The topic is mind-bogglingly complex, but can be reduced to a simple idea: sending information over a network so that only the intended target can access or change that information.</span></span> <span data-ttu-id="5739e-329">이 개념은 다시 기밀성, 무결성 및 인증이라는 세 가지 중요한 개념으로 세분화됩니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-329">This breaks down into three important concepts: secrecy, integrity, and authentication.</span></span> <span data-ttu-id="5739e-330">TLS/DTLS 프로토콜은 세 가지 영역 모두에 솔루션을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-330">The TLS/DTLS protocol provides solutions for all three.</span></span>

<span data-ttu-id="5739e-331">암호화는 TLS 및 DTLS 프로토콜 내에서 기밀성, 무결성 및 인증을 제공하는 여러 가지 방법에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-331">Encryption is used in different ways to provide secrecy, integrity, and authentication within the TLS and DTLS protocols.</span></span> <span data-ttu-id="5739e-332">세선 또는 서버 인스턴스를 만들 때 TLS 또는 DTLS에 암호화를 제공해야 합니다. TLS는 암호화 자체가 아닌 암호화를 사용하기 위한 유연한 프레임워크를 제공하기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-332">The encryption must be supplied to TLS or DTLS upon creation of a session or server instance as TLS provides a flexible framework for using encryption and not the encryption itself.</span></span> <span data-ttu-id="5739e-333">NetX Secure DTLS는 대부분의 애플리케이션에 필요한 암호화 루틴을 제공하므로 적절한 암호화를 찾기 위해 고생할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-333">NetX Secure DTLS provides the necessary encryption routines for most applications so you do not have to be concerned about finding appropriate encryption.</span></span>

<span data-ttu-id="5739e-334">이러한 토픽에 대한 자세한 설명은 NetX Secure TLS 사용자 가이드의 챕터 3에서 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-334">A more detailed description of these topics can be found in Chapter 3 of the NetX Secure TLS User Guide.</span></span>

## <a name="tls-and-dtls-extensions"></a><span data-ttu-id="5739e-335">TLS 및 DTLS 확장</span><span class="sxs-lookup"><span data-stu-id="5739e-335">TLS and DTLS Extensions</span></span>

<span data-ttu-id="5739e-336">TLS(및 그에 따른 DTLS)는 특정 애플리케이션을 위한 추가 기능이 포함된 여러 확장을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-336">TLS (and therefore DTLS) provides a number of extensions that provide additional functionality for certain applications.</span></span> <span data-ttu-id="5739e-337">이러한 확장은 일반적으로 ClientHello 또는 ServerHello 메시지의 일부로 전송되며, 확장을 사용해야 한다고 원격 호스트에 알리거나 보안 TLS 세션을 설정하는 데 사용할 추가 세부 정보를 원격 호스트에 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-337">These extensions are typically sent as part of the ClientHello or ServerHello messages, indicating to a remote host the desire to use an extension or providing additional details for use in establishing the secure TLS session.</span></span>

<span data-ttu-id="5739e-338">NetX Secure DTLS는 NetX Secure TLS에 있는 모든 확장을 지원하며, 자세한 설명은 NetX Secure TLS 사용자 가이드 챕터 3에서 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-338">NetX Secure DTLS supports all of the extensions found in NetX Secure TLS, and a complete description of those can be found in the NetX Secure TLS User Guide, Chapter 3.</span></span>

## <a name="authentication-methods"></a><span data-ttu-id="5739e-339">인증 방법</span><span class="sxs-lookup"><span data-stu-id="5739e-339">Authentication Methods</span></span>

<span data-ttu-id="5739e-340">TLS 및 DTLS는 안전하지 않은 네트워크를 통해 두 디바이스 간에 보안 연결을 설정할 수 있는 프레임워크를 제공하지만, 해당 연결의 반대쪽 끝에 있는 디바이스 ID를 알아야 한다는 문제가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-340">TLS and DTLS provide the framework for establishing a secure connection between two devices over an insecure network, but part of the problem is knowing the identity of the device on the other end of that connection.</span></span> <span data-ttu-id="5739e-341">원격 호스트의 ID를 인증하는 메커니즘이 없으면 공격자가 신뢰할 수 있는 디바이스를 손쉽게 속일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-341">Without a mechanism for authenticating the identity of remote hosts, it becomes a trivial operation for an attacker to pose as a trusted device.</span></span>

<span data-ttu-id="5739e-342">처음에는 IP 주소, 하드웨어 MAC 주소 또는 DNS를 사용하면 네트워크에서 호스트를 식별하는 데 비교적 높은 수준의 신뢰도를 제공하는 것처럼 보일 수 있지만, TCP/IP 기술의 특성과 주소를 쉽게 스푸핑할 수 있고 DNS 항목이 손상(예: DNS 캐시 손상을 통해)될 수 있다는 점을 고려할 때 TLS에는 사기성 ID를 차단하기 위한 추가 보호 계층이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-342">Initially, it may seem that using IP addresses, hardware MAC addresses, or DNS would provide a relatively high level of confidence for identifying hosts on a network, but given the nature of TCP/IP technology and the ease with which addresses can be spoofed and DNS entries corrupted (e.g. through DNS cache poisoning), it becomes clear that TLS needs an additional layer of protection against fraudulent identities.</span></span>

<span data-ttu-id="5739e-343">TLS에 이와 같은 추가 인증 계층을 제공할 수 있는 다양한 메커니즘이 있지만, 가장 일반적인 방법은 *디지털 인증서* 입니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-343">There are various mechanisms that can provide this extra layer of authentication for TLS, but the most common is the *digital certificate.*</span></span> <span data-ttu-id="5739e-344">기타 메커니즘으로는 PSK(미리 공유한 키) 및 암호 체계가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-344">Other mechanisms include Pre-Shared Keys (PSK) and password schemes.</span></span>

### <a name="digital-cerificates"></a><span data-ttu-id="5739e-345">디지털 인증서</span><span class="sxs-lookup"><span data-stu-id="5739e-345">Digital Cerificates</span></span>

<span data-ttu-id="5739e-346">디지털 인증서는 TLS에서 원격 호스트를 인증하는 가장 일반적인 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-346">Digital certificates are the most common method for authenticating a remote host in TLS.</span></span> <span data-ttu-id="5739e-347">기본적으로 디지털 인증서는 컴퓨터 네트워크 상의 디바이스에 대한 ID 정보를 제공하는 특정 형식을 포함하고 있는 문서입니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-347">Essentially, a digital certificate is a document with specific formatting that provides identity information for a device on a computer network.</span></span>

<span data-ttu-id="5739e-348">TLS는 일반적으로 International Telecommunication Union에서 개발한 표준인 X.509 형식을 사용하지만, 사용하려는 형식을 TLS 호스트에서 동의할 수 있다면 다른 형식의 인증서를 사용해도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-348">TLS normally uses a format called X.509, a standard developed by the International Telecommunication Union, though other formats of certificates may be used if the TLS hosts can agree on the format being used.</span></span> <span data-ttu-id="5739e-349">X.509는 디지털 문서를 작성하는 데 사용할 수 있는 다양한 인코딩 및 인증서의 형식을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-349">X.509 defines a specific format for certificates and various encodings that can be used to produce a digital document.</span></span> <span data-ttu-id="5739e-350">TLS에 사용되는 대부분의 X.509 인증서는 다른 통신 표준의 변형인 ASN.1을 사용하여 인코딩됩니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-350">Most X.509 certificates used with TLS are encoded using a variant of ASN.1, another telecommunications standard.</span></span> <span data-ttu-id="5739e-351">ASN.1에는 다양한 디지털 인코딩이 포함되어 있지만, TLS 인증서에 사용되는 가장 일반적인 인코딩은 DER(Distinguished Encoding Rules) 표준입니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-351">Within ASN.1 there are various digital encodings, but the most common encoding for TLS certificates is the Distinguished Encoding Rules (DER) standard.</span></span> <span data-ttu-id="5739e-352">DER은 구문 분석을 쉽게 수행할 수 있도록 분명하게 설계된 ASN.1 BER(Basic Encoding Rules)의 간소화된 하위 세트입니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-352">DER is a simplified subset of the ASN.1 Basic Encoding Rules (BER) that is designed to be unambiguous, making parsing easier.</span></span> <span data-ttu-id="5739e-353">네트워크를 통해 TLS 인증서는 일반적으로 이진 DER로 인코딩되며, 이 형식은 NetX Secure에서 X.509 인증서에 요구하는 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-353">Over the wire, TLS certificates are usually encoded in binary DER, and this is the format that NetX Secure expects for X.509 certificates.</span></span>

<span data-ttu-id="5739e-354">DER 형식의 이진 인증서는 실제 TLS 프로토콜에 사용되지만 .pem, .crt, .p12 등의 파일 확장명을 사용하여 다양한 인코딩으로 생성하고 저장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-354">Though DER-formatted binary certificates are used in the actual TLS protocol, they may be generated and stored in a number of different encodings, with file extensions such as .pem, .crt, and .p12.</span></span> <span data-ttu-id="5739e-355">여러 제조업체의 다양한 애플리케이션에서 다양한 변형이 사용되지만, 일반적으로 널리 제공되는 도구를 사용하여 DER로 변환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-355">The different variants are used by different applications from different manufacturers, but generally all can be converted into DER using widely available tools.</span></span>

<span data-ttu-id="5739e-356">가장 일반적인 대체 인증서 인코딩은 PEM입니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-356">The most common of the alternative certificate encodings is PEM.</span></span> <span data-ttu-id="5739e-357">Privacy Enhanced Mail의 PEM 형식은 base-64로 인코딩된 DER 인코딩 버전으로, 인코딩 결과가 이메일 또는 웹 기반 프로토콜을 사용하여 쉽게 보낼 수 있는 인쇄 가능한 텍스트로 생성되기 때문에 자주 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-357">The PEM format (from Privacy-Enhanced Mail) is a base-64 encoded version of the DER encoding that is often used because the encoding results in printable text that can be easily sent using email or web-based protocols.</span></span>

<span data-ttu-id="5739e-358">NetX Secure 애플리케이션의 인증서 생성은 일반적으로 이 설명서의 범위를 벗어나지만, OpenSSL 명령줄 도구([www.openssl.org](http://www.openssl.org))는 광범위하게 사용할 수 있으며 대부분의 형식을 변환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-358">Generating a certificate for your NetX Secure application is generally outside the scope of this manual, but the OpenSSL command-line tool ([www.openssl.org](http://www.openssl.org)) is widely available and can convert between most formats.</span></span>

<span data-ttu-id="5739e-359">애플리케이션에 따라 사용자 고유의 인증서를 생성할 수도 있고, 제조업체 또는 정부 기관에서 인증서를 제공할 수도 있고, 상용 인증 기관에서 인증서를 구매할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-359">Depending on your application, you may generate your own certificates, be provided certificates by a manufacturer or government organization, or purchase certificates from a commercial certificate authority.</span></span>

<span data-ttu-id="5739e-360">NetX Secure 애플리케이션에서 디지털 인증서를 사용하려면 먼저 인증서를 이진 DER 형식으로 변환하고, 필요에 따라 연결된 프라이빗 키(예: RSA의 경우 "프라이빗 지수")를 이진 형식(일반적으로 PKCS#1 형식의 DER 인코딩 RSA 키)으로 변환해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-360">To use a digital certificate in your NetX Secure application, you must first convert your certificate into a binary DER format and, optionally, convert the associated private key (the “private exponent” for RSA, for example) into a binary format, typically a PKCS#1-formatted, DER-encoded RSA key.</span></span> <span data-ttu-id="5739e-361">변환이 완료되면 디바이스에 인증서 및 프라이빗 키를 로드해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-361">Once the conversion is complete, it is up to you to load the certificate and private key onto the device.</span></span> <span data-ttu-id="5739e-362">선택 가능한 옵션으로는 플래시 기반 파일 시스템을 사용하거나, 데이터에서 C 배열을 생성하고(Linux의 "xxd" 같은 도구를 사용하여) 인증서와 키를 애플리케이션에 상수 데이터로 컴파일하는 방법이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-362">Possible options include using a flash-based file system or generating a C array from the data (using a tool such as “xxd” from Linux) and compiling the certificate and key into your application as constant data.</span></span>

<span data-ttu-id="5739e-363">인증서가 디바이스에 로드되면 DTLS API를 사용하여 인증서를 DTLS 세션 또는 서버와 연결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-363">Once your certificate is loaded onto the device, the DTLS API can be used to associate your certificate with a DTLS session or server.</span></span>

<span data-ttu-id="5739e-364">NetX Secure DTLS에서 X.509 인증서를 사용하는 방법에 대한 자세한 내용과 예제는 NetX Secure TLS 사용자 가이드의 "NetX Secure로 X.509 인증서 가져오기" 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="5739e-364">For details and examples on how to use X.509 certificates with NetX Secure DTLS, see the section “Importing X.509 certificates into NetX Secure” in the NetX Secure TLS User Guide.</span></span>

<span data-ttu-id="5739e-365">자세한 내용은 API 참조에서 다음 DTLS 서비스를 확인하세요.</span><span class="sxs-lookup"><span data-stu-id="5739e-365">Refer to the following DTLS services in the API reference for more information:</span></span>

- <span data-ttu-id="5739e-366">nx_secure_x509_certificate_initialize</span><span class="sxs-lookup"><span data-stu-id="5739e-366">nx_secure_x509_certificate_initialize,</span></span>
- <span data-ttu-id="5739e-367">nx_secure_dtls_session_local_certificate_add</span><span class="sxs-lookup"><span data-stu-id="5739e-367">nx_secure_dtls_session_local_certificate_add,</span></span>
- <span data-ttu-id="5739e-368">nx_secure_dtls_server_local_certificate_add</span><span class="sxs-lookup"><span data-stu-id="5739e-368">nx_secure_dtls_server_local_certificate_add,</span></span>
- <span data-ttu-id="5739e-369">nx_secure_dtls_session_local_certificate_remove</span><span class="sxs-lookup"><span data-stu-id="5739e-369">nx_secure_dtls_session_local_certificate_remove,</span></span>
- <span data-ttu-id="5739e-370">nx_secure_dtls_server_local_certificate_remove</span><span class="sxs-lookup"><span data-stu-id="5739e-370">nx_secure_dtls_server_local_certificate_remove,</span></span>
- <span data-ttu-id="5739e-371">nx_secure_dtls_session_trusted_certificate_add</span><span class="sxs-lookup"><span data-stu-id="5739e-371">nx_secure_dtls_session_trusted_certificate_add,</span></span>
- <span data-ttu-id="5739e-372">nx_secure_dtls_server_trusted_certificate_add</span><span class="sxs-lookup"><span data-stu-id="5739e-372">nx_secure_dtls_server_trusted_certificate_add,</span></span>
- <span data-ttu-id="5739e-373">nx_secure_dtls_session_trusted_certificate_remove</span><span class="sxs-lookup"><span data-stu-id="5739e-373">nx_secure_dtls_session_trusted_certificate_remove</span></span>
- <span data-ttu-id="5739e-374">nx_secure_dtls_server_trusted_certificate_remove</span><span class="sxs-lookup"><span data-stu-id="5739e-374">nx_secure_dtls_server_trusted_certificate_remove</span></span>

### <a name="tls-client-certificate-specifics"></a><span data-ttu-id="5739e-375">TLS 클라이언트 인증서 세부 정보</span><span class="sxs-lookup"><span data-stu-id="5739e-375">TLS Client Certificate Specifics</span></span>

<span data-ttu-id="5739e-376">일반적으로 DTLS 클라이언트를 구현할 때 로컬 인증서를 디바이스에 로드하지 않아도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-376">DTLS Client implementations generally do not require a local certificate to be loaded onto the device.</span></span> <span data-ttu-id="5739e-377">로컬 인증서는 로컬 디바이스를 식별하는 인증서입니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-377">A local certificate is a certificate that identifies the local device.</span></span> <span data-ttu-id="5739e-378">특히 로컬 인증서는 TLS/DTLS 애플리케이션이 로드되는 디바이스의 ID 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-378">Specifically, a local certificate provides identity information for the device upon which the TLS/DTLS application is loaded.</span></span> <span data-ttu-id="5739e-379">클라이언트 인증서 인증을 사용하도록 설정하는 경우에는 예외지만, 일반적인 상황은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-379">The exception to this is when Client Certificate Authentication is enabled, but this is less common.</span></span>

<span data-ttu-id="5739e-380">DTLS 클라이언트를 사용하려면 신뢰할 수 있는 인증서를 하나 이상 로드해야 하며(필요한 경우 더 많이 로드할 수 있음) 원격 인증서를 할당할 공간이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-380">A DTLS Client requires at least one trusted certificate to be loaded (more may be loaded if required), and space for a remote certificate to be allocated.</span></span> <span data-ttu-id="5739e-381">신뢰할 수 있는 인증서는 직접 또는 PKI(공개 키 인프라)를 통해 원격 디바이스의 신뢰와 인증을 위한 기반을 제공하는 인증서입니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-381">A trusted certificate is a certificate that provides a basis for trust and authentication of the remote device, either directly or through a Public Key Infrastructure (PKI).</span></span> <span data-ttu-id="5739e-382">신뢰 체인의 루트를 일반적으로 인증 기관 또는 CA 인증서라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-382">The root of the chain of trust is usually called a Certification Authority or CA certificate.</span></span> <span data-ttu-id="5739e-383">원격 인증서는 TLS 핸드셰이크 중에 원격 호스트에서 보낸 인증서를 참조합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-383">A remote certificate refers to the certificate sent by the remote host during the TLS handshake.</span></span> <span data-ttu-id="5739e-384">원격 인증서는 해당 원격 호스트의 ID를 제공하며, 로컬 디바이스의 신뢰할 수 있는 인증서와 비교하여 인증됩니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-384">It provides identity for that remote host and is authenticated by comparing it to a trusted certificate on the local device.</span></span>

<span data-ttu-id="5739e-385">신뢰할 수 있는 인증서를 추가하고 원격 인증서의 공간을 할당하는 방법에 대한 자세한 내용은 nx_secure_dtls_session_create 및 nx_secure_dtls_session_trusted_certificate_add 서비스의 TLS API 참조를 확인하세요.</span><span class="sxs-lookup"><span data-stu-id="5739e-385">For more information on adding trusted certificates and allocating space for remote certificates, see the TLS API reference for the following services: nx_secure_dtls_session_create, nx_secure_dtls_session_trusted_certificate_add.</span></span>

### <a name="tlsdtls-server-certificate-specifics"></a><span data-ttu-id="5739e-386">TLS/DTLS 서버 인증서 세부 정보</span><span class="sxs-lookup"><span data-stu-id="5739e-386">TLS/DTLS Server Certificate Specifics</span></span>

<span data-ttu-id="5739e-387">일반적으로 DTLS 서버를 구현할 때 "신뢰할 수 있는" 인증서를 디바이스에 로드하거나 원격 인증서를 할당할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-387">DTLS Server implementations generally do not require “trusted” certificates to be loaded onto the device or remote certificates to be allocated.</span></span> <span data-ttu-id="5739e-388">클라이언트 인증서 인증을 사용하는 경우에는 예외입니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-388">The exception to this being when Client Certificate Authentication is enabled.</span></span>

<span data-ttu-id="5739e-389">TLS 서버의 경우 TLS 핸드셰이크 중에 원격 클라이언트에 인증서를 제공하여 서버를 클라이언트에 인증할 수 있도록 "로컬"(또는 "ID") 인증서를 로드해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-389">A TLS Server requires a “local” (or “identity”) certificate to be loaded so the server can provide it to the remote client during the TLS handshake to authenticate the server to the client.</span></span>

<span data-ttu-id="5739e-390">NetX TLS 서버 애플리케이션에 사용할 로컬 인증서를 로드하는 방법에 대한 자세한 내용은 nx_secure_dtls_server_local_certificate_add 및 nx_secure_dtls_server_local_certificate_remove 서비스의 API 참조에서 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-390">For more information about loading local certificates for use with NetX TLS server applications, see the API reference for the following services: nx_secure_dtls_server_local_certificate_add, nx_secure_dtls_server_local_certificate_remove.</span></span>


### <a name="pre-shared-keys-psk"></a><span data-ttu-id="5739e-391">PSK(미리 공유한 키)</span><span class="sxs-lookup"><span data-stu-id="5739e-391">Pre-Shared Keys (PSK)</span></span>

<span data-ttu-id="5739e-392">TLS에서 식별 인증을 제공하는 또 다른 메커니즘은 PSK(미리 공유한 키)라는 개념입니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-392">An alternative mechanism for providing identification authentication in TLS is the notion of Pre-Shared Keys (PSK).</span></span> <span data-ttu-id="5739e-393">PSK ciphersuite를 사용하면 프로세서 사용량이 많은 공개 키 암호화 작업을 수행할 필요가 없으므로 리소스가 제한적인 임베디드 디바이스에 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-393">Using a PSK ciphersuite removes the need to do the processor-intensive public-key encryption operations, a boon for resource-constrained embedded devices.</span></span> <span data-ttu-id="5739e-394">PSK는 TLS/DTLS 핸드셰이크의 인증서를 대체하며 TLS/DTLS 세션 키 생성을 위해 암호화된 Pre-Master Secret 대신 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-394">The PSK replaces the certificate in the TLS/DTLS handshake and is used in place of the encrypted Pre-Master Secret for TLS/DTLS session key generation.</span></span>

<span data-ttu-id="5739e-395">PSK ciphersuite는 TLS/DTLS 세션을 설정하려면 두 디바이스 모두에 공유 비밀이 있어야 한다는 점에서 제한적입니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-395">The PSK ciphersuites are limited in the sense that that a shared secret must be present on both devices before a TLS/DTLS session can be established.</span></span> <span data-ttu-id="5739e-396">즉, TLS PSK 연결이 아닌 다른 안전한 방법으로 해당 비밀을 디바이스에 로드해야 합니다. PSK는 TLS PSK 연결을 통해 업데이트할 수 있지만, 디바이스는 반드시 다른 메커니즘을 통해 로드된 PSK를 사용하여 시작해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-396">This means that the devices must have been loaded with that secret using some secure means other than a TLS PSK connection - PSKs may be updated over a TLS PSK connection, but the device must necessarily start with a PSK that is loaded through some other mechanism.</span></span> <span data-ttu-id="5739e-397">예를 들어 출하 전에 공장에서 PSK를 사용하여 센서 디바이스와 게이트웨이 디바이스를 로드하거나, 표준 TLS 연결(인증서 포함)을 사용하여 PSK를 로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-397">For example, a sensor device and its gateway device could be loaded with PSKs in the factory before shipping, or a standard TLS connection (with a certificate) could be used to load the PSK.</span></span>

<span data-ttu-id="5739e-398">PSK ciphersuite는 RFC 4279에 설명된 여러 가지 형식으로 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-398">PSK ciphersuites come in a couple of forms, described in RFC 4279.</span></span> <span data-ttu-id="5739e-399">첫 번째 형식은 표준 TLS 핸드셰이크에서 인증서에 전송된 공개 키와 동일한 방식으로 사용되는 RSA 또는 Diffie-Hellman 키를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-399">The first uses RSA or Diffie-Hellman keys which are used in the same manner as the public keys transmitted in the certificate in standard TLS handshakes.</span></span> <span data-ttu-id="5739e-400">리소스가 제한적인 환경에서 더 많이 사용되는 두 번째 형식은 세션 키(AES에서 사용할)를 직접 생성하는 데 사용되는 PSK를 사용하며, 비용이 많이 드는 RSA 또는 Diffie-Hellman 작업의 사용을 방지합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-400">The second form, which is of more use in a resource-constrained environment, uses a PSK that is used to directly generate the session keys (for use by AES, for example), avoiding the use of the expensive RSA or Diffie-Hellman operations.</span></span>

<span data-ttu-id="5739e-401">NetX Secure는 애플리케이션에서 모든 공개 키 암호화 코드 및 메모리를 사용하지 않도록 두 번째 PSK ciphersuite 형식을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-401">NetX Secure supports the second form of PSK ciphersuites, enabling applications to remove all public-key cryptography code and memory usage.</span></span> <span data-ttu-id="5739e-402">PSK 자체는 AES 키가 아니지만 실제 키가 생성되는 암호와 비슷한 것으로 간주할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-402">The PSK itself is not an AES key, but can be considered as being more like a password from which the actual keys are generated.</span></span> <span data-ttu-id="5739e-403">PSK 값에는 몇 가지 제한 사항이 있지만, 암호와 마찬가지로 값이 길수록 강력한 보안을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-403">There are few restrictions on what the PSK value can be, though longer values will provide more security (same as with passwords).</span></span>

<span data-ttu-id="5739e-404">NetX Secure 애플리케이션에서 PSK를 사용하려면 먼저 글로벌 매크로 **NX_SECURE_ENABLE_PSK_CIPHERSUITES** 를 정의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-404">To use PSK with your NetX Secure application, you must first define the global macro **NX_SECURE_ENABLE_PSK_CIPHERSUITES**.</span></span> <span data-ttu-id="5739e-405">이 작업은 일반적으로 컴파일러 설정을 통해 수행되지만 nx_secure_tls.h 헤더 파일에 정의를 배치할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-405">This is usually done through your compiler settings, but the definition can also be placed in the nx_secure_tls.h header file.</span></span> <span data-ttu-id="5739e-406">매크로가 정의되면 PSK ciphersuite 지원이 NetX Secure DTLS 애플리케이션으로 컴파일됩니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-406">With the macro defined, PSK ciphersuite support will be compiled into your NetX Secure DTLS application.</span></span>

<span data-ttu-id="5739e-407">PSK 지원을 사용하도록 설정한 후에는 DTLS API를 사용하여 애플리케이션에 대한 PSK를 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-407">With PSK support enabled, you can then use the DTLS API to set up PSKs for your application.</span></span> <span data-ttu-id="5739e-408">각 PSK에는 PSK 값(실제 비밀 "키" – 안전하게 보관해야 함), 특정 PSK를 식별하는 데 사용되는 "ID" 값, 그리고 TLS 서버에서 특정 PSK 값을 선택하는 데 사용하는 "ID 힌트"가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-408">Each PSK will require a PSK value (the actual secret “key” – keep this value safe), an “identity” value used to identify the specific PSK, and an “identity hint” that is used by a TLS server to choose a particular PSK value.</span></span>

<span data-ttu-id="5739e-409">PSK 자체는 네트워크 연결을 통해 전송되지 않으므로 임의의 이진 값일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-409">The PSK itself can be any binary value as it is never sent over a network connection.</span></span> <span data-ttu-id="5739e-410">PSK의 최대 길이는 64바이트입니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-410">The PSK can be any value up to 64 bytes in length.</span></span>

<span data-ttu-id="5739e-411">ID 및 힌트는 UTF-8을 사용하여 서식이 지정된 인쇄 가능한 문자열이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-411">The identity and hint must be printable character strings formatted using UTF-8.</span></span> <span data-ttu-id="5739e-412">ID 및 힌트 값의 최대 길이는 128바이트입니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-412">The identity and hint values may be any length up to 128 bytes.</span></span>

<span data-ttu-id="5739e-413">ID 및 PSK는 서로 통신해야 하는 네트워크 상의 모든 디바이스에 로드되는 고유한 쌍을 형성합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-413">The identity and PSK form a unique pair that is loaded onto every device in the network that need to communicate with one another.</span></span>

<span data-ttu-id="5739e-414">"힌트"는 PSK를 함수 또는 서비스별로 그룹화하는 애플리케이션 프로필을 정의하는 데 주로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-414">The “hint” is primarily used for defining specific application profiles to group PSKs by function or service.</span></span> <span data-ttu-id="5739e-415">이러한 값은 미리 합의해야 하며 애플리케이션에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-415">These values must be agreed upon in advance and are application dependent.</span></span> <span data-ttu-id="5739e-416">예를 들어 PSK를 사용하도록 설정된 OpenSSL 명령줄 서버 애플리케이션은 TLS 핸드셰이크를 계속하려면 TLS 클라이언트에서 제공해야 하는 기본 문자열인 "Client_identity"를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-416">As an example, the OpenSSL command-line server application (with PSK enabled) uses the default string “Client_identity”, which must be provided by a TLS client in order to continue with the TLS handshake.</span></span>

<span data-ttu-id="5739e-417">PSK에 대한 자세한 내용은 nx_secure_dtls_psk_add 및 nx_secure_dtls_server_psk_add 서비스에 대한 NetX Secure API 참조를 확인하세요.</span><span class="sxs-lookup"><span data-stu-id="5739e-417">For more information on PSKs, see the NetX Secure API reference for the following services: nx_secure_dtls_psk_add, nx_secure_dtls_server_psk_add.</span></span>

## <a name="importing-x509-certificates-into-netx-secure"></a><span data-ttu-id="5739e-418">NetX Secure로 X.509 인증서 가져오기</span><span class="sxs-lookup"><span data-stu-id="5739e-418">Importing X.509 certificates into NetX Secure</span></span>

<span data-ttu-id="5739e-419">디지털 인증서는 인터넷에서 이루어지는 대부분의 TLS 연결에 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-419">Digital certificates are required for most TLS connections on the Internet.</span></span> <span data-ttu-id="5739e-420">인증서는 일반적으로 *CA(인증 기관)* 라고 하는 신뢰할 수 있는 중개자를 사용하여 인터넷을 통해 이전에는 알 수 없었던 호스트를 인증하는 방법을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-420">Certificates provide a method for authenticating previously unknown hosts over the Internet through the use of trusted intermediaries, usually called *Certificate Authorities* or CAs.</span></span> <span data-ttu-id="5739e-421">NetX Secure 디바이스를 상용 클라우드 서비스(예: Amazon Web Services)와 연결하려면 인증서를 디바이스에 로드하여 인증서를 애플리케이션으로 가져와야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-421">To connect your NetX Secure device with a commercial cloud service (such as Amazon Web Services), you will need to import certificates into your application by loading them onto your device.</span></span>

<span data-ttu-id="5739e-422">인증서와 함께 인증서와 연결된 *프라이빗 키* 가 필요할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-422">Along with certificates, you will also sometimes need a *private key* that is associated with your certificate.</span></span> <span data-ttu-id="5739e-423">일부 애플리케이션(예: 클라이언트 인증서 인증을 사용하지 않는 경우 TLS 클라이언트)에서는 인증서 하나로 충분하지만, 인증서를 사용하여 디바이스를 식별하는 경우에는 프라이빗 키가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-423">In some applications (such as TLS Client when Client Certificate Authentication is not being used) the certificate alone will be sufficient, but if your certificate is being used to identify your device you will need a private key.</span></span> <span data-ttu-id="5739e-424">프라이빗 키는 일반적으로 인증서를 만들 때 생성되고 별도의 파일에 저장되며, 이러한 파일은 종종 암호로 암호화됩니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-424">Private keys are typically generated when you create your certificate and are stored in a separate file, often encrypted with a password.</span></span>

<span data-ttu-id="5739e-425">NetX Secure 애플리케이션으로 인증서를 가져오는 방법에 대한 자세한 내용은 NetX Secure TLS 사용자 가이드의 챕터 3을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="5739e-425">For a detailed description of importing certificates into NetX Secure applications, please refer to Chapter 3 in the NetX Secure TLS User Guide.</span></span>

## <a name="client-certificate-authentication-in-netx-secure-tls"></a><span data-ttu-id="5739e-426">NetX Secure TLS의 클라이언트 인증서 인증</span><span class="sxs-lookup"><span data-stu-id="5739e-426">Client Certificate Authentication in NetX Secure TLS</span></span>

<span data-ttu-id="5739e-427">X.509 인증서 인증을 사용하는 경우 TLS/DTLS 프로토콜을 사용하려면 DTLS 서버 인스턴스에서 식별용 인증서를 제공해야 하지만, 기본적으로 DTLS 클라이언트 인스턴스는 다른 형태의 인증(예: 사용자 이름/암호 조합)을 사용하여 인증용 인증서를 제공할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-427">When using X.509 certificate authentication, the TLS/DTLS protocol requires that the DTLS Server instance provide a certificate for identification, but by default the DTLS Client instance does not need to provide a certificate for authentication, using another form of authentication instead (e.g. a username/password combination).</span></span> <span data-ttu-id="5739e-428">따라서 인터넷의 웹 사이트에서 가장 일반적으로 사용되는 TLS에 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-428">This matches the most common use of TLS on the Internet for Web sites.</span></span> <span data-ttu-id="5739e-429">예를 들어 온라인 소매점 사이트는 웹 브라우저를 사용하는 잠재 고객에게 서버가 합법적이라는 것을 증명해야 하지만 사용자는 로그인/암호를 사용하여 특정 계정에 액세스합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-429">For example, an online retail site must prove to a potential customer using a web browser that the server is legitimate, but the user will use a login/password to access a specific account.</span></span>

<span data-ttu-id="5739e-430">그러나 기본 사례가 항상 적절한 것은 아니므로 TLS/DTLS는 상황에 따라 DTLS 서버 인스턴스가 원격 클라이언트에서 인증서를 요청하는 것을 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-430">However, the default case is not always desirable, so TLS/DTLS optionally allows for the DTLS Server instance to request a certificate from the remote Client.</span></span> <span data-ttu-id="5739e-431">이 기능을 사용하면 DTLS 서버는 핸드셰이크 중에 CertificateRequest 메시지를 DTLS 클라이언트에 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-431">When this feature is enabled, the DTLS Server will send a CertificateRequest message to the DTLS Client during the handshake.</span></span> <span data-ttu-id="5739e-432">클라이언트는 자체 인증서 및 해당 인증서와 연결된 일치하는 프라이빗 키를 소유하고 있음을 증명하는 암호화 토큰이 포함된 CertificateVerify 메시지로 응답해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-432">The Client must respond with a certificate of its own and a CertificateVerify message which contains a cryptographic token proving that the Client owns the matching private key associated with that certificate.</span></span> <span data-ttu-id="5739e-433">확인이 실패하거나 인증서가 서버의 신뢰할 수 있는 인증서에 연결되지 않은 경우 TLS 핸드셰이크가 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-433">If the verification fails or the certificate is not connected to a trusted certificate on the Server, the TLS handshake fails.</span></span>

<span data-ttu-id="5739e-434">TLS의 클라이언트 인증서 인증에 대한 두 가지 사례가 있는데, 다음 섹션에서 다룹니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-434">There are two separate cases for Client Certificate Authentication in TLS – the following sections cover both cases.</span></span>

### <a name="client-certificate-authentication-for-dtls-clients"></a><span data-ttu-id="5739e-435">DTLS 클라이언트용 클라이언트 인증서 인증</span><span class="sxs-lookup"><span data-stu-id="5739e-435">Client Certificate Authentication for DTLS Clients</span></span>

<span data-ttu-id="5739e-436">DTLS 클라이언트는 클라이언트 인증을 위해 인증서를 요청하는 서버에 연결을 시도할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-436">A DTLS Client may attempt a connection to a server that requests a certificate for client authentication.</span></span> <span data-ttu-id="5739e-437">이 경우 클라이언트는 서버에 인증서를 제공하고 인증서와 일치하는 프라이빗 키가 서버에 있는지 확인해야 합니다. 그렇지 않으면 서버가 DTLS 핸드셰이크를 종료합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-437">In this case the Client must provide a certificate to the server and verify that it owns the matching private key or the Server will terminate the DTLS handshake.</span></span>

<span data-ttu-id="5739e-438">NetX Secure DTLS에는 이 기능을 지원하는 특별한 구성이 없지만 애플리케이션에서 *nx_secure_tls_session_local_certificate_add* 서비스를 사용하여 TLS 클라이언트 인스턴스에 대한 로컬 식별 인증서를 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-438">In NetX Secure DTLS, there is no special configuration to support this feature but the application will have to provide a local identification certificate for the TLS Client instance using the *nx_secure_tls_session_local_certificate_add* service.</span></span> <span data-ttu-id="5739e-439">애플리케이션에서 인증서를 제공하지 않지만 원격 서버에서 클라이언트 인증서 인증을 사용하고 인증서를 요청하는 경우에는 DTLS 핸드셰이크가 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-439">If no certificate is provided by the application but the remote server is using Client Certificate Authentication and requests a certificate, the DTLS handshake will fail.</span></span> <span data-ttu-id="5739e-440">DTLS 핸드셰이크를 완료하려면 *nx_secure_dtls_session_local_certificate_add* 를 사용하여 DTLS 세션에 제공된 인증서를 원격 서버에서 인식해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-440">The certificate provided to the DTLS Session with *nx_secure_dtls_session_local_certificate_add* must be recognized by the remote server in order to complete the DTLS handshake.</span></span>

### <a name="client-certificate-authentication-for-tls-servers"></a><span data-ttu-id="5739e-441">TLS 서버용 클라이언트 인증서 인증</span><span class="sxs-lookup"><span data-stu-id="5739e-441">Client Certificate Authentication for TLS Servers</span></span>

<span data-ttu-id="5739e-442">클라이언트 인증서 인증에 대한 DTLS 서버 사례는 선택 사항으로 제공되는 기능 때문에 DTLS 클라이언트 사례보다 약간 더 복잡합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-442">The DTLS Server case for Client Certificate Authentication is slightly more complex than the DTLS Client case due to the feature being optional.</span></span> <span data-ttu-id="5739e-443">이 경우 TLS 서버는 원격 TLS 클라이언트에서 인증서를 구체적으로 요청한 다음, CertificateVerify 메시지를 처리하여 원격 클라이언트가 일치하는 프라이빗 키를 소유하고 있는지 확인해야 합니다. 그 후 서버에서는 클라이언트가 제공한 인증서를 신뢰할 수 있는 로컬 인증서 저장소의 인증서까지 추적할 수 있는지 확인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-443">In this case, the TLS Server needs to specifically request a certificate from the remote TLS Client, then process the CertificateVerify message to verify that the remote Client owns the matching private key, and then the Server must check that the certificate provided by the Client can be traced to a certificate in the local trusted certificate store.</span></span>

<span data-ttu-id="5739e-444">NetX Secure TLS 서버 인스턴스에서 클라이언트 인증서 인증은 *nx_secure_dtls_server_x509_client_verify_configure* 및 *nx_secure_dtls_server_x509_client_verify_disable* 서비스를 통해 제어됩니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-444">In NetX Secure TLS Server instances, Client Certificate Authentication is controlled by the *nx_secure_dtls_server_x509_client_verify_configure* and *nx_secure_dtls_server_x509_client_verify_disable* services.</span></span>

<span data-ttu-id="5739e-445">클라이언트 인증서 인증을 사용하도록 설정하려면 애플리케이션에서 DTLS 서버 세션 인스턴스를 사용하여 *nx_secure_dtls_server_x509_client_verify_configure* 를 호출한 후 *nx_secure_dtls_server_start* 를 호출해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-445">To enable Client Certificate Authentication, an application must call *nx_secure_dtls_server_x509_client_verify_configure* with the DTLS Server session instance before calling *nx_secure_dtls_server_start*.</span></span> <span data-ttu-id="5739e-446">확인하려면 *nx_secure_dtls_server_x509_client_verify_configure* 의 매개 변수로 제공되는 수신 클라이언트 인증서를 위한 공간을 할당해야 합니다</span><span class="sxs-lookup"><span data-stu-id="5739e-446">The verification requires space to be allocated for incoming client certificates which is provided as a parameter to *nx_secure_dtls_server_x509_client_verify_configure.*</span></span> <span data-ttu-id="5739e-447">버퍼는 클라이언트에서 제공하는 인증서 체인의 최대 크기를 충분히 수용할 수 있는 크기에 *DTLS 서버 세션 수를 곱한 값* 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-447">Note that the buffer must be large enough to hold the maximum-size certificate chain provided by a client *times the number of DTLS server sessions*.</span></span> <span data-ttu-id="5739e-448">각 서버 세션에는 제공된 단일 버퍼에서 할당되는 공간이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-448">Each server session requires space which will be allocated from the single provided buffer.</span></span> <span data-ttu-id="5739e-449">버퍼가 충분히 커야 합니다. 그렇지 않으면 제공된 클라이언트 인증서 체인이 너무 클 경우 오류가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-449">Make sure the buffer is large enough or an error will occur if the provided Client certificate chain is too large.</span></span>

<span data-ttu-id="5739e-450">클라이언트 인증서 인증을 사용하면 DTLS 서버는 DTLS 핸드셰이크 중에 원격 DTLS 클라이언트에 인증서를 요청합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-450">When Client Certificate Authentication is enabled, the DTLS Server will request a certificate from the remote DTLS Client during the DTLS handshake.</span></span> <span data-ttu-id="5739e-451">NetX Secure DTLS 서버에서는 X.509 발급자 체인을 따라 *nx_secure_dtls_server_trusted_certificate_add* 를 사용하여 만든 신뢰할 수 있는 인증서 저장소와 대조하여 클라이언트 인증서를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-451">In NetX Secure DTLS Server, the Client certificate is checked against the store of trusted certificates created with *nx_secure_dtls_server_trusted_certificate_add* by following the X.509 issuer chain.</span></span> <span data-ttu-id="5739e-452">원격 클라이언트는 ID 인증서를 신뢰할 수 있는 저장소의 인증서에 연결하는 체인을 제공해야 합니다. 그렇지 않으면 DTLS 핸드셰이크가 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-452">The remote Client must provide a chain that connects its identity certificate to a certificate in the trusted store or the DTLS handshake will fail.</span></span> <span data-ttu-id="5739e-453">또한 CertificateVerify 메시지 처리가 실패하면 DTLS 핸드셰이크도 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-453">Additionally, if the CertificateVerify message processing fails, the DTLS handshake will also fail.</span></span>

<span data-ttu-id="5739e-454">CertificateVerify 메서드에 사용되는 서명 메서드는 TLS 버전 1.0 및 TLS 버전 1.1용으로 수정되었으며, NetX Secure DTLS의 기반이 되는 TLS 버전 1.2의 TLS 서버에서 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-454">The signature methods used for the CertificateVerify method are fixed for TLS version 1.0 and TLS version 1.1, and are specified by the TLS Server in TLS version 1.2, upon which NetX Secure DTLS is based.</span></span> <span data-ttu-id="5739e-455">DTLS 1.2의 경우 지원되는 서명 메서드는 일반적으로 암호화 메서드 테이블에 제공된 관련 메서드를 따르지만, 일반적으로 SHA-256과 함께 RSA를 사용합니다. 암호화 메서드로 TLS를 초기화하는 방법에 대한 자세한 내용은 "NetX Secure TLS의 암호화" 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="5739e-455">For DTLS 1.2, the signature methods supported generally follow the relevant methods supplied in the cryptographic method table, but typically RSA with SHA-256 (see the section “Cryptography in NetX Secure TLS” for more information on initializing TLS with cryptographic methods).</span></span>

## <a name="cryptography-in-netx-secure-tls"></a><span data-ttu-id="5739e-456">NetX Secure TLS의 암호화</span><span class="sxs-lookup"><span data-stu-id="5739e-456">Cryptography in NetX Secure TLS</span></span>

<span data-ttu-id="5739e-457">TLS는 암호화를 사용하여 네트워크 통신을 보호할 수 있는 프로토콜을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-457">TLS defines a protocol in which cryptography can be used to secure network communications.</span></span> <span data-ttu-id="5739e-458">따라서 실제 암호화를 TLS 사용자에게 매우 광범위하게 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-458">As such, it leaves the actual cryptography to be used fairly wide open for TLS users.</span></span> <span data-ttu-id="5739e-459">이 사양에서는 단일 ciphersuite를 구현하기만 하면 됩니다. TLS 1.2의 경우에는 해당 ciphersuite는 TLS_RSA_WITH_AES_128_CBC_SHA입니다. 즉, 공개 키 작업에는 RSA를 사용하고, 세션 암호화에는 128비트 키를 사용하여 AES를 CBC 모드로 사용하고, 메시지 인증 해시에는 SHA-1을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-459">The specification only requires a single ciphersuite to be implemented – in the case of TLS 1.2, that ciphersuite is TLS_RSA_WITH_AES_128_CBC_SHA, indicating the use of RSA for public-key operations, AES in CBC mode with 128-bit keys for session encryption, and SHA-1 for message authentication hashes.</span></span>

<span data-ttu-id="5739e-460">TLS 1.2 규격을 준수하는 NetX Secure는 기본적으로 필수 TLS_RSA_WITH_AES_128_CBC_SHA ciphersuite를 사용하지만, 하드웨어 기능과 기타 고려 사항으로 인해 각 암호화 메서드에 대해 가능한 구현 수를 고려하여 NetX Secure는 사용자가 TLS에서 사용할 암호화 메서드를 지정할 수 있는 일반 암호화 API를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-460">Being TLS 1.2-compliant, NetX Secure enables the mandatory TLS_RSA_WITH_AES_128_CBC_SHA ciphersuite by default, but given the number of possible implementations for each of the cryptographic methods due to hardware capabilities and other considerations, NetX Secure provides a generic cryptographic API that allows a user to specify which cryptographic methods to use with TLS.</span></span>

> [!NOTE]
> <span data-ttu-id="5739e-461">일반 암호화 API 메커니즘을 사용하면 사용자가 고유의 ciphersuite를 구현할 수 있지만, TLS ciphersuite 및 확장에 익숙한 고급 사용자만 이 메커니즘을 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-461">The generic cryptographic API mechanism also allows users to implement their own ciphersuites, but this is recommended for advanced users who are familiar with the TLS ciphersuites and extensions.</span></span> <span data-ttu-id="5739e-462">자체 ciphersuite를 지원하려면 Express 논리 담당자에게 문의하세요.</span><span class="sxs-lookup"><span data-stu-id="5739e-462">Please contact your Express Logic representative if you are interested in supporting your own ciphersuites.</span></span>

<span data-ttu-id="5739e-463">DTLS에 대한 암호화 메서드를 구성하는 방법에 대한 자세한 내용은 NetX Secure TLS 사용자 가이드의 챕터 3을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="5739e-463">Please see the NetX Secure TLS User Guide, Chapter 3 for a detailed discussion about how to configure cryptographic methods for DTLS.</span></span> <span data-ttu-id="5739e-464">TLS 및 DTLS에 동일한 프로세스가 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="5739e-464">The same process applies to both TLS and DTLS.</span></span>
