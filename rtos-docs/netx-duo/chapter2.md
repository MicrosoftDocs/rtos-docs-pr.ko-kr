---
title: 2장 - Azure RTOS NetX Duo 설치 및 사용
description: 이 장에서는 고성능 네트워크 스택인 Azure RTOS NetX Duo의 설치, 설정, 사용과 관련된 다양한 문제에 대해 설명합니다.
author: philmea
ms.author: philmea
ms.date: 05/19/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 8ee9d16c71d6c207de2098d688d49e6482c8b780
ms.sourcegitcommit: 60ad844b58639d88830f2660ab0c4ff86b92c10f
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/07/2021
ms.locfileid: "106550153"
---
# <a name="chapter-2---installation-and-use-of-azure-rtos-netx-duo"></a><span data-ttu-id="fef75-103">2장 - Azure RTOS NetX Duo 설치 및 사용</span><span class="sxs-lookup"><span data-stu-id="fef75-103">Chapter 2 - Installation and Use of Azure RTOS NetX Duo</span></span>

<span data-ttu-id="fef75-104">이 장에서는 다음을 비롯하여 고성능 네트워크 스택인 Azure RTOS NetX Duo의 설치, 설정, 사용과 관련된 다양한 문제에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-104">This chapter contains a description of various issues related to installation, setup, and use of the high- performance network stack Azure RTOS NetX Duo, including the following:</span></span> 

## <a name="host-considerations"></a><span data-ttu-id="fef75-105">호스트 고려 사항</span><span class="sxs-lookup"><span data-stu-id="fef75-105">Host Considerations</span></span>

<span data-ttu-id="fef75-106">임베디드 개발은 일반적으로 Windows 또는 Linux(Unix) 호스트 컴퓨터에서 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-106">Embedded development is usually performed on Windows or Linux (Unix) host computers.</span></span> <span data-ttu-id="fef75-107">애플리케이션이 컴파일되고 연결된 후 호스트에서 실행 파일이 생성되면 실행을 위해 대상 하드웨어로 다운로드됩니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-107">After the application is compiled, linked, and the executable is generated on the host, it is downloaded to the target hardware for execution.</span></span>

<span data-ttu-id="fef75-108">일반적으로 대상 다운로드는 개발 도구의 디버거 내에서 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-108">Usually the target download is done from within the development tool's debugger.</span></span> <span data-ttu-id="fef75-109">다운로드 후 디버거는 대상 실행 제어(이동, 중지, 중단점 등) 뿐만 아니라 메모리 및 프로세서 레지스터에 대한 액세스를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-109">After download, the debugger is responsible for providing target execution control (go, halt, breakpoint, etc.) as well as access to memory and processor registers.</span></span>

<span data-ttu-id="fef75-110">대부분의 개발 도구 디버거는 JTAG(IEEE 1149.1) 및 BDM(백그라운드 디버그 모드)과 같은 OCD(온-칩 디버그) 연결을 통해 대상 하드웨어와 통신합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-110">Most development tool debuggers communicate with the target hardware via on-chip debug (OCD) connections such as JTAG (IEEE 1149.1) and Background Debug Mode (BDM).</span></span> <span data-ttu-id="fef75-111">또한 디버거는 ICE(회로 내 에뮬레이션) 연결을 통해 대상 하드웨어와 통신합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-111">Debuggers also communicate with target hardware through In-Circuit Emulation (ICE) connections.</span></span> <span data-ttu-id="fef75-112">OCD와 ICE 연결은 모두 대상 상주 소프트웨어에 대한 최소 침입으로 강력한 솔루션을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-112">Both OCD and ICE connections provide robust solutions with minimal intrusion on the target resident software.</span></span>

<span data-ttu-id="fef75-113">호스트에서 사용되는 리소스의 경우에는 GUXI에 대한 소스 코드를 ASCII 형식으로 전달하고 호스트 컴퓨터의 하드 디스크에 약 1MB의 공간이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-113">As for resources used on the host, the source code for NetX Duo is delivered in ASCII format and requires approximately 1 Mbytes of space on the host computer's hard disk.</span></span>

## <a name="target-considerations"></a><span data-ttu-id="fef75-114">대상 고려 사항</span><span class="sxs-lookup"><span data-stu-id="fef75-114">Target Considerations</span></span>

<span data-ttu-id="fef75-115">NetX Duo에는 대상에서 5KB~45KB의 ROM(읽기 전용 메모리)이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-115">NetX Duo requires between 5 KBytes and 45 KBytes of Read-Only Memory (ROM) on the target.</span></span> <span data-ttu-id="fef75-116">NetX Duo 스레드 스택 및 기타 글로벌 데이터 구조에는 대상에서 1~5KB의 RAM(Random Access Memory)이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-116">Another 1 to 5KBytes of the target's Random Access Memory (RAM) are required for the NetX Duo thread stack and other global data structures.</span></span>

<span data-ttu-id="fef75-117">NetX Duo는 두 개의 ThreadX 타이머 개체와 하나의 ThreadX 뮤텍스 개체도 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-117">In addition, NetX Duo requires the use of two ThreadX timer objects and one ThreadX mutex object.</span></span> <span data-ttu-id="fef75-118">이러한 기능은 NetX Duo 프로토콜 스택 내의 정기적인 처리 요구 사항 및 스레드 보호에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-118">These facilities are used for periodic processing needs and thread protection inside the NetX Duo protocol stack.</span></span>

## <a name="product-distribution"></a><span data-ttu-id="fef75-119">제품 배포</span><span class="sxs-lookup"><span data-stu-id="fef75-119">Product Distribution</span></span>

<span data-ttu-id="fef75-120">Azure RTOS NetX Duo는 <https://github.com/azure-rtos/netxduo/>에 있는 공용 소스 코드 리포지토리에서 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-120">Azure RTOS NetX Duo can be obtained from our public source code repository at <https://github.com/azure-rtos/netxduo/>.</span></span>

<span data-ttu-id="fef75-121">다음은 리포지토리에 있는 몇 가지 중요한 파일 목록입니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-121">The following is a list of several important files in the repository:</span></span>

<span data-ttu-id="fef75-122">**nx_api.h**</span><span class="sxs-lookup"><span data-stu-id="fef75-122">**nx_api.h**</span></span>  
<span data-ttu-id="fef75-123">모든 시스템 등식, 데이터 구조 및 서비스 프로토타입이 포함되어 있는 C 헤더 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-123">C header file containing all system equates, data structures, and service prototypes.</span></span>

<span data-ttu-id="fef75-124">**nx_port.h** 모든 개발 도구 및 대상 특정 데이터 정의 및 구조를 포함하는 C 헤더 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-124">**nx_port.h** C header file containing all development-tool and targetspecific data definitions and structures.</span></span> 

<span data-ttu-id="fef75-125">**demo_netx.c** 작은 데모 애플리케이션을 포함하는 C 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-125">**demo_netx.c** C file containing a small demo application.</span></span>

<span data-ttu-id="fef75-126">**nx.a(또는 nx.lib)**</span><span class="sxs-lookup"><span data-stu-id="fef75-126">**nx.a (or nx.lib)**</span></span>  
<span data-ttu-id="fef75-127">표준 패키지와 함께 배포되는 NetX C 라이브러리의 이진 버전입니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-127">Binary version of the NetX C library that is distributed with the standard package.</span></span>

## <a name="netx-duo-installation"></a><span data-ttu-id="fef75-128">NetX Duo 설치</span><span class="sxs-lookup"><span data-stu-id="fef75-128">NetX Duo Installation</span></span>

<span data-ttu-id="fef75-129">NetX Duo는 GitHub 리포지토리를 로컬 머신에 복제하여 설치됩니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-129">NetX Duo is installed by cloning the GitHub repository to your local machine.</span></span> <span data-ttu-id="fef75-130">다음은 PC에서 NetX Duo 리포지토리의 복제본을 만들기 위한 일반적인 구문입니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-130">The following is typical syntax for creating a clone of the NetX Duo repository on your PC:</span></span>

```c
    git clone https://github.com/azure-rtos/netxduo
```

<span data-ttu-id="fef75-131">또는 GitHub 기본 페이지의 다운로드 단추를 사용하여 리포지토리의 복사본을 다운로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-131">Alternatively you can download a copy of the repository using the download button on the GitHub main page.</span></span>

<span data-ttu-id="fef75-132">또한 온라인 리포지토리의 프런트 페이지에서 NetX Duo 라이브러리를 빌드하기 위한 지침을 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-132">You will also find instructions for building the NetX Duo library on the front page of the online repository.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="fef75-133">*애플리케이션 소프트웨어는 NetX Duo 라이브러리 파일(일반적으로 **nx.a** 또는 **nx.lib**) 및 C 포함 파일 **nx_api.h 및 nx_port.h** 에 액세스해야 합니다. 이는 개발 도구에 대한 적절한 경로를 설정하거나 애플리케이션 개발 영역에 이러한 파일을 복사하여 수행됩니다.*</span><span class="sxs-lookup"><span data-stu-id="fef75-133">*Application software needs access to the NetX Duo library file (usually **nx.a** or **nx.lib**) and the C include files **nx_api.h, and nx_port.h**. This is accomplished either by setting the appropriate path for the development tools or by copying these files into the application development area.*</span></span>

## <a name="using-netx-duo"></a><span data-ttu-id="fef75-134">NetX Duo 사용</span><span class="sxs-lookup"><span data-stu-id="fef75-134">Using NetX Duo</span></span>

<span data-ttu-id="fef75-135">NetX Duo를 사용하는 것은 쉽습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-135">Using NetX Duo is easy.</span></span> <span data-ttu-id="fef75-136">기본적으로 컴파일하는 동안 및 NetX Duo 라이브러리 _*_nx.a_*_(또는 _ *_nx.lib_*)\*와 연결하는 동안 \***nx_api.h** _가 애플리케이션 코드에 포함되어 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-136">Basically, the application code must include ***nx_api.h** _ during compilation and link with the NetX Duo library _*_nx.a_*_ (or _ *_nx.lib_*)*.</span></span>

<span data-ttu-id="fef75-137">NetX Duo 애플리케이션을 빌드하는 데 필요한 네 가지 간단한 단계는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-137">The following are the four easy steps required to build a NetX Duo application:</span></span>

[!div class="mx-tdCol2BreakAll"]

| <span data-ttu-id="fef75-138">단계</span><span class="sxs-lookup"><span data-stu-id="fef75-138">Step</span></span>  | <span data-ttu-id="fef75-139">Description</span><span class="sxs-lookup"><span data-stu-id="fef75-139">Description</span></span>  |
|---|---|
|<span data-ttu-id="fef75-140">&nbsp;1단계:</span><span class="sxs-lookup"><span data-stu-id="fef75-140">Step&nbsp;1:</span></span> |<span data-ttu-id="fef75-141">NetX Duo 서비스 또는 데이터 구조를 사용하는 모든 애플리케이션 파일에 ***nx_api.h*** 파일을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-141">Include the ***nx_api.h*** file in all application files that use NetX Duo services or data structures.</span></span>|
|<span data-ttu-id="fef75-142">&nbsp;2단계:</span><span class="sxs-lookup"><span data-stu-id="fef75-142">Step&nbsp;2:</span></span> |<span data-ttu-id="fef75-143">_ _tx_application_define_\* 함수 또는 애플리케이션 스레드에서 \***nx_system_initialize** _를 호출하여 NetX Duo 시스템을 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-143">Initialize the NetX Duo system by calling ***nx_system_initialize** _ from the _ *_tx_application_define_** function or an application thread.</span></span>|
|<span data-ttu-id="fef75-144">&nbsp;3단계:</span><span class="sxs-lookup"><span data-stu-id="fef75-144">Step&nbsp;3:</span></span> |<span data-ttu-id="fef75-145">***nx_system_initialize*** 를 호출한 후 IP 인스턴스를 만들고 ARP(주소 확인 프로토콜) 및 소켓(필요한 경우)을 사용하도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-145">Create an IP instance, enable the Address Resolution Protocol (ARP), if necessary, and any sockets after ***nx_system_initialize*** is called.</span></span>|
|<span data-ttu-id="fef75-146">&nbsp;4단계:</span><span class="sxs-lookup"><span data-stu-id="fef75-146">Step&nbsp;4:</span></span> |<span data-ttu-id="fef75-147">애플리케이션 원본을 컴파일하고 NetX Duo 런타임 라이브러리 ***nx.a** _(또는 _*_nx.lib_\*\*)와 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-147">Compile application source and link with the NetX Duo runtime library ***nx.a** _ (or _*_nx.lib_\*\*).</span></span> <span data-ttu-id="fef75-148">결과 이미지를 대상으로 다운로드하여 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-148">The resulting image can be downloaded to the target and executed!</span></span>|

## <a name="troubleshooting"></a><span data-ttu-id="fef75-149">문제 해결</span><span class="sxs-lookup"><span data-stu-id="fef75-149">Troubleshooting</span></span>

<span data-ttu-id="fef75-150">각 NetX Duo 포트는 실제 네트워크에서 또는 시뮬레이션된 네트워크 드라이버를 통해 실행되는 하나 이상의 데모와 함께 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-150">Each NetX Duo port is delivered with one or more demonstrations that execute on an actual network or via a simulated network driver.</span></span> <span data-ttu-id="fef75-151">항상 데모 시스템을 먼저 실행하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-151">It is always a good idea to get the demonstration system running first.</span></span>

<span data-ttu-id="fef75-152">데모 시스템이 제대로 실행되지 않으면 다음 작업을 수행하여 문제의 범위를 좁힙니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-152">If the demonstration system does not run properly, perform the following operations to narrow the problem:</span></span>

1. <span data-ttu-id="fef75-153">데모가 어느 정도 실행되고 있는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-153">Determine how much of the demonstration is running.</span></span>
2. <span data-ttu-id="fef75-154">모든 새 애플리케이션 스레드의 스택 크기를 늘립니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-154">Increase stack sizes in any new application threads.</span></span>
3. <span data-ttu-id="fef75-155">구성 옵션 섹션에 나열된 적절한 디버그 옵션을 사용하여 NetX 라이브러리를 다시 컴파일합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-155">Recompile the NetX Duo library with the appropriate debug options listed in the configuration option section.</span></span>
4. <span data-ttu-id="fef75-156">NX_IP 구조체를 검사하여 패킷이 송신 또는 수신되고 있는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-156">Examine the NX_IP structure to see if packets are being sent or received.</span></span>
5. <span data-ttu-id="fef75-157">기본 패킷 풀을 검사하여 사용할 수 있는 패킷이 있는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-157">Examine the default packet pool to see if there are available packets.</span></span>
6. <span data-ttu-id="fef75-158">네트워크 드라이버가 IPv4 또는 IPv6 연결이 필요한 애플리케이션의 4바이트 경계에 ARP 및 IP 패킷을 해당 헤더와 함께 제공하는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-158">Ensure the network driver is supplying ARP and IP packets with its headers on 4-byte boundaries for applications requiring IPv4 or IPv6 connectivity.</span></span>
7. <span data-ttu-id="fef75-159">최근 변경 내용을 일시적으로 무시하여 문제가 사라지거나 달라지는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-159">Temporarily bypass any recent changes to see if the problem disappears or changes.</span></span> <span data-ttu-id="fef75-160">이러한 정보는 Microsoft 지원 엔지니어에게 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-160">Such information should prove useful to Microsoft support engineers.</span></span>

<span data-ttu-id="fef75-161">12페이지의 “제공할 사항”에서 설명하는 절차에 따라 문제 해결 단계에서 수집한 정보를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-161">Follow the procedures outlined in the "What We Need From You" on page 12 to send the information gathered from the troubleshooting steps.</span></span>

## <a name="configuration-options"></a><span data-ttu-id="fef75-162">구성 옵션</span><span class="sxs-lookup"><span data-stu-id="fef75-162">Configuration Options</span></span>

<span data-ttu-id="fef75-163">NetX Duo를 사용하여 NetX Duo 라이브러리 및 애플리케이션을 빌드할 때 몇 가지 구성 옵션이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-163">There are several configuration options when building the NetX Duo library and the application using NetX Duo.</span></span> <span data-ttu-id="fef75-164">구성 옵션은 달리 지정되지 않은 경우 애플리케이션 원본, 명령줄 또는 ***nx_user.h*** 포함 파일 내에 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-164">The configuration options can be defined in the application source, on the command line, or within the ***nx_user.h*** include file, unless otherwise specified.</span></span>

> [!NOTE]
> <span data-ttu-id="fef75-165">**nx_user.h** 에 정의된 옵션은 애플리케이션 및 NetX Duo 라이브러리가 **NX_INCLUDE_USER_DEFINE_FILE** 옵션이 정의된 상태로 빌드된 경우에만 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-165">*Options defined in **nx_user.h** are applied only if the application and NetX Duo library are built with* **NX_INCLUDE_USER_DEFINE_FILE** defined.\*</span></span>

<span data-ttu-id="fef75-166">다음 섹션에는 NetX Duo에서 사용할 수 있는 구성 옵션이 나열되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-166">The following sections list the configuration options available in NetX Duo.</span></span> <span data-ttu-id="fef75-167">IPv4 및 IPv6 둘 다에 적용되는 일반 옵션이 먼저 나열되고 그 다음에 IPv6 관련 옵션이 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-167">General options applicable to both IPv4 and IPv6 are listed first, followed by IPv6-specific options.</span></span>

### <a name="system-configuration-options"></a><span data-ttu-id="fef75-168">시스템 구성 옵션</span><span class="sxs-lookup"><span data-stu-id="fef75-168">System Configuration Options</span></span>

| <span data-ttu-id="fef75-169">옵션</span><span class="sxs-lookup"><span data-stu-id="fef75-169">Option</span></span>  | <span data-ttu-id="fef75-170">Description</span><span class="sxs-lookup"><span data-stu-id="fef75-170">Description</span></span>  |
|---|---|
| <span data-ttu-id="fef75-171">NX_ASSERT_FAIL</span><span class="sxs-lookup"><span data-stu-id="fef75-171">NX_ASSERT_FAIL</span></span>    | <span data-ttu-id="fef75-172">어설션이 실패할 때 사용할 디버그 문을 정의하는 기호입니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-172">Symbol that defines the debug statement to use when an assertion fails.</span></span>                               |
| <span data-ttu-id="fef75-173">NX_DEBUG</span><span class="sxs-lookup"><span data-stu-id="fef75-173">NX_DEBUG</span></span>           | <span data-ttu-id="fef75-174">정의된 경우 RAM 이더넷 네트워크 드라이버에서 제공되는 선택적 인쇄 디버그 정보를 사용하도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-174">Defined, enables the optional print debug information available from the RAM Ethernet network driver.</span></span> |
| <span data-ttu-id="fef75-175">NX_DEBUG_PACKET</span><span class="sxs-lookup"><span data-stu-id="fef75-175">NX_DEBUG_PACKET</span></span>   | <span data-ttu-id="fef75-176">정의된 경우 RAM 이더넷 네트워크 드라이버에서 제공되는 선택적 디버그 패킷 덤핑을 사용하도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-176">Defined, enables the optional debug packet dumping available in the RAM Ethernet network driver.</span></span>      |
| <span data-ttu-id="fef75-177">NX_DISABLE_ASSERT</span><span class="sxs-lookup"><span data-stu-id="fef75-177">NX_DISABLE_ASSERT</span></span> | <span data-ttu-id="fef75-178">정의된 경우 소스 코드에서 ASSERT 검사를 사용하지 않도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-178">Defined, disables ASSERT checks in the source code.</span></span> <span data-ttu-id="fef75-179">기본적으로 이 옵션은 정의되어 있지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-179">By default this option is not defined.</span></span>            |
|<span data-ttu-id="fef75-180">NX_DISABLE_ERROR_CHECKING</span><span class="sxs-lookup"><span data-stu-id="fef75-180">NX_DISABLE_ERROR_CHECKING</span></span> | <span data-ttu-id="fef75-181">정의된 경우 기본 NetX Duo 오류 검사 API를 제거하여 성능을 개선합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-181">Defined, removes the basic NetX Duo error checking API and improves performance.</span></span> <span data-ttu-id="fef75-182">오류 검사를 사용하지 않도록 설정해도 영향을 받지 않는 API 반환 코드는 API 정의의 굵은 서체에 나열됩니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-182">API return codes not affected by disabling error checking are listed in bold typeface in the API definition.</span></span> <span data-ttu-id="fef75-183">이 정의는 일반적으로 애플리케이션을 충분히 디버그한 후 사용되며 이 정의를 사용하면 성능은 개선되고 코드 크기는 감소하는 경우 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-183">This define is typically used after the application is debugged sufficiently and its use improves performance and decreases code size.</span></span>|
|<span data-ttu-id="fef75-184">NX_DRIVER_DEFERRED_PROCESSING</span><span class="sxs-lookup"><span data-stu-id="fef75-184">NX_DRIVER_DEFERRED_PROCESSING</span></span> | <span data-ttu-id="fef75-185">정의된 경우 지연된 네트워크 드라이버 패킷 처리를 사용하도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-185">Defined, enables deferred network driver packet handling.</span></span> <span data-ttu-id="fef75-186">이렇게 하면 네트워크 드라이버에서 IP 인스턴스에 패킷을 배치하고 NetX Duo 내부 IP 도우미 스레드에서 실제 처리 루틴이 호출되도록 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-186">This allows the network driver to place a packet on the IP instance and have the real processing routine called from the NetX Duo internal IP helper thread.</span></span>|
|<span data-ttu-id="fef75-187">NX_DUAL_PACKET_POOL_ENABLE</span><span class="sxs-lookup"><span data-stu-id="fef75-187">NX_DUAL_PACKET_POOL_ENABLE</span></span> | <span data-ttu-id="fef75-188">\***NX_ENABLE_DUAL_PACKET_POOL** _로 이름을 바꿨습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-188">Renamed to  \***NX_ENABLE_DUAL_PACKET_POOL** _.</span></span> <span data-ttu-id="fef75-189">아직 지원되는 옵션이지만 새 디자인에서는 _\*_NX_ENABLE_DUAL_PACKET_POOL_\*\*을 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-189">Although it is still being supported, new designs are encouraged to use _\*_NX_ENABLE_DUAL_PACKET_POOL_\*\*.</span></span>|
|<span data-ttu-id="fef75-190">NX_ENABLE_DUAL_PACKET_POOL</span><span class="sxs-lookup"><span data-stu-id="fef75-190">NX_ENABLE_DUAL_PACKET_POOL</span></span> | <span data-ttu-id="fef75-191">정의된 경우 스택에서는 2개의 패킷 풀(페이로드 크기가 큰 패킷 풀 1개, 페이로드 크기가 더 작은 패킷 풀 1개)을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-191">Defined, allows the stack to use two packet pools, one with large payload size and one with smaller payload size.</span></span> <span data-ttu-id="fef75-192">기본적으로 이 옵션은 사용하도록 설정되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-192">By default this option is not enabled.</span></span>|
|<span data-ttu-id="fef75-193">NX_ENABLE_EXTENDED_NOTIFY_SUPPORT</span><span class="sxs-lookup"><span data-stu-id="fef75-193">NX_ENABLE_EXTENDED_NOTIFY_SUPPORT</span></span>| <span data-ttu-id="fef75-194">정의된 경우 스택에서 더 많은 콜백 후크를 사용하도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-194">Defined, enables more callback hooks in the stack.</span></span> <span data-ttu-id="fef75-195">이러한 콜백 함수는 BSD 래퍼 계층에서 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-195">These callback functions are used by the BSD wrapper layer.</span></span> <span data-ttu-id="fef75-196">기본적으로 이 옵션은 정의되어 있지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-196">By default this option is not defined.</span></span>|
|<span data-ttu-id="fef75-197">NX_ENABLE_INTERFACE_CAPABILITY</span><span class="sxs-lookup"><span data-stu-id="fef75-197">NX_ENABLE_INTERFACE_CAPABILITY</span></span>| <span data-ttu-id="fef75-198">정의된 경우 인터페이스 디바이스 드라이버에서 체크섬 오프로드와 같은 추가 기능 정보를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-198">Defined, allows the interface device driver to specify extra capability information, such as checksum off-loading.</span></span> <span data-ttu-id="fef75-199">기본적으로 이 옵션은 정의되어 있지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-199">By default this option is not defined.</span></span>|
|<span data-ttu-id="fef75-200">NX_ENABLE_SOURCE_ADDRESS_CHECK</span><span class="sxs-lookup"><span data-stu-id="fef75-200">NX_ENABLE_SOURCE_ADDRESS_CHECK</span></span>| <span data-ttu-id="fef75-201">정의된 경우 수신 패킷의 원본 주소를 확인할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-201">Defined, enables the source address of incoming packet to be checked.</span></span> <span data-ttu-id="fef75-202">이 옵션은 기본적으로 사용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-202">By default this option is disabled.</span></span>|
| <span data-ttu-id="fef75-203">NX_IPSEC_ENABLE</span><span class="sxs-lookup"><span data-stu-id="fef75-203">NX_IPSEC_ENABLE</span></span>  | <span data-ttu-id="fef75-204">정의된 경우 NetX Duo 라이브러리가 IPsec 작업을 지원할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-204">Defined, enables the NetX Duo library to support IPsec operations.</span></span> <span data-ttu-id="fef75-205">이 기능을 사용하려면 선택적 NetX Duo IPsec 모듈이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-205">This feature requires the optional NetX Duo IPsec module.</span></span> <span data-ttu-id="fef75-206">기본적으로 이 기능은 사용하지 않도록 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-206">By default this feature is not enabled.</span></span>            |
| <span data-ttu-id="fef75-207">NX_LITTLE_ENDIAN</span><span class="sxs-lookup"><span data-stu-id="fef75-207">NX_LITTLE_ENDIAN</span></span> | <span data-ttu-id="fef75-208">정의된 경우 little endian 환경에서 필요한 바이트 스와핑을 수행하여 프로토콜 헤더가 적절한 big endian 형식인지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-208">Defined, performs the necessary byte swapping on little endian environments to ensure the protocol headers are in proper big endian format.</span></span> <span data-ttu-id="fef75-209">기본값은 일반적으로 ***nx_port.h*** 에 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-209">Note the default is typically setup in ***nx_port.h***.</span></span>|
|<span data-ttu-id="fef75-210">NX_MAX_PHYSICAL_INTERFACES</span><span class="sxs-lookup"><span data-stu-id="fef75-210">NX_MAX_PHYSICAL_INTERFACES</span></span> | <span data-ttu-id="fef75-211">디바이스의 총 실제 네트워크 인터페이스 수를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-211">Specifies the total number of physical network interfaces on the device.</span></span> <span data-ttu-id="fef75-212">기본값은 1이고 ***nx_api.h*** 에 정의되어 있습니다. 디바이스에는 하나 이상의 실제 인터페이스가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-212">The default value is 1 and is defined in ***nx_api.h***; a device must have at least one physical interface.</span></span> <span data-ttu-id="fef75-213">루프백 인터페이스는 포함되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-213">Note this does not include the loopback interface.</span></span>|
| <span data-ttu-id="fef75-214">NX_NAT_ENABLE</span><span class="sxs-lookup"><span data-stu-id="fef75-214">NX_NAT_ENABLE</span></span> | <span data-ttu-id="fef75-215">정의된 경우 NetX Duo는 NAT 프로세스를 사용하여 빌드됩니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-215">Defined, NetX Duo is built with NAT process.</span></span> <span data-ttu-id="fef75-216">기본적으로 이 옵션은 정의되어 있지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-216">By default this option is not defined.</span></span>|
| <span data-ttu-id="fef75-217">NX_PHYSICAL_HEADER</span><span class="sxs-lookup"><span data-stu-id="fef75-217">NX_PHYSICAL_HEADER</span></span>  | <span data-ttu-id="fef75-218">프레임의 실제 헤더 크기(바이트)를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-218">Specifies the size in bytes of the physical header of the frame.</span></span> <span data-ttu-id="fef75-219">기본값은 16이며(32비트 경계에 맞춘 일반적인 14바이트 이더넷 프레임 기준) \***nx_api.h** _에 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-219">The default value is 16 (based on a typical 14-byte Ethernet frame aligned to 32-bit boundary) and is defined in \***nx_api.h** _.</span></span> <span data-ttu-id="fef75-220">애플리케이션은 _ *_nx_user.h_\*\*에서와 같이 _*_nx_api.h_\*_ 가 포함되기 전에 값을 정의하여 이 기본값을 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-220">The application can override the default by defining the value before _*_nx_api.h_*_ is included, such as in _ *_nx_user.h_*.\*</span></span> |
| <span data-ttu-id="fef75-221">NX_PHYSICAL_TRAILER</span><span class="sxs-lookup"><span data-stu-id="fef75-221">NX_PHYSICAL_TRAILER</span></span> | <span data-ttu-id="fef75-222">실제 패킷 트레일러의 크기(바이트)를 지정하며, 일반적으로 이더넷 CRC 등의 항목에 대한 스토리지를 예약하는 데 사용됩니다. 기본값은 4이고 ***nx_api.h*** 에 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-222">Specifies the size in bytes of the physical packet trailer and is typically used to reserve storage for things like Ethernet CRCs, etc. The default value is 4 and is defined in ***nx_api.h***.</span></span>|

### <a name="arp-configuration-options"></a><span data-ttu-id="fef75-223">ARP 구성 옵션</span><span class="sxs-lookup"><span data-stu-id="fef75-223">ARP Configuration Options</span></span>

| <span data-ttu-id="fef75-224">옵션</span><span class="sxs-lookup"><span data-stu-id="fef75-224">Option</span></span>  | <span data-ttu-id="fef75-225">Description</span><span class="sxs-lookup"><span data-stu-id="fef75-225">Description</span></span>  |
|---|---|
|<span data-ttu-id="fef75-226">NX_ARP_DEFEND_BY_REPLY</span><span class="sxs-lookup"><span data-stu-id="fef75-226">NX_ARP_DEFEND_BY_REPLY</span></span> | <span data-ttu-id="fef75-227">정의된 경우 NetX Duo에서 ARP 응답을 송신하여 해당 IP 주소를 방어할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-227">Defined, allows NetX Duo to defend its IP address by sending an ARP response.</span></span>|
|<span data-ttu-id="fef75-228">NX_ARP_DEFEND_INTERVAL</span><span class="sxs-lookup"><span data-stu-id="fef75-228">NX_ARP_DEFEND_INTERVAL</span></span>| <span data-ttu-id="fef75-229">충돌하는 주소가 표시된 수신 ARP 메시지에 응답하여 ARP 모듈이 다음 방어 패킷을 송신하는 간격(초)을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-229">Defines the interval, in seconds, the ARP module sends out the next defend packet in response to an incoming ARP message that indicates an address in conflict.</span></span>|
|<span data-ttu-id="fef75-230">NX_ARP_DISABLE_AUTO_ARP_ENTRY</span><span class="sxs-lookup"><span data-stu-id="fef75-230">NX_ARP_DISABLE_AUTO_ARP_ENTRY</span></span>|  <span data-ttu-id="fef75-231">\***NX_DISABLE_ARP_AUTO_ENTRY** _로 이름이 바뀌었습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-231">Renamed to \***NX_DISABLE_ARP_AUTO_ENTRY** _.</span></span> <span data-ttu-id="fef75-232">아직 지원되는 옵션이지만 새 디자인에서는 _\*_NX_DISABLE_ARP_AUTO_ENTRY_\*\*를 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-232">Although it is still being supported, new designs are encouraged to use _\*_NX_DISABLE_ARP_AUTO_ENTRY_\*\*.</span></span>|
|<span data-ttu-id="fef75-233">NX_ARP_EXPIRATION_RATE</span><span class="sxs-lookup"><span data-stu-id="fef75-233">NX_ARP_EXPIRATION_RATE</span></span>| <span data-ttu-id="fef75-234">ARP 항목이 유효한 상태로 유지되는 시간(초)을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-234">Specifies the number of seconds ARP entries remain valid.</span></span> <span data-ttu-id="fef75-235">기본값인 0을 사용하면 ARP 항목 만료 또는 에이징을 사용하지 않도록 설정하며 기본값은 \***nx_api.h** _에 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-235">The default value of zero disables expiration or aging of ARP entries and is defined in \***nx_api.h** _.</span></span> <span data-ttu-id="fef75-236">애플리케이션은 _ _nx_api.h_\*가 포함되기 전에 값을 정의하여 이 기본값을 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-236">The application can override the default by defining the value before _ *_nx_api.h_*\* is included.</span></span>|
|<span data-ttu-id="fef75-237">NX_ARP_MAC_CHANGE_NOTIFICATION_ENABLE</span><span class="sxs-lookup"><span data-stu-id="fef75-237">NX_ARP_MAC_CHANGE_NOTIFICATION_ENABLE</span></span> | <span data-ttu-id="fef75-238">\***NX_ENABLE_ARP_MAC_CHANGE_NOTIFICATION** _으로 이름이 바뀌었습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-238">Renamed to \***NX_ENABLE_ARP_MAC_CHANGE_NOTIFICATION** _.</span></span> <span data-ttu-id="fef75-239">아직 지원되는 옵션이지만 새 디자인에서는 _\*_NX_ENABLE_ARP_MAC_CHANGE_NOTIFICATION_\*\*을 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-239">Although it is still being supported, new designs are encouraged to use _\*_NX_ENABLE_ARP_MAC_CHANGE_NOTIFICATION_\*\*.</span></span>|
|<span data-ttu-id="fef75-240">NX_ARP_MAX_QUEUE_DEPTH</span><span class="sxs-lookup"><span data-stu-id="fef75-240">NX_ARP_MAX_QUEUE_DEPTH</span></span> | <span data-ttu-id="fef75-241">ARP 응답을 기다리는 동안 큐에 대기될 수 있는 최대 패킷 수를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-241">Specifies the maximum number of packets that can be queued while waiting for an ARP response.</span></span> <span data-ttu-id="fef75-242">기본값은 4이고 ***nx_api.h*** 에 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-242">The default value is 4 and is defined in ***nx_api.h***.</span></span>|
|<span data-ttu-id="fef75-243">NX_ARP_MAXIMUM_RETRIES</span><span class="sxs-lookup"><span data-stu-id="fef75-243">NX_ARP_MAXIMUM_RETRIES</span></span> | <span data-ttu-id="fef75-244">ARP 응답 없이 수행되는 최대 ARP 재시도 수를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-244">Specifies the maximum number of ARP retries made without an ARP response.</span></span> <span data-ttu-id="fef75-245">기본값은 18이고 \***nx_api.h** _에 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-245">The default value is 18 and is defined in \***nx_api.h** _.</span></span> <span data-ttu-id="fef75-246">애플리케이션은 _ _nx_api.h_\*가 포함되기 전에 값을 정의하여 이 기본값을 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-246">The application can override the default by defining the value before _ *_nx_api.h_*\* is included.</span></span>|
|<span data-ttu-id="fef75-247">NX_ARP_UPDATE_RATE</span><span class="sxs-lookup"><span data-stu-id="fef75-247">NX_ARP_UPDATE_RATE</span></span> | <span data-ttu-id="fef75-248">ARP 재시도 간 시간(초)을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-248">Specifies the number of seconds between ARP retries.</span></span> <span data-ttu-id="fef75-249">기본값은 10으로, 10초를 나타내며 \***nx_api.h** _에 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-249">The default value is 10, which represents 10 seconds, and is defined in \***nx_api.h** _.</span></span> <span data-ttu-id="fef75-250">애플리케이션은 _ _nx_api.h_\*가 포함되기 전에 값을 정의하여 이 기본값을 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-250">The application can override the default by defining the value before _ *_nx_api.h_*\* is included.</span></span>|
|<span data-ttu-id="fef75-251">NX_DISABLE_ARP_AUTO_ENTRY</span><span class="sxs-lookup"><span data-stu-id="fef75-251">NX_DISABLE_ARP_AUTO_ENTRY</span></span> | <span data-ttu-id="fef75-252">정의된 경우 ARP 캐시에 ARP 요청 정보를 입력할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-252">Defined, disables entering ARP request information in the ARP cache.</span></span>|
|<span data-ttu-id="fef75-253">NX_DISABLE_ARP_INFO</span><span class="sxs-lookup"><span data-stu-id="fef75-253">NX_DISABLE_ARP_INFO</span></span> | <span data-ttu-id="fef75-254">정의된 경우 ARP 정보를 수집할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-254">Defined, disables ARP information gathering.</span></span>|
|<span data-ttu-id="fef75-255">NX_ENABLE_ARP_MAC_CHANGE_NOTIFICATION</span><span class="sxs-lookup"><span data-stu-id="fef75-255">NX_ENABLE_ARP_MAC_CHANGE_NOTIFICATION</span></span>| <span data-ttu-id="fef75-256">정의된 경우 MAC 주소가 업데이트된 것이 검색되면 ARP에서 콜백 알림 함수를 호출하도록 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-256">Defined, allows ARP to invoke a callback notify function on detecting the MAC address is updated.</span></span>|

### <a name="icmp-configuration-options"></a><span data-ttu-id="fef75-257">ICMP 구성 옵션</span><span class="sxs-lookup"><span data-stu-id="fef75-257">ICMP Configuration Options</span></span>

| <span data-ttu-id="fef75-258">옵션</span><span class="sxs-lookup"><span data-stu-id="fef75-258">Option</span></span>  | <span data-ttu-id="fef75-259">Description</span><span class="sxs-lookup"><span data-stu-id="fef75-259">Description</span></span>  |
|---|---|
|<span data-ttu-id="fef75-260">NX_DISABLE_ICMP_INFO</span><span class="sxs-lookup"><span data-stu-id="fef75-260">NX_DISABLE_ICMP_INFO</span></span>| <span data-ttu-id="fef75-261">정의된 경우 ICMP 정보를 수집할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-261">Defined, disables ICMP information gathering.</span></span>|
|<span data-ttu-id="fef75-262">NX_DISABLE_ICMP_RX_CHECKSUM</span><span class="sxs-lookup"><span data-stu-id="fef75-262">NX_DISABLE_ICMP_RX_CHECKSUM</span></span>| <span data-ttu-id="fef75-263">정의된 경우 수신된 ICMP 패킷에 대해 ICMPv4 및 ICMPv6 체크섬 계산을 모두 사용하지 않도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-263">Defined, disables both ICMPv4 and ICMPv6 checksum computation on received ICMP packets.</span></span> <span data-ttu-id="fef75-264">이 옵션은 네트워크 인터페이스 드라이버가 ICMPv4 및 ICMPv6 체크섬을 확인할 수 있고 애플리케이션에서 IP 조각화 또는 IPsec 기능을 사용하지 않는 경우에 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-264">This option is useful when the network interface driver is able to verify the ICMPv4 and ICMPv6 checksum, and the application does not use the IP fragmentation feature or the IPsec feature.</span></span> <span data-ttu-id="fef75-265">기본적으로 이 옵션은 정의되어 있지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-265">By default this option is not defined.</span></span>|
|<span data-ttu-id="fef75-266">NX_DISABLE_ICMP_TX_CHECKSUM</span><span class="sxs-lookup"><span data-stu-id="fef75-266">NX_DISABLE_ICMP_TX_CHECKSUM</span></span> | <span data-ttu-id="fef75-267">정의된 경우 전송된 ICMP 패킷에 대해 ICMPv4 및 ICMPv6 체크섬 계산을 모두 사용하지 않도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-267">Defined, disables both ICMPv4 and ICMPv6 checksum computation on transmitted ICMP packets.</span></span> <span data-ttu-id="fef75-268">이 옵션은 네트워크 인터페이스 드라이버에서 ICMPv4 및 ICMPv6 체크섬을 계산할 수 있으며</span><span class="sxs-lookup"><span data-stu-id="fef75-268">This option is useful where the network interface driver is able to compute the ICMPv4 and ICMPv6 checksum,</span></span>
<span data-ttu-id="fef75-269">애플리케이션에서 IP 조각화 기능 또는 IPsec 기능을 사용하지 않는 경우에 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-269">and the application does not use the IP fragmentation feature or IPsec feature.</span></span> <span data-ttu-id="fef75-270">기본적으로 이 옵션은 정의되어 있지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-270">By default this option is not defined.</span></span>|
|<span data-ttu-id="fef75-271">NX_DISABLE_ICMPV4_ERROR_MESSAGE</span><span class="sxs-lookup"><span data-stu-id="fef75-271">NX_DISABLE_ICMPV4_ERROR_MESSAGE</span></span> | <span data-ttu-id="fef75-272">정의된 경우 NetX Duo는 잘못된 형식의 IPv4 헤더와 같은 오류 조건에 대한 응답으로 ICMPv4 오류 메시지를 보내지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-272">Defined, NetX Duo does not send ICMPv4 Error Messages in response to error conditions such as improperly formatted IPv4 header.</span></span> <span data-ttu-id="fef75-273">기본적으로 이 옵션은 정의되어 있지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-273">By default this option is not defined.</span></span>|
|<span data-ttu-id="fef75-274">NX_DISABLE_ICMPV4_RX_CHECKSUM</span><span class="sxs-lookup"><span data-stu-id="fef75-274">NX_DISABLE_ICMPV4_RX_CHECKSUM</span></span> | <span data-ttu-id="fef75-275">정의된 경우 수신된 ICMP 패킷에 대해 ICMPv4 체크섬 계산을 사용하지 않도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-275">Defined, disables ICMPv4 checksum computation on received ICMP packets.</span></span> <span data-ttu-id="fef75-276">이 옵션은 ***NX_DISABLE_ICMP_RX_CHECKSUM*** 이 정의된 경우 자동으로 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-276">This option is defined automatically if ***NX_DISABLE_ICMP_RX_CHECKSUM*** is defined.</span></span> <span data-ttu-id="fef75-277">기본적으로 이 옵션은 정의되어 있지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-277">By default this option is not defined.</span></span>|
|<span data-ttu-id="fef75-278">NX_DISABLE_ICMPv4_RX_CHECKSUM</span><span class="sxs-lookup"><span data-stu-id="fef75-278">NX_DISABLE_ICMPv4_RX_CHECKSUM</span></span> | <span data-ttu-id="fef75-279">\***NX_DISABLE_ICMPV4_RX_CHECKSUM** _으로 이름을 바꿨습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-279">Renamed to \***NX_DISABLE_ICMPV4_RX_CHECKSUM** _.</span></span> <span data-ttu-id="fef75-280">아직 지원되는 옵션이지만 새 디자인에서는 _\*_NX_DISABLE_ICMPV4_RX_CHECKSUM_\*\*을 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-280">Although it is still being supported, new designs are encouraged to use _\*_NX_DISABLE_ICMPV4_RX_CHECKSUM_\*\*.</span></span>|
|<span data-ttu-id="fef75-281">NX_DISABLE_ICMPV4_TX_CHECKSUM</span><span class="sxs-lookup"><span data-stu-id="fef75-281">NX_DISABLE_ICMPV4_TX_CHECKSUM</span></span> | <span data-ttu-id="fef75-282">정의된 경우 전송된 ICMP 패킷에 대해 ICMPv4 체크섬 계산을 사용하지 않도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-282">Defined, disables ICMPv4 checksum computation on transmitted ICMP packets.</span></span> <span data-ttu-id="fef75-283">이 옵션은 ***NX_DISABLE_ICMP_TX_CHECKSUM*** 이 정의된 경우 자동으로 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-283">This option is defined automatically if ***NX_DISABLE_ICMP_TX_CHECKSUM*** is defined.</span></span> <span data-ttu-id="fef75-284">기본적으로 이 옵션은 정의되어 있지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-284">By default this option is not defined.</span></span>|
|<span data-ttu-id="fef75-285">NX_DISABLE_ICMPv4_TX_CHECKSUM</span><span class="sxs-lookup"><span data-stu-id="fef75-285">NX_DISABLE_ICMPv4_TX_CHECKSUM</span></span> | <span data-ttu-id="fef75-286">\***NX_DISABLE_ICMPV4_TX_CHECKSUM** _으로 이름을 바꿨습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-286">Renamed to \***NX_DISABLE_ICMPV4_TX_CHECKSUM** _.</span></span></br><span data-ttu-id="fef75-287">아직 지원되는 옵션이지만 새 디자인에서는 _\*_NX_DISABLE_ICMPV4_TX_CHECKSUM_\*\*을 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-287">Although it is still being supported, new designs are encouraged to use _\*_NX_DISABLE_ICMPV4_TX_CHECKSUM_\*\*.</span></span>|
|<span data-ttu-id="fef75-288">NX_ENABLE_ICMP_ADDRESS_CHECK</span><span class="sxs-lookup"><span data-stu-id="fef75-288">NX_ENABLE_ICMP_ADDRESS_CHECK</span></span> | <span data-ttu-id="fef75-289">정의된 경우 ICMP 패킷의 대상 주소가 선택됩니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-289">Defined, the destination address of ICMP packet is checked.</span></span> <span data-ttu-id="fef75-290">기본적으로 이 옵션은 사용하지 않도록 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-290">The default is disabled.</span></span> <span data-ttu-id="fef75-291">IP 브로드캐스트 또는 IP 멀티캐스트 주소로 향하는 ICMP 에코 요청은 자동으로 삭제됩니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-291">An ICMP Echo Request destined to an IP broadcast or IP multicast address will be silently discarded.</span></span>|

### <a name="igmp-configuration-options"></a><span data-ttu-id="fef75-292">IGMP 구성 옵션</span><span class="sxs-lookup"><span data-stu-id="fef75-292">IGMP Configuration Options</span></span>

| <span data-ttu-id="fef75-293">옵션</span><span class="sxs-lookup"><span data-stu-id="fef75-293">Option</span></span>  | <span data-ttu-id="fef75-294">Description</span><span class="sxs-lookup"><span data-stu-id="fef75-294">Description</span></span>  |
|---|---|
|<span data-ttu-id="fef75-295">NX_DISABLE_IGMP_INFO</span><span class="sxs-lookup"><span data-stu-id="fef75-295">NX_DISABLE_IGMP_INFO</span></span> | <span data-ttu-id="fef75-296">정의된 경우 IGMP 정보를 수집할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-296">Defined, disables IGMP information gathering.</span></span>|
|<span data-ttu-id="fef75-297">NX_DISABLE_IGMPV2</span><span class="sxs-lookup"><span data-stu-id="fef75-297">NX_DISABLE_IGMPV2</span></span> | <span data-ttu-id="fef75-298">정의된 경우 IGMPv2 지원을 사용하지 않도록 설정하므로 NetX Duo에서 IGMPv1만 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-298">Defined, disables IGMPv2 support, and NetX Duo supports IGMPv1 only.</span></span> <span data-ttu-id="fef75-299">기본적으로 이 옵션은 설정되어 있지 않으며 ***nx_api.h*** 에 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-299">By default this option is not set and is defined in ***nx_api.h***.</span></span>|
|<span data-ttu-id="fef75-300">NX_MAX_MULTICAST_GROUPS</span><span class="sxs-lookup"><span data-stu-id="fef75-300">NX_MAX_MULTICAST_GROUPS</span></span> | <span data-ttu-id="fef75-301">조인할 수 있는 최대 멀티캐스트 그룹 수를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-301">Specifies the maximum number of multicast groups that can be joined.</span></span> <span data-ttu-id="fef75-302">기본값은 7이며 \***nx_api.h** _에 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-302">The default value is 7 and is defined in \***nx_api.h** _.</span></span> <span data-ttu-id="fef75-303">애플리케이션은 _ _nx_api.h_\*가 포함되기 전에 값을 정의하여 이 기본값을 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-303">The application can override the default by defining the value before _ *_nx_api.h_*\* is included.</span></span>|

### <a name="ip-configuration-options"></a><span data-ttu-id="fef75-304">IP 구성 옵션</span><span class="sxs-lookup"><span data-stu-id="fef75-304">IP Configuration Options</span></span>

| <span data-ttu-id="fef75-305">옵션</span><span class="sxs-lookup"><span data-stu-id="fef75-305">Option</span></span>  | <span data-ttu-id="fef75-306">Description</span><span class="sxs-lookup"><span data-stu-id="fef75-306">Description</span></span>  |
|---|---|
|<span data-ttu-id="fef75-307">NX_DISABLE_FRAGMENTATION</span><span class="sxs-lookup"><span data-stu-id="fef75-307">NX_DISABLE_FRAGMENTATION</span></span> | <span data-ttu-id="fef75-308">정의된 경우 IPv4 및 IPv6 조각화와 리어셈블리 논리를 모두 사용하지 않도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-308">Defined, disables both IPv4 and IPv6 fragmentation and reassembly logic.</span></span>|
| <span data-ttu-id="fef75-309">NX_DISABLE_IPV4</span><span class="sxs-lookup"><span data-stu-id="fef75-309">NX_DISABLE_IPV4</span></span>     | <span data-ttu-id="fef75-310">정의된 경우 IPv4 기능을 사용하지 않도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-310">Defined, disables IPv4 functionality.</span></span> <span data-ttu-id="fef75-311">이 옵션은 IPv6만 지원하도록 NetX Duo를 빌드하는 데 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-311">This option can be used to build NetX Duo to suupport IPv6 only.</span></span> <span data-ttu-id="fef75-312">기본적으로 이 옵션은 정의되어 있지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-312">By default this option is not defined.</span></span> |
| <span data-ttu-id="fef75-313">NX_DISABLE_IP_INFO</span><span class="sxs-lookup"><span data-stu-id="fef75-313">NX_DISABLE_IP_INFO</span></span> | <span data-ttu-id="fef75-314">정의된 경우 IP 정보를 수집할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-314">Defined, disables IP information gathering.</span></span>|
|<span data-ttu-id="fef75-315">NX_DISABLE_IP_RX_CHECKSUM</span><span class="sxs-lookup"><span data-stu-id="fef75-315">NX_DISABLE_IP_RX_CHECKSUM</span></span> | <span data-ttu-id="fef75-316">정의된 경우 수신된 IPv4 패킷의 체크섬 논리를 사용하지 않도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-316">Defined, disables checksum logic on received IPv4 packets.</span></span> <span data-ttu-id="fef75-317">네트워크 디바이스에서 IPv4 체크섬을 확인할 수 있고 애플리케이션에서 IP 조각화 또는 IPsec을 사용하지 않는 경우에 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-317">This is useful if the network device is able to verify the IPv4 checksum, and the application does not expect to use IP fragmentation or IPsec.</span></span>|
|<span data-ttu-id="fef75-318">NX_DISABLE_IP_TX_CHECKSUM</span><span class="sxs-lookup"><span data-stu-id="fef75-318">NX_DISABLE_IP_TX_CHECKSUM</span></span> | <span data-ttu-id="fef75-319">정의된 경우 송신된 IPv4 패킷의 체크섬 논리를 사용하지 않도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-319">Defined, disables checksum logic on IPv4 packets sent.</span></span> <span data-ttu-id="fef75-320">기본 네트워크 디바이스에서 IPv4 헤더 체크섬을 생성할 수 있고 애플리케이션에서 IP 조각화 또는 IPsec을 사용하지 않는 경우에 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-320">This is useful in situations in which the underlying network device is capable of generating the IPv4 header checksum, and the application does not expect to use IP fragmentation or IPsec.</span></span>|
|<span data-ttu-id="fef75-321">NX_DISABLE_LOOPBACK_INTERFACE</span><span class="sxs-lookup"><span data-stu-id="fef75-321">NX_DISABLE_LOOPBACK_INTERFACE</span></span> | <span data-ttu-id="fef75-322">정의된 경우 루프백 인터페이스에 대해 NetX Duo 지원을 사용하지 않도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-322">Defined, disables NetX Duo support for the loopback interface.</span></span>|
|<span data-ttu-id="fef75-323">NX_DISABLE_RX_SIZE_CHECKING</span><span class="sxs-lookup"><span data-stu-id="fef75-323">NX_DISABLE_RX_SIZE_CHECKING</span></span> | <span data-ttu-id="fef75-324">정의된 경우 수신된 패킷에서 크기 검사를 사용하지 않도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-324">Defined, disables the size checking on received packets.</span></span>|
|<span data-ttu-id="fef75-325">NX_ENABLE_IP_RAW_PACKET_FILTER</span><span class="sxs-lookup"><span data-stu-id="fef75-325">NX_ENABLE_IP_RAW_PACKET_FILTER</span></span> | <span data-ttu-id="fef75-326">정의된 경우 IP 원시 패킷 수신 필터 기능을 사용하도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-326">Defined, enables the IP raw packet receive filter functionality.</span></span> <span data-ttu-id="fef75-327">수신될 원시 IP 패킷 유형을 보다 강력하게 제어해야 하는 애플리케이션은 이 기능을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-327">Applications requiring more control over the type of raw IP packets to be received can use this feature.</span></span> <span data-ttu-id="fef75-328">또한 IP 원시 패킷 필터 기능은 BSD 호환성 계층에서 원시 소켓 작업을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-328">The IP raw packet filter feature also supports the raw socket operation in the BSD compatibility layer.</span></span> <span data-ttu-id="fef75-329">기본적으로 이 옵션은 정의되어 있지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-329">By default this option is not defined.</span></span>|
|<span data-ttu-id="fef75-330">NX_ENABLE_IP_STATIC_ROUTING</span><span class="sxs-lookup"><span data-stu-id="fef75-330">NX_ENABLE_IP_STATIC_ROUTING</span></span> | <span data-ttu-id="fef75-331">정의된 경우 대상 주소에 특정한 다음 홉 주소를 할당할 수 있는 IPv4 고정 라우팅을 사용하도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-331">Defined, enables IPv4 static routing in which a destination address can be assigned a specific next hop address.</span></span> <span data-ttu-id="fef75-332">기본적으로 IPv4 고정 라우팅은 사용하지 않도록 설정되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-332">By default IPv4 static routing is disabled.</span></span>|
|<span data-ttu-id="fef75-333">NX_FRAGMENT_IMMEDIATE_ASSEMBLY</span><span class="sxs-lookup"><span data-stu-id="fef75-333">NX_FRAGMENT_IMMEDIATE_ASSEMBLY</span></span> | <span data-ttu-id="fef75-334">정의된 경우 IPv4 및 IPv6 리어셈블리 논리를 IP 조각 수신 후 바로 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-334">Defined, allows IPv4 and IPv6 reassembly logic to execute right away after receiving an IP fragment.</span></span> <span data-ttu-id="fef75-335">기본적으로 이 옵션은 정의되어 있지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-335">By default this option is not defined.</span></span>|
|<span data-ttu-id="fef75-336">NX_IP_MAX_REASSEMBLY_TIME</span><span class="sxs-lookup"><span data-stu-id="fef75-336">NX_IP_MAX_REASSEMBLY_TIME</span></span> | <span data-ttu-id="fef75-337">IPv4 조각 및 IPv6 조각을 리어셈블할 수 있는 최대 시간을 제어하는 기호입니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-337">Symbol that controls maximum time allowed to reassemble IPv4 fragment and IPv6 fragment.</span></span> <span data-ttu-id="fef75-338">여기에 정의된 값은 \***NX_IPV4_MAX_REASSEMBLY_TIME** _ 및 _ \*_NX_IPV6_MAX_REASSEMBLY_TIME_\*\*을 모두 덮어씁니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-338">Note the value defined here overwrites both ***NX_IPV4_MAX_REASSEMBLY_TIME** _ and _*_NX_IPV6_MAX_REASSEMBLY_TIME_\*\*.</span></span>|
|<span data-ttu-id="fef75-339">NX_IP_PERIODIC_RATE</span><span class="sxs-lookup"><span data-stu-id="fef75-339">NX_IP_PERIODIC_RATE</span></span> | <span data-ttu-id="fef75-340">정의된 경우 1초 동안의 ThreadX 타이머 틱 수를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-340">Defined, specifies the number of ThreadX timer ticks in one second.</span></span> <span data-ttu-id="fef75-341">기본값은 ThreadX 기호 \***TX_TIMER_TICKS_PER_SECOND** _에서 파생되며 기본적으로 100(10ms 타이머)으로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-341">The default value is derived from the ThreadX symbol \***TX_TIMER_TICKS_PER_SECOND,** _ which by default is set to 100 (10ms timer).</span></span> <span data-ttu-id="fef75-342">NetX Duo 모듈의 나머지 부분도 _ \*_NX_IP_PERIODIC_RATE_\*\*에서 타이밍 정보가 파생되므로 이 값을 수정하는 경우 애플리케이션에서 주의를 기울여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-342">Applications shall exercise caution when modifying this value, as the rest of the NetX Duo modules derive timing information from _ *_NX_IP_PERIODIC_RATE_.*\*</span></span>|
|<span data-ttu-id="fef75-343">NX_IP_RAW_MAX_QUEUE_DEPTH</span><span class="sxs-lookup"><span data-stu-id="fef75-343">NX_IP_RAW_MAX_QUEUE_DEPTH</span></span> | <span data-ttu-id="fef75-344">원시 패킷 수신 큐에서 원시 IP 패킷 수를 제어하는 기호를 큐에 대기시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-344">Symbol that controls the number of raw IP packets can be queued on the raw packet receive queue.</span></span> <span data-ttu-id="fef75-345">기본적으로 값은 20으로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-345">By default value is set to 20.</span></span>| 
|<span data-ttu-id="fef75-346">NX_IP_ROUTING_TABLE_SIZE</span><span class="sxs-lookup"><span data-stu-id="fef75-346">NX_IP_ROUTING_TABLE_SIZE</span></span> | <span data-ttu-id="fef75-347">정의된 경우 지정된 대상 주소에 대한 나가는 인터페이스 및 다음 홉 주소 목록에 해당하는 IPv4 고정 라우팅 테이블의 최대 항목 수를 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-347">Defined, sets the maximum number of entries in the IPv4 static routing table, which is a list of an outgoing interface and the next hop addresses for a given destination address.</span></span> <span data-ttu-id="fef75-348">기본값은 8이며 \***nx_api.h** _에 정의됩니다. 이 기호는 _ \*_NX_ENABLE_IP_STATIC_ROUTING_\*\*이 정의된 경우에만 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-348">The default value is 8 and is defined in ***nx_api.h.** _ This symbol is used only if _ *_NX_ENABLE_IP_STATIC_ROUTING_** is defined.</span></span>|
|<span data-ttu-id="fef75-349">NX_IPV4_MAX_REASSEMBLY_TIME</span><span class="sxs-lookup"><span data-stu-id="fef75-349">NX_IPV4_MAX_REASSEMBLY_TIME</span></span> | <span data-ttu-id="fef75-350">IPv4 조각을 리어셈블할 수 있는 최대 시간을 제어하는 기호입니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-350">Symbol that controls maximum time allowed to reassemble IPv4 fragment.</span></span> <span data-ttu-id="fef75-351">NX_IP_MAX_REASSEMBLY_TIME에 정의된 값은 이 값을 덮어씁니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-351">Note the value defined in NX_IP_MAX_REASSEMBLY_TIME overwrites this value.</span></span>|

### <a name="packet-configuration-options"></a><span data-ttu-id="fef75-352">패킷 구성 옵션</span><span class="sxs-lookup"><span data-stu-id="fef75-352">Packet Configuration Options</span></span>

| <span data-ttu-id="fef75-353">옵션</span><span class="sxs-lookup"><span data-stu-id="fef75-353">Option</span></span>  | <span data-ttu-id="fef75-354">Description</span><span class="sxs-lookup"><span data-stu-id="fef75-354">Description</span></span>  |
|---|---|
|<span data-ttu-id="fef75-355">NX_DISABLE_PACKET_CHAIN</span><span class="sxs-lookup"><span data-stu-id="fef75-355">NX_DISABLE_PACKET_CHAIN</span></span> | <span data-ttu-id="fef75-356">정의된 경우 패킷 체인 논리를 사용하지 않도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-356">Defined, disables the packet chain logic.</span></span> <span data-ttu-id="fef75-357">기본적으로 이는 정의되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-357">By default this is not defined.</span></span>|
|<span data-ttu-id="fef75-358">NX_DISABLE_PACKET_INFO</span><span class="sxs-lookup"><span data-stu-id="fef75-358">NX_DISABLE_PACKET_INFO</span></span> | <span data-ttu-id="fef75-359">정의된 경우 패킷 풀 정보를 수집할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-359">Defined, disables packet pool information gathering.</span></span>|
|<span data-ttu-id="fef75-360">NX_ENABLE_LOW_WATERMARK</span><span class="sxs-lookup"><span data-stu-id="fef75-360">NX_ENABLE_LOW_WATERMARK</span></span> | <span data-ttu-id="fef75-361">정의된 경우 NetX Duo 패킷 풀 하위 워터마크 기능을 사용하도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-361">Defined, enables NetX Duo packet pool low watermark feature.</span></span> <span data-ttu-id="fef75-362">애플리케이션에서 하위 워터마크 값을 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-362">Application sets low watermark value.</span></span> <span data-ttu-id="fef75-363">TCP 패킷을 받을 때 패킷 풀 하위 워터마크에 도달하면 NetX Duo는 패킷을 해제한 후 자동으로 삭제하여 패킷 풀이 고갈되지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-363">On receiving TCP packets, if the packet pool low watermark is reached, NetX Duo silently discards the packet by releasing it, preventing the packet pool from starvation.</span></span> <span data-ttu-id="fef75-364">기본적으로 이 기능은 사용하지 않도록 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-364">By default this feature is not enabled.</span></span>|
|<span data-ttu-id="fef75-365">NX_ENABLE_PACKET_DEBUG_INFO</span><span class="sxs-lookup"><span data-stu-id="fef75-365">NX_ENABLE_PACKET_DEBUG_INFO</span></span> | <span data-ttu-id="fef75-366">정의된 경우 패킷 디버그 정보를 기록합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-366">Defined, logs packet debug information.</span></span>|
|<span data-ttu-id="fef75-367">NX_PACKET_ALIGNMENT</span><span class="sxs-lookup"><span data-stu-id="fef75-367">NX_PACKET_ALIGNMENT</span></span> | <span data-ttu-id="fef75-368">정의된 경우 패킷 페이로드 영역의 시작 주소에 대한 맞춤 요구 사항(바이트)을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-368">Defined, specifies the alignment requirement, in bytes, for starting address of the packet payload area.</span></span> <span data-ttu-id="fef75-369">이 옵션을 사용하면 ***NX_PACKET_HEADER_PAD** _ 및 _*_NX_PACKET_HEADER_PAD_SIZE_\*\*가 더 이상 사용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-369">This option deprecates  ***NX_PACKET_HEADER_PAD** _ and _*_NX_PACKET_HEADER_PAD_SIZE_\*\*.</span></span> <span data-ttu-id="fef75-370">기본적으로 이 옵션은 4로 정의되며 페이로드 영역 4바이트의 시작 주소가 정렬됩니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-370">By default this option is defined to be 4, making the starting address of the payload area 4-byte aligned.</span></span>|
|<span data-ttu-id="fef75-371">NX_PACKET_HEADER_PAD</span><span class="sxs-lookup"><span data-stu-id="fef75-371">NX_PACKET_HEADER_PAD</span></span> | <span data-ttu-id="fef75-372">정의된 경우 NX_PACKET 제어 블록의 끝에 패딩을 사용하도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-372">Defined, enables padding towards the end of the NX_PACKET control block.</span></span> <span data-ttu-id="fef75-373">패딩할 ULONG 워드 수는 \***NX_PACKET_HEADER_PAD_SIZE** _로 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-373">The number of ULONG words to pad is defined by  \***NX_PACKET_HEADER_PAD_SIZE** _.</span></span> <span data-ttu-id="fef75-374">이 옵션은 _\*_NX_PACKET_ALIGNMENT_\*\*에서 더 이상 사용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-374">Note this option is depreciated by _\*_NX_PACKET_ALIGNMENT_\*\*.</span></span>|
|<span data-ttu-id="fef75-375">NX_PACKET_HEADER_PAD_SIZE</span><span class="sxs-lookup"><span data-stu-id="fef75-375">NX_PACKET_HEADER_PAD_SIZE</span></span> | <span data-ttu-id="fef75-376">NX_PACKET 구조체에 패딩할 ULONG 단어 수를 설정하여 패킷 페이로드 영역을 원하는 맞춤에서 시작할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-376">Sets the number of ULONG words to be padded to the NX_PACKET structure, allowing the packet payload area to start at the desired alignment.</span></span> <span data-ttu-id="fef75-377">이 기능은 수신 버퍼 설명자가 NX_PACKET 페이로드 영역을 직접 가리키며 네트워크 인터페이스 수신 논리 또는 캐시 작업 논리에서 특정 맞춤 요구 사항을 충족하는 버퍼 시작 주소가 필요한 경우에 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-377">This feature is useful when receive buffer descriptors point directly into NX_PACKET payload area, and the network  interface receive logic or the cache operation logic expects the buffer starting address to meet certain alignment requirements.</span></span> <span data-ttu-id="fef75-378">이 값은 \***NX_PACKET_HEADER_PAD** _가 정의된 경우에만 유효합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-378">This value becomes valid only when \***NX_PACKET_HEADER_PAD** _ is defined.</span></span> <span data-ttu-id="fef75-379">이 옵션은 _\*_NX_PACKET_ALIGNMENT_\*\*에서 더 이상 사용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-379">Note this option is deprecated by _\*_NX_PACKET_ALIGNMENT_\*\*.</span></span>|

### <a name="rarp-configuration-options"></a><span data-ttu-id="fef75-380">RARP 구성 옵션</span><span class="sxs-lookup"><span data-stu-id="fef75-380">RARP Configuration Options</span></span>

| <span data-ttu-id="fef75-381">옵션</span><span class="sxs-lookup"><span data-stu-id="fef75-381">Option</span></span>  | <span data-ttu-id="fef75-382">Description</span><span class="sxs-lookup"><span data-stu-id="fef75-382">Description</span></span>  |
|---|---|
|<span data-ttu-id="fef75-383">NX_DISABLE_RARP_INFO</span><span class="sxs-lookup"><span data-stu-id="fef75-383">NX_DISABLE_RARP_INFO</span></span> | <span data-ttu-id="fef75-384">정의된 경우 RARP 정보를 수집할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-384">Defined, disables RARP information gathering.</span></span>|

### <a name="tcp-configuration-options"></a><span data-ttu-id="fef75-385">TCP 구성 옵션</span><span class="sxs-lookup"><span data-stu-id="fef75-385">TCP Configuration Options</span></span>

| <span data-ttu-id="fef75-386">옵션</span><span class="sxs-lookup"><span data-stu-id="fef75-386">Option</span></span> | <span data-ttu-id="fef75-387">Description</span><span class="sxs-lookup"><span data-stu-id="fef75-387">Description</span></span> |
|---|---|
|<span data-ttu-id="fef75-388">NX_DISABLE_RESET_DISCONNECT</span><span class="sxs-lookup"><span data-stu-id="fef75-388">NX_DISABLE_RESET_DISCONNECT</span></span> | <span data-ttu-id="fef75-389">정의된 경우 제공되는 제한 시간 값이 ***NX_NO_WAIT*** 로 지정되면 연결 해제 중에 초기화 처리를 사용하지 않도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-389">Defined, disables the reset processing during disconnect when the timeout value supplied is specified as ***NX_NO_WAIT***.</span></span>|
|<span data-ttu-id="fef75-390">NX_DISABLE_TCP_INFO</span><span class="sxs-lookup"><span data-stu-id="fef75-390">NX_DISABLE_TCP_INFO</span></span> | <span data-ttu-id="fef75-391">정의된 경우 TCP 정보를 수집할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-391">Defined, disables TCP information gathering.</span></span>|
|<span data-ttu-id="fef75-392">NX_DISABLE_TCP_RX_CHECKSUM</span><span class="sxs-lookup"><span data-stu-id="fef75-392">NX_DISABLE_TCP_RX_CHECKSUM</span></span> | <span data-ttu-id="fef75-393">정의된 경우 수신된 TCP 패킷의 체크섬 논리를 사용하지 않도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-393">Defined, disables checksum logic on received TCP packets.</span></span> <span data-ttu-id="fef75-394">이 기능은 링크 계층에 안정적인 체크섬 또는 CRC 처리가 있거나 인터페이스 드라이버가 하드웨어의 TCP 체크섬을 확인할 수 있고 애플리케이션이 IPsec을 사용하지 않는 경우에만 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-394">This is only useful in situations in which the link-layer has reliable checksum or  CRC processing, or the interface driver is able to verify the TCP checksum in hardware, and the application does not use IPsec.</span></span>|
|<span data-ttu-id="fef75-395">NX_DISABLE_TCP_TX_CHECKSUM</span><span class="sxs-lookup"><span data-stu-id="fef75-395">NX_DISABLE_TCP_TX_CHECKSUM</span></span> | <span data-ttu-id="fef75-396">정의된 경우 TCP 패킷 송신에 체크섬 논리를 사용하지 않도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-396">Defined, disables checksum logic for sending TCP packets.</span></span> <span data-ttu-id="fef75-397">수신 네트워크 노드에 수신된 TCP 체크섬 논리가 사용하지 않도록 설정되어 있거나 기본 네트워크 드라이버가 TCP 체크섬을 생성할 수 있고 애플리케이션이 IPsec을 사용하지 않는 경우에만 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-397">This is only useful in situations in which the receiving network node has received TCP checksum logic disabled or the underlying network driver is capable of generating the TCP checksum, and the application does not use IPsec.</span></span>|
|<span data-ttu-id="fef75-398">NX_ENABLE_TCP_KEEPALIVE</span><span class="sxs-lookup"><span data-stu-id="fef75-398">NX_ENABLE_TCP_KEEPALIVE</span></span> | <span data-ttu-id="fef75-399">정의된 경우 선택적 TCP 연결 유지 타이머를 사용하도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-399">Defined, enables the optional TCP keepalive timer.</span></span> <span data-ttu-id="fef75-400">기본 설정은 사용하지 않도록 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-400">The default settings is not enabled.</span></span>|
|<span data-ttu-id="fef75-401">NX_ENABLE_TCP_MSS_CHECK</span><span class="sxs-lookup"><span data-stu-id="fef75-401">NX_ENABLE_TCP_MSS_CHECK</span></span> | <span data-ttu-id="fef75-402">정의된 경우 TCP 연결을 수락하기 전에 최소 피어 MSS 확인을 사용하도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-402">Defined, enables the verification of minimum peer MSS before accepting a TCP connection.</span></span> <span data-ttu-id="fef75-403">이 기능을 사용하려면 ***NX_ENABLE_TCP_MSS_MINIMUM*** 기호가 정의되어 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-403">To use this feature, the symbol ***NX_ENABLE_TCP_MSS_MINIMUM*** must be defined.</span></span> <span data-ttu-id="fef75-404">이 옵션은 기본적으로 사용하도록 설정되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-404">By default, this option is not enabled.</span></span>|
|<span data-ttu-id="fef75-405">NX_ENABLE_TCP_QUEUE_DEPTH_UPDATE_NOTIFY</span><span class="sxs-lookup"><span data-stu-id="fef75-405">NX_ENABLE_TCP_QUEUE_DEPTH_UPDATE_NOTIFY</span></span>| <span data-ttu-id="fef75-406">정의된 경우 애플리케이션에서 TCP 전송 큐 크기가 더 이상 최대값이 아닐 때 호출되는 콜백 함수를 설치할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-406">Defined, allows the application to install a callback function that is invoked when the TCP transmit queue depth is no longer at maximum value.</span></span> <span data-ttu-id="fef75-407">이 콜백은 TCP 소켓이 더 많은 데이터를 전송할 준비가 되었음을 나타내는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-407">This callback serves as an indication that the TCP socket is ready to transmit more data.</span></span> <span data-ttu-id="fef75-408">기본적으로 이 옵션은 사용하도록 설정되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-408">By default this option is not enabled.</span></span>|
|<span data-ttu-id="fef75-409">NX_ENABLE_TCP_WINDOW_SCALING</span><span class="sxs-lookup"><span data-stu-id="fef75-409">NX_ENABLE_TCP_WINDOW_SCALING</span></span> | <span data-ttu-id="fef75-410">TCP 애플리케이션의 창 크기 조정 옵션을 사용하도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-410">Enables the window scaling option for TCP applications.</span></span> <span data-ttu-id="fef75-411">정의된 경우 TCP 연결 단계에서 창 크기 조정 옵션을 협상하고 애플리케이션에서 64K보다 큰 창 크기를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-411">If defined, window scaling option is negotiated during TCP connection phase, and the application is able to specify a window size larger than 64K.</span></span> <span data-ttu-id="fef75-412">기본 설정은 사용하지 않도록 설정됩니다(정의되지 않음).</span><span class="sxs-lookup"><span data-stu-id="fef75-412">The default setting is not enabled (not defined).</span></span>|
|<span data-ttu-id="fef75-413">NX_MAX_LISTEN_REQUESTS</span><span class="sxs-lookup"><span data-stu-id="fef75-413">NX_MAX_LISTEN_REQUESTS</span></span> | <span data-ttu-id="fef75-414">최대 서버 수신 대기 요청 수를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-414">Specifies the maximum number of server listen requests.</span></span> <span data-ttu-id="fef75-415">기본값은 10이며 \***nx_api.h** _에 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-415">The default value is 10 and is defined in \***nx_api.h** _.</span></span> <span data-ttu-id="fef75-416">애플리케이션은 _ _nx_api.h_\*가 포함되기 전에 값을 정의하여 이 기본값을 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-416">The application can override the default by defining the value before _ *_nx_api.h_*\* is included.</span></span>|
|<span data-ttu-id="fef75-417">NX_TCP_ACK_EVERY_N_PACKETS</span><span class="sxs-lookup"><span data-stu-id="fef75-417">NX_TCP_ACK_EVERY_N_PACKETS</span></span> | <span data-ttu-id="fef75-418">ACK 송신 전 수신할 TCP 패킷 수를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-418">Specifies the number of TCP packets to receive before sending an ACK.</span></span> <span data-ttu-id="fef75-419">\***NX_TCP_IMMEDIATE_ACK** _는 사용하도록 설정되어 있지만 \*_NX_TCP_ACK_EVERY_N_PACKETS_\*\*는 사용하도록 설정되어 있지 않은 경우 이전 버전과의 호환성을 위해 이 값이 자동으로 1로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-419">Note if ***NX_TCP_IMMEDIATE_ACK** _ is enabled but _ *_NX_TCP_ACK_EVERY_N_PACKETS_** is not, this value is automatically set to 1 for backward compatibility.</span></span>|
|<span data-ttu-id="fef75-420">NX_TCP_ACK_TIMER_RATE</span><span class="sxs-lookup"><span data-stu-id="fef75-420">NX_TCP_ACK_TIMER_RATE</span></span> | <span data-ttu-id="fef75-421">TCP 지연 ACK 처리의 타이머 속도를 계산하기 위해 시스템 틱 수(NX_IP_PERIODIC_RATE)를 나누는 방법을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-421">Specifies how the number of system ticks (NX_IP_PERIODIC_RATE) is divided to calculate the timer rate for the TCP delayed ACK processing.</span></span> <span data-ttu-id="fef75-422">기본값은 5로, 200ms를 나타내며 \***nx_tcp.h** _에 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-422">The default value is 5, which represents 200ms, and is defined in \***nx_tcp.h** _.</span></span> <span data-ttu-id="fef75-423">애플리케이션은 _ _nx_api.h_\*가 포함되기 전에 값을 정의하여 이 기본값을 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-423">The application can override the default by defining the value before _ *_nx_api.h_*\* is included.</span></span>|
|<span data-ttu-id="fef75-424">NX_TCP_ENABLE_KEEPALIVE</span><span class="sxs-lookup"><span data-stu-id="fef75-424">NX_TCP_ENABLE_KEEPALIVE</span></span> | <span data-ttu-id="fef75-425">\***NX_ENABLE_TCP_KEEPALIVE** _로 이름이 변경되었습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-425">Renamed to \***NX_ENABLE_TCP_KEEPALIVE** _.</span></span> <span data-ttu-id="fef75-426">아직 지원되는 옵션이지만 새 디자인에서는 _\*_NX_ENABLE_TCP_KEEPALIVE_\*\*를 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-426">Although it is still being supported, new designs are encouraged to use _\*_NX_ENABLE_TCP_KEEPALIVE_\*\*.</span></span>|
|<span data-ttu-id="fef75-427">NX_TCP_ENABLE_MSS_CHECK</span><span class="sxs-lookup"><span data-stu-id="fef75-427">NX_TCP_ENABLE_MSS_CHECK</span></span> | <span data-ttu-id="fef75-428">***NX_ENABLE_TCP_MSS_CHECK** _로 이름을 바꿨습니다. 아직 지원되는 옵션이지만 새 디자인에서는 _ _NX_ENABLE_TCP_MSS_CHECK_*를 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-428">Renamed to ***NX_ENABLE_TCP_MSS_CHECK** _.Although it is still being supported, new designs are encouraged to use _ *_NX_ENABLE_TCP_MSS_CHECK._**</span></span>|
|<span data-ttu-id="fef75-429">NX_TCP_ENABLE_WINDOW_SCALING</span><span class="sxs-lookup"><span data-stu-id="fef75-429">NX_TCP_ENABLE_WINDOW_SCALING</span></span> | <span data-ttu-id="fef75-430">\***NX_ENABLE_TCP_WINDOW_SCALING** _으로 이름을 바꿨습니다. 아직 지원되는 옵션이지만 새 디자인에서는 _ _NX_ENABLE_TCP_WINDOW_SCALING_\*\*을 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-430">Renamed to ***NX_ENABLE_TCP_WINDOW_SCALING** _.Although it is still being supported, new designs are encouraged to use _*_NX_ENABLE_TCP_WINDOW_SCALING_\*\*.</span></span>|
|<span data-ttu-id="fef75-431">NX_TCP_FAST_TIMER_RATE</span><span class="sxs-lookup"><span data-stu-id="fef75-431">NX_TCP_FAST_TIMER_RATE</span></span> | <span data-ttu-id="fef75-432">빠른 TCP 타이머 속도를 계산하기 위해 NetX Duo 내부 틱 수(NX_IP_PERIODIC_RATE)를 나누는 방법을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-432">Specifies how the number of NetX Duo internal ticks (NX_IP_PERIODIC_RATE) is divided to calculate the fast TCP timer rate.</span></span> <span data-ttu-id="fef75-433">빠른 TCP 타이머는 지연 ACK 타이머를 포함하여 다양한 TCP 타이머를 구동하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-433">The fast TCP timer is used to drive the various TCP timers, including the delayed ACK timer.</span></span> <span data-ttu-id="fef75-434">기본값은 10으로, 100ms를 나타내며 ThreadX 타이머가 10ms로 실행되고 있다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-434">The default value is 10, which represents 100ms assuming the ThreadX timer is running at 10ms.</span></span> <span data-ttu-id="fef75-435">이 값은 \***nx_tcp.h** _에 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-435">This value is defined in \***nx_tcp.h** _.</span></span> <span data-ttu-id="fef75-436">애플리케이션은 _ _nx_api.h_\*가 포함되기 전에 값을 정의하여 이 기본값을 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-436">The  application can override the default by defining the value before _ *_nx_api.h_*\* is included.</span></span>|
|<span data-ttu-id="fef75-437">NX_TCP_IMMEDIATE_ACK</span><span class="sxs-lookup"><span data-stu-id="fef75-437">NX_TCP_IMMEDIATE_ACK</span></span>| <span data-ttu-id="fef75-438">정의된 경우 선택적으로 TCP 즉시 ACK 응답 처리를 사용하도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-438">Defined, enables the optional TCP immediate ACK response processing.</span></span> <span data-ttu-id="fef75-439">이 기호를 정의하는 것은 ***NX_TCP_ACK_EVERY_N_PACKETS*** 를 1로 정의하는 것과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-439">Defining this symbol is equivalent to defining  ***NX_TCP_ACK_EVERY_N_PACKETS*** to be 1.</span></span>|
|<span data-ttu-id="fef75-440">NX_TCP_KEEPALIVE_INITIAL</span><span class="sxs-lookup"><span data-stu-id="fef75-440">NX_TCP_KEEPALIVE_INITIAL</span></span> | <span data-ttu-id="fef75-441">연결 유지 타이머가 활성화되기 전의 비활성 시간(초)을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-441">Specifies the number of seconds of inactivity before the keepalive timer activates.</span></span> <span data-ttu-id="fef75-442">기본값은 7200으로, 2시간을 나타내며 \***nx_tcp.h** _에 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-442">The default value is 7200, which represents 2 hours, and is defined in \***nx_tcp.h** _.</span></span> <span data-ttu-id="fef75-443">애플리케이션은 _ _nx_api.h_\*가 포함되기 전에 값을 정의하여 이 기본값을 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-443">The application can override the default by defining the value before _ *_nx_api.h_*\* is included.</span></span>|
|<span data-ttu-id="fef75-444">NX_TCP_KEEPALIVE_RETRIES</span><span class="sxs-lookup"><span data-stu-id="fef75-444">NX_TCP_KEEPALIVE_RETRIES</span></span> | <span data-ttu-id="fef75-445">연결이 끊어진 것으로 간주하기 전 허용되는 연결 유지 재시도 수를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-445">Specifies how many keepalive retries are allowed before the connection is deemed broken.</span></span> <span data-ttu-id="fef75-446">기본값은 10으로, 10번의 재시도를 나타내며 \***nx_tcp.h** _에 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-446">The default value is 10, which represents 10 retries, and is defined in \***nx_tcp.h** _.</span></span> <span data-ttu-id="fef75-447">애플리케이션은 _ _nx_api.h_\*가 포함되기 전에 값을 정의하여 이 기본값을 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-447">The application can override the default by defining the value before _ *_nx_api.h_*\* is included.</span></span>|
|<span data-ttu-id="fef75-448">NX_TCP_KEEPALIVE_RETRY</span><span class="sxs-lookup"><span data-stu-id="fef75-448">NX_TCP_KEEPALIVE_RETRY</span></span> | <span data-ttu-id="fef75-449">연결의 상대방이 응답하지 않는다고 가정하는 연결 유지 타이머의 재시도 간 간격(초)을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-449">Specifies the number of seconds between retries of the keepalive timer assuming the other side of the connection is not responding.</span></span> <span data-ttu-id="fef75-450">기본값은 75로, 재시도 간 간격이 75초임을 나타내며 \***nx_tcp.h** _에 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-450">The default value is 75, which represents 75 seconds between retries, and is defined in \***nx_tcp.h** _.</span></span> <span data-ttu-id="fef75-451">애플리케이션은 _ _nx_api.h_\*가 포함되기 전에 값을 정의하여 이 기본값을 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-451">The application can override the default by defining the value before _ *_nx_api.h_*\* is included.</span></span>|
|<span data-ttu-id="fef75-452">NX_TCP_MAX_OUT_OF_ORDER_PACKETS</span><span class="sxs-lookup"><span data-stu-id="fef75-452">NX_TCP_MAX_OUT_OF_ORDER_PACKETS</span></span> | <span data-ttu-id="fef75-453">TCP 소켓 수신 큐에 보관할 수 있는 순서가 잘못된 TCP 패킷의 최대 수를 정의하는 기호입니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-453">Symbol that defines the maximum number of out-of-order TCP packets can be kept in the TCP socket receive queue.</span></span> <span data-ttu-id="fef75-454">이 기호를 사용하면 TCP 수신 소켓에서 큐에 대기되는 패킷 수를 제한하여 패킷 풀이 부족해지는 것을 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-454">This symbol can be used to limit the number of packets queued in the TCP receive socket, preventing the packet pool from being starved.</span></span> <span data-ttu-id="fef75-455">기본적으로 이 기호는 정의되지 않으므로 TCP 소켓에서 큐에 대기되는, 순서가 잘못된 패킷 수에는 제한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-455">By default this symbol is not defined, thus there is no limit on the number of out of order packets being queued in the TCP socket.</span></span>|
|<span data-ttu-id="fef75-456">NX_TCP_MAXIMUM_RETRIES</span><span class="sxs-lookup"><span data-stu-id="fef75-456">NX_TCP_MAXIMUM_RETRIES</span></span> | <span data-ttu-id="fef75-457">연결이 끊어진 것으로 간주하기 전 허용되는 데이터 전송 재시도 수를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-457">Specifies how many data transmit retries are allowed before the connection is deemed broken.</span></span> <span data-ttu-id="fef75-458">기본값은 10으로, 10번의 재시도를 나타내며 \***nx_tcp.h** _에 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-458">The default value is 10, which represents 10 retries, and is defined in \***nx_tcp.h** _.</span></span> <span data-ttu-id="fef75-459">애플리케이션은 _ _nx_api.h_\*가 포함되기 전에 값을 정의하여 이 기본값을 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-459">The application can override the default by defining the value before _ *_nx_api.h_*\* is included.</span></span>|
|<span data-ttu-id="fef75-460">NX_TCP_MAXIMUM_RX_QUEUE</span><span class="sxs-lookup"><span data-stu-id="fef75-460">NX_TCP_MAXIMUM_RX_QUEUE</span></span> | <span data-ttu-id="fef75-461">TCP 소켓의 최대 수신 큐를 정의하는 기호입니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-461">Symbol that defines the maximum receive queue for TCP sockets.</span></span> <span data-ttu-id="fef75-462">이 기능은 ***NX_ENABLE_LOW_WATERMARK*** 를 통해 사용하도록 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-462">This feature is enabled by ***NX_ENABLE_LOW_WATERMARK***.</span></span>|
|<span data-ttu-id="fef75-463">NX_TCP_MAXIMUM_TX_QUEUE</span><span class="sxs-lookup"><span data-stu-id="fef75-463">NX_TCP_MAXIMUM_TX_QUEUE</span></span> | <span data-ttu-id="fef75-464">TCP 송신 요청을 일시 중단하거나 거부하기 전 TCP 전송 큐의 최대 크기를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-464">Specifies the maximum depth of the TCP transmit queue before TCP send requests are suspended or rejected.</span></span> <span data-ttu-id="fef75-465">기본값은 20으로, 언제든지 최대 20개의 패킷이 전송 큐에 있을 수 있음을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-465">The default value is 20, which means that a maximum of 20 packets can be in the transmit queue at any given time.</span></span> <span data-ttu-id="fef75-466">패킷은 패킷 데이터의 일부 또는 전체에 적용되는 ACK를 연결 상대방으로부터 수신할 때까지 전송 큐에 남아 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-466">Note packets stay in the transmit queue until an ACK that covers some or all of the packet data is received from the other side of the connection.</span></span> <span data-ttu-id="fef75-467">이 상수는 \***nx_tcp.h** _에 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-467">This constant is defined in \***nx_tcp.h** _.</span></span> <span data-ttu-id="fef75-468">애플리케이션은 _ _nx_api.h_\*가 포함되기 전에 값을 정의하여 이 기본값을 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-468">The application can override the default by defining the value before _ *_nx_api.h_*\* is included.</span></span>|
|<span data-ttu-id="fef75-469">NX_TCP_MSS_MINIMUM</span><span class="sxs-lookup"><span data-stu-id="fef75-469">NX_TCP_MSS_MINIMUM</span></span> | <span data-ttu-id="fef75-470">NetX Duo TCP 모듈에서 수락하는 최소 MSS 값을 정의하는 기호입니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-470">Symbol that defines the minimal MSS value NetX Duo TCP module accepts.</span></span> <span data-ttu-id="fef75-471">이 기능은 ***NX_ENABLE_TCP_MSS_CHECK*** 를 통해 사용하도록 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-471">This feature is enabled by ***NX_ENABLE_TCP_MSS_CHECK***.</span></span>|
|<span data-ttu-id="fef75-472">NX_TCP_QUEUE_DEPTH_UPDATE_NOTIFY_ENABLE</span><span class="sxs-lookup"><span data-stu-id="fef75-472">NX_TCP_QUEUE_DEPTH_UPDATE_NOTIFY_ENABLE</span></span> | <span data-ttu-id="fef75-473">\***NX_ENABLE_TCP_QUEUE_DEPTH_UPDATE_NOTIFY** _로 이름을 바꿨습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-473">Renamed to \***NX_ENABLE_TCP_QUEUE_DEPTH_UPDATE_NOTIFY** _.</span></span> <span data-ttu-id="fef75-474">아직 지원되는 옵션이지만 새 디자인에서는 _\*_NX_ENABLE_TCP_QUEUE_DEPTH_UPDATE_NOTIFY_\*\*를 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-474">Although it is still being supported, new designs are encouraged to use _\*_NX_ENABLE_TCP_QUEUE_DEPTH_UPDATE_NOTIFY_\*\*.</span></span>|
|<span data-ttu-id="fef75-475">NX_TCP_RETRY_SHIFT</span><span class="sxs-lookup"><span data-stu-id="fef75-475">NX_TCP_RETRY_SHIFT</span></span> | <span data-ttu-id="fef75-476">재시도 간 재전송 제한 시간 길이를 변경하는 방법을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-476">Specifies how the retransmit timeout period changes between retries.</span></span> <span data-ttu-id="fef75-477">이 값이 0이면 초기 재전송 시간 제한과 이어지는 재전송 시간 제한이 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-477">If this value is 0, the initial retransmit timeout is the same as subsequent retransmit timeouts.</span></span> <span data-ttu-id="fef75-478">이 값이 1이면 각각의 이어지는 재전송 시간 제한이 2배로 길어집니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-478">If this value is 1, each successive retransmit is twice as long.</span></span> <span data-ttu-id="fef75-479">이 값이 2이면 각각의 이어지는 재전송 시간 제한이 4배로 길어집니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-479">If this value is 2, each subsequent retransmit timeout is four times as long.</span></span> <span data-ttu-id="fef75-480">기본값은 0이며 \***nx_tcp.h** _에 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-480">The default value is 0 and is defined in \***nx_tcp.h** _.</span></span> <span data-ttu-id="fef75-481">애플리케이션은 _ _nx_api.h_\*가 포함되기 전에 값을 정의하여 이 기본값을 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-481">The application can override the default by defining the value before _ *_nx_api.h_*\* is included.</span></span>|
|<span data-ttu-id="fef75-482">NX_TCP_TRANSMIT_TIMER_RATE</span><span class="sxs-lookup"><span data-stu-id="fef75-482">NX_TCP_TRANSMIT_TIMER_RATE</span></span> | <span data-ttu-id="fef75-483">TCP 전송 재시도 처리에 대한 타이머 속도를 계산하기 위해 시스템 틱 수(\***NX_IP_PERIODIC_RATE** _)를 나누는 방법을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-483">Specifies how the number of system ticks (\***NX_IP_PERIODIC_RATE** _) is divided to calculate the timer rate for the TCP transmit retry processing.</span></span> <span data-ttu-id="fef75-484">기본값은 1로, 1초를 나타내며 _*_nx_tcp.h_*_ 에 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-484">The default value is 1, which represents 1 second, and is defined in _*_nx_tcp.h_*_.</span></span> <span data-ttu-id="fef75-485">애플리케이션은 _ _nx_api.h_\*가 포함되기 전에 값을 정의하여 이 기본값을 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-485">The application can override the default by defining the value before _ *_nx_api.h_*\* is included.</span></span>|

### <a name="udp-configuration-options"></a><span data-ttu-id="fef75-486">UDP 구성 옵션</span><span class="sxs-lookup"><span data-stu-id="fef75-486">UDP Configuration Options</span></span>

| <span data-ttu-id="fef75-487">옵션</span><span class="sxs-lookup"><span data-stu-id="fef75-487">Option</span></span>  | <span data-ttu-id="fef75-488">Description</span><span class="sxs-lookup"><span data-stu-id="fef75-488">Description</span></span>  |
|---|---|
|<span data-ttu-id="fef75-489">NX_DISABLE_UDP_INFO</span><span class="sxs-lookup"><span data-stu-id="fef75-489">NX_DISABLE_UDP_INFO</span></span> | <span data-ttu-id="fef75-490">정의된 경우 UDP 정보를 수집할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-490">Defined, disables UDP information gathering.</span></span>|
|<span data-ttu-id="fef75-491">NX_DISABLE_UDP_RX_CHECKSUM</span><span class="sxs-lookup"><span data-stu-id="fef75-491">NX_DISABLE_UDP_RX_CHECKSUM</span></span> | <span data-ttu-id="fef75-492">정의된 경우 수신 UDP 패킷의 UDP 체크섬 계산을 사용하지 않도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-492">Defined, disables the UDP checksum computation on incoming UDP packets.</span></span> <span data-ttu-id="fef75-493">네트워크 인터페이스 드라이버가 하드웨어의 UDP 헤더 체크섬을 확인할 수 있고 애플리케이션이 IPsec 또는 IP 조각화 논리를 사용하도록 설정하지 않는 경우에 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-493">This is useful if the network interface driver is able to verify UDP header checksum in hardware, and the application does not enable IPsec or IP fragmentation logic.</span></span>|
|<span data-ttu-id="fef75-494">NX_DISABLE_UDP_TX_CHECKSUM</span><span class="sxs-lookup"><span data-stu-id="fef75-494">NX_DISABLE_UDP_TX_CHECKSUM</span></span> | <span data-ttu-id="fef75-495">정의된 경우 발신 UDP 패킷의 UDP 체크섬 계산을 사용하지 않도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-495">Defined, disables the UDP checksum computation on outgoing UDP packets.</span></span> <span data-ttu-id="fef75-496">네트워크 인터페이스 드라이버가 UDP 헤더 체크섬을 계산하여 데이터를 전송하기 전 IP 헤드에 값을 삽입할 수 있으며 애플리케이션이 IPsec 또는 IP 조각화 논리를 사용하도록 설정하지 않는 경우에 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-496">This is useful if the network interface driver is able to compute UDP header checksum and insert the value in the IP head before transmitting the data, and the application does not enable IPsec or IP fragmentation logic.</span></span>|

### <a name="ipv6-options"></a><span data-ttu-id="fef75-497">IPv6 옵션</span><span class="sxs-lookup"><span data-stu-id="fef75-497">IPv6 Options</span></span>  

| <span data-ttu-id="fef75-498">옵션</span><span class="sxs-lookup"><span data-stu-id="fef75-498">Option</span></span>  | <span data-ttu-id="fef75-499">Description</span><span class="sxs-lookup"><span data-stu-id="fef75-499">Description</span></span>  |
|---|---|
| <span data-ttu-id="fef75-500">NX_DISABLE_IPV6</span><span class="sxs-lookup"><span data-stu-id="fef75-500">NX_DISABLE_IPV6</span></span> | <span data-ttu-id="fef75-501">NetX Duo 라이브러리를 빌드할 때 IPv6 기능을 사용하지 않도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-501">Disables IPv6 functionality when the NetX Duo library is built.</span></span> <span data-ttu-id="fef75-502">IPv6가 필요하지 않은 애플리케이션의 경우에는 IPv6를 지원하는 데 필요한 코드 및 추가 스토리지 공간을 가져올 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-502">For applications that do not need IPv6, this avoids pulling in code and additional storage space needed to support IPv6.</span></span>|
|<span data-ttu-id="fef75-503">NX_DISABLE_IPV6_PATH_MTU_DISCOVERY</span><span class="sxs-lookup"><span data-stu-id="fef75-503">NX_DISABLE_IPV6_PATH_MTU_DISCOVERY</span></span> | <span data-ttu-id="fef75-504">정의된 경우 NetX Duo 호스트 대상 테이블의 대상에 대한 경로에서 최대 MTU를 결정하는 데 사용되는 경로 MTU 검색을 사용하지 않도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-504">Defined, disables path MTU discovery, which is used to determine the maximum MTU in the path to a target in the NetX Duo host destination table.</span></span> <span data-ttu-id="fef75-505">이렇게 하면 NetX Duo 호스트가 조각화가 필요하지 않은 가능한 최대 패킷을 보낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-505">This enables the NetX Duo host to send the largest possible packet that will not require fragmentation.</span></span> <span data-ttu-id="fef75-506">기본적으로 이 옵션은 정의되어 있습니다(경로 MTU가 사용하지 않도록 설정됨).</span><span class="sxs-lookup"><span data-stu-id="fef75-506">By default, this option is defined (path MTU is disabled).</span></span>|
|<span data-ttu-id="fef75-507">NX_ENABLE_IPV6_ADDRESS_CHANGE_NOTIFY</span><span class="sxs-lookup"><span data-stu-id="fef75-507">NX_ENABLE_IPV6_ADDRESS_CHANGE_NOTIFY</span></span> | <span data-ttu-id="fef75-508">정의된 경우 IPv6 주소가 변경될 때 콜백 함수를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-508">Defined, allows a callback function to be invoked when the IPv6 address is changed.</span></span> <span data-ttu-id="fef75-509">기본적으로 이 옵션은 사용하도록 설정되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-509">By default this option is not enabled.</span></span>|
|<span data-ttu-id="fef75-510">NX_ENABLE_IPV6_MULTICAST</span><span class="sxs-lookup"><span data-stu-id="fef75-510">NX_ENABLE_IPV6_MULTICAST</span></span> | <span data-ttu-id="fef75-511">정의된 경우 IPv6 멀티캐스트 조인/탈퇴 함수를 사용하도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-511">Defined, enables IPv6 multicast join/leave function.</span></span> <span data-ttu-id="fef75-512">기본적으로 이 옵션은 사용하도록 설정되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-512">By default this option is not enabled.</span></span>|
|<span data-ttu-id="fef75-513">NX_ENABLE_IPV6_PATH_MTU_DISCOVERY</span><span class="sxs-lookup"><span data-stu-id="fef75-513">NX_ENABLE_IPV6_PATH_MTU_DISCOVERY</span></span> | <span data-ttu-id="fef75-514">정의된 경우 IPv6 경로 MTU 검색 기능을 사용하도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-514">Defined, enables the IPv6 path MTU discovery feature.</span></span> <span data-ttu-id="fef75-515">기본적으로 이 옵션은 사용하도록 설정되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-515">By default this option is not enabled.</span></span>|
|<span data-ttu-id="fef75-516">NX_IPV6_ADDRESS_CHANGE_NOTIFY_ENABLE</span><span class="sxs-lookup"><span data-stu-id="fef75-516">NX_IPV6_ADDRESS_CHANGE_NOTIFY_ENABLE</span></span> | <span data-ttu-id="fef75-517">\***NX_ENABLE_IPV6_ADDRESS_CHANGE_NOTIFY** _로 이름을 바꿨습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-517">Renamed to \***NX_ENABLE_IPV6_ADDRESS_CHANGE_NOTIFY** _.</span></span> <span data-ttu-id="fef75-518">아직 지원되는 옵션이지만 새 디자인에서는 _\*_NX_ENABLE_IPV6_ADDRESS_CHANGE_NOTIFY_\*\*를 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-518">Although it is still being supported, new designs are encouraged to use _\*_NX_ENABLE_IPV6_ADDRESS_CHANGE_NOTIFY_\*\*.</span></span>|
|<span data-ttu-id="fef75-519">NX_IPV6_DEFAULT_ROUTER_TABLE_SIZE</span><span class="sxs-lookup"><span data-stu-id="fef75-519">NX_IPV6_DEFAULT_ROUTER_TABLE_SIZE</span></span> | <span data-ttu-id="fef75-520">IPv6 라우팅 테이블에 있는 항목 수를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-520">Specifies the number of entries in the IPv6 routing table.</span></span> <span data-ttu-id="fef75-521">기본 라우터에는 적어도 1개의 항목이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-521">At least onS entry is needed for the default router.</span></span> <span data-ttu-id="fef75-522">***nx_api.h*** 에 정의된 경우 기본값은 8입니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-522">Defined in ***nx_api.h***, the default value is 8.</span></span>|
|<span data-ttu-id="fef75-523">NX_IPV6_DESTINATION_TABLE_SIZE</span><span class="sxs-lookup"><span data-stu-id="fef75-523">NX_IPV6_DESTINATION_TABLE_SIZE</span></span> | <span data-ttu-id="fef75-524">IPv6 대상 테이블의 항목 수를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-524">Specifies the number of entries in the IPv6 destination table.</span></span> <span data-ttu-id="fef75-525">IPv6 주소에 대한 다음 홉 주소에 대한 정보를 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-525">This stores information about next hop addresses for IPv6 addresses.</span></span> <span data-ttu-id="fef75-526">***nx_api.h*** 에 정의된 경우 기본값은 8입니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-526">Defined in ***nx_api.h***, the default value is 8.</span></span>|
|<span data-ttu-id="fef75-527">NX_IPV6_MAX_REASSEMBLY_TIME</span><span class="sxs-lookup"><span data-stu-id="fef75-527">NX_IPV6_MAX_REASSEMBLY_TIME</span></span> | <span data-ttu-id="fef75-528">IPv6 조각을 리어셈블하도록 허용되는 최대 시간을 제어하는 기호입니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-528">Symbol that controls the maximum time allowed to reassemble IPv6 fragment.</span></span>|
|<span data-ttu-id="fef75-529">NX_IPV6_MULTICAST_ENABLE</span><span class="sxs-lookup"><span data-stu-id="fef75-529">NX_IPV6_MULTICAST_ENABLE</span></span> | <span data-ttu-id="fef75-530">\***NX_ENABLE_IPV6_MULTICAST** _로 이름을 바꿨습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-530">Renamed to \***NX_ENABLE_IPV6_MULTICAST** _.</span></span> <span data-ttu-id="fef75-531">아직 지원되는 옵션이지만 새 디자인에서는 _\*_NX_ENABLE_IPV6_MULTICAST_\*\*를 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-531">Although it is still being supported, new designs are encouraged to use _\*_NX_ENABLE_IPV6_MULTICAST_\*\*.</span></span>|
|<span data-ttu-id="fef75-532">NX_IPV6_PREFIX_LIST_TABLE_SIZE</span><span class="sxs-lookup"><span data-stu-id="fef75-532">NX_IPV6_PREFIX_LIST_TABLE_SIZE</span></span> | <span data-ttu-id="fef75-533">접두사 테이블의 크기를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-533">Specifies the size of the prefix table.</span></span> <span data-ttu-id="fef75-534">접두사 정보는 라우터 보급 알림에서 가져오며 IPv6 주소 구성의 일부입니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-534">Prefix information is obtained from router advertisements and is part of the IPv6 address configuration.</span></span> <span data-ttu-id="fef75-535">***nx_api.h*** 에 정의된 경우 기본값은 8입니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-535">Defined in ***nx_api.h***, the default value is 8.</span></span>|
|<span data-ttu-id="fef75-536">NX_IPV6_STATELESS_AUTOCONFIG_CONTROL</span><span class="sxs-lookup"><span data-stu-id="fef75-536">NX_IPV6_STATELESS_AUTOCONFIG_CONTROL</span></span> | <span data-ttu-id="fef75-537">정의된 경우 NetX Duo에서 상태 비저장 주소 자동 구성 기능을 사용하지 않도록 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-537">Defined, allows NetX Duo to disable stateless address autoconfiguration feature.</span></span> <span data-ttu-id="fef75-538">기본적으로 이 옵션은 사용하도록 설정되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-538">By default this option is not enabled.</span></span>|
|<span data-ttu-id="fef75-539">NX_MAX_IPV6_ADDRESSES</span><span class="sxs-lookup"><span data-stu-id="fef75-539">NX_MAX_IPV6_ADDRESSES</span></span> | <span data-ttu-id="fef75-540">IPv6 주소 풀의 항목 수를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-540">Specifies the number of entries in the IPv6 address pool.</span></span> <span data-ttu-id="fef75-541">인터페이스 구성 동안 NetX Duo는 풀의 IPv6 항목을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-541">During interface configuration, NetX Duo uses IPv6 entries from the pool.</span></span> <span data-ttu-id="fef75-542">각 인터페이스에 하나 이상의 링크 로컬 주소와 두 개의 전체 주소가 포함되도록 기본적으로 (NX_MAX_PHYSICAL_INTERFACES \* 3)으로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-542">It is defaulted to (NX_MAX_PHYSICAL_INTERFACES \* 3) to allow each interface to have at least one link local address and two global addresses.</span></span> <span data-ttu-id="fef75-543">모든 인터페이스는 IPv6 주소 풀을 공유합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-543">Note that all interfaces share the IPv6 address pool.</span></span>|
|<span data-ttu-id="fef75-544">NX_PATH_MTU_INCREASE_WAIT_INTERVAL</span><span class="sxs-lookup"><span data-stu-id="fef75-544">NX_PATH_MTU_INCREASE_WAIT_INTERVAL</span></span> | <span data-ttu-id="fef75-545">대상 테이블의 특정 대상에 대한 경로 MTU를 다시 설정할 대기 간격(타이머 틱 수)을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-545">Specifies the wait interval in timer ticks to reset the path MTU for a specific target in the destination table.</span></span> <span data-ttu-id="fef75-546">***NX_DISABLE_IPV6_PATH_MTU_DISCOVERY*** 가 정의되면 이 기호를 정의해도 아무 영향이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-546">If ***NX_DISABLE_IPV6_PATH_MTU_DISCOVERY*** is defined, defining this symbol has no effect.</span></span>|
|<span data-ttu-id="fef75-547">NX_PATH_MTU_INCREASE_WAIT_INTERVAL</span><span class="sxs-lookup"><span data-stu-id="fef75-547">NX_PATH_MTU_INCREASE_WAIT_INTERVAL</span></span> | <span data-ttu-id="fef75-548">대상 테이블 항목에 대한 경로 MTU 값을 다시 설정할 대기 간격(초)을 지정하는 기호입니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-548">Symbol that specifies the wait interval (in seconds) to reset the path MTU value for a destination table entry.</span></span> <span data-ttu-id="fef75-549">***NX_ENABLE_IPV6_PATH_MTU_DISCOVERY*** 가 정의된 경우에만 유효합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-549">It is valid only if ***NX_ENABLE_IPV6_PATH_MTU_DISCOVERY*** is defined.</span></span> <span data-ttu-id="fef75-550">기본적으로 이 값은 600(초)로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-550">By default this value is set to 600 (seconds).</span></span>|

### <a name="neighbor-cache-configuration-options"></a><span data-ttu-id="fef75-551">네트워크 환경 캐시 구성 옵션</span><span class="sxs-lookup"><span data-stu-id="fef75-551">Neighbor Cache Configuration Options</span></span>

| <span data-ttu-id="fef75-552">옵션</span><span class="sxs-lookup"><span data-stu-id="fef75-552">Option</span></span>  | <span data-ttu-id="fef75-553">Description</span><span class="sxs-lookup"><span data-stu-id="fef75-553">Description</span></span>  |
|---|---|
|<span data-ttu-id="fef75-554">NX_DELAY_FIRST_PROBE_TIME</span><span class="sxs-lookup"><span data-stu-id="fef75-554">NX_DELAY_FIRST_PROBE_TIME</span></span> | <span data-ttu-id="fef75-555">STALE 상태의 캐시 항목에 대해 첫 번째 요청이 전송되기까지의 지연 시간(초)을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-555">Specifies the delay in seconds before the first solicitation is sent out for a cache entry in the STALE state.</span></span> <span data-ttu-id="fef75-556">***nx_nd_cache.h*** 에 정의되며 기본값은 5입니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-556">Defined in ***nx_nd_cache.h***, the default value is 5.</span></span>|
|<span data-ttu-id="fef75-557">NX_DISABLE_IPV6_DAD</span><span class="sxs-lookup"><span data-stu-id="fef75-557">NX_DISABLE_IPV6_DAD</span></span> | <span data-ttu-id="fef75-558">정의된 경우 이 옵션은 IPv6 주소 할당 중에 DAD(중복 주소 검색)를 사용하지 않도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-558">Defined, this option disables Duplicate Address Detection (DAD) during IPv6 address assignment.</span></span> <span data-ttu-id="fef75-559">주소는 수동 구성 또는 상태 비저장 주소 자동 구성으로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-559">Addresses are set either by manual configuration or through Stateless Address Auto Configuration.</span></span>|
|<span data-ttu-id="fef75-560">NX_DISABLE_IPV6_PURGE_UNUSED_CACHE_ENTRIES</span><span class="sxs-lookup"><span data-stu-id="fef75-560">NX_DISABLE_IPV6_PURGE_UNUSED_CACHE_ENTRIES</span></span> | <span data-ttu-id="fef75-561">정의된 경우 이 옵션은 테이블이 가득 찰 때 새 항목을 위한 공간을 만들기 위해 시간 제한이 만료되기 전에 NetX Duo가 오래된 캐시 테이블 항목을 제거하지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-561">Defined, this option prevents NetX Duo from removing older cache table entries before their timeout expires to make room for new entries when the table is full.</span></span> <span data-ttu-id="fef75-562">고정 및 라우터 항목은 제거되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-562">Static and router entries are never purged.</span></span>|
|<span data-ttu-id="fef75-563">NX_IPV6_DAD_TRANSMITS</span><span class="sxs-lookup"><span data-stu-id="fef75-563">NX_IPV6_DAD_TRANSMITS</span></span> | <span data-ttu-id="fef75-564">NetX Duo가 인터페이스 주소를 유효한 것으로 표시하기 전에 전송할 네트워크 환경 요청 메시지의 수를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-564">Specifies the number of Neighbor Solicitation messages to be sent before NetX Duo marks an interface address as valid.</span></span> <span data-ttu-id="fef75-565">\***NX_DISABLE_IPV6_DAD** _가 정의되면(DAD 사용 안 함) 이 옵션을 설정해도 아무 효과가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-565">If \***NX_DISABLE_IPV6_DAD** _ is defined (DAD disabled), setting this option has no effect.</span></span> <span data-ttu-id="fef75-566">또는 값 0을 지정하면 DAD가 해제되지만 NetX Duo에 DAD 기능이 남아 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-566">Alternatively, a value of zero (0) turns off DAD but leaves the DAD functionality in NetX Duo.</span></span> <span data-ttu-id="fef75-567">_\*_nx_api.h_\*\*에 정의된 경우 기본값은 3입니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-567">Defined in _\*_nx_api.h_\*\*, the default value is 3.</span></span>|
|<span data-ttu-id="fef75-568">NX_IPV6_DISABLE_PURGE_UNUSED_CACHE_ENTRIES</span><span class="sxs-lookup"><span data-stu-id="fef75-568">NX_IPV6_DISABLE_PURGE_UNUSED_CACHE_ENTRIES</span></span> | <span data-ttu-id="fef75-569">\***NX_DISABLE_IPV6_PURGE_UNUSED_CACHE_ENTRIES** _로 이름을 바꿨습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-569">Renamed to \***NX_DISABLE_IPV6_PURGE_UNUSED_CACHE_ENTRIES** _.</span></span> <span data-ttu-id="fef75-570">아직 지원되는 옵션이지만 새 디자인에서는 _\*_NX_DISABLE_IPV6_PURGE_UNUSED_CACHE_ENTRIES_\*\*를 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-570">Although it is still being supported, new designs are encouraged to use _\*_NX_DISABLE_IPV6_PURGE_UNUSED_CACHE_ENTRIES_\*\*.</span></span>|
|<span data-ttu-id="fef75-571">NX_IPV6_NEIGHBOR_CACHE_SIZE</span><span class="sxs-lookup"><span data-stu-id="fef75-571">NX_IPV6_NEIGHBOR_CACHE_SIZE</span></span> | <span data-ttu-id="fef75-572">IPv6 네트워크 환경 캐시 테이블의 항목 수를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-572">Specifies the number of entries in the IPv6 Neighbor Cache table.</span></span> <span data-ttu-id="fef75-573">***nx_nd_cache.h*** 에 정의되며 기본값은 16입니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-573">Defined in ***nx_nd_cache.h***, the default value is 16.</span></span>|
|<span data-ttu-id="fef75-574">NX_MAX_MULTICAST_SOLICIT</span><span class="sxs-lookup"><span data-stu-id="fef75-574">NX_MAX_MULTICAST_SOLICIT</span></span> | <span data-ttu-id="fef75-575">IPv6 주소와 MAC 주소 간의 매핑이 필요한 경우 NetX Duo가 IPv6 네트워크 환경 검색 프로토콜의 일부로 전송하는 네트워크 환경 요청 메시지의 수를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-575">Specifies the number of Neighbor Solicitation messages NetX Duo transmits as part of the IPv6 Neighbor Discovery protocol when mapping between IPv6 address and MAC address is required.</span></span> <span data-ttu-id="fef75-576">***nx_nd_cache.h*** 에 정의되며 기본값은 3입니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-576">Defined in ***nx_nd_cache.h***, the default value is 3.</span></span>|
|<span data-ttu-id="fef75-577">NX_MAX_UNICAST_SOLICIT</span><span class="sxs-lookup"><span data-stu-id="fef75-577">NX_MAX_UNICAST_SOLICIT</span></span> | <span data-ttu-id="fef75-578">NetX Duo가 특정 네트워크 환경의 연결을 확인하기 위해 전송하는 네트워크 환경 요청 메시지의 수를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-578">Specifies the number of Neighbor Solicitation messages NetX Duo transmits to determine a specific neighbor's reachability.</span></span> <span data-ttu-id="fef75-579">***nx_nd_cache.h*** 에 정의되며 기본값은 3입니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-579">Defined in ***nx_nd_cache.h***, the default value is 3.</span></span>|
|<span data-ttu-id="fef75-580">NX_ND_MAX_QUEUE_DEPTH</span><span class="sxs-lookup"><span data-stu-id="fef75-580">NX_ND_MAX_QUEUE_DEPTH</span></span> | <span data-ttu-id="fef75-581">ND 캐시가 확인되기 위해 큐에 대기 중인 최대 패킷 수를 정의하는 기호입니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-581">Symbol that defines the maximum number of packets queued up for ND cache to be resolved.</span></span> <span data-ttu-id="fef75-582">기본적으로 이 기호는 4로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-582">By default this symbol is set to 4.</span></span>|
|<span data-ttu-id="fef75-583">NX_REACHABLE_TIME</span><span class="sxs-lookup"><span data-stu-id="fef75-583">NX_REACHABLE_TIME</span></span> | <span data-ttu-id="fef75-584">캐시 대상 IPv6 주소에서 받은 패킷이 없을 때 캐시 항목이 REACHABLE 상태가 될 수 있는 시간 제한(초)을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-584">Specifies the time out in seconds for a cache entry to exist in the REACHABLE state with no packets received from the cache destination IPv6 address.</span></span> <span data-ttu-id="fef75-585">***nx_nd_cache.h*** 에 정의되며 기본값은 30입니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-585">Defined in ***nx_nd_cache.h***, the default value is 30.</span></span>|
|<span data-ttu-id="fef75-586">NX_RETRANS_TIMER</span><span class="sxs-lookup"><span data-stu-id="fef75-586">NX_RETRANS_TIMER</span></span>  | <span data-ttu-id="fef75-587">NetX Duo에서 보낸 요청 패킷 사이의 지연 시간(밀리초)을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-587">Specifies in milliseconds the length of delay between solicitation packets sent by NetX Duo.</span></span> <span data-ttu-id="fef75-588">***nx_nd_cache.h*** 에 정의되며 기본값은 1000입니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-588">Defined in ***nx_nd_cache.h***, the default value is 1000.</span></span>|
| <span data-ttu-id="fef75-589">NXDUO_DISABLE_DAD</span><span class="sxs-lookup"><span data-stu-id="fef75-589">NXDUO_DISABLE_DAD</span></span> | <span data-ttu-id="fef75-590">\***NX_DISABLE_IPV6_DAD** _로 이름을 바꿨습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-590">Renamed to \***NX_DISABLE_IPV6_DAD** _.</span></span> <span data-ttu-id="fef75-591">아직 지원되는 옵션이지만 새 디자인에서는 _\*_NX_DISABLE_IPV6_DAD_\*\*를 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-591">Although it is still being supported, new designs are encouraged to use _\*_NX_DISABLE_IPV6_DAD_\*\*.</span></span>|
|<span data-ttu-id="fef75-592">NXDUO_DUP_ADDR_DETECT_TRANSMITS</span><span class="sxs-lookup"><span data-stu-id="fef75-592">NXDUO_DUP_ADDR_DETECT_TRANSMITS</span></span> | <span data-ttu-id="fef75-593">\***NX_IPV6_DAD_TRANSMITS** _로 이름을 바꿨습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-593">Renamed to \***NX_IPV6_DAD_TRANSMITS** _.</span></span> <span data-ttu-id="fef75-594">아직 지원되는 옵션이지만 새 디자인에서는 _\*_NX_IPV6_DAD_TRANSMITS_\*\*를 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-594">Although it is still being supported, new designs are encouraged to use _\*_NX_IPV6_DAD_TRANSMITS_\*\*.</span></span>|

### <a name="miscellaneous-icmpv6-configuration-options"></a><span data-ttu-id="fef75-595">기타 ICMPv6 구성 옵션</span><span class="sxs-lookup"><span data-stu-id="fef75-595">Miscellaneous ICMPv6 Configuration Options</span></span>

| <span data-ttu-id="fef75-596">옵션</span><span class="sxs-lookup"><span data-stu-id="fef75-596">Option</span></span>  | <span data-ttu-id="fef75-597">Description</span><span class="sxs-lookup"><span data-stu-id="fef75-597">Description</span></span>  |
|---|---|
|<span data-ttu-id="fef75-598">NX_DISABLE_ICMPV6_ERROR_MESSAGE</span><span class="sxs-lookup"><span data-stu-id="fef75-598">NX_DISABLE_ICMPV6_ERROR_MESSAGE</span></span> | <span data-ttu-id="fef75-599">정의된 경우 다른 호스트에서 받은 문제 패킷에 대한 응답으로 NetX Duo에서 ICMPv6 오류 메시지를 보내지 않도록 설정합니다(예: 잘못된 형식의 헤더 또는 패킷 헤더 형식이 더 이상 사용되지 않음).</span><span class="sxs-lookup"><span data-stu-id="fef75-599">Defined, disables NetX Duo from sending an ICMPv6 error message in response to a problem packet (e.g., improperly formatted header or packet header type is deprecated) received from another host.</span></span>|
|<span data-ttu-id="fef75-600">NX_DISABLE_ICMPV6_REDIRECT_PROCESS</span><span class="sxs-lookup"><span data-stu-id="fef75-600">NX_DISABLE_ICMPV6_REDIRECT_PROCESS</span></span> | <span data-ttu-id="fef75-601">정의된 경우 ICMPv6 리디렉션 패킷 처리를 사용하지 않도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-601">Defined, disables ICMPv6 redirect packet processing.</span></span> <span data-ttu-id="fef75-602">기본적으로 NetX Duo는 리디렉션 메시지를 처리하고 다음 홉 IP 주소 정보를 사용하여 대상 테이블을 업데이트합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-602">NetX Duo by default processes redirect messages and updates the destination table with next hop IP address information.</span></span>|
|<span data-ttu-id="fef75-603">NX_DISABLE_ICMPV6_ROUTER_ADVERTISEMENT_PROCESS</span><span class="sxs-lookup"><span data-stu-id="fef75-603">NX_DISABLE_ICMPV6_ROUTER_ADVERTISEMENT_PROCESS</span></span> | <span data-ttu-id="fef75-604">정의된 경우 IPv6 라우터 보급 알림 패킷에서 받은 정보를 NetX Duo에서 처리하지 않도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-604">Defined, disables NetX Duo from processing information received in IPv6 router advertisement packets.</span></span>|
|<span data-ttu-id="fef75-605">NX_DISABLE_ICMPV6_ROUTER_SOLICITATION</span><span class="sxs-lookup"><span data-stu-id="fef75-605">NX_DISABLE_ICMPV6_ROUTER_SOLICITATION</span></span> | <span data-ttu-id="fef75-606">정의된 경우 NetX Duo에서 정기적으로 IPv6 라우터 요청 메시지를 라우터에 전송하지 않도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-606">Defined, disables NetX Duo from sending IPv6 router solicitation messages at regular intervals to the router.</span></span>|
|<span data-ttu-id="fef75-607">NX_DISABLE_ICMPV6_RX_CHECKSUM</span><span class="sxs-lookup"><span data-stu-id="fef75-607">NX_DISABLE_ICMPV6_RX_CHECKSUM</span></span> | <span data-ttu-id="fef75-608">정의된 경우 수신된 ICMP 패킷에 대해 ICMPv6 체크섬 계산을 사용하지 않도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-608">Defined, disables ICMPv6 checksum computation on received ICMP packets.</span></span>|
|<span data-ttu-id="fef75-609">NX_DISABLE_ICMPv6_RX_CHECKSUM</span><span class="sxs-lookup"><span data-stu-id="fef75-609">NX_DISABLE_ICMPv6_RX_CHECKSUM</span></span> | <span data-ttu-id="fef75-610">\***NX_DISABLE_ICMPV6_RX_CHECKSUM** _으로 이름을 바꿨습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-610">Renamed to \***NX_DISABLE_ICMPV6_RX_CHECKSUM** _.</span></span> <span data-ttu-id="fef75-611">아직 지원되는 옵션이지만 새 디자인에서는 _\*_NX_DISABLE_CMPV6_RX_CHECKSUM_\*\*을 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-611">Although it is still being supported, new designs are encouraged to use _\*_NX_DISABLE_CMPV6_RX_CHECKSUM_\*\*.</span></span>|
|<span data-ttu-id="fef75-612">NX_DISABLE_ICMPV6_TX_CHECKSUM</span><span class="sxs-lookup"><span data-stu-id="fef75-612">NX_DISABLE_ICMPV6_TX_CHECKSUM</span></span> | <span data-ttu-id="fef75-613">정의된 경우 전송된 ICMP 패킷에 대해 ICMPv6 체크섬 계산을 모두 사용하지 않도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-613">Defined, disables and ICMPv6 checksum computation on transmitted ICMP packets.</span></span>|
|<span data-ttu-id="fef75-614">NX_DISABLE_ICMPV6_TX_CHECKSUM</span><span class="sxs-lookup"><span data-stu-id="fef75-614">NX_DISABLE_ICMPV6_TX_CHECKSUM</span></span> | <span data-ttu-id="fef75-615">\***NX_DISABLE_ICMPV6_TX_CHECKSUM** _으로 이름을 바꿨습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-615">Renamed to \***NX_DISABLE_ICMPV6_TX_CHECKSUM** _.</span></span> <span data-ttu-id="fef75-616">아직 지원되는 옵션이지만 새 디자인에서는 _\*_NX_DISABLE_ICMPV6_TX_CHECKSUM_\*\*을 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-616">Although it is still being supported, new designs are encouraged to use _\*_NX_DISABLE_ICMPV6_TX_CHECKSUM_\*\*.</span></span>|
|<span data-ttu-id="fef75-617">NX_ICMPV6_MAX_RTR_SOLICITATIONS</span><span class="sxs-lookup"><span data-stu-id="fef75-617">NX_ICMPV6_MAX_RTR_SOLICITATIONS</span></span> | <span data-ttu-id="fef75-618">라우터 응답이 수신될 때까지 호스트가 보내는 최대 라우터 요청 수를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-618">Define the max number of router solicitations a host sends until a router response is received.</span></span> <span data-ttu-id="fef75-619">응답이 수신되지 않으면 호스트는 라우터가 없다는 결론을 내립니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-619">If no response is received, the host concludes no router is present.</span></span> <span data-ttu-id="fef75-620">기본값은 3입니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-620">The default value is 3.</span></span>|
|<span data-ttu-id="fef75-621">NX_ICMPV6_RTR_SOLICITATION_DELAY</span><span class="sxs-lookup"><span data-stu-id="fef75-621">NX_ICMPV6_RTR_SOLICITATION_DELAY</span></span> | <span data-ttu-id="fef75-622">초기 라우터 요청의 최대 지연 시간(초)을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-622">Specifies the maximum delay for the initial router solicitation in seconds.</span></span>|
|<span data-ttu-id="fef75-623">NX_ICMPV6_RTR_SOLICITATION_INTERVAL</span><span class="sxs-lookup"><span data-stu-id="fef75-623">NX_ICMPV6_RTR_SOLICITATION_INTERVAL</span></span> | <span data-ttu-id="fef75-624">두 라우터 요청 메시지 사이의 간격을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-624">Specifies the interval between two router solicitation messages.</span></span> <span data-ttu-id="fef75-625">기본값은 4입니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-625">The default value is 4.</span></span>|
|<span data-ttu-id="fef75-626">NXDUO_DESTINATION_TABLE_SIZE</span><span class="sxs-lookup"><span data-stu-id="fef75-626">NXDUO_DESTINATION_TABLE_SIZE</span></span> | <span data-ttu-id="fef75-627">\***NX_IPV6_DESTINATION_TABLE_SIZE** _로 이름을 바꿨습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-627">Renamed to \***NX_IPV6_DESTINATION_TABLE_SIZE** _.</span></span> <span data-ttu-id="fef75-628">아직 지원되는 옵션이지만 새 디자인에서는 _\*_NX_IPV6_DESTINATION_TABLE_SIZE_\*\*를 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-628">Although it is still being supported, new designs are encouraged to use _\*_NX_IPV6_DESTINATION_TABLE_SIZE_\*\*.</span></span>|
|<span data-ttu-id="fef75-629">NXDUO_DISABLE_ICMPV6_ERROR_MESSAGE</span><span class="sxs-lookup"><span data-stu-id="fef75-629">NXDUO_DISABLE_ICMPV6_ERROR_MESSAGE</span></span> | <span data-ttu-id="fef75-630">\***NX_DISABLE_ICMPV6_ERROR_MESSAGE** _로 이름을 바꿨습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-630">Renamed to \***NX_DISABLE_ICMPV6_ERROR_MESSAGE** _.</span></span> <span data-ttu-id="fef75-631">아직 지원되는 옵션이지만 새 디자인에서는 _\*_NX_DISABLE_ICMPV6_ERROR_MESSAGE_\*\*를 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-631">Although it is still being supported, new designs are encouraged to use _\*_NX_DISABLE_ICMPV6_ERROR_MESSAGE_\*\*.</span></span>|
|<span data-ttu-id="fef75-632">NXDUO_DISABLE_ICMPV6_REDIRECT_PROCESS</span><span class="sxs-lookup"><span data-stu-id="fef75-632">NXDUO_DISABLE_ICMPV6_REDIRECT_PROCESS</span></span> | <span data-ttu-id="fef75-633">\***NX_DISABLE_ICMPV6_REDIRECT_PROCESS** _로 이름을 바꿨습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-633">Renamed to \***NX_DISABLE_ICMPV6_REDIRECT_PROCESS** _.</span></span> <span data-ttu-id="fef75-634">아직 지원되는 옵션이지만 새 디자인에서는 _ \*_NX_DISABLE_ICMPV6_REDIRECT_PROCESS_\*\*를 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-634">Although it is still being supported, new designs are encouraged to use _ *_NX_DISABLE_ICMPV6_REDIRECT_PROCESS_*\*</span></span>|  
|<span data-ttu-id="fef75-635">NXDUO_DISABLE_ICMPV6_ROUTER_ADVERTISEMENT_PROCESS</span><span class="sxs-lookup"><span data-stu-id="fef75-635">NXDUO_DISABLE_ICMPV6_ROUTER_ADVERTISEMENT_PROCESS</span></span>| <span data-ttu-id="fef75-636">\***NX_DISABLE_ICMPV6_ROUTER_ADVERTISEMENT_PROCESS** _로 이름을 바꿨습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-636">Renamed to \***NX_DISABLE_ICMPV6_ROUTER_ADVERTISEMENT_PROCESS** _.</span></span> <span data-ttu-id="fef75-637">아직 지원되는 옵션이지만 새 디자인에서는 _\*_NX_DISABLE_ICMPV6_ROUTER_ADVERTISEMENT_PROCESS_\*\*를 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-637">Although it is still being supported, new designs are encouraged to use _\*_NX_DISABLE_ICMPV6_ROUTER_ADVERTISEMENT_PROCESS_\*\*.</span></span>|
|<span data-ttu-id="fef75-638">NXDUO_DISABLE_ICMPV6_ROUTER_SOLICITATION</span><span class="sxs-lookup"><span data-stu-id="fef75-638">NXDUO_DISABLE_ICMPV6_ROUTER_SOLICITATION</span></span> | <span data-ttu-id="fef75-639">\***NX_DISABLE_ICMPV6_ROUTER_SOLICITATION** _으로 이름을 바꿨습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-639">Renamed to \***NX_DISABLE_ICMPV6_ROUTER_SOLICITATION** _.</span></span> <span data-ttu-id="fef75-640">아직 지원되는 옵션이지만 새 디자인에서는 _\*_NX_DISABLE_ICMPV6_ROUTER_SOLICITATION_\*\*을 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-640">Although it is still being supported, new designs are encouraged to use _\*_NX_DISABLE_ICMPV6_ROUTER_SOLICITATION_\*\*.</span></span>|
|<span data-ttu-id="fef75-641">NXDUO_ICMPV6_MAX_RTR_SOLICITATIONS</span><span class="sxs-lookup"><span data-stu-id="fef75-641">NXDUO_ICMPV6_MAX_RTR_SOLICITATIONS</span></span> | <span data-ttu-id="fef75-642">\***NX_ICMPV6_MAX_RTR_SOLICITATIONS** _로 이름을 바꿨습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-642">Renamed to \***NX_ICMPV6_MAX_RTR_SOLICITATIONS** _.</span></span> <span data-ttu-id="fef75-643">아직 지원되는 옵션이지만 새 디자인에서는 _\*_NX_ICMPV6_MAX_RTR_SOLICITATIONS_\*\*를 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-643">Although it is still being supported, new designs are encouraged to use _\*_NX_ICMPV6_MAX_RTR_SOLICITATIONS_\*\*.</span></span>|
|<span data-ttu-id="fef75-644">NXDUO_ICMPV6_RTR_SOLICITATION_INTERVAL</span><span class="sxs-lookup"><span data-stu-id="fef75-644">NXDUO_ICMPV6_RTR_SOLICITATION_INTERVAL</span></span> | <span data-ttu-id="fef75-645">\***NX_ICMPV6_RTR_SOLICITATION_INTERVAL** _로 이름을 바꿨습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-645">Renamed to \***NX_ICMPV6_RTR_SOLICITATION_INTERVAL** _.</span></span> <span data-ttu-id="fef75-646">이 기호는 더 이상 사용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-646">This symbol is being depreciated.</span></span> <span data-ttu-id="fef75-647">아직 지원되는 옵션이지만 새 디자인에서는 _ \*_NX_ICMPV6_RTR_SOLICITATION_INTERVAL_\*\*을 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-647">Although it is still being supported, new designs are encouraged to use _ *_NX_ICMPV6_RTR_SOLICITATION_INTERVAL_*\*</span></span>|

## <a name="netx-duo-version-id"></a><span data-ttu-id="fef75-648">NetX Duo 버전 ID</span><span class="sxs-lookup"><span data-stu-id="fef75-648">NetX Duo Version ID</span></span>

<span data-ttu-id="fef75-649">사용자 및 애플리케이션 소프트웨어 둘 다 런타임 중에 NetX Duo의 현재 버전을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-649">The current version of NetX Duo is available to both the user and the application software during runtime.</span></span> <span data-ttu-id="fef75-650">**nx_port.h** 파일의 검사에서 Netx Duo 버전을 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-650">You can obtain the NetX Duo version from examination of the **nx_port.h** file.</span></span> <span data-ttu-id="fef75-651">또한 이 파일에는 해당 포트의 버전 기록도 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-651">In addition, this file also contains a version history of the corresponding port.</span></span> <span data-ttu-id="fef75-652">애플리케이션 소프트웨어는 _*_nx_port.h_\*\*에서 전역 문자열 _*_nx_version_id__ 를 검사하여 NetX Duo 버전을 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-652">Application software can obtain the NetX Duo version by examining the global string _\**_nx_version_id_*_ in _\*_nx_port.h_\*\*.</span></span>

<span data-ttu-id="fef75-653">애플리케이션 소프트웨어는 ***nx_api.h*** 에 정의되어 있는 아래에 표시된 상수에서 릴리스 정보를 가져올 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-653">Application software can also obtain release information from the constants shown below defined in ***nx_api.h***.</span></span>

<span data-ttu-id="fef75-654">이러한 상수는 이름과 제품 주 버전 및 부 버전별로 현재 제품 릴리스를 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="fef75-654">These constants identify the current product release by name and the product major and minor version.</span></span>

<span data-ttu-id="fef75-655">\#define EL_PRODUCT_NETXDUO</span><span class="sxs-lookup"><span data-stu-id="fef75-655">\#define EL_PRODUCT_NETXDUO</span></span>  
<span data-ttu-id="fef75-656">\#define NETXDUO_MAJOR_VERSION</span><span class="sxs-lookup"><span data-stu-id="fef75-656">\#define NETXDUO_MAJOR_VERSION</span></span>  
<span data-ttu-id="fef75-657">\#define NETXDUO_MINOR_VERSION</span><span class="sxs-lookup"><span data-stu-id="fef75-657">\#define NETXDUO_MINOR_VERSION</span></span>